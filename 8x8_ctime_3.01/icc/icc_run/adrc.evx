@ 1 "adrc/adrc.ev"
MACROS



@ 1 "adrc/adrc_variables.ev" 1
/*
@if __VERSION__ < "2003.3.0000"
@error  Hercules version must be later than 2003.3.0000
@endif
*/

VARIABLE string layer_name = "NULL";
VARIABLE double ignoreBlockage = 0;
VARIABLE double readCellView = 0;
VARIABLE double ignoreFRAM_Err = 0;
VARIABLE double ignoreContactCodeSpacing = 0;
VARIABLE double checkCrossHierShort = 0;
VARIABLE double ignoreChildCell = 0;
/* For Router special DRC option */
VARIABLE double router_ignoreSameNetAdjacentViaDRC=0;
VARIABLE double router_parallelLengthNetMode = 0;
/* Variables for metal layers*/
VARIABLE double fatTblSpacingMode = 0;
VARIABLE double fatTblMinEnclosedAreaMode = 0;
VARIABLE double fatWireExtensionMode = 0;
VARIABLE double minEdgeMode = 0;
VARIABLE double minLengthMode = 0;
VARIABLE double parallelLengthMode = 0;
VARIABLE double minWidth = 0;
VARIABLE double maxWidth = 0;
VARIABLE double minArea = 0;
VARIABLE double minEnclosedArea = 0;
VARIABLE double minEnclosedWidth = 0;
VARIABLE double windowSize = 0;
VARIABLE double maxDensity = 0;
VARIABLE double minDensity = 0;
VARIABLE double gradientWindowSize = 0;
VARIABLE double maxGradientDensity = 0;
VARIABLE string layer2_name = "NULL";
VARIABLE double numOfMultiLayer = 0;
VARIABLE double consecutiveWindowSize = 0;
VARIABLE double maxConsecutiveDensity = 0;
VARIABLE double maxNumMinEdge = 0;
VARIABLE double maxTotalMinEdgeLength = 0;
VARIABLE double minEdgeLength = 0;
VARIABLE double minEdgeLength2 = 0;
VARIABLE double minEdgeLength3 = 0;
VARIABLE double minSpacing = 0;
VARIABLE double sameNetMinSpacing = 0;
VARIABLE double sameNetWidthThreshold = 0;
VARIABLE double stub2StubSpacing = 0;
VARIABLE double stubSpacing = 0;
VARIABLE double sideStubExt = 0;
VARIABLE double sideStubThreshold = 0;
VARIABLE double stubThreshold = 0;
VARIABLE double stubRange = 0;
VARIABLE double stubMode = 0;
VARIABLE double fatWireThreshold = 0;
VARIABLE double fatThinMinSpacing = 0;
VARIABLE double fatFatMinSpacing = 0;
VARIABLE double fatTblDimension = 0;
VARIABLE double fatTblThreshold = 0;
VARIABLE double fatTblNextThreshold = 0;
VARIABLE double fatTblThreshold_Start = 0;
VARIABLE double fatTblThreshold_End = 0;
VARIABLE double fatTblThreshold_1 = 0;
VARIABLE double fatTblExtensionRange = 0;
VARIABLE double fatTblParallelLength = 0;
VARIABLE double fatTblSpacing = 0;
VARIABLE double fatTblSpacing_dg = 0;
VARIABLE double fatTblEnclosedArea = 0;
/* Variables for cut layers*/
VARIABLE double cornerSpacingMode = 0;
VARIABLE double cut_size = 0;
VARIABLE double metalLayer1_minSpacing = 0;
VARIABLE double metalLayer2_minSpacing = 0;
VARIABLE double cut_minSpacing = 0;
VARIABLE double cut_sameNetMinSpacing = 0;
VARIABLE double cut_cornerMinSpacing = 0;
VARIABLE double cutBlkg_minSpacing = 0;
VARIABLE double cut_maxNumAdjacentCut = 0;
VARIABLE double cut_adjacentCutRange = 0;
VARIABLE double cut_width = 0;
VARIABLE double cut_lineTblThreshold = 0;
VARIABLE double cut_lineTblNextThreshold = 0;
VARIABLE double cut_lineTblMinSpacing = 0;
VARIABLE double cut_matrixTblThreshold = 0;
VARIABLE double cut_matrixTblNextThreshold = 0;
VARIABLE double cut_matrixTblMinSpacing = 0;
VARIABLE double cut_enclosedCutNeighborRange = 0;
VARIABLE double cut_enclosedCutNumNeighbor = 0;
VARIABLE double cut_enclosedCutMinSpacing = 0;
VARIABLE double cut_enclosedCutToNeighborMinSpacing = 0;
VARIABLE double cut_enclosedCutDiagViaExcluded = 0;
VARIABLE double cut_defaultContactMinSpacing = 0;
VARIABLE double cut_fatContactThreshold1 = 0;
VARIABLE double cut_fatContactThreshold2 = 0;
VARIABLE double cut_fatContactMinSpacing = 0;
VARIABLE double cut_maxStackLevel = 0;
VARIABLE double cut_maxCutSpacing = 0;
VARIABLE double cut_fatTblDimension = 0;
VARIABLE double cut_fatTblThreshold_1 = 0;
VARIABLE double cut_fatTblThreshold_2 = 0;
VARIABLE double cut_fatTblNextThreshold_1 = 0;
VARIABLE double cut_fatTblNextThreshold_2 = 0;
VARIABLE double cut_fatMetalAndMode = 0;
VARIABLE double cut_fatTblExtensionRange = 0;
VARIABLE double cut_fatTblMinCuts = 0;
VARIABLE double cut_fatTblMinSpacing = 0;
VARIABLE double cut_fatTblExtensionMinCuts = 0;
VARIABLE double cut_fatTblExtensionMinSpacing = 0;
/* Variables for Via Farm, Enclosure rule */
VARIABLE double cut_ViaFarm_spacing = 0;
VARIABLE double cut_ViaFarm_maxNum = 0;
VARIABLE double cut_minEnclosure1 = -1;
VARIABLE double cut_minEnclosure2 = -1;
VARIABLE double cut_EOLEnclosure1 = 0;
VARIABLE double cut_EOLEnclosure2 = 0;
VARIABLE double cut_ExtViaFarm_spacing = 0;
VARIABLE double cut_ExtViaFarm_maxNum = 0;
VARIABLE double cut_ExtMinEnclosure1 = -1;
VARIABLE double cut_ExtMinEnclosure2 = -1;
VARIABLE double cut_ExtEOLEnclosure1 = 0;
VARIABLE double cut_ExtEOLEnclosure2 = 0;
/* Variables for diff layers */
VARIABLE double diff_minSpacing = 0;
VARIABLE double diff_netMinSpacing = 0;
VARIABLE double diff_cornerMinSpacing = 0;
VARIABLE double diff_minEnclosure = 0;
VARIABLE double diff_endOfLineMode = 0;
VARIABLE double diff_endOfLineEnclosure = 0;
VARIABLE double diff_not_stackable = 0;
VARIABLE double diff_fatTblViaKeepoutThreshold = 0;
VARIABLE double diff_fatTblViaKeepoutNextThreshold = 0;
VARIABLE double diff_fatTblViaKeepoutMinSize = 0;
VARIABLE double diff_fatTblViaKeepoutEnclosure = 0;
/* spacing to handle via array in stackLevel */
VARIABLE double cut_stackLevelSpacing = 0;
/* Variable for bound box length of polygon */
VARIABLE double minLength = 0;
VARIABLE double maxLength = 0;
/* Fat Poly Contact Rule */
VARIABLE double fatPolyContactRule = 0;
/* protrusion leng rule check */
VARIABLE double fatTblThresh_protru = 0;
VARIABLE double fatTblLength_protru = 0;
VARIABLE double fatTblWidth_protru = 0;
/* Contact code checking */
VARIABLE double viaFarm_maxNum=0;
VARIABLE double viaFarm_spacing=0;
VARIABLE double via_minEnclosure1=-1;
VARIABLE double via_EOLEnclosure1=0;
VARIABLE double via_minEnclosure2=-1;
VARIABLE double via_EOLEnclosure2=0;
/* For temporary usage */
VARIABLE double temporary_1 = 0;
VARIABLE double temporary_2 = 0;
VARIABLE double addEmptyMetalCheck = 1;
VARIABLE double addEmptyViaCheck = 1;
@ 5 "adrc/adrc.ev" 2


HEADER {
	INLIB = CHIP
	OUTLIB = hercules_out
	LAYOUT_PATH = /home/m106/m106061556/ICLAB/final_pj/ICLAB_final_pj/8x8_ctime_3.01/icc/icc_run
	BLOCK = CHIP
	FORMAT = MILKYWAY
	GROUP_DIR = run_details/group
	OUTPUT_FORMAT = MILKYWAY
	MILKYWAY_VIEW_NAME = trash
	OUTPUT_LAYOUT_PATH = run_details
}

DATABASE_OPTIONS {
	USE_REF_CONTROL_FILE = TRUE
	HIER_REF_LIB_MODE = TRUE
	DB_MODE = DRC_BLACK_BOX
	IGNORE_MISSING_CELL = TRUE
	DB_CELL_LIST = {*}
}

OPTIONS {
	INTERNAL_RESOLUTION = 0.0002 
	MAXIMUM_CELLNAME_LENGTH = 127
}

EXPLODE_OPTIONS {
	EXPLODE_ALL = {*}
}

DRC_OPTIONS {
	DRC_ERROR_BOX = 0.01
}

ERROR_PROPERTY {
	comment_property (51)
}


ASSIGN {
	metal1_pin       (11) {VIEW = FRAM, OBJECT_TYPE = PIN }
	metal1_top       (11) {VIEW = { CEL}}
	metal1_rbkg      (11) {VIEW = FRAM, OBJECT_TYPE = {*,!PIN}}
	metal2_pin       (13) {VIEW = FRAM, OBJECT_TYPE = PIN }
	metal2_top       (13) {VIEW = { CEL}}
	metal2_rbkg      (13) {VIEW = FRAM, OBJECT_TYPE = {*,!PIN}}
	metal3_pin       (15) {VIEW = FRAM, OBJECT_TYPE = PIN }
	metal3_top       (15) {VIEW = { CEL}}
	metal3_rbkg      (15) {VIEW = FRAM, OBJECT_TYPE = {*,!PIN}}
	metal4_pin       (17) {VIEW = FRAM, OBJECT_TYPE = PIN }
	metal4_top       (17) {VIEW = { CEL}}
	metal4_rbkg      (17) {VIEW = FRAM, OBJECT_TYPE = {*,!PIN}}
	metal5_pin       (19) {VIEW = FRAM, OBJECT_TYPE = PIN }
	metal5_top       (19) {VIEW = { CEL}}
	metal5_rbkg      (19) {VIEW = FRAM, OBJECT_TYPE = {*,!PIN}}
	metal6_pin       (21) {VIEW = FRAM, OBJECT_TYPE = PIN }
	metal6_top       (21) {VIEW = { CEL}}
	metal6_rbkg      (21) {VIEW = FRAM, OBJECT_TYPE = {*,!PIN}}
	metal7_pin       (23) {VIEW = FRAM, OBJECT_TYPE = PIN }
	metal7_top       (23) {VIEW = { CEL}}
	metal7_rbkg      (23) {VIEW = FRAM, OBJECT_TYPE = {*,!PIN}}
	metal8_pin       (25) {VIEW = FRAM, OBJECT_TYPE = PIN }
	metal8_top       (25) {VIEW = { CEL}}
	metal8_rbkg      (25) {VIEW = FRAM, OBJECT_TYPE = {*,!PIN}}
	metal9_pin       (27) {VIEW = FRAM, OBJECT_TYPE = PIN }
	metal9_top       (27) {VIEW = { CEL}}
	metal9_rbkg      (27) {VIEW = FRAM, OBJECT_TYPE = {*,!PIN}}
	metal10_pin       (41) {VIEW = FRAM, OBJECT_TYPE = PIN }
	metal10_top       (41) {VIEW = { CEL}}
	metal10_rbkg      (41) {VIEW = FRAM, OBJECT_TYPE = {*,!PIN}}

	metal1_blockage  (218)
	metal2_blockage  (219)
	metal3_blockage  (220)
	metal4_blockage  (216)
	metal5_blockage  (239)
	metal6_blockage  (240)
	metal7_blockage  (208)
	metal8_blockage  (210)
	metal9_blockage  (214)
	metal10_blockage  (236)

	via1_top         (12)  {VIEW = CEL}
	via1_fram        (12)  {VIEW = FRAM}
	via2_top         (14)  {VIEW = CEL}
	via2_fram        (14)  {VIEW = FRAM}
	via3_top         (16)  {VIEW = CEL}
	via3_fram        (16)  {VIEW = FRAM}
	via4_top         (18)  {VIEW = CEL}
	via4_fram        (18)  {VIEW = FRAM}
	via5_top         (20)  {VIEW = CEL}
	via5_fram        (20)  {VIEW = FRAM}
	via6_top         (22)  {VIEW = CEL}
	via6_fram        (22)  {VIEW = FRAM}
	via7_top         (24)  {VIEW = CEL}
	via7_fram        (24)  {VIEW = FRAM}
	via8_top         (26)  {VIEW = CEL}
	via8_fram        (26)  {VIEW = FRAM}
	via9_top         (42)  {VIEW = CEL}
	via9_fram        (42)  {VIEW = FRAM}

	via1_blockage    (224)
	via2_blockage    (225)
	via3_blockage    (217)
	via4_blockage    (241)
	via5_blockage    (242)
	via6_blockage    (243)
	via7_blockage    (209)
	via8_blockage    (211)
	via9_blockage    (215)

	PR_BNDY  	         (255)

	empty  	         (255;255)
}

/*Data preparation*/
BOOLEAN metal1_top OR metal1_pin  {  } TEMP=metal1_top
BOOLEAN metal1_top OR metal1_rbkg {  } TEMP=metal1
BOOLEAN metal2_top OR metal2_pin  {  } TEMP=metal2_top
BOOLEAN metal2_top OR metal2_rbkg {  } TEMP=metal2
BOOLEAN metal3_top OR metal3_pin  {  } TEMP=metal3_top
BOOLEAN metal3_top OR metal3_rbkg {  } TEMP=metal3
BOOLEAN metal4_top OR metal4_pin  {  } TEMP=metal4_top
BOOLEAN metal4_top OR metal4_rbkg {  } TEMP=metal4
BOOLEAN metal5_top OR metal5_pin  {  } TEMP=metal5_top
BOOLEAN metal5_top OR metal5_rbkg {  } TEMP=metal5
BOOLEAN metal6_top OR metal6_pin  {  } TEMP=metal6_top
BOOLEAN metal6_top OR metal6_rbkg {  } TEMP=metal6
BOOLEAN metal7_top OR metal7_pin  {  } TEMP=metal7_top
BOOLEAN metal7_top OR metal7_rbkg {  } TEMP=metal7
BOOLEAN metal8_top OR metal8_pin  {  } TEMP=metal8_top
BOOLEAN metal8_top OR metal8_rbkg {  } TEMP=metal8
BOOLEAN metal9_top OR metal9_pin  {  } TEMP=metal9_top
BOOLEAN metal9_top OR metal9_rbkg {  } TEMP=metal9
BOOLEAN metal10_top OR metal10_pin  {  } TEMP=metal10_top
BOOLEAN metal10_top OR metal10_rbkg {  } TEMP=metal10

BOOLEAN via1_top OR via1_fram { } TEMP=via1
BOOLEAN via2_top OR via2_fram { } TEMP=via2
BOOLEAN via3_top OR via3_fram { } TEMP=via3
BOOLEAN via4_top OR via4_fram { } TEMP=via4
BOOLEAN via5_top OR via5_fram { } TEMP=via5
BOOLEAN via6_top OR via6_fram { } TEMP=via6
BOOLEAN via7_top OR via7_fram { } TEMP=via7
BOOLEAN via8_top OR via8_fram { } TEMP=via8
BOOLEAN via9_top OR via9_fram { } TEMP=via9

CONNECT {
   metal1 metal2 BY via1
   metal2 metal3 BY via2
   metal3 metal4 BY via3
   metal4 metal5 BY via4
   metal5 metal6 BY via5
   metal6 metal7 BY via6
   metal7 metal8 BY via7
   metal8 metal9 BY via8
   metal9 metal10 BY via9
} CONNECT_DB = all_layer

SET ignoreBlockage = 1;
SET readCellView = 0;



/*Metal rules*/
SET minEdgeMode = 1;
SET stubMode = 0;

/*metal 1*/
SET layer_name = "Met1";










SET minWidth = 0.05;
SET maxWidth = 5;
SET minArea = 0.01;
SET minEnclosedArea = 0.2;
SET minSpacing = 0.05;
SET stub2StubSpacing = 0;

SET fatTblDimension = 5;
@ 1 "adrc/adrc_check_metal.ev" 1
/* Data Preparation */
if (fatTblDimension > 1 || fatWireThreshold > 0 || maxWidth > 0) {
  if (ignoreBlockage) {
      /* Let the real blockage be treated as thin */
      BOOLEAN metal1  NOT metal1_rbkg  {} TEMP=fat_candidate
  } else {
      COPY metal1  {} TEMP=fat_candidate
  }
  COPY fat_candidate {} TEMP=fat_target
}
/*Check width*/
if (minWidth > 0) {
    INTERNAL metal1  { 
        COMMENT = "$layer_name MinWidth  : minimum width = minWidth um" 
        SPACING < minWidth
        POINT_TOUCH = FALSE
    } (11 )
}
 
if (maxWidth > 0) {
    SIZE  fat_candidate {
        COMMENT = "$layer_name MaxWidth  : maximum width = maxWidth um"
 	UNDER_OVER = maxWidth / 2 
    } (11 ) 
}
 
/*Check area*/
if (minArea > 0) {
    AREA metal1  { 
	COMMENT = "$layer_name MinArea   : minimum area = minArea um*um"
	RANGE = [0.0001 * 0.0001 , minArea - 0.0001 * 0.0001 ]
    } (11 )
}
/* check min length of bounding box on polygon */
if (minLength > 0) {
  if (minLengthMode == 1) {
    INTERNAL metal1  {
        SPACING < minLength
        VERTICAL_ONLY = TRUE
        SET_CORNERS_TO_SPACING = FALSE
    } TEMP = ver_short
    BOOLEAN metal1  NOT ver_short { } TEMP = ver_long
    INTERNAL metal1  {
        SPACING < minLength
        HORIZONTAL_ONLY = TRUE
        SET_CORNERS_TO_SPACING = FALSE
    } TEMP = hor_short
    BOOLEAN metal1  NOT hor_short { } TEMP = hor_long
    SELECT CUT_LAYER1 INSIDE ver_long { } TEMP = good_cut
    BOOLEAN CUT_LAYER1 NOT good_cut { } TEMP = fail_cut_1
    SELECT fail_cut_1 INSIDE hor_long { } TEMP = good_cut
    BOOLEAN fail_cut_1 NOT good_cut { } TEMP = fail_cut_1
    SELECT CUT_LAYER2 INSIDE ver_long { } TEMP = good_cut
    BOOLEAN CUT_LAYER2 NOT good_cut { } TEMP = fail_cut_2
    SELECT fail_cut_2 INSIDE hor_long { } TEMP = good_cut
    BOOLEAN fail_cut_2 NOT good_cut { } TEMP = fail_cut_2
    BOOLEAN fail_cut_1 OR fail_cut_2 { } TEMP = fail_cut
    BOOLEAN hor_short NOT ver_long { } TEMP = hor_short
    BOOLEAN ver_short NOT hor_long { } TEMP = ver_short
    SELECT ver_short INTERACT fail_cut { } TEMP = ver_fail
    SELECT hor_short INTERACT fail_cut { } TEMP = hor_fail
    BOOLEAN ver_fail OR hor_fail { } TEMP = all_fail
    INTERNAL all_fail {
        COMMENT = "$layer_name MinLength : minimum length = minLength um"
        SPACING < minLength
        VERTICAL_ONLY = TRUE
        SET_CORNERS_TO_SPACING = FALSE
    } (11 )
  } else {
    POLYGON_FEATURES metal1  {
      COMMENT = "$layer_name MinLength : minimum length = minLength um"
      EQUATIONS {
        vnum = EV_VNUM_IN;
        if ( vnum > 0) {
	  bdLeft = EV_VXCOORD_IN[0];
	  bdRight = EV_VXCOORD_IN[0];
	  bdBottom = EV_VYCOORD_IN[0];
	  bdTop = EV_VYCOORD_IN[0];
          FOR (i = 1; i < vnum; i++) {
	    if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
            else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
	    if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
            else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
          }
	  if ( (bdRight - bdLeft) < minLength &&
	       (bdTop - bdBottom) < minLength) {
	    FOR (i = 0; i < vnum; i++) {
              EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
	      EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
            }
	    EV_VNUM_OUT = vnum;
	    EV_SAVE_POLYGON();
          }
        }
      }
    } (11 ) 
  }
  SET minLength = 0;
}
/* check max length of bounding box on polygon */
if (maxLength > 0) {
  POLYGON_FEATURES metal1  {
    COMMENT = "$layer_name MaxLength : maximum length = maxLength um"
    EQUATIONS {
      vnum = EV_VNUM_IN;
      if ( vnum > 0) {
	bdLeft = EV_VXCOORD_IN[0];
	bdRight = EV_VXCOORD_IN[0];
	bdBottom = EV_VYCOORD_IN[0];
	bdTop = EV_VYCOORD_IN[0];
        FOR (i = 1; i < vnum; i++) {
	  if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
          else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
	  if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
          else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
        }
	if ( (bdRight - bdLeft + bdTop - bdBottom) > maxLength ) {
          EV_VXCOORD_OUT[0] = bdLeft;
	  EV_VYCOORD_OUT[0] = bdBottom;
          EV_VXCOORD_OUT[1] = bdLeft;
	  EV_VYCOORD_OUT[1] = bdTop;
          EV_VXCOORD_OUT[2] = bdRight;
	  EV_VYCOORD_OUT[2] = bdTop;
          EV_VXCOORD_OUT[3] = bdRight;
	  EV_VYCOORD_OUT[3] = bdBottom;
          EV_VXCOORD_OUT[4] = bdLeft;
	  EV_VYCOORD_OUT[4] = bdBottom;
	  EV_VNUM_OUT = 5;
	  EV_SAVE_POLYGON();
        }
      }
    }
  } (11 ) 
  SET maxLength = 0;
}
 
/*Check enclosed area*/
if (minEnclosedArea > 0) {
    SELECT metal1  INSIDE_HOLE {
        INNER_HOLE_ONLY
    } TEMP = holes
    BOOLEAN holes NOT metal1  { } TEMP = holes
 
    AREA holes {
        COMMENT = "$layer_name EnclsArea : minimum enclosed area = minEnclosedArea um*um"
        RANGE = [0.0001 * 0.0001 , minEnclosedArea - 0.0001 * 0.0001 ]
    } (11 )
    /* check min length of bounding box on polygon */
    if (minEnclosedWidth > 0) {
      POLYGON_FEATURES holes {
        COMMENT = "$layer_name EnclsWidth: minimum enclosed Width = minEnclosedWidth um"
        EQUATIONS {
          vnum = EV_VNUM_IN;
          if ( vnum > 0) {
            bdLeft = EV_VXCOORD_IN[0];
            bdRight = EV_VXCOORD_IN[0];
            bdBottom = EV_VYCOORD_IN[0];
            bdTop = EV_VYCOORD_IN[0];
            FOR (i = 1; i < vnum; i++) {
              if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
              else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
              if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
              else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
            }
            if ( (bdRight - bdLeft) < minEnclosedWidth &&
                 (bdTop - bdBottom) < minEnclosedWidth) {
              FOR (i = 0; i < vnum; i++) {
                EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
                EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
              }
              EV_VNUM_OUT = vnum;
              EV_SAVE_POLYGON();
            }
          }
        }
      } (11 ) 
    }
}
 
/*check special notch rule*/
if ((minEdgeLength2 > 0.0001  && minEdgeLength3 > 0.0001 ) || minEdgeMode==2) {
  if (minEdgeMode==2) {
    SET minEdgeLength3 = minEdgeLength ;
  }
  NOTCH metal1  {
     SPACING < minEdgeLength3
     SET_CORNERS_TO_SPACING=FALSE
     PARALLEL = TRUE
     OUTPUT_EDGES = TRUE
  } TEMP = notch_vectors
  SELECT_VECTOR notch_vectors {
     LENGTH_RANGE = [0.0001 , minEdgeLength2 - 0.0001 ]
  } TEMP = short_edges
  EXTERNAL short_edges metal1  {
     SPACING < minEdgeLength3
     SET_CORNERS_TO_SPACING=FALSE
     PARALLEL = TRUE
  } TEMP = notch_err
  /* Choose the real U-shaped notch */
  SIZE notch_err { OVERSIZE = 0.0002 *10 } TEMP = neighbors 
  BOOLEAN neighbors AND metal1  { } TEMP = neighbors
  VERTEX neighbors { 
     CONCAVE = TRUE
     CONVEX = TRUE
     SIZE = 0.0002 
  } TEMP = corners
  SELECT_EDGE neighbors INTERACT notch_err { } TEMP = target_edges
  BOOLEAN target_edges NOT corners { } TEMP = target_edges
  VERTEX neighbors { 
     CONCAVE = TRUE
     SIZE = 2* 0.0002 
  } TEMP = corners
  SELECT target_edges INTERACT corners { RANGE = [2, 2] } TEMP=target_edges
  SELECT notch_err INTERACT target_edges {
     COMMENT = "$layer_name SpeclNotch: sameNetSp = minEdgeLength3 um (sideLen minEdgeLength2 um)" 
  } (11 )
}
/*check consecutive short edges*/
if (minEdgeLength > 0.0001  && minEdgeMode != 2) { 
  INTERNAL metal1_top  {
     SEGMENT < minEdgeLength
     FLAG_ACUTE_ANGLE = FALSE
     FLAG_ACUTE_EDGE = FALSE
     OUTPUT_EDGES = TRUE
  } TEMP = short_edges
  if ((minEdgeMode == 0 && maxTotalMinEdgeLength>0) || maxNumMinEdge > 0) {
    SET temporary_1 = 0.0002 *2;
    SET temporary_2 = 2*temporary_1+ 0.0001 ;
    SELECT metal1_top  INTERACT short_edges { } TEMP = target_top
    CLASSIFY_EDGES target_top {
       LENGTH = temporary_1
       DMIN   = temporary_2
       INSIDE_CORNER  TEMP = inside_corner_edges
       OUTSIDE_CORNER TEMP = outside_corner_edges
       REMAINDER      TEMP = remainder_edges
    }
    if (minEdgeMode == 0 && (maxNumMinEdge>0 || maxTotalMinEdgeLength > 0)) {
       SELECT short_edges ENCLOSING inside_corner_edges { } TEMP = short_edges
    }
  }
  if (maxTotalMinEdgeLength > 0) {
    LENGTH short_edges {
       RANGE = [maxTotalMinEdgeLength + 0.0001 , 9999999999 ]
    } TEMP = max_length_err
    /* Work around: translate polygons into dimensional check output */
    SIZE max_length_err { OVERSIZE = 2* 0.0002  } TEMP = max_length_err
    INTERNAL max_length_err {
       SPACING < 3* 0.0002 
       SET_CORNERS_TO_SPACING=FALSE
       COMMENT = "$layer_name MinEdgeLen: maximum total length ( minEdgeLength um)= maxTotalMinEdgeLength um"
    } (11 )
  }
  if (maxTotalMinEdgeLength == 0 || maxNumMinEdge > 0) {
    if (maxNumMinEdge==0)  {
       COPY short_edges {} TEMP=max_edge_err
    } else {
       SIZE short_edges {
         VSIZE_HEAD = - 0.0002 
        VSIZE_TAIL = - 0.0002 
       } TEMP = short_edges
       SIZE short_edges {
          OVERSIZE = 5* 0.0002 
          SIZE_ENDPOINTS = FALSE
       } TEMP = short_contours
       SELECT short_contours ENCLOSING remainder_edges {
          RANGE = [maxNumMinEdge + 1, 9999999999 ]
       } TEMP = short_contours
       SELECT short_edges INSIDE short_contours { } TEMP=max_edge_err
    }
    /* Work around: translate polygons into dimensional check output */
    SIZE max_edge_err { OVERSIZE = 2* 0.0002  } TEMP = max_edge_error
    INTERNAL max_edge_error {
       SPACING < 3* 0.0002 
       SET_CORNERS_TO_SPACING=FALSE
       COMMENT = "$layer_name MinEdgeLen: maximum number of consecutive short edges ( minEdgeLength um)= maxNumMinEdge"
    } (11 ) 
  }
}
 
/*check basic spacing*/
if (sameNetMinSpacing > 0 && sameNetMinSpacing != minSpacing) {
  if (sameNetMinSpacing > minSpacing) {
    /* Special condition for U-shaped Metal spacing rule */
    NOTCH metal1_pin  {
        SPACING < sameNetMinSpacing
        BOX_CORNER = FALSE 
        SET_CORNERS_TO_SPACING=FALSE
        NON_PARALLEL = TRUE
        OUTPUT_EDGES = TRUE
    } TEMP = errs_to_be_waived
    NOTCH metal1_top  {
	SPACING < sameNetMinSpacing
	BOX_CORNER = FALSE 
        SET_CORNERS_TO_SPACING=FALSE
	NON_PARALLEL = TRUE
        OUTPUT_EDGES = TRUE
    } TEMP = all_errs
    BOOLEAN all_errs NOT errs_to_be_waived { } TEMP=err_edge
    EXTERNAL err_edge metal1_top  {
	SPACING < sameNetMinSpacing
	BOX_CORNER = FALSE 
        SET_CORNERS_TO_SPACING=FALSE
	NON_PARALLEL = TRUE
    } TEMP = notch_err
    SIZE notch_err { OVERSIZE = 0.0002 *10 } TEMP = neighbors
    BOOLEAN neighbors AND metal1_top  { } TEMP = neighbors
    VERTEX neighbors { 
       CONCAVE = TRUE
       CONVEX = TRUE
       SIZE = 0.0002 
    } TEMP = corners
    SELECT_EDGE neighbors INTERACT notch_err { } TEMP = target_edges
    BOOLEAN target_edges AND notch_err { } TEMP = target_edges
    BOOLEAN target_edges NOT corners { } TEMP = target_edges
    VERTEX neighbors {
       CONCAVE = TRUE
       SIZE = 2* 0.0002 
    } TEMP = corners
    SELECT target_edges INTERACT corners { RANGE = [2, 2] } TEMP = target_edges
    SELECT notch_err TOUCHING target_edges {
      COMMENT = "$layer_name U-ShpNotch: U-shape notch minimum spacing = sameNetMinSpacing um" 
    } (11 )
  } else {
    NOTCH metal1  {
        COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = sameNetMinSpacing um" 
	SPACING < sameNetMinSpacing
	BOX_CORNER = FALSE 
	NON_PARALLEL = TRUE
    } (11 )
  }
  if (minSpacing > 0) {
    if (stubMode == 0 && stubSpacing > 0 && stubSpacing < minSpacing) {
	EXTERNAL metal1  {
	    COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um"
            LONGEDGE > stubThreshold + 0.0001 
	    LONGEDGE_TO_EDGE < minSpacing
	    SPACING <= 0
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            CHECK_SAME_POLYGON = TRUE 
	} (11 )
    } else {
        EXTERNAL metal1  {
	    COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um" 
	    SPACING < minSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
	    CHECK_SAME_POLYGON = FALSE
        } (11 )
    }
  }
} else {
  if (minSpacing > 0) {
    if (stubMode == 0 && stubSpacing > 0 && stubSpacing < minSpacing) {
        EXTERNAL metal1  {
            COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um"
            LONGEDGE > stubThreshold + 0.0001  
            LONGEDGE_TO_EDGE < minSpacing
            SPACING <= 0 
            BOX_CORNER = FALSE 
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            CHECK_SAME_POLYGON = TRUE 
        } (11 )
    } else {
        EXTERNAL metal1  {
	    COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um" 
            SPACING < minSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
	    CHECK_SAME_POLYGON = TRUE 
        } (11 )
    }
  }
}
 
/*check dogbone */
if (sameNetMinSpacing > 0 && sameNetWidthThreshold) {
  NOTCH metal1  {
    SPACING < sameNetMinSpacing
    BOX_CORNER = FALSE 
    NON_PARALLEL = TRUE
  } TEMP = dog_bone
 
  if (!layer_empty(dog_bone)) {
    SIZE dog_bone {EDGESIZE = sameNetWidthThreshold} TEMP = dog_ext
    BOOLEAN dog_ext NOT dog_bone {} TEMP = dog_ext
    BOOLEAN dog_ext AND metal1  {} TEMP = dog_ext
    if (!layer_empty(dog_ext)) {
      SELECT dog_ext EDGE_TOUCH dog_bone { OUTSIDE RANGE = [1, 9999999999 ] } TEMP = dog_ext
      NOTCH metal1  {
        SPACING < sameNetMinSpacing
        BOX_CORNER = FALSE 
        NON_PARALLEL = TRUE
	OUTPUT_EDGES = TRUE
      } TEMP = dog_bone
      SELECT dog_ext OUTSIDE dog_bone {} TEMP = dog_ext
      INTERNAL dog_ext {
	COMMENT = "$layer_name dogBone   : notch spacing = sameNetMinSpacing um width sameNetWidthThreshold um" 
	SPACING < sameNetWidthThreshold
      } (11 )
    }
  }
}
/*check basic fat spacing*/
if (fatWireThreshold > 0 && fatTblDimension == 0) {
    SIZE fat_candidate { UNDER_OVER = fatWireThreshold / 2.0 - 0.0001  } TEMP = m_fat
    BOOLEAN m_fat AND metal1  {  } TEMP = m_fat
    BOOLEAN metal1  NOT m_fat {  } TEMP = m_thin
    if (ignoreBlockage == 0) {
        /* the blockages on the metal_blockage layer are treated as thin blockages */
        BOOLEAN m_thin OR metal1_blockage  {  } TEMP = m_thin
    }
 
    if (fatFatMinSpacing > 0) {
	EXTERNAL m_fat {
	    COMMENT = "$layer_name FatWireSpc: fat & fat ( fatWireThreshold um) minimum spacing = fatFatMinSpacing um"
	    SPACING < fatFatMinSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = FALSE
	    CHECK_SAME_POLYGON = TRUE 
       } (11 )
    }
 
    if (fatThinMinSpacing > 0) {
	EXTERNAL m_fat m_thin {
	    COMMENT = "$layer_name FatWireSpc: fat & thin ( fatWireThreshold um) minimum spacing fatThinMinSpacing um"
	    SPACING < fatThinMinSpacing
 	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = FALSE
        } (11 )
    }
}
 
/*check thin blockage spacing*/
if (minSpacing > 0 && ignoreBlockage == 0) {
    if (!layer_empty (metal1_blockage )) {
	EXTERNAL metal1_blockage  metal1  {
	    COMMENT = "$layer_name Spacing   : metal & thin blockage minimum spacing = minSpacing um"
	    SPACING < minSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
            TOUCH = TRUE
        } (11 )
    }
}
/*check blockage overlap*/
/*check shorts between top_level routing and fram_blockages*/
if (minSpacing>0 || checkCrossHierShort>0) {
   if (ignoreBlockage == 0) {
      BOOLEAN metal1_blockage  or metal1_rbkg  {} TEMP=all_blockage
   } else {
      COPY metal1_rbkg  {} TEMP=all_blockage
   }
   BOOLEAN all_blockage AND metal1_top  {} TEMP = overlap_shape1
   EXTERNAL all_blockage metal1_top  {
      SPACING <= 0
      TOUCH = TRUE
   } TEMP = overlap_shape2
   if (checkCrossHierShort>0) {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
         COMMENT = "$layer_name Short Cross Hierarchy"
      } (11 )
   } else {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
         COMMENT = "$layer_name Overlap   : metal & blockage overlap"
      } (11 )
   }
}
 
if (fatPolyContactRule > 0) {
  /* Fat Poly Contact Rule: not new fat wire formed */
  if (readCellView > 0) {
     SIZE metal1 { UNDER_OVER = fatPolyContactRule / 2.0 - 0.0001  } TEMP = fat
     BOOLEAN fat AND metal1 {  } TEMP = fat 
  } else {
     SIZE metal1_top { UNDER_OVER = fatPolyContactRule / 2.0 - 0.0001  } TEMP = fat
     BOOLEAN fat AND metal1_top {  } TEMP = fat 
  }
  SIZE metal1_pin { UNDER_OVER = fatPolyContactRule / 2.0 - 0.0001  } TEMP = fat_pin
  BOOLEAN fat_pin AND metal1_pin {  } TEMP = fat_pin
  BOOLEAN fat NOT fat_pin {
    COMMENT = "$layer_name FatPolyContactRule: fatPolyContactRule um" 
  } (11 )
}
/* Special End-of-Line Spacing Rule */
if (stubMode == 0 && stubSpacing > 0 && stubSpacing < minSpacing) {
  EXTERNAL metal1  {
     COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 0)"
     LONGEDGE > stubThreshold + 0.0001 
     LONGEDGE_TO_EDGE <= 0 
     SPACING < stubSpacing 
     SET_CORNERS_TO_SPACING = FALSE
     PARALLEL_POINT_PROJECTION = FALSE
  } (11 )
} else if (stubMode > 0 && stubSpacing > minSpacing) {
  if (stubMode == 4) {
     INTERNAL metal1  {
        SEGMENT[90,90] < stubThreshold
        OUTPUT_EDGES = TRUE
     } TEMP = end_of_line
  } else {
     INTERNAL metal1  {
        SEGMENT[90,90] <= stubThreshold
        OUTPUT_EDGES = TRUE
     } TEMP = end_of_line
  }
  /* Quick filter to reduce the size of possible end of line */
  if (sideStubExt > 0) {
    SIZE end_of_line {
       VSIZE_HEAD = sideStubExt
       VSIZE_TAIL = sideStubExt
       OUTPUT_EDGES = TRUE
    } TEMP = eol_ext
  } else {
    COPY end_of_line { } TEMP=eol_ext
  }
  if (stub2StubSpacing > stubSpacing) {
     SET temporary_1 = stub2StubSpacing;
  } else {
     SET temporary_1 = stubSpacing; 
  }
  EXTERNAL eol_ext metal1  {
     SPACING < temporary_1
     TOUCH = TRUE
     OVERLAP = TRUE 
     SET_CORNERS_TO_SPACING = FALSE
     PARALLEL_POINT_PROJECTION = FALSE
     OUTPUT_EDGES = TRUE
  } TEMP=err_edge
  SELECT eol_ext INTERACT err_edge { } TEMP=eol_ext
  SELECT end_of_line INTERACT eol_ext { } TEMP=end_of_line 
  /* Reduce the size of METAL_LAYER */
  if (stubMode==3) {
     SIZE end_of_line {
        VSIZE_HEAD = stubSpacing 
        VSIZE_TAIL = stubSpacing 
        VSIZE_INSIDE = sideStubThreshold
        VSIZE_OUTSIDE = stubSpacing
     } TEMP = eol_filter 
  } else {
     if (stubMode == 1 && stubRange > 0) {
        SIZE end_of_line {
           VSIZE_HEAD = stubSpacing- 0.0001 
           VSIZE_TAIL = stubSpacing- 0.0001 
           VSIZE_OUTSIDE = stubSpacing- 0.0001 
        } TEMP = eol_filter
     } else {
        SIZE end_of_line {
           VSIZE_HEAD = stubSpacing- 0.0001 
           VSIZE_TAIL = stubSpacing- 0.0001 
           VSIZE_INSIDE = sideStubThreshold- 0.0001 
           VSIZE_OUTSIDE = stubSpacing- 0.0001 
        } TEMP = eol_filter
     }
  }
  SELECT metal1  INTERACT eol_filter { } TEMP=target_top
  /* Get the side edges and the whole eol of line set */
  SELECT_EDGE target_top INTERACT end_of_line { 
    POINT_TOUCH = TRUE
  } TEMP = eol_set
  VERTEX target_top { 
     CONCAVE = TRUE 
     CONVEX = TRUE
     SIZE = 0.0002 
  } TEMP = corners
  SELECT corners OUTSIDE end_of_line {} TEMP =corners 
  BOOLEAN eol_set NOT corners { } TEMP=eol_set
  BOOLEAN eol_set NOT end_of_line { } TEMP=side_edge
  /* find out the real end of line */
  if (stubRange > 0) {
     if (stubMode == 1) {
         COPY side_edge { } TEMP = all_side_edge
         LENGTH side_edge { SPACING <= stubRange- 0.0001  } TEMP=side_edge
     } else {
         LENGTH side_edge { SPACING < stubRange- 0.0002  } TEMP=eol_filter
         BOOLEAN side_edge NOT eol_filter { } TEMP=side_edge
     }
     SELECT end_of_line INTERACT side_edge { RANGE = [1,2] } TEMP = end_of_line
  } 
  if (stubMode == 1) {
    if (stub2StubSpacing > 0) {
       if (sideStubExt < 0) {
          SIZE end_of_line {
            VSIZE_HEAD = sideStubExt / 2
            VSIZE_TAIL = sideStubExt / 2
            OUTPUT_EDGES = TRUE
          } TEMP = eol_ext_tip
	 
          EXTERNAL eol_ext_tip {
            COMMENT = "$layer_name specEoLSpc: stub2Stubspacing= stub2StubSpacing um (mode = 1)"
            SPACING < stub2StubSpacing
            SET_CORNERS_TO_SPACING = FALSE
            PARALLEL_POINT_PROJECTION = TRUE
          } (11 )
       } else {
          EXTERNAL end_of_line {
            COMMENT = "$layer_name specEoLSpc: stub2Stubspacing= stub2StubSpacing um (mode = 1)"
            SPACING < stub2StubSpacing
            SET_CORNERS_TO_SPACING = FALSE
            PARALLEL_POINT_PROJECTION = FALSE
          } (11 )
       }
    }
    if (stubRange > 0) {
       SIZE end_of_line {
         VSIZE_INSIDE = 0.0002 
       } TEMP = eol_poly
       SELECT_EDGE eol_poly TOUCHING target_top { } TEMP=eol_edge
       EXTERNAL eol_edge target_top {
         COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
         CONVEX_TO_CONVEX < stubSpacing
         CONVEX_TO_CONVEX [POINT_PROJECTION] < stubSpacing
         CONVEX_TO_EDGE < stubSpacing
         CONCAVE_TO_CONVEX < stubSpacing
         LONGEDGE > 0.0002 
         LONGEDGE_TO_EDGE < stubSpacing
         SPACING <= 0
         SET_CORNERS_TO_SPACING = TRUE
         PARALLEL_POINT_PROJECTION = TRUE
       } (11 )
       SELECT all_side_edge INTERACT end_of_line { } TEMP = side_edge
       SIZE side_edge {
         VSIZE_HEAD = 0.0002 
         VSIZE_TAIL = 0.0002 
       } TEMP = side_edge_ext
       BOOLEAN side_edge_ext NOT side_edge { } TEMP = side_edge_ext
       SELECT side_edge_ext INTERACT end_of_line { } TEMP = side_edge_ext
       EXTERNAL side_edge_ext target_top {
         COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
         SPACING < stubSpacing
         SET_CORNERS_TO_SPACING = FALSE
         PARALLEL_POINT_PROJECTION = FALSE
       } (11 )
    } else {
       if (stub2StubSpacing > 0) {
         VECTORIZE target_top {
            DIRECTED=TRUE
         } TEMP=target_edges
         BOOLEAN target_edges NOT end_of_line { } TEMP = target_edges
         EXTERNAL end_of_line target_edges {
            COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
            SPACING < stubSpacing
            TOUCH=TRUE
            OVERLAP=TRUE
            SET_CORNERS_TO_SPACING=FALSE
            PARALLEL_POINT_PROJECTION=FALSE
         } (11 )
       } else {
         if (sideStubExt > 0) {
            SIZE end_of_line {
               VSIZE_HEAD = sideStubExt
               VSIZE_TAIL = sideStubExt
               OUTPUT_EDGES = TRUE
            } TEMP = end_of_line
            EXTERNAL end_of_line target_top {
               COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing ,crnKeepOut= sideStubExt um (mode = 1)"
               SPACING < stubSpacing
               TOUCH=TRUE
               OVERLAP=TRUE
               SET_CORNERS_TO_SPACING=FALSE
               PARALLEL_POINT_PROJECTION=FALSE
            } (11 )
         } else {
            EXTERNAL end_of_line target_top {
               COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
               SPACING < stubSpacing
               TOUCH=TRUE
               OVERLAP=TRUE
               SET_CORNERS_TO_SPACING=FALSE
               PARALLEL_POINT_PROJECTION=FALSE
            } (11 )
         }
       }
    }
  } else { /* stubMode == 2,3,4 */
    /* stubMode 2 eol classify and reduction */
    if (stubMode !=3 && sideStubExt > 0) {
      if (stubMode == 4) {
        SIZE end_of_line {
           VSIZE_HEAD = sideStubExt
           VSIZE_TAIL = sideStubExt
           OUTPUT_EDGES = TRUE
        } TEMP = eol_ext
        EXTERNAL eol_ext target_top {
           SPACING < stubSpacing
           SET_CORNERS_TO_SPACING=FALSE
           PARALLEL_POINT_PROJECTION=FALSE
           OUTPUT_EDGES = TRUE
        } TEMP=err_edge
        SELECT eol_ext INTERACT err_edge { } TEMP=eol_ext
      } else {
        EXTERNAL end_of_line target_top {
           SPACING < stubSpacing
           SET_CORNERS_TO_SPACING=FALSE
           PARALLEL_POINT_PROJECTION=FALSE
           OUTPUT_EDGES = TRUE
        } TEMP=err_edge
        SELECT end_of_line INTERACT err_edge { } TEMP=eol_body
        SIZE end_of_line {
           VSIZE_HEAD = sideStubExt
           VSIZE_TAIL = sideStubExt
           OUTPUT_EDGES = TRUE
        } TEMP = eol_ext
        BOOLEAN eol_ext NOT end_of_line {} TEMP=eol_ext
        EXTERNAL eol_ext target_top {
           SPACING < stubSpacing
           SET_CORNERS_TO_SPACING=FALSE
           PARALLEL_POINT_PROJECTION=FALSE
           OUTPUT_EDGES = TRUE
        } TEMP=err_edge
        SELECT eol_ext INTERACT err_edge { } TEMP=eol_ext
        BOOLEAN eol_body OR eol_ext { } TEMP=eol_ext
      } 
    } else {
      COPY end_of_line { } TEMP=eol_ext
    }
    SELECT side_edge INTERACT eol_ext { } TEMP=side_edge
    SIZE eol_ext {
       VSIZE_INSIDE = sideStubThreshold 
       VSIZE_OUTSIDE = sideStubExt
    } TEMP = eol_range
    if (sideStubExt > 0) {
       SIZE side_edge {
          VSIZE_HEAD = sideStubExt
          VSIZE_TAIL = sideStubExt
          OUTPUT_EDGES = TRUE
       } TEMP = check_edge
    } else {
       COPY side_edge { } TEMP = check_edge
    }
    BOOLEAN check_edge AND eol_range { } TEMP=check_edge
    EXTERNAL check_edge target_top {
       SPACING < temporary_1
       SET_CORNERS_TO_SPACING = FALSE
       SHADOW_OTHER_LAYER = TRUE
       PARALLEL_POINT_PROJECTION = FALSE
       OUTPUT_EDGES = TRUE
    } TEMP=err_edge
    if (0 && stubMode!=4) { /* Temporarily do not check mode 2,3 side edge length */
       LENGTH side_edge { SPACING < stubSpacing- 0.0001 *2 } TEMP=err_edge_1
       BOOLEAN err_edge OR err_edge_1 { } TEMP=err_edge
    }
    SELECT check_edge INTERACT err_edge { } TEMP=side_edge
    if (stubMode!=3) {
       SELECT eol_ext INTERACT side_edge {} TEMP=err_eol
       EXTERNAL err_eol target_top {
          COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing ,crnKeepOut= sideStubExt um (mode = stubMode )"
          SPACING < temporary_1
          PARALLEL_POINT_PROJECTION=FALSE
          SET_CORNERS_TO_SPACING=FALSE
       } (11 )
    } else { /* stubMode == 3 */
       SELECT eol_ext INTERACT side_edge { RANGE = [2, 2] } TEMP=err_eol
       EXTERNAL err_eol target_top {
          COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 3)"
          SPACING < temporary_1
          PARALLEL_POINT_PROJECTION=FALSE
          SET_CORNERS_TO_SPACING=FALSE
       } (11 )
    }
  }
} /* stubMode > 0, not aligned */
/* Avoid empty optimization result parsing error */
if (addEmptyMetalCheck) {
   BOOLEAN empty OR empty {
      COMMENT = "$layer_name Empty: Dummy Output"
   } (11 )
   SET addEmptyMetalCheck=0;
}
/* reset variables */


 
SET minWidth = 0;
SET maxWidth = 0;
SET minArea = 0;
SET minEnclosedArea = 0;
SET minSpacing = 0;
SET sameNetMinSpacing = 0;
SET maxNumMinEdge = 0;
SET maxTotalMinEdgeLength = 0;
SET minEdgeLength = 0;
SET minEdgeLength2 = 0;
SET minEdgeLength3 = 0;
SET stubRange = 0;
SET stubSpacing = 0;
SET stub2StubSpacing = 0;
SET sideStubExt = 0;
SET sideStubThreshold = 0;
SET stubThreshold = 0;
SET fatPolyContactRule = 0;
SET fatWireThreshold = 0;
SET fatThinMinSpacing = 0;
SET fatFatMinSpacing = 0;
SET fatTblDimension = 0;
@ 195 "adrc/adrc.ev" 2

SET minSpacing = 0.05;
SET fatTblThresh_protru = 0.15;
SET fatTblLength_protru = 0.1;
SET fatTblWidth_protru = 0.06;
@ 1 "adrc/adrc_protru.ev" 1
/*protrusion length rule*/
SIZE metal1     { UNDER_OVER = fatTblThresh_protru / 2.0 - 0.0001  } TEMP = fat
BOOLEAN fat AND metal1  {  } TEMP = fat 
BOOLEAN metal1  NOT fat {  } TEMP = fat_nbr
SIZE fat { OVERSIZE = fatTblLength_protru + 0.0001  } TEMP = fat_ext
BOOLEAN fat_nbr AND fat_ext {} TEMP = fat_nbr
SELECT fat_nbr INTERACT fat TEMP = fat_nbr
/* Get the correct fat extension */
SELECT_EDGE fat_nbr TOUCHING fat { } TEMP = ext_filter
SIZE ext_filter { VSIZE_INSIDE = 0.0001  } TEMP = ext_filter
SIZE ext_filter INSIDE fat_nbr {
   OVERSIZE = fatTblLength_protru- 0.0001 
   INCREMENT = minSpacing
} TEMP=dummy TEMP = fat_nbr
  
VERTEX fat_nbr {
   CONCAVE = TRUE
   SIZE = 0.0002 
} TEMP = corners
SELECT fat_nbr OUTSIDE corners { } TEMP = fat_nbr1
BOOLEAN fat_nbr NOT fat_nbr1 { } TEMP = fat_nbr2
SELECT_CONTAINS fat_nbr1 {
   WIDTH =  0.0002 
   HEIGHT = fatTblLength_protru
} TEMP = good_fat_nbr1
BOOLEAN fat_nbr1 NOT good_fat_nbr1 { } TEMP = fat_nbr1
/* check with L or T shape of fat extension */
SELECT_EDGE fat_nbr2 INTERACT corners { } TEMP = side_edge
LENGTH side_edge { SPACING < fatTblLength_protru } TEMP = vio_edge
SELECT fat_nbr2 INTERACT vio_edge { } TEMP = fat_nbr2
BOOLEAN fat_nbr1 OR fat_nbr2 { } TEMP = fat_nbr
INTERAL fat_nbr {
   SPACING < fatTblWidth_protru
} TEMP = possible_err
if (!layer_empty(possible_err)) {
   SELECT fat_nbr INTERACT possible_err { } TEMP=fat_nbr
   SELECT fat INTERACT fat_nbr {} TEMP=fat
   BOOLEAN fat OR fat_nbr {} TEMP=fat
   INTERNAL fat {
      COMMENT = "$layer_name ProtrusionLength : threshold fatTblThresh_protru um, length  fatTblLength_protru um, width fatTblWidth_protru um"
      SPACING < fatTblWidth_protru
   } (11 )
}
/* protrusion leng rule check */
SET fatTblThresh_protru = 0;
SET fatTblLength_protru = 0;
SET fatTblWidth_protru = 0;
SET minSpacing = 0;
@ 200 "adrc/adrc.ev" 2


SET minSpacing = 0.05;
SET fatTblThresh_protru = 0.3;
SET fatTblLength_protru = 0.17;
SET fatTblWidth_protru = 0.07;
@ 1 "adrc/adrc_protru.ev" 1
/*protrusion length rule*/
SIZE metal1     { UNDER_OVER = fatTblThresh_protru / 2.0 - 0.0001  } TEMP = fat
BOOLEAN fat AND metal1  {  } TEMP = fat 
BOOLEAN metal1  NOT fat {  } TEMP = fat_nbr
SIZE fat { OVERSIZE = fatTblLength_protru + 0.0001  } TEMP = fat_ext
BOOLEAN fat_nbr AND fat_ext {} TEMP = fat_nbr
SELECT fat_nbr INTERACT fat TEMP = fat_nbr
/* Get the correct fat extension */
SELECT_EDGE fat_nbr TOUCHING fat { } TEMP = ext_filter
SIZE ext_filter { VSIZE_INSIDE = 0.0001  } TEMP = ext_filter
SIZE ext_filter INSIDE fat_nbr {
   OVERSIZE = fatTblLength_protru- 0.0001 
   INCREMENT = minSpacing
} TEMP=dummy TEMP = fat_nbr
  
VERTEX fat_nbr {
   CONCAVE = TRUE
   SIZE = 0.0002 
} TEMP = corners
SELECT fat_nbr OUTSIDE corners { } TEMP = fat_nbr1
BOOLEAN fat_nbr NOT fat_nbr1 { } TEMP = fat_nbr2
SELECT_CONTAINS fat_nbr1 {
   WIDTH =  0.0002 
   HEIGHT = fatTblLength_protru
} TEMP = good_fat_nbr1
BOOLEAN fat_nbr1 NOT good_fat_nbr1 { } TEMP = fat_nbr1
/* check with L or T shape of fat extension */
SELECT_EDGE fat_nbr2 INTERACT corners { } TEMP = side_edge
LENGTH side_edge { SPACING < fatTblLength_protru } TEMP = vio_edge
SELECT fat_nbr2 INTERACT vio_edge { } TEMP = fat_nbr2
BOOLEAN fat_nbr1 OR fat_nbr2 { } TEMP = fat_nbr
INTERAL fat_nbr {
   SPACING < fatTblWidth_protru
} TEMP = possible_err
if (!layer_empty(possible_err)) {
   SELECT fat_nbr INTERACT possible_err { } TEMP=fat_nbr
   SELECT fat INTERACT fat_nbr {} TEMP=fat
   BOOLEAN fat OR fat_nbr {} TEMP=fat
   INTERNAL fat {
      COMMENT = "$layer_name ProtrusionLength : threshold fatTblThresh_protru um, length  fatTblLength_protru um, width fatTblWidth_protru um"
      SPACING < fatTblWidth_protru
   } (11 )
}
/* protrusion leng rule check */
SET fatTblThresh_protru = 0;
SET fatTblLength_protru = 0;
SET fatTblWidth_protru = 0;
SET minSpacing = 0;
@ 206 "adrc/adrc.ev" 2


SET minSpacing = 0.05;
SET fatTblThresh_protru = 1.5;
SET fatTblLength_protru = 0.7;
SET fatTblWidth_protru = 0.15;
@ 1 "adrc/adrc_protru.ev" 1
/*protrusion length rule*/
SIZE metal1     { UNDER_OVER = fatTblThresh_protru / 2.0 - 0.0001  } TEMP = fat
BOOLEAN fat AND metal1  {  } TEMP = fat 
BOOLEAN metal1  NOT fat {  } TEMP = fat_nbr
SIZE fat { OVERSIZE = fatTblLength_protru + 0.0001  } TEMP = fat_ext
BOOLEAN fat_nbr AND fat_ext {} TEMP = fat_nbr
SELECT fat_nbr INTERACT fat TEMP = fat_nbr
/* Get the correct fat extension */
SELECT_EDGE fat_nbr TOUCHING fat { } TEMP = ext_filter
SIZE ext_filter { VSIZE_INSIDE = 0.0001  } TEMP = ext_filter
SIZE ext_filter INSIDE fat_nbr {
   OVERSIZE = fatTblLength_protru- 0.0001 
   INCREMENT = minSpacing
} TEMP=dummy TEMP = fat_nbr
  
VERTEX fat_nbr {
   CONCAVE = TRUE
   SIZE = 0.0002 
} TEMP = corners
SELECT fat_nbr OUTSIDE corners { } TEMP = fat_nbr1
BOOLEAN fat_nbr NOT fat_nbr1 { } TEMP = fat_nbr2
SELECT_CONTAINS fat_nbr1 {
   WIDTH =  0.0002 
   HEIGHT = fatTblLength_protru
} TEMP = good_fat_nbr1
BOOLEAN fat_nbr1 NOT good_fat_nbr1 { } TEMP = fat_nbr1
/* check with L or T shape of fat extension */
SELECT_EDGE fat_nbr2 INTERACT corners { } TEMP = side_edge
LENGTH side_edge { SPACING < fatTblLength_protru } TEMP = vio_edge
SELECT fat_nbr2 INTERACT vio_edge { } TEMP = fat_nbr2
BOOLEAN fat_nbr1 OR fat_nbr2 { } TEMP = fat_nbr
INTERAL fat_nbr {
   SPACING < fatTblWidth_protru
} TEMP = possible_err
if (!layer_empty(possible_err)) {
   SELECT fat_nbr INTERACT possible_err { } TEMP=fat_nbr
   SELECT fat INTERACT fat_nbr {} TEMP=fat
   BOOLEAN fat OR fat_nbr {} TEMP=fat
   INTERNAL fat {
      COMMENT = "$layer_name ProtrusionLength : threshold fatTblThresh_protru um, length  fatTblLength_protru um, width fatTblWidth_protru um"
      SPACING < fatTblWidth_protru
   } (11 )
}
/* protrusion leng rule check */
SET fatTblThresh_protru = 0;
SET fatTblLength_protru = 0;
SET fatTblWidth_protru = 0;
SET minSpacing = 0;
@ 212 "adrc/adrc.ev" 2





/* Start of Met1 fat table spacing rules */
SET fatTblSpacingMode = 0;
SET parallelLengthMode = 0;
SET router_parallelLengthNetMode = 0;

SET fatTblThreshold = 0.151;
SET fatTblParallelLength = 0.151;
SET minWidth = 0.05;

SET fatTblThreshold_Start = 0;
SET fatTblSpacing = 0.06;
@ 1 "adrc/adrc_fatMetal.ev" 1
/*check fat metal table*/
if (fatTblThreshold > 0) {
    if ((fatTblThreshold / 2.0) > 0.0001 ) {
       SIZE fat_candidate  { UNDER_OVER = fatTblThreshold / 2.0 - 0.0001  } TEMP = fat_candidate
       if (fatTblNextThreshold > 0) {
          SIZE fat_candidate { UNDER_OVER = fatTblNextThreshold / 2.0 - 0.0001  } TEMP = fat_next
          BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
          BOOLEAN fat AND fat_target { } TEMP = fat
          SET fatTblNextThreshold = 0;
       } else {
          BOOLEAN fat_candidate AND fat_target {  } TEMP = fat 
       }
    } else {
      COPY fat_target {  } TEMP = fat 
    }
    COPY fat_target { } TEMP = spc_target
    if (fatTblThreshold_Start > 0  || fatTblThreshold_End > 0) {
       if (fatTblThreshold_Start > 0) {
          SIZE fat_target { UNDER_OVER = fatTblThreshold_Start / 2.0 - 0.0001  } TEMP = spc_target
       }
       if (fatTblThreshold_End > 0 && fatTblThreshold_End > fatTblThreshold_Start) {
          SIZE spc_target { UNDER_OVER = fatTblThreshold_End / 2.0 - 0.0001  } TEMP = fat_end
          BOOLEAN spc_target NOT fat_end { } TEMP = spc_target
       }
       BOOLEAN spc_target AND fat_target {  } TEMP = spc_target
       if (ignoreBlockage == 0 && fatTblThreshold_Start < fatTblThreshold_1) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal1_blockage  {  } TEMP = spc_target
       }
       SET fatTblThreshold_Start = 0;
       SET fatTblThreshold_End = 0;
       SET fatTblThreshold_1 = 0;
    } else {
       if (ignoreBlockage == 0) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal1_blockage  {  } TEMP = spc_target
       }
    }
 
    if (fatTblEnclosedArea > 0) {
       SELECT holes INTERACT fat { } TEMP = fat_holes
       AREA fat_holes { 
          RANGE = [0.0001 * 0.0001 , fatTblEnclosedArea - 0.0001 * 0.0001 ]
       } TEMP = fat_holes
       if (fatTblMinEnclosedAreaMode==0) {
          SIZE fat_holes { OVER_UNDER = fatTblThreshold / 2.0 + 0.0001  } TEMP = ovun_holes
          SELECT ovun_holes INTERACT fat_holes { RANGE = [2, 9999999999 ] } TEMP = merged_holes
          BOOLEAN fat_candidate AND fat_target { } TEMP = fat_metal
          BOOLEAN metal1  NOT fat_metal { } TEMP = thin_metal
          BOOLEAN thin_metal NOT ovun_holes { } TEMP = thin_metal
          SELECT ovun_holes INTERACT thin_metal { } TEMP = thin_holes
          BOOLEAN thin_holes OR merged_holes { } TEMP = thin_holes
          BOOLEAN fat_holes NOT thin_holes { } TEMP = fat_holes
       }
       COPY fat_holes { 
	  COMMENT = "$layer_name EnclsArea : fat metal ( fatTblThreshold um) minimum enclosed area (mode fatTblMinEnclosedAreaMode ) = fatTblEnclosedArea um*um"
       } (11 )
       SET fatTblEnclosedArea = 0;
    }
    if (fatTblSpacing > 0) {
       /*check fat metal*/ 
       if (fatTblParallelLength > 0) {
          if (router_parallelLengthNetMode == 1 || parallelLengthMode == 1) {
             AREA spc_target { RANGE = [fatTblParallelLength * minWidth + 0.0001 , 9999999999 ] } TEMP = spc_target1
             COPY spc_target1 { } TEMP = spc_target2
          } else {
             COPY spc_target { } TEMP = spc_target2
          }
          if (parallelLengthMode == 1) {
             SELECT metal1  INTERACT fat { } TEMP = fat_all 
             BOOLEAN fat_all OR fat { } TEMP = fat2
             SELECT metal1  INTERACT spc_target2 { } TEMP = spc_target_all
             BOOLEAN spc_target_all OR spc_target2 { } TEMP = spc_target2
          } else {
             COPY fat { } TEMP = fat2
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING <= fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
                OUTPUT_EDGES = TRUE
             } TEMP = vio_edge
             SELECT vio_edge INTERACT fat { } TEMP = vio_edge
             SELECT vio_edge INTERACT spc_target1 { } TEMP = vio_edge
             SELECT violation INTERACT vio_edge { } TEMP = violation
          } else {
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
          }
          BOOLEAN violation NOT fat_target { } TEMP = violation
          if (fatTblParallelLength < fatTblSpacing) {
             SELECT_EDGE violation TOUCHING fat2 {
                VSIZE_INSIDE = fatTblParallelLength - 0.0002 
             } TEMP = vio_filter
             SELECT_CONTAINS vio_filter { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = vio_filter
             SELECT violation INTERACT vio_filter { } TEMP = violation
          } else {
             SELECT_CONTAINS violation { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = violation
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING = [fatTblSpacing, fatTblSpacing]
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
             } TEMP = violation3
             BOOLEAN violation3 NOT fat_target { } TEMP = violation3
             BOOLEAN violation NOT violation3 { } TEMP= violation
          }
          SELECT_EDGE fat2 TOUCHING violation { } TEMP=fat_viol
          BOOLEAN fat_viol AND violation { } TEMP=fat_viol
          SELECT_EDGE spc_target2 TOUCHING violation { } TEMP=spc_target2
          BOOLEAN spc_target2 AND violation { } TEMP= spc_target2
	  if (ignoreChildCell == 1) {
             EXTERNAL fat_viol spc_target2 {
		SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		TOUCH = FALSE
		POINT_TOUCH = FALSE
		NON_PARALLEL = TRUE
	     } TEMP = spc_mode0_out
             BOOLEAN spc_mode0_out NOT spc_mode0_child_out { } TEMP = spc_mode0_diff_out
             SELECT spc_mode0_out INTERACT spc_mode0_diff_out { } TEMP = spc_mode0_out
	     SELECT_EDGE fat2 TOUCHING spc_mode0_out { } TEMP=fat_viol
	     BOOLEAN fat_viol AND spc_mode0_out { } TEMP=fat_viol
	     SELECT_EDGE spc_target2 TOUCHING spc_mode0_out { } TEMP=spc_target2
	     BOOLEAN spc_target2 AND spc_mode0_out { } TEMP=spc_target2
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (11 )  		
	  } else {
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing 
	        SET_CORNERS_TO_SPACING = FALSE
	        PARALLEL_POINT_PROJECTION = FALSE
	        TOUCH = FALSE
	        POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (11 )
	  }
	  if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	     if (ignoreChildCell == 1) {
		EXTERNAL fat spc_target {
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} TEMP = spc_mode1_out
	        BOOLEAN spc_mode1_out NOT spc_mode1_child_out { } TEMP = spc_mode1_diff_out
	        SELECT spc_mode1_out INTERACT spc_mode1_diff_out { } TEMP = spc_mode1_out
                SELECT_EDGE fat TOUCHING spc_mode1_out { } TEMP=fat_viol
	        BOOLEAN fat_viol AND spc_mode1_out { } TEMP=fat_viol
	        SELECT_EDGE spc_target TOUCHING spc_mode1_out { } TEMP=spc_target2
	        BOOLEAN spc_target2 AND spc_mode1_out { } TEMP=spc_target2
	        EXTERNAL fat_viol spc_target2 {
	           COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um " 	    
		   SPACING < fatTblSpacing_dg
                   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} (11 )
	     } else {
	        EXTERNAL fat spc_target {
		   COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um "
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
	    	   PARALLEL_POINT_PROJECTION = FALSE
	           TOUCH = FALSE
	     	   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } (11 ) 
	     }
          }
       } else {
	  if (ignoreChildCell == 1) {
              EXTERNAL fat spc_target {
                 SPACING < fatTblSpacing
                 BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
              } TEMP = spc_out
	      BOOLEAN spc_out NOT spc_child_out { } TEMP = spc_diff_out
	      SELECT spc_out INTERACT spc_diff_out { } TEMP = spc_out
	      SELECT_EDGE fat TOUCHING spc_out { } TEMP=fat_viol
	      BOOLEAN fat_viol AND spc_out { } TEMP=fat_viol
              SELECT_EDGE spc_target TOUCHING spc_out { } TEMP=spc_target2
	      BOOLEAN spc_target2 AND spc_out { } TEMP=spc_target2
	      EXTERNAL fat_viol spc_target2 {
		 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
		 BOX_CORNER = FALSE 
		 NON_PARALLEL = TRUE
		 POINT_TOUCH = FALSE
	      } (11 ) 
	  } else {
	      EXTERNAL fat spc_target {
                 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
	         BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
	      } (11 ) 
	  }
       }
       /*check metal in the extension range*/ 
       if (fatTblExtensionRange > 0) {
	  if (fatWireExtensionMode == 0) {
	     SIZE fat { OVERSIZE = fatTblExtensionRange } TEMP = fat_tmp
             BOOLEAN fat_tmp AND metal1  { } TEMP = fat_tmp
  	     BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
             SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_ext
             BOOLEAN fat_ext OR fat { } TEMP = fat_ext
	     if (fatTblParallelLength > 0) {
                if (fatTblParallelLength > fatTblExtensionRange) {
                   SIZE fat { OVERSIZE = fatTblParallelLength } TEMP = fat_tmp
                   BOOLEAN fat_tmp AND metal1  { } TEMP = fat_tmp
  	           BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
                   SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_parallel
                   BOOLEAN fat_parallel OR fat { } TEMP = fat_parallel
                } else {
                   COPY fat_ext { } TEMP = fat_parallel
                }
		EXTERNAL fat_parallel spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
	           NON_PARALLEL = TRUE
	        } TEMP = vio_filter_set
		EXTERNAL fat_ext spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } TEMP = vio_set
                if (fatTblParallelLength < fatTblSpacing) {
                   SELECT_EDGE vio_filter_set TOUCHING fat_parallel {
                      VSIZE_INSIDE = fatTblParallelLength - 0.0002 
                   } TEMP = vio_filter_set_filter
                   SELECT_CONTAINS vio_filter_set_filter { 
                      WIDTH =  0.0002 
                      HEIGHT = fatTblParallelLength + 0.0001 
                   } TEMP = vio_filter_set_filter
                   SELECT vio_filter_set INTERACT vio_filter_set_filter { } TEMP = vio_filter
                } else {
	           SELECT_CONTAINS vio_filter_set { 
	              WIDTH =  0.0002 
	              HEIGHT = fatTblParallelLength + 0.0001 
	           } TEMP = vio_filter
                }
                SELECT vio_set INSIDE vio_filter { } TEMP = mode0_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out1 NOT mode0_child_out1 { } TEMP = mode0_diff_out1
                   SELECT mode0_out1 INTERACT mode0_diff_out1 { } TEMP = mode0_out1
                }
                COPY mode0_out1 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing  = fatTblSpacing um"
                } (11 )
		if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	           EXTERNAL fat_ext spc_target {
		      SPACING < fatTblSpacing_dg
	              SET_CORNERS_TO_SPACING = FALSE
		      PARALLEL_POINT_PROJECTION = FALSE
		      TOUCH = TRUE
		      POINT_TOUCH = FALSE
		      NON_PARALLEL = TRUE
	           } TEMP = mode0_out2
                   if (ignoreChildCell == 1) {
                      BOOLEAN mode0_out2 NOT mode0_child_out2 { } TEMP = mode0_diff_out2
                      SELECT mode0_out2 INTERACT mode0_diff_out2 { } TEMP = mode0_out2
                   }
                   COPY mode0_out2 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing (mode 1/2) = fatTblSpacing um/ fatTblSpacing_dg um "
                   } (11 )
	        } 
	     } else {
	        EXTERNAL fat_ext spc_target {
		   SPACING < fatTblSpacing
		   NON_PARALLEL = TRUE
		   SET_CORNERS_TO_SPACING = FALSE
		   POINT_TOUCH = FALSE
		} TEMP = mode0_out3
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out3 NOT mode0_child_out3 { } TEMP = mode0_diff_out3
                   SELECT mode0_out3 INTERACT mode0_diff_out3 { } TEMP = mode0_out3
                }
                COPY mode0_out3 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range ( fatTblExtensionRange um) minimum spacing = fatTblSpacing um"
                } (11 )
	     }
	  } else if (fatWireExtensionMode == 1) {
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal1  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             if (fatTblParallelLength > 0) {
                EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
		   BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   CHECK_SAME_POLYGON = TRUE 
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
	        SELECT fat_ext INTERACT spacing {  } TEMP = fat_ext
		BOOLEAN fat_ext OR spacing {  } TEMP = combined_fat_ext
                EXTERNAL combined_fat_ext fat {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
                } TEMP = fat_spacing
		BOOLEAN fat_spacing AND fat_ran {  } TEMP = fat_spacing
		BOOLEAN combined_fat_ext OR fat_spacing {  } TEMP = combined_fat_ext
                SELECT_CONTAINS combined_fat_ext { 
                   WIDTH =  0.0002 
                   HEIGHT = fatTblParallelLength + 0.0001 
                } TEMP = combined_fat_ext
		SELECT spacing INTERACT combined_fat_ext { 
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out1 NOT mode1_child_out1 { } TEMP = mode1_diff_out1
                   SELECT mode1_out1 INTERACT mode1_diff_out1 { } TEMP = mode1_out1 
                }
                COPY mode1_out1 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (11 ) 
	     } else {
               	EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
	           BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
	           CHECK_SAME_POLYGON = TRUE 
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
                SELECT spacing INTERACT fat_ext {
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out2
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out2 NOT mode1_child_out2 { } TEMP = mode1_diff_out2
                   SELECT mode1_out2 INTERACT mode1_diff_out2 { } TEMP = mode1_out2
                }
                COPY mode1_out2 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (11 )
	     }
	  } else if (fatWireExtensionMode == 2) {
	     SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
             BOOLEAN fat_ran AND metal1  {  } TEMP = fat_ext
             BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	      	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
             } TEMP = spacing
 	     SELECT spacing INSIDE fat_ran {  } TEMP = spacing
	     SELECT spacing OUTSIDE fat {  } TEMP = spacing
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode2_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode2_out NOT mode2_child_out { } TEMP = mode2_diff_out
                SELECT mode2_out INTERACT mode2_diff_out { } TEMP = mode2_out 
             }
             COPY mode2_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 2, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (11 )
	  } else if (fatWireExtensionMode == 3) {
             SIZE fat {
	        GROW_LEFT = fatTblExtensionRange
	        GROW_RIGHT = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal1  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	       	PARALLEL = TRUE

	       	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		HORIZONTAL_ONLY = TRUE
             } TEMP = spacing_hor
	     SELECT spacing_hor INSIDE fat_ran {  } TEMP = spacing_hor
	     SELECT spacing_hor OUTSIDE fat {  } TEMP = spacing_hor
             SIZE fat {
	        GROW_TOP = fatTblExtensionRange
	        GROW_BOTTOM = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal1  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	        POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		VERTICAL_ONLY = TRUE
             } TEMP = spacing_ver
	     SELECT spacing_ver INSIDE fat_ran {  } TEMP = spacing_ver
	     SELECT spacing_ver OUTSIDE fat {  } TEMP = spacing_ver
  	     BOOLEAN spacing_hor OR spacing_ver {  } TEMP = spacing
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal1  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
  	     /* check overlapped projection length */
 	     if (fatTblParallelLength > 0) {
                POLYGON_FEATURES fat_ext {
                   EQUATIONS {
                      vnum = EV_VNUM_IN;
                      if ( vnum > 0) {
                         bdLeft = EV_VXCOORD_IN[0];
                         bdRight = EV_VXCOORD_IN[0];
                         bdBottom = EV_VYCOORD_IN[0];
                         bdTop = EV_VYCOORD_IN[0];
                         FOR (i = 1; i < vnum; i++) {
                            if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
                            else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
                            if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
                            else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
                         } /* FOR i */
                         if ( (bdRight - bdLeft) >= fatTblParallelLength ||
                  	      (bdTop - bdBottom) >= fatTblParallelLength) {
                            FOR (i = 0; i < vnum; i++) {
                               EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
                               EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
                            }
                            EV_VNUM_OUT = vnum;
                 	    EV_SAVE_POLYGON();
                         }
                      }
                   }
                } TEMP = fat_ext /* POLYGON_FEATURE */
             }
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode3_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode3_out NOT mode3_child_out { } TEMP = mode3_diff_out
                SELECT mode3_out INTERACT mode3_diff_out { } TEMP = mode3_out
             }
             COPY mode3_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 3, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (11 )
          }
       }
       SET fatTblSpacing = 0;
    }
}
@ 228 "adrc/adrc.ev" 2


SET fatTblThreshold = 0.301;
SET fatTblParallelLength = 0.301;
SET minWidth = 0.05;

SET fatTblThreshold_Start = 0;
SET fatTblSpacing = 0.1;
@ 1 "adrc/adrc_fatMetal.ev" 1
/*check fat metal table*/
if (fatTblThreshold > 0) {
    if ((fatTblThreshold / 2.0) > 0.0001 ) {
       SIZE fat_candidate  { UNDER_OVER = fatTblThreshold / 2.0 - 0.0001  } TEMP = fat_candidate
       if (fatTblNextThreshold > 0) {
          SIZE fat_candidate { UNDER_OVER = fatTblNextThreshold / 2.0 - 0.0001  } TEMP = fat_next
          BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
          BOOLEAN fat AND fat_target { } TEMP = fat
          SET fatTblNextThreshold = 0;
       } else {
          BOOLEAN fat_candidate AND fat_target {  } TEMP = fat 
       }
    } else {
      COPY fat_target {  } TEMP = fat 
    }
    COPY fat_target { } TEMP = spc_target
    if (fatTblThreshold_Start > 0  || fatTblThreshold_End > 0) {
       if (fatTblThreshold_Start > 0) {
          SIZE fat_target { UNDER_OVER = fatTblThreshold_Start / 2.0 - 0.0001  } TEMP = spc_target
       }
       if (fatTblThreshold_End > 0 && fatTblThreshold_End > fatTblThreshold_Start) {
          SIZE spc_target { UNDER_OVER = fatTblThreshold_End / 2.0 - 0.0001  } TEMP = fat_end
          BOOLEAN spc_target NOT fat_end { } TEMP = spc_target
       }
       BOOLEAN spc_target AND fat_target {  } TEMP = spc_target
       if (ignoreBlockage == 0 && fatTblThreshold_Start < fatTblThreshold_1) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal1_blockage  {  } TEMP = spc_target
       }
       SET fatTblThreshold_Start = 0;
       SET fatTblThreshold_End = 0;
       SET fatTblThreshold_1 = 0;
    } else {
       if (ignoreBlockage == 0) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal1_blockage  {  } TEMP = spc_target
       }
    }
 
    if (fatTblEnclosedArea > 0) {
       SELECT holes INTERACT fat { } TEMP = fat_holes
       AREA fat_holes { 
          RANGE = [0.0001 * 0.0001 , fatTblEnclosedArea - 0.0001 * 0.0001 ]
       } TEMP = fat_holes
       if (fatTblMinEnclosedAreaMode==0) {
          SIZE fat_holes { OVER_UNDER = fatTblThreshold / 2.0 + 0.0001  } TEMP = ovun_holes
          SELECT ovun_holes INTERACT fat_holes { RANGE = [2, 9999999999 ] } TEMP = merged_holes
          BOOLEAN fat_candidate AND fat_target { } TEMP = fat_metal
          BOOLEAN metal1  NOT fat_metal { } TEMP = thin_metal
          BOOLEAN thin_metal NOT ovun_holes { } TEMP = thin_metal
          SELECT ovun_holes INTERACT thin_metal { } TEMP = thin_holes
          BOOLEAN thin_holes OR merged_holes { } TEMP = thin_holes
          BOOLEAN fat_holes NOT thin_holes { } TEMP = fat_holes
       }
       COPY fat_holes { 
	  COMMENT = "$layer_name EnclsArea : fat metal ( fatTblThreshold um) minimum enclosed area (mode fatTblMinEnclosedAreaMode ) = fatTblEnclosedArea um*um"
       } (11 )
       SET fatTblEnclosedArea = 0;
    }
    if (fatTblSpacing > 0) {
       /*check fat metal*/ 
       if (fatTblParallelLength > 0) {
          if (router_parallelLengthNetMode == 1 || parallelLengthMode == 1) {
             AREA spc_target { RANGE = [fatTblParallelLength * minWidth + 0.0001 , 9999999999 ] } TEMP = spc_target1
             COPY spc_target1 { } TEMP = spc_target2
          } else {
             COPY spc_target { } TEMP = spc_target2
          }
          if (parallelLengthMode == 1) {
             SELECT metal1  INTERACT fat { } TEMP = fat_all 
             BOOLEAN fat_all OR fat { } TEMP = fat2
             SELECT metal1  INTERACT spc_target2 { } TEMP = spc_target_all
             BOOLEAN spc_target_all OR spc_target2 { } TEMP = spc_target2
          } else {
             COPY fat { } TEMP = fat2
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING <= fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
                OUTPUT_EDGES = TRUE
             } TEMP = vio_edge
             SELECT vio_edge INTERACT fat { } TEMP = vio_edge
             SELECT vio_edge INTERACT spc_target1 { } TEMP = vio_edge
             SELECT violation INTERACT vio_edge { } TEMP = violation
          } else {
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
          }
          BOOLEAN violation NOT fat_target { } TEMP = violation
          if (fatTblParallelLength < fatTblSpacing) {
             SELECT_EDGE violation TOUCHING fat2 {
                VSIZE_INSIDE = fatTblParallelLength - 0.0002 
             } TEMP = vio_filter
             SELECT_CONTAINS vio_filter { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = vio_filter
             SELECT violation INTERACT vio_filter { } TEMP = violation
          } else {
             SELECT_CONTAINS violation { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = violation
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING = [fatTblSpacing, fatTblSpacing]
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
             } TEMP = violation3
             BOOLEAN violation3 NOT fat_target { } TEMP = violation3
             BOOLEAN violation NOT violation3 { } TEMP= violation
          }
          SELECT_EDGE fat2 TOUCHING violation { } TEMP=fat_viol
          BOOLEAN fat_viol AND violation { } TEMP=fat_viol
          SELECT_EDGE spc_target2 TOUCHING violation { } TEMP=spc_target2
          BOOLEAN spc_target2 AND violation { } TEMP= spc_target2
	  if (ignoreChildCell == 1) {
             EXTERNAL fat_viol spc_target2 {
		SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		TOUCH = FALSE
		POINT_TOUCH = FALSE
		NON_PARALLEL = TRUE
	     } TEMP = spc_mode0_out
             BOOLEAN spc_mode0_out NOT spc_mode0_child_out { } TEMP = spc_mode0_diff_out
             SELECT spc_mode0_out INTERACT spc_mode0_diff_out { } TEMP = spc_mode0_out
	     SELECT_EDGE fat2 TOUCHING spc_mode0_out { } TEMP=fat_viol
	     BOOLEAN fat_viol AND spc_mode0_out { } TEMP=fat_viol
	     SELECT_EDGE spc_target2 TOUCHING spc_mode0_out { } TEMP=spc_target2
	     BOOLEAN spc_target2 AND spc_mode0_out { } TEMP=spc_target2
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (11 )  		
	  } else {
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing 
	        SET_CORNERS_TO_SPACING = FALSE
	        PARALLEL_POINT_PROJECTION = FALSE
	        TOUCH = FALSE
	        POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (11 )
	  }
	  if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	     if (ignoreChildCell == 1) {
		EXTERNAL fat spc_target {
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} TEMP = spc_mode1_out
	        BOOLEAN spc_mode1_out NOT spc_mode1_child_out { } TEMP = spc_mode1_diff_out
	        SELECT spc_mode1_out INTERACT spc_mode1_diff_out { } TEMP = spc_mode1_out
                SELECT_EDGE fat TOUCHING spc_mode1_out { } TEMP=fat_viol
	        BOOLEAN fat_viol AND spc_mode1_out { } TEMP=fat_viol
	        SELECT_EDGE spc_target TOUCHING spc_mode1_out { } TEMP=spc_target2
	        BOOLEAN spc_target2 AND spc_mode1_out { } TEMP=spc_target2
	        EXTERNAL fat_viol spc_target2 {
	           COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um " 	    
		   SPACING < fatTblSpacing_dg
                   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} (11 )
	     } else {
	        EXTERNAL fat spc_target {
		   COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um "
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
	    	   PARALLEL_POINT_PROJECTION = FALSE
	           TOUCH = FALSE
	     	   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } (11 ) 
	     }
          }
       } else {
	  if (ignoreChildCell == 1) {
              EXTERNAL fat spc_target {
                 SPACING < fatTblSpacing
                 BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
              } TEMP = spc_out
	      BOOLEAN spc_out NOT spc_child_out { } TEMP = spc_diff_out
	      SELECT spc_out INTERACT spc_diff_out { } TEMP = spc_out
	      SELECT_EDGE fat TOUCHING spc_out { } TEMP=fat_viol
	      BOOLEAN fat_viol AND spc_out { } TEMP=fat_viol
              SELECT_EDGE spc_target TOUCHING spc_out { } TEMP=spc_target2
	      BOOLEAN spc_target2 AND spc_out { } TEMP=spc_target2
	      EXTERNAL fat_viol spc_target2 {
		 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
		 BOX_CORNER = FALSE 
		 NON_PARALLEL = TRUE
		 POINT_TOUCH = FALSE
	      } (11 ) 
	  } else {
	      EXTERNAL fat spc_target {
                 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
	         BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
	      } (11 ) 
	  }
       }
       /*check metal in the extension range*/ 
       if (fatTblExtensionRange > 0) {
	  if (fatWireExtensionMode == 0) {
	     SIZE fat { OVERSIZE = fatTblExtensionRange } TEMP = fat_tmp
             BOOLEAN fat_tmp AND metal1  { } TEMP = fat_tmp
  	     BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
             SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_ext
             BOOLEAN fat_ext OR fat { } TEMP = fat_ext
	     if (fatTblParallelLength > 0) {
                if (fatTblParallelLength > fatTblExtensionRange) {
                   SIZE fat { OVERSIZE = fatTblParallelLength } TEMP = fat_tmp
                   BOOLEAN fat_tmp AND metal1  { } TEMP = fat_tmp
  	           BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
                   SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_parallel
                   BOOLEAN fat_parallel OR fat { } TEMP = fat_parallel
                } else {
                   COPY fat_ext { } TEMP = fat_parallel
                }
		EXTERNAL fat_parallel spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
	           NON_PARALLEL = TRUE
	        } TEMP = vio_filter_set
		EXTERNAL fat_ext spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } TEMP = vio_set
                if (fatTblParallelLength < fatTblSpacing) {
                   SELECT_EDGE vio_filter_set TOUCHING fat_parallel {
                      VSIZE_INSIDE = fatTblParallelLength - 0.0002 
                   } TEMP = vio_filter_set_filter
                   SELECT_CONTAINS vio_filter_set_filter { 
                      WIDTH =  0.0002 
                      HEIGHT = fatTblParallelLength + 0.0001 
                   } TEMP = vio_filter_set_filter
                   SELECT vio_filter_set INTERACT vio_filter_set_filter { } TEMP = vio_filter
                } else {
	           SELECT_CONTAINS vio_filter_set { 
	              WIDTH =  0.0002 
	              HEIGHT = fatTblParallelLength + 0.0001 
	           } TEMP = vio_filter
                }
                SELECT vio_set INSIDE vio_filter { } TEMP = mode0_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out1 NOT mode0_child_out1 { } TEMP = mode0_diff_out1
                   SELECT mode0_out1 INTERACT mode0_diff_out1 { } TEMP = mode0_out1
                }
                COPY mode0_out1 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing  = fatTblSpacing um"
                } (11 )
		if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	           EXTERNAL fat_ext spc_target {
		      SPACING < fatTblSpacing_dg
	              SET_CORNERS_TO_SPACING = FALSE
		      PARALLEL_POINT_PROJECTION = FALSE
		      TOUCH = TRUE
		      POINT_TOUCH = FALSE
		      NON_PARALLEL = TRUE
	           } TEMP = mode0_out2
                   if (ignoreChildCell == 1) {
                      BOOLEAN mode0_out2 NOT mode0_child_out2 { } TEMP = mode0_diff_out2
                      SELECT mode0_out2 INTERACT mode0_diff_out2 { } TEMP = mode0_out2
                   }
                   COPY mode0_out2 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing (mode 1/2) = fatTblSpacing um/ fatTblSpacing_dg um "
                   } (11 )
	        } 
	     } else {
	        EXTERNAL fat_ext spc_target {
		   SPACING < fatTblSpacing
		   NON_PARALLEL = TRUE
		   SET_CORNERS_TO_SPACING = FALSE
		   POINT_TOUCH = FALSE
		} TEMP = mode0_out3
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out3 NOT mode0_child_out3 { } TEMP = mode0_diff_out3
                   SELECT mode0_out3 INTERACT mode0_diff_out3 { } TEMP = mode0_out3
                }
                COPY mode0_out3 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range ( fatTblExtensionRange um) minimum spacing = fatTblSpacing um"
                } (11 )
	     }
	  } else if (fatWireExtensionMode == 1) {
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal1  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             if (fatTblParallelLength > 0) {
                EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
		   BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   CHECK_SAME_POLYGON = TRUE 
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
	        SELECT fat_ext INTERACT spacing {  } TEMP = fat_ext
		BOOLEAN fat_ext OR spacing {  } TEMP = combined_fat_ext
                EXTERNAL combined_fat_ext fat {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
                } TEMP = fat_spacing
		BOOLEAN fat_spacing AND fat_ran {  } TEMP = fat_spacing
		BOOLEAN combined_fat_ext OR fat_spacing {  } TEMP = combined_fat_ext
                SELECT_CONTAINS combined_fat_ext { 
                   WIDTH =  0.0002 
                   HEIGHT = fatTblParallelLength + 0.0001 
                } TEMP = combined_fat_ext
		SELECT spacing INTERACT combined_fat_ext { 
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out1 NOT mode1_child_out1 { } TEMP = mode1_diff_out1
                   SELECT mode1_out1 INTERACT mode1_diff_out1 { } TEMP = mode1_out1 
                }
                COPY mode1_out1 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (11 ) 
	     } else {
               	EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
	           BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
	           CHECK_SAME_POLYGON = TRUE 
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
                SELECT spacing INTERACT fat_ext {
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out2
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out2 NOT mode1_child_out2 { } TEMP = mode1_diff_out2
                   SELECT mode1_out2 INTERACT mode1_diff_out2 { } TEMP = mode1_out2
                }
                COPY mode1_out2 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (11 )
	     }
	  } else if (fatWireExtensionMode == 2) {
	     SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
             BOOLEAN fat_ran AND metal1  {  } TEMP = fat_ext
             BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	      	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
             } TEMP = spacing
 	     SELECT spacing INSIDE fat_ran {  } TEMP = spacing
	     SELECT spacing OUTSIDE fat {  } TEMP = spacing
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode2_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode2_out NOT mode2_child_out { } TEMP = mode2_diff_out
                SELECT mode2_out INTERACT mode2_diff_out { } TEMP = mode2_out 
             }
             COPY mode2_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 2, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (11 )
	  } else if (fatWireExtensionMode == 3) {
             SIZE fat {
	        GROW_LEFT = fatTblExtensionRange
	        GROW_RIGHT = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal1  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	       	PARALLEL = TRUE

	       	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		HORIZONTAL_ONLY = TRUE
             } TEMP = spacing_hor
	     SELECT spacing_hor INSIDE fat_ran {  } TEMP = spacing_hor
	     SELECT spacing_hor OUTSIDE fat {  } TEMP = spacing_hor
             SIZE fat {
	        GROW_TOP = fatTblExtensionRange
	        GROW_BOTTOM = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal1  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	        POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		VERTICAL_ONLY = TRUE
             } TEMP = spacing_ver
	     SELECT spacing_ver INSIDE fat_ran {  } TEMP = spacing_ver
	     SELECT spacing_ver OUTSIDE fat {  } TEMP = spacing_ver
  	     BOOLEAN spacing_hor OR spacing_ver {  } TEMP = spacing
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal1  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
  	     /* check overlapped projection length */
 	     if (fatTblParallelLength > 0) {
                POLYGON_FEATURES fat_ext {
                   EQUATIONS {
                      vnum = EV_VNUM_IN;
                      if ( vnum > 0) {
                         bdLeft = EV_VXCOORD_IN[0];
                         bdRight = EV_VXCOORD_IN[0];
                         bdBottom = EV_VYCOORD_IN[0];
                         bdTop = EV_VYCOORD_IN[0];
                         FOR (i = 1; i < vnum; i++) {
                            if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
                            else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
                            if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
                            else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
                         } /* FOR i */
                         if ( (bdRight - bdLeft) >= fatTblParallelLength ||
                  	      (bdTop - bdBottom) >= fatTblParallelLength) {
                            FOR (i = 0; i < vnum; i++) {
                               EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
                               EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
                            }
                            EV_VNUM_OUT = vnum;
                 	    EV_SAVE_POLYGON();
                         }
                      }
                   }
                } TEMP = fat_ext /* POLYGON_FEATURE */
             }
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode3_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode3_out NOT mode3_child_out { } TEMP = mode3_diff_out
                SELECT mode3_out INTERACT mode3_diff_out { } TEMP = mode3_out
             }
             COPY mode3_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 3, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (11 )
          }
       }
       SET fatTblSpacing = 0;
    }
}
@ 236 "adrc/adrc.ev" 2


SET fatTblThreshold = 1.501;
SET fatTblParallelLength = 1.501;
SET minWidth = 0.05;

SET fatTblThreshold_Start = 0;
SET fatTblSpacing = 0.5;
@ 1 "adrc/adrc_fatMetal.ev" 1
/*check fat metal table*/
if (fatTblThreshold > 0) {
    if ((fatTblThreshold / 2.0) > 0.0001 ) {
       SIZE fat_candidate  { UNDER_OVER = fatTblThreshold / 2.0 - 0.0001  } TEMP = fat_candidate
       if (fatTblNextThreshold > 0) {
          SIZE fat_candidate { UNDER_OVER = fatTblNextThreshold / 2.0 - 0.0001  } TEMP = fat_next
          BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
          BOOLEAN fat AND fat_target { } TEMP = fat
          SET fatTblNextThreshold = 0;
       } else {
          BOOLEAN fat_candidate AND fat_target {  } TEMP = fat 
       }
    } else {
      COPY fat_target {  } TEMP = fat 
    }
    COPY fat_target { } TEMP = spc_target
    if (fatTblThreshold_Start > 0  || fatTblThreshold_End > 0) {
       if (fatTblThreshold_Start > 0) {
          SIZE fat_target { UNDER_OVER = fatTblThreshold_Start / 2.0 - 0.0001  } TEMP = spc_target
       }
       if (fatTblThreshold_End > 0 && fatTblThreshold_End > fatTblThreshold_Start) {
          SIZE spc_target { UNDER_OVER = fatTblThreshold_End / 2.0 - 0.0001  } TEMP = fat_end
          BOOLEAN spc_target NOT fat_end { } TEMP = spc_target
       }
       BOOLEAN spc_target AND fat_target {  } TEMP = spc_target
       if (ignoreBlockage == 0 && fatTblThreshold_Start < fatTblThreshold_1) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal1_blockage  {  } TEMP = spc_target
       }
       SET fatTblThreshold_Start = 0;
       SET fatTblThreshold_End = 0;
       SET fatTblThreshold_1 = 0;
    } else {
       if (ignoreBlockage == 0) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal1_blockage  {  } TEMP = spc_target
       }
    }
 
    if (fatTblEnclosedArea > 0) {
       SELECT holes INTERACT fat { } TEMP = fat_holes
       AREA fat_holes { 
          RANGE = [0.0001 * 0.0001 , fatTblEnclosedArea - 0.0001 * 0.0001 ]
       } TEMP = fat_holes
       if (fatTblMinEnclosedAreaMode==0) {
          SIZE fat_holes { OVER_UNDER = fatTblThreshold / 2.0 + 0.0001  } TEMP = ovun_holes
          SELECT ovun_holes INTERACT fat_holes { RANGE = [2, 9999999999 ] } TEMP = merged_holes
          BOOLEAN fat_candidate AND fat_target { } TEMP = fat_metal
          BOOLEAN metal1  NOT fat_metal { } TEMP = thin_metal
          BOOLEAN thin_metal NOT ovun_holes { } TEMP = thin_metal
          SELECT ovun_holes INTERACT thin_metal { } TEMP = thin_holes
          BOOLEAN thin_holes OR merged_holes { } TEMP = thin_holes
          BOOLEAN fat_holes NOT thin_holes { } TEMP = fat_holes
       }
       COPY fat_holes { 
	  COMMENT = "$layer_name EnclsArea : fat metal ( fatTblThreshold um) minimum enclosed area (mode fatTblMinEnclosedAreaMode ) = fatTblEnclosedArea um*um"
       } (11 )
       SET fatTblEnclosedArea = 0;
    }
    if (fatTblSpacing > 0) {
       /*check fat metal*/ 
       if (fatTblParallelLength > 0) {
          if (router_parallelLengthNetMode == 1 || parallelLengthMode == 1) {
             AREA spc_target { RANGE = [fatTblParallelLength * minWidth + 0.0001 , 9999999999 ] } TEMP = spc_target1
             COPY spc_target1 { } TEMP = spc_target2
          } else {
             COPY spc_target { } TEMP = spc_target2
          }
          if (parallelLengthMode == 1) {
             SELECT metal1  INTERACT fat { } TEMP = fat_all 
             BOOLEAN fat_all OR fat { } TEMP = fat2
             SELECT metal1  INTERACT spc_target2 { } TEMP = spc_target_all
             BOOLEAN spc_target_all OR spc_target2 { } TEMP = spc_target2
          } else {
             COPY fat { } TEMP = fat2
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING <= fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
                OUTPUT_EDGES = TRUE
             } TEMP = vio_edge
             SELECT vio_edge INTERACT fat { } TEMP = vio_edge
             SELECT vio_edge INTERACT spc_target1 { } TEMP = vio_edge
             SELECT violation INTERACT vio_edge { } TEMP = violation
          } else {
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
          }
          BOOLEAN violation NOT fat_target { } TEMP = violation
          if (fatTblParallelLength < fatTblSpacing) {
             SELECT_EDGE violation TOUCHING fat2 {
                VSIZE_INSIDE = fatTblParallelLength - 0.0002 
             } TEMP = vio_filter
             SELECT_CONTAINS vio_filter { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = vio_filter
             SELECT violation INTERACT vio_filter { } TEMP = violation
          } else {
             SELECT_CONTAINS violation { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = violation
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING = [fatTblSpacing, fatTblSpacing]
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
             } TEMP = violation3
             BOOLEAN violation3 NOT fat_target { } TEMP = violation3
             BOOLEAN violation NOT violation3 { } TEMP= violation
          }
          SELECT_EDGE fat2 TOUCHING violation { } TEMP=fat_viol
          BOOLEAN fat_viol AND violation { } TEMP=fat_viol
          SELECT_EDGE spc_target2 TOUCHING violation { } TEMP=spc_target2
          BOOLEAN spc_target2 AND violation { } TEMP= spc_target2
	  if (ignoreChildCell == 1) {
             EXTERNAL fat_viol spc_target2 {
		SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		TOUCH = FALSE
		POINT_TOUCH = FALSE
		NON_PARALLEL = TRUE
	     } TEMP = spc_mode0_out
             BOOLEAN spc_mode0_out NOT spc_mode0_child_out { } TEMP = spc_mode0_diff_out
             SELECT spc_mode0_out INTERACT spc_mode0_diff_out { } TEMP = spc_mode0_out
	     SELECT_EDGE fat2 TOUCHING spc_mode0_out { } TEMP=fat_viol
	     BOOLEAN fat_viol AND spc_mode0_out { } TEMP=fat_viol
	     SELECT_EDGE spc_target2 TOUCHING spc_mode0_out { } TEMP=spc_target2
	     BOOLEAN spc_target2 AND spc_mode0_out { } TEMP=spc_target2
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (11 )  		
	  } else {
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing 
	        SET_CORNERS_TO_SPACING = FALSE
	        PARALLEL_POINT_PROJECTION = FALSE
	        TOUCH = FALSE
	        POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (11 )
	  }
	  if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	     if (ignoreChildCell == 1) {
		EXTERNAL fat spc_target {
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} TEMP = spc_mode1_out
	        BOOLEAN spc_mode1_out NOT spc_mode1_child_out { } TEMP = spc_mode1_diff_out
	        SELECT spc_mode1_out INTERACT spc_mode1_diff_out { } TEMP = spc_mode1_out
                SELECT_EDGE fat TOUCHING spc_mode1_out { } TEMP=fat_viol
	        BOOLEAN fat_viol AND spc_mode1_out { } TEMP=fat_viol
	        SELECT_EDGE spc_target TOUCHING spc_mode1_out { } TEMP=spc_target2
	        BOOLEAN spc_target2 AND spc_mode1_out { } TEMP=spc_target2
	        EXTERNAL fat_viol spc_target2 {
	           COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um " 	    
		   SPACING < fatTblSpacing_dg
                   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} (11 )
	     } else {
	        EXTERNAL fat spc_target {
		   COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um "
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
	    	   PARALLEL_POINT_PROJECTION = FALSE
	           TOUCH = FALSE
	     	   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } (11 ) 
	     }
          }
       } else {
	  if (ignoreChildCell == 1) {
              EXTERNAL fat spc_target {
                 SPACING < fatTblSpacing
                 BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
              } TEMP = spc_out
	      BOOLEAN spc_out NOT spc_child_out { } TEMP = spc_diff_out
	      SELECT spc_out INTERACT spc_diff_out { } TEMP = spc_out
	      SELECT_EDGE fat TOUCHING spc_out { } TEMP=fat_viol
	      BOOLEAN fat_viol AND spc_out { } TEMP=fat_viol
              SELECT_EDGE spc_target TOUCHING spc_out { } TEMP=spc_target2
	      BOOLEAN spc_target2 AND spc_out { } TEMP=spc_target2
	      EXTERNAL fat_viol spc_target2 {
		 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
		 BOX_CORNER = FALSE 
		 NON_PARALLEL = TRUE
		 POINT_TOUCH = FALSE
	      } (11 ) 
	  } else {
	      EXTERNAL fat spc_target {
                 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
	         BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
	      } (11 ) 
	  }
       }
       /*check metal in the extension range*/ 
       if (fatTblExtensionRange > 0) {
	  if (fatWireExtensionMode == 0) {
	     SIZE fat { OVERSIZE = fatTblExtensionRange } TEMP = fat_tmp
             BOOLEAN fat_tmp AND metal1  { } TEMP = fat_tmp
  	     BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
             SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_ext
             BOOLEAN fat_ext OR fat { } TEMP = fat_ext
	     if (fatTblParallelLength > 0) {
                if (fatTblParallelLength > fatTblExtensionRange) {
                   SIZE fat { OVERSIZE = fatTblParallelLength } TEMP = fat_tmp
                   BOOLEAN fat_tmp AND metal1  { } TEMP = fat_tmp
  	           BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
                   SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_parallel
                   BOOLEAN fat_parallel OR fat { } TEMP = fat_parallel
                } else {
                   COPY fat_ext { } TEMP = fat_parallel
                }
		EXTERNAL fat_parallel spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
	           NON_PARALLEL = TRUE
	        } TEMP = vio_filter_set
		EXTERNAL fat_ext spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } TEMP = vio_set
                if (fatTblParallelLength < fatTblSpacing) {
                   SELECT_EDGE vio_filter_set TOUCHING fat_parallel {
                      VSIZE_INSIDE = fatTblParallelLength - 0.0002 
                   } TEMP = vio_filter_set_filter
                   SELECT_CONTAINS vio_filter_set_filter { 
                      WIDTH =  0.0002 
                      HEIGHT = fatTblParallelLength + 0.0001 
                   } TEMP = vio_filter_set_filter
                   SELECT vio_filter_set INTERACT vio_filter_set_filter { } TEMP = vio_filter
                } else {
	           SELECT_CONTAINS vio_filter_set { 
	              WIDTH =  0.0002 
	              HEIGHT = fatTblParallelLength + 0.0001 
	           } TEMP = vio_filter
                }
                SELECT vio_set INSIDE vio_filter { } TEMP = mode0_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out1 NOT mode0_child_out1 { } TEMP = mode0_diff_out1
                   SELECT mode0_out1 INTERACT mode0_diff_out1 { } TEMP = mode0_out1
                }
                COPY mode0_out1 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing  = fatTblSpacing um"
                } (11 )
		if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	           EXTERNAL fat_ext spc_target {
		      SPACING < fatTblSpacing_dg
	              SET_CORNERS_TO_SPACING = FALSE
		      PARALLEL_POINT_PROJECTION = FALSE
		      TOUCH = TRUE
		      POINT_TOUCH = FALSE
		      NON_PARALLEL = TRUE
	           } TEMP = mode0_out2
                   if (ignoreChildCell == 1) {
                      BOOLEAN mode0_out2 NOT mode0_child_out2 { } TEMP = mode0_diff_out2
                      SELECT mode0_out2 INTERACT mode0_diff_out2 { } TEMP = mode0_out2
                   }
                   COPY mode0_out2 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing (mode 1/2) = fatTblSpacing um/ fatTblSpacing_dg um "
                   } (11 )
	        } 
	     } else {
	        EXTERNAL fat_ext spc_target {
		   SPACING < fatTblSpacing
		   NON_PARALLEL = TRUE
		   SET_CORNERS_TO_SPACING = FALSE
		   POINT_TOUCH = FALSE
		} TEMP = mode0_out3
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out3 NOT mode0_child_out3 { } TEMP = mode0_diff_out3
                   SELECT mode0_out3 INTERACT mode0_diff_out3 { } TEMP = mode0_out3
                }
                COPY mode0_out3 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range ( fatTblExtensionRange um) minimum spacing = fatTblSpacing um"
                } (11 )
	     }
	  } else if (fatWireExtensionMode == 1) {
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal1  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             if (fatTblParallelLength > 0) {
                EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
		   BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   CHECK_SAME_POLYGON = TRUE 
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
	        SELECT fat_ext INTERACT spacing {  } TEMP = fat_ext
		BOOLEAN fat_ext OR spacing {  } TEMP = combined_fat_ext
                EXTERNAL combined_fat_ext fat {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
                } TEMP = fat_spacing
		BOOLEAN fat_spacing AND fat_ran {  } TEMP = fat_spacing
		BOOLEAN combined_fat_ext OR fat_spacing {  } TEMP = combined_fat_ext
                SELECT_CONTAINS combined_fat_ext { 
                   WIDTH =  0.0002 
                   HEIGHT = fatTblParallelLength + 0.0001 
                } TEMP = combined_fat_ext
		SELECT spacing INTERACT combined_fat_ext { 
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out1 NOT mode1_child_out1 { } TEMP = mode1_diff_out1
                   SELECT mode1_out1 INTERACT mode1_diff_out1 { } TEMP = mode1_out1 
                }
                COPY mode1_out1 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (11 ) 
	     } else {
               	EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
	           BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
	           CHECK_SAME_POLYGON = TRUE 
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
                SELECT spacing INTERACT fat_ext {
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out2
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out2 NOT mode1_child_out2 { } TEMP = mode1_diff_out2
                   SELECT mode1_out2 INTERACT mode1_diff_out2 { } TEMP = mode1_out2
                }
                COPY mode1_out2 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (11 )
	     }
	  } else if (fatWireExtensionMode == 2) {
	     SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
             BOOLEAN fat_ran AND metal1  {  } TEMP = fat_ext
             BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	      	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
             } TEMP = spacing
 	     SELECT spacing INSIDE fat_ran {  } TEMP = spacing
	     SELECT spacing OUTSIDE fat {  } TEMP = spacing
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode2_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode2_out NOT mode2_child_out { } TEMP = mode2_diff_out
                SELECT mode2_out INTERACT mode2_diff_out { } TEMP = mode2_out 
             }
             COPY mode2_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 2, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (11 )
	  } else if (fatWireExtensionMode == 3) {
             SIZE fat {
	        GROW_LEFT = fatTblExtensionRange
	        GROW_RIGHT = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal1  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	       	PARALLEL = TRUE

	       	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		HORIZONTAL_ONLY = TRUE
             } TEMP = spacing_hor
	     SELECT spacing_hor INSIDE fat_ran {  } TEMP = spacing_hor
	     SELECT spacing_hor OUTSIDE fat {  } TEMP = spacing_hor
             SIZE fat {
	        GROW_TOP = fatTblExtensionRange
	        GROW_BOTTOM = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal1  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	        POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		VERTICAL_ONLY = TRUE
             } TEMP = spacing_ver
	     SELECT spacing_ver INSIDE fat_ran {  } TEMP = spacing_ver
	     SELECT spacing_ver OUTSIDE fat {  } TEMP = spacing_ver
  	     BOOLEAN spacing_hor OR spacing_ver {  } TEMP = spacing
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal1  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
  	     /* check overlapped projection length */
 	     if (fatTblParallelLength > 0) {
                POLYGON_FEATURES fat_ext {
                   EQUATIONS {
                      vnum = EV_VNUM_IN;
                      if ( vnum > 0) {
                         bdLeft = EV_VXCOORD_IN[0];
                         bdRight = EV_VXCOORD_IN[0];
                         bdBottom = EV_VYCOORD_IN[0];
                         bdTop = EV_VYCOORD_IN[0];
                         FOR (i = 1; i < vnum; i++) {
                            if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
                            else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
                            if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
                            else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
                         } /* FOR i */
                         if ( (bdRight - bdLeft) >= fatTblParallelLength ||
                  	      (bdTop - bdBottom) >= fatTblParallelLength) {
                            FOR (i = 0; i < vnum; i++) {
                               EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
                               EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
                            }
                            EV_VNUM_OUT = vnum;
                 	    EV_SAVE_POLYGON();
                         }
                      }
                   }
                } TEMP = fat_ext /* POLYGON_FEATURE */
             }
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode3_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode3_out NOT mode3_child_out { } TEMP = mode3_diff_out
                SELECT mode3_out INTERACT mode3_diff_out { } TEMP = mode3_out
             }
             COPY mode3_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 3, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (11 )
          }
       }
       SET fatTblSpacing = 0;
    }
}
@ 244 "adrc/adrc.ev" 2


SET fatTblThreshold = 3.001;
SET fatTblParallelLength = 3.001;
SET minWidth = 0.05;

SET fatTblThreshold_Start = 0;
SET fatTblSpacing = 0.6;
@ 1 "adrc/adrc_fatMetal.ev" 1
/*check fat metal table*/
if (fatTblThreshold > 0) {
    if ((fatTblThreshold / 2.0) > 0.0001 ) {
       SIZE fat_candidate  { UNDER_OVER = fatTblThreshold / 2.0 - 0.0001  } TEMP = fat_candidate
       if (fatTblNextThreshold > 0) {
          SIZE fat_candidate { UNDER_OVER = fatTblNextThreshold / 2.0 - 0.0001  } TEMP = fat_next
          BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
          BOOLEAN fat AND fat_target { } TEMP = fat
          SET fatTblNextThreshold = 0;
       } else {
          BOOLEAN fat_candidate AND fat_target {  } TEMP = fat 
       }
    } else {
      COPY fat_target {  } TEMP = fat 
    }
    COPY fat_target { } TEMP = spc_target
    if (fatTblThreshold_Start > 0  || fatTblThreshold_End > 0) {
       if (fatTblThreshold_Start > 0) {
          SIZE fat_target { UNDER_OVER = fatTblThreshold_Start / 2.0 - 0.0001  } TEMP = spc_target
       }
       if (fatTblThreshold_End > 0 && fatTblThreshold_End > fatTblThreshold_Start) {
          SIZE spc_target { UNDER_OVER = fatTblThreshold_End / 2.0 - 0.0001  } TEMP = fat_end
          BOOLEAN spc_target NOT fat_end { } TEMP = spc_target
       }
       BOOLEAN spc_target AND fat_target {  } TEMP = spc_target
       if (ignoreBlockage == 0 && fatTblThreshold_Start < fatTblThreshold_1) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal1_blockage  {  } TEMP = spc_target
       }
       SET fatTblThreshold_Start = 0;
       SET fatTblThreshold_End = 0;
       SET fatTblThreshold_1 = 0;
    } else {
       if (ignoreBlockage == 0) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal1_blockage  {  } TEMP = spc_target
       }
    }
 
    if (fatTblEnclosedArea > 0) {
       SELECT holes INTERACT fat { } TEMP = fat_holes
       AREA fat_holes { 
          RANGE = [0.0001 * 0.0001 , fatTblEnclosedArea - 0.0001 * 0.0001 ]
       } TEMP = fat_holes
       if (fatTblMinEnclosedAreaMode==0) {
          SIZE fat_holes { OVER_UNDER = fatTblThreshold / 2.0 + 0.0001  } TEMP = ovun_holes
          SELECT ovun_holes INTERACT fat_holes { RANGE = [2, 9999999999 ] } TEMP = merged_holes
          BOOLEAN fat_candidate AND fat_target { } TEMP = fat_metal
          BOOLEAN metal1  NOT fat_metal { } TEMP = thin_metal
          BOOLEAN thin_metal NOT ovun_holes { } TEMP = thin_metal
          SELECT ovun_holes INTERACT thin_metal { } TEMP = thin_holes
          BOOLEAN thin_holes OR merged_holes { } TEMP = thin_holes
          BOOLEAN fat_holes NOT thin_holes { } TEMP = fat_holes
       }
       COPY fat_holes { 
	  COMMENT = "$layer_name EnclsArea : fat metal ( fatTblThreshold um) minimum enclosed area (mode fatTblMinEnclosedAreaMode ) = fatTblEnclosedArea um*um"
       } (11 )
       SET fatTblEnclosedArea = 0;
    }
    if (fatTblSpacing > 0) {
       /*check fat metal*/ 
       if (fatTblParallelLength > 0) {
          if (router_parallelLengthNetMode == 1 || parallelLengthMode == 1) {
             AREA spc_target { RANGE = [fatTblParallelLength * minWidth + 0.0001 , 9999999999 ] } TEMP = spc_target1
             COPY spc_target1 { } TEMP = spc_target2
          } else {
             COPY spc_target { } TEMP = spc_target2
          }
          if (parallelLengthMode == 1) {
             SELECT metal1  INTERACT fat { } TEMP = fat_all 
             BOOLEAN fat_all OR fat { } TEMP = fat2
             SELECT metal1  INTERACT spc_target2 { } TEMP = spc_target_all
             BOOLEAN spc_target_all OR spc_target2 { } TEMP = spc_target2
          } else {
             COPY fat { } TEMP = fat2
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING <= fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
                OUTPUT_EDGES = TRUE
             } TEMP = vio_edge
             SELECT vio_edge INTERACT fat { } TEMP = vio_edge
             SELECT vio_edge INTERACT spc_target1 { } TEMP = vio_edge
             SELECT violation INTERACT vio_edge { } TEMP = violation
          } else {
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
          }
          BOOLEAN violation NOT fat_target { } TEMP = violation
          if (fatTblParallelLength < fatTblSpacing) {
             SELECT_EDGE violation TOUCHING fat2 {
                VSIZE_INSIDE = fatTblParallelLength - 0.0002 
             } TEMP = vio_filter
             SELECT_CONTAINS vio_filter { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = vio_filter
             SELECT violation INTERACT vio_filter { } TEMP = violation
          } else {
             SELECT_CONTAINS violation { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = violation
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING = [fatTblSpacing, fatTblSpacing]
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
             } TEMP = violation3
             BOOLEAN violation3 NOT fat_target { } TEMP = violation3
             BOOLEAN violation NOT violation3 { } TEMP= violation
          }
          SELECT_EDGE fat2 TOUCHING violation { } TEMP=fat_viol
          BOOLEAN fat_viol AND violation { } TEMP=fat_viol
          SELECT_EDGE spc_target2 TOUCHING violation { } TEMP=spc_target2
          BOOLEAN spc_target2 AND violation { } TEMP= spc_target2
	  if (ignoreChildCell == 1) {
             EXTERNAL fat_viol spc_target2 {
		SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		TOUCH = FALSE
		POINT_TOUCH = FALSE
		NON_PARALLEL = TRUE
	     } TEMP = spc_mode0_out
             BOOLEAN spc_mode0_out NOT spc_mode0_child_out { } TEMP = spc_mode0_diff_out
             SELECT spc_mode0_out INTERACT spc_mode0_diff_out { } TEMP = spc_mode0_out
	     SELECT_EDGE fat2 TOUCHING spc_mode0_out { } TEMP=fat_viol
	     BOOLEAN fat_viol AND spc_mode0_out { } TEMP=fat_viol
	     SELECT_EDGE spc_target2 TOUCHING spc_mode0_out { } TEMP=spc_target2
	     BOOLEAN spc_target2 AND spc_mode0_out { } TEMP=spc_target2
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (11 )  		
	  } else {
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing 
	        SET_CORNERS_TO_SPACING = FALSE
	        PARALLEL_POINT_PROJECTION = FALSE
	        TOUCH = FALSE
	        POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (11 )
	  }
	  if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	     if (ignoreChildCell == 1) {
		EXTERNAL fat spc_target {
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} TEMP = spc_mode1_out
	        BOOLEAN spc_mode1_out NOT spc_mode1_child_out { } TEMP = spc_mode1_diff_out
	        SELECT spc_mode1_out INTERACT spc_mode1_diff_out { } TEMP = spc_mode1_out
                SELECT_EDGE fat TOUCHING spc_mode1_out { } TEMP=fat_viol
	        BOOLEAN fat_viol AND spc_mode1_out { } TEMP=fat_viol
	        SELECT_EDGE spc_target TOUCHING spc_mode1_out { } TEMP=spc_target2
	        BOOLEAN spc_target2 AND spc_mode1_out { } TEMP=spc_target2
	        EXTERNAL fat_viol spc_target2 {
	           COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um " 	    
		   SPACING < fatTblSpacing_dg
                   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} (11 )
	     } else {
	        EXTERNAL fat spc_target {
		   COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um "
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
	    	   PARALLEL_POINT_PROJECTION = FALSE
	           TOUCH = FALSE
	     	   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } (11 ) 
	     }
          }
       } else {
	  if (ignoreChildCell == 1) {
              EXTERNAL fat spc_target {
                 SPACING < fatTblSpacing
                 BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
              } TEMP = spc_out
	      BOOLEAN spc_out NOT spc_child_out { } TEMP = spc_diff_out
	      SELECT spc_out INTERACT spc_diff_out { } TEMP = spc_out
	      SELECT_EDGE fat TOUCHING spc_out { } TEMP=fat_viol
	      BOOLEAN fat_viol AND spc_out { } TEMP=fat_viol
              SELECT_EDGE spc_target TOUCHING spc_out { } TEMP=spc_target2
	      BOOLEAN spc_target2 AND spc_out { } TEMP=spc_target2
	      EXTERNAL fat_viol spc_target2 {
		 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
		 BOX_CORNER = FALSE 
		 NON_PARALLEL = TRUE
		 POINT_TOUCH = FALSE
	      } (11 ) 
	  } else {
	      EXTERNAL fat spc_target {
                 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
	         BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
	      } (11 ) 
	  }
       }
       /*check metal in the extension range*/ 
       if (fatTblExtensionRange > 0) {
	  if (fatWireExtensionMode == 0) {
	     SIZE fat { OVERSIZE = fatTblExtensionRange } TEMP = fat_tmp
             BOOLEAN fat_tmp AND metal1  { } TEMP = fat_tmp
  	     BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
             SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_ext
             BOOLEAN fat_ext OR fat { } TEMP = fat_ext
	     if (fatTblParallelLength > 0) {
                if (fatTblParallelLength > fatTblExtensionRange) {
                   SIZE fat { OVERSIZE = fatTblParallelLength } TEMP = fat_tmp
                   BOOLEAN fat_tmp AND metal1  { } TEMP = fat_tmp
  	           BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
                   SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_parallel
                   BOOLEAN fat_parallel OR fat { } TEMP = fat_parallel
                } else {
                   COPY fat_ext { } TEMP = fat_parallel
                }
		EXTERNAL fat_parallel spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
	           NON_PARALLEL = TRUE
	        } TEMP = vio_filter_set
		EXTERNAL fat_ext spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } TEMP = vio_set
                if (fatTblParallelLength < fatTblSpacing) {
                   SELECT_EDGE vio_filter_set TOUCHING fat_parallel {
                      VSIZE_INSIDE = fatTblParallelLength - 0.0002 
                   } TEMP = vio_filter_set_filter
                   SELECT_CONTAINS vio_filter_set_filter { 
                      WIDTH =  0.0002 
                      HEIGHT = fatTblParallelLength + 0.0001 
                   } TEMP = vio_filter_set_filter
                   SELECT vio_filter_set INTERACT vio_filter_set_filter { } TEMP = vio_filter
                } else {
	           SELECT_CONTAINS vio_filter_set { 
	              WIDTH =  0.0002 
	              HEIGHT = fatTblParallelLength + 0.0001 
	           } TEMP = vio_filter
                }
                SELECT vio_set INSIDE vio_filter { } TEMP = mode0_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out1 NOT mode0_child_out1 { } TEMP = mode0_diff_out1
                   SELECT mode0_out1 INTERACT mode0_diff_out1 { } TEMP = mode0_out1
                }
                COPY mode0_out1 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing  = fatTblSpacing um"
                } (11 )
		if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	           EXTERNAL fat_ext spc_target {
		      SPACING < fatTblSpacing_dg
	              SET_CORNERS_TO_SPACING = FALSE
		      PARALLEL_POINT_PROJECTION = FALSE
		      TOUCH = TRUE
		      POINT_TOUCH = FALSE
		      NON_PARALLEL = TRUE
	           } TEMP = mode0_out2
                   if (ignoreChildCell == 1) {
                      BOOLEAN mode0_out2 NOT mode0_child_out2 { } TEMP = mode0_diff_out2
                      SELECT mode0_out2 INTERACT mode0_diff_out2 { } TEMP = mode0_out2
                   }
                   COPY mode0_out2 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing (mode 1/2) = fatTblSpacing um/ fatTblSpacing_dg um "
                   } (11 )
	        } 
	     } else {
	        EXTERNAL fat_ext spc_target {
		   SPACING < fatTblSpacing
		   NON_PARALLEL = TRUE
		   SET_CORNERS_TO_SPACING = FALSE
		   POINT_TOUCH = FALSE
		} TEMP = mode0_out3
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out3 NOT mode0_child_out3 { } TEMP = mode0_diff_out3
                   SELECT mode0_out3 INTERACT mode0_diff_out3 { } TEMP = mode0_out3
                }
                COPY mode0_out3 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range ( fatTblExtensionRange um) minimum spacing = fatTblSpacing um"
                } (11 )
	     }
	  } else if (fatWireExtensionMode == 1) {
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal1  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             if (fatTblParallelLength > 0) {
                EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
		   BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   CHECK_SAME_POLYGON = TRUE 
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
	        SELECT fat_ext INTERACT spacing {  } TEMP = fat_ext
		BOOLEAN fat_ext OR spacing {  } TEMP = combined_fat_ext
                EXTERNAL combined_fat_ext fat {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
                } TEMP = fat_spacing
		BOOLEAN fat_spacing AND fat_ran {  } TEMP = fat_spacing
		BOOLEAN combined_fat_ext OR fat_spacing {  } TEMP = combined_fat_ext
                SELECT_CONTAINS combined_fat_ext { 
                   WIDTH =  0.0002 
                   HEIGHT = fatTblParallelLength + 0.0001 
                } TEMP = combined_fat_ext
		SELECT spacing INTERACT combined_fat_ext { 
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out1 NOT mode1_child_out1 { } TEMP = mode1_diff_out1
                   SELECT mode1_out1 INTERACT mode1_diff_out1 { } TEMP = mode1_out1 
                }
                COPY mode1_out1 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (11 ) 
	     } else {
               	EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
	           BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
	           CHECK_SAME_POLYGON = TRUE 
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
                SELECT spacing INTERACT fat_ext {
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out2
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out2 NOT mode1_child_out2 { } TEMP = mode1_diff_out2
                   SELECT mode1_out2 INTERACT mode1_diff_out2 { } TEMP = mode1_out2
                }
                COPY mode1_out2 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (11 )
	     }
	  } else if (fatWireExtensionMode == 2) {
	     SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
             BOOLEAN fat_ran AND metal1  {  } TEMP = fat_ext
             BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	      	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
             } TEMP = spacing
 	     SELECT spacing INSIDE fat_ran {  } TEMP = spacing
	     SELECT spacing OUTSIDE fat {  } TEMP = spacing
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode2_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode2_out NOT mode2_child_out { } TEMP = mode2_diff_out
                SELECT mode2_out INTERACT mode2_diff_out { } TEMP = mode2_out 
             }
             COPY mode2_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 2, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (11 )
	  } else if (fatWireExtensionMode == 3) {
             SIZE fat {
	        GROW_LEFT = fatTblExtensionRange
	        GROW_RIGHT = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal1  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	       	PARALLEL = TRUE

	       	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		HORIZONTAL_ONLY = TRUE
             } TEMP = spacing_hor
	     SELECT spacing_hor INSIDE fat_ran {  } TEMP = spacing_hor
	     SELECT spacing_hor OUTSIDE fat {  } TEMP = spacing_hor
             SIZE fat {
	        GROW_TOP = fatTblExtensionRange
	        GROW_BOTTOM = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal1  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	        POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		VERTICAL_ONLY = TRUE
             } TEMP = spacing_ver
	     SELECT spacing_ver INSIDE fat_ran {  } TEMP = spacing_ver
	     SELECT spacing_ver OUTSIDE fat {  } TEMP = spacing_ver
  	     BOOLEAN spacing_hor OR spacing_ver {  } TEMP = spacing
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal1  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
  	     /* check overlapped projection length */
 	     if (fatTblParallelLength > 0) {
                POLYGON_FEATURES fat_ext {
                   EQUATIONS {
                      vnum = EV_VNUM_IN;
                      if ( vnum > 0) {
                         bdLeft = EV_VXCOORD_IN[0];
                         bdRight = EV_VXCOORD_IN[0];
                         bdBottom = EV_VYCOORD_IN[0];
                         bdTop = EV_VYCOORD_IN[0];
                         FOR (i = 1; i < vnum; i++) {
                            if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
                            else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
                            if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
                            else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
                         } /* FOR i */
                         if ( (bdRight - bdLeft) >= fatTblParallelLength ||
                  	      (bdTop - bdBottom) >= fatTblParallelLength) {
                            FOR (i = 0; i < vnum; i++) {
                               EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
                               EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
                            }
                            EV_VNUM_OUT = vnum;
                 	    EV_SAVE_POLYGON();
                         }
                      }
                   }
                } TEMP = fat_ext /* POLYGON_FEATURE */
             }
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode3_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode3_out NOT mode3_child_out { } TEMP = mode3_diff_out
                SELECT mode3_out INTERACT mode3_diff_out { } TEMP = mode3_out
             }
             COPY mode3_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 3, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (11 )
          }
       }
       SET fatTblSpacing = 0;
    }
}
@ 252 "adrc/adrc.ev" 2


SET fatTblThreshold = 0;
SET fatTblEnclosedArea = 0;
SET fatTblExtensionRange = 0;
SET fatTblParallelLength = 0;
SET minWidth = 0;

/* End of Met1 fat table spacing rules */










/*metal 2*/
SET layer_name = "Met2";










SET minWidth = 0.056;
SET maxWidth = 5;
SET minArea = 0.016;
SET minEnclosedArea = 0.2;
SET minSpacing = 0.056;
SET sameNetMinSpacing = 0.056;
SET stub2StubSpacing = 0;

SET fatTblDimension = 5;
@ 1 "adrc/adrc_check_metal.ev" 1
/* Data Preparation */
if (fatTblDimension > 1 || fatWireThreshold > 0 || maxWidth > 0) {
  if (ignoreBlockage) {
      /* Let the real blockage be treated as thin */
      BOOLEAN metal2  NOT metal2_rbkg  {} TEMP=fat_candidate
  } else {
      COPY metal2  {} TEMP=fat_candidate
  }
  COPY fat_candidate {} TEMP=fat_target
}
/*Check width*/
if (minWidth > 0) {
    INTERNAL metal2  { 
        COMMENT = "$layer_name MinWidth  : minimum width = minWidth um" 
        SPACING < minWidth
        POINT_TOUCH = FALSE
    } (13 )
}
 
if (maxWidth > 0) {
    SIZE  fat_candidate {
        COMMENT = "$layer_name MaxWidth  : maximum width = maxWidth um"
 	UNDER_OVER = maxWidth / 2 
    } (13 ) 
}
 
/*Check area*/
if (minArea > 0) {
    AREA metal2  { 
	COMMENT = "$layer_name MinArea   : minimum area = minArea um*um"
	RANGE = [0.0001 * 0.0001 , minArea - 0.0001 * 0.0001 ]
    } (13 )
}
/* check min length of bounding box on polygon */
if (minLength > 0) {
  if (minLengthMode == 1) {
    INTERNAL metal2  {
        SPACING < minLength
        VERTICAL_ONLY = TRUE
        SET_CORNERS_TO_SPACING = FALSE
    } TEMP = ver_short
    BOOLEAN metal2  NOT ver_short { } TEMP = ver_long
    INTERNAL metal2  {
        SPACING < minLength
        HORIZONTAL_ONLY = TRUE
        SET_CORNERS_TO_SPACING = FALSE
    } TEMP = hor_short
    BOOLEAN metal2  NOT hor_short { } TEMP = hor_long
    SELECT CUT_LAYER1 INSIDE ver_long { } TEMP = good_cut
    BOOLEAN CUT_LAYER1 NOT good_cut { } TEMP = fail_cut_1
    SELECT fail_cut_1 INSIDE hor_long { } TEMP = good_cut
    BOOLEAN fail_cut_1 NOT good_cut { } TEMP = fail_cut_1
    SELECT CUT_LAYER2 INSIDE ver_long { } TEMP = good_cut
    BOOLEAN CUT_LAYER2 NOT good_cut { } TEMP = fail_cut_2
    SELECT fail_cut_2 INSIDE hor_long { } TEMP = good_cut
    BOOLEAN fail_cut_2 NOT good_cut { } TEMP = fail_cut_2
    BOOLEAN fail_cut_1 OR fail_cut_2 { } TEMP = fail_cut
    BOOLEAN hor_short NOT ver_long { } TEMP = hor_short
    BOOLEAN ver_short NOT hor_long { } TEMP = ver_short
    SELECT ver_short INTERACT fail_cut { } TEMP = ver_fail
    SELECT hor_short INTERACT fail_cut { } TEMP = hor_fail
    BOOLEAN ver_fail OR hor_fail { } TEMP = all_fail
    INTERNAL all_fail {
        COMMENT = "$layer_name MinLength : minimum length = minLength um"
        SPACING < minLength
        VERTICAL_ONLY = TRUE
        SET_CORNERS_TO_SPACING = FALSE
    } (13 )
  } else {
    POLYGON_FEATURES metal2  {
      COMMENT = "$layer_name MinLength : minimum length = minLength um"
      EQUATIONS {
        vnum = EV_VNUM_IN;
        if ( vnum > 0) {
	  bdLeft = EV_VXCOORD_IN[0];
	  bdRight = EV_VXCOORD_IN[0];
	  bdBottom = EV_VYCOORD_IN[0];
	  bdTop = EV_VYCOORD_IN[0];
          FOR (i = 1; i < vnum; i++) {
	    if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
            else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
	    if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
            else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
          }
	  if ( (bdRight - bdLeft) < minLength &&
	       (bdTop - bdBottom) < minLength) {
	    FOR (i = 0; i < vnum; i++) {
              EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
	      EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
            }
	    EV_VNUM_OUT = vnum;
	    EV_SAVE_POLYGON();
          }
        }
      }
    } (13 ) 
  }
  SET minLength = 0;
}
/* check max length of bounding box on polygon */
if (maxLength > 0) {
  POLYGON_FEATURES metal2  {
    COMMENT = "$layer_name MaxLength : maximum length = maxLength um"
    EQUATIONS {
      vnum = EV_VNUM_IN;
      if ( vnum > 0) {
	bdLeft = EV_VXCOORD_IN[0];
	bdRight = EV_VXCOORD_IN[0];
	bdBottom = EV_VYCOORD_IN[0];
	bdTop = EV_VYCOORD_IN[0];
        FOR (i = 1; i < vnum; i++) {
	  if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
          else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
	  if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
          else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
        }
	if ( (bdRight - bdLeft + bdTop - bdBottom) > maxLength ) {
          EV_VXCOORD_OUT[0] = bdLeft;
	  EV_VYCOORD_OUT[0] = bdBottom;
          EV_VXCOORD_OUT[1] = bdLeft;
	  EV_VYCOORD_OUT[1] = bdTop;
          EV_VXCOORD_OUT[2] = bdRight;
	  EV_VYCOORD_OUT[2] = bdTop;
          EV_VXCOORD_OUT[3] = bdRight;
	  EV_VYCOORD_OUT[3] = bdBottom;
          EV_VXCOORD_OUT[4] = bdLeft;
	  EV_VYCOORD_OUT[4] = bdBottom;
	  EV_VNUM_OUT = 5;
	  EV_SAVE_POLYGON();
        }
      }
    }
  } (13 ) 
  SET maxLength = 0;
}
 
/*Check enclosed area*/
if (minEnclosedArea > 0) {
    SELECT metal2  INSIDE_HOLE {
        INNER_HOLE_ONLY
    } TEMP = holes
    BOOLEAN holes NOT metal2  { } TEMP = holes
 
    AREA holes {
        COMMENT = "$layer_name EnclsArea : minimum enclosed area = minEnclosedArea um*um"
        RANGE = [0.0001 * 0.0001 , minEnclosedArea - 0.0001 * 0.0001 ]
    } (13 )
    /* check min length of bounding box on polygon */
    if (minEnclosedWidth > 0) {
      POLYGON_FEATURES holes {
        COMMENT = "$layer_name EnclsWidth: minimum enclosed Width = minEnclosedWidth um"
        EQUATIONS {
          vnum = EV_VNUM_IN;
          if ( vnum > 0) {
            bdLeft = EV_VXCOORD_IN[0];
            bdRight = EV_VXCOORD_IN[0];
            bdBottom = EV_VYCOORD_IN[0];
            bdTop = EV_VYCOORD_IN[0];
            FOR (i = 1; i < vnum; i++) {
              if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
              else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
              if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
              else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
            }
            if ( (bdRight - bdLeft) < minEnclosedWidth &&
                 (bdTop - bdBottom) < minEnclosedWidth) {
              FOR (i = 0; i < vnum; i++) {
                EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
                EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
              }
              EV_VNUM_OUT = vnum;
              EV_SAVE_POLYGON();
            }
          }
        }
      } (13 ) 
    }
}
 
/*check special notch rule*/
if ((minEdgeLength2 > 0.0001  && minEdgeLength3 > 0.0001 ) || minEdgeMode==2) {
  if (minEdgeMode==2) {
    SET minEdgeLength3 = minEdgeLength ;
  }
  NOTCH metal2  {
     SPACING < minEdgeLength3
     SET_CORNERS_TO_SPACING=FALSE
     PARALLEL = TRUE
     OUTPUT_EDGES = TRUE
  } TEMP = notch_vectors
  SELECT_VECTOR notch_vectors {
     LENGTH_RANGE = [0.0001 , minEdgeLength2 - 0.0001 ]
  } TEMP = short_edges
  EXTERNAL short_edges metal2  {
     SPACING < minEdgeLength3
     SET_CORNERS_TO_SPACING=FALSE
     PARALLEL = TRUE
  } TEMP = notch_err
  /* Choose the real U-shaped notch */
  SIZE notch_err { OVERSIZE = 0.0002 *10 } TEMP = neighbors 
  BOOLEAN neighbors AND metal2  { } TEMP = neighbors
  VERTEX neighbors { 
     CONCAVE = TRUE
     CONVEX = TRUE
     SIZE = 0.0002 
  } TEMP = corners
  SELECT_EDGE neighbors INTERACT notch_err { } TEMP = target_edges
  BOOLEAN target_edges NOT corners { } TEMP = target_edges
  VERTEX neighbors { 
     CONCAVE = TRUE
     SIZE = 2* 0.0002 
  } TEMP = corners
  SELECT target_edges INTERACT corners { RANGE = [2, 2] } TEMP=target_edges
  SELECT notch_err INTERACT target_edges {
     COMMENT = "$layer_name SpeclNotch: sameNetSp = minEdgeLength3 um (sideLen minEdgeLength2 um)" 
  } (13 )
}
/*check consecutive short edges*/
if (minEdgeLength > 0.0001  && minEdgeMode != 2) { 
  INTERNAL metal2_top  {
     SEGMENT < minEdgeLength
     FLAG_ACUTE_ANGLE = FALSE
     FLAG_ACUTE_EDGE = FALSE
     OUTPUT_EDGES = TRUE
  } TEMP = short_edges
  if ((minEdgeMode == 0 && maxTotalMinEdgeLength>0) || maxNumMinEdge > 0) {
    SET temporary_1 = 0.0002 *2;
    SET temporary_2 = 2*temporary_1+ 0.0001 ;
    SELECT metal2_top  INTERACT short_edges { } TEMP = target_top
    CLASSIFY_EDGES target_top {
       LENGTH = temporary_1
       DMIN   = temporary_2
       INSIDE_CORNER  TEMP = inside_corner_edges
       OUTSIDE_CORNER TEMP = outside_corner_edges
       REMAINDER      TEMP = remainder_edges
    }
    if (minEdgeMode == 0 && (maxNumMinEdge>0 || maxTotalMinEdgeLength > 0)) {
       SELECT short_edges ENCLOSING inside_corner_edges { } TEMP = short_edges
    }
  }
  if (maxTotalMinEdgeLength > 0) {
    LENGTH short_edges {
       RANGE = [maxTotalMinEdgeLength + 0.0001 , 9999999999 ]
    } TEMP = max_length_err
    /* Work around: translate polygons into dimensional check output */
    SIZE max_length_err { OVERSIZE = 2* 0.0002  } TEMP = max_length_err
    INTERNAL max_length_err {
       SPACING < 3* 0.0002 
       SET_CORNERS_TO_SPACING=FALSE
       COMMENT = "$layer_name MinEdgeLen: maximum total length ( minEdgeLength um)= maxTotalMinEdgeLength um"
    } (13 )
  }
  if (maxTotalMinEdgeLength == 0 || maxNumMinEdge > 0) {
    if (maxNumMinEdge==0)  {
       COPY short_edges {} TEMP=max_edge_err
    } else {
       SIZE short_edges {
         VSIZE_HEAD = - 0.0002 
        VSIZE_TAIL = - 0.0002 
       } TEMP = short_edges
       SIZE short_edges {
          OVERSIZE = 5* 0.0002 
          SIZE_ENDPOINTS = FALSE
       } TEMP = short_contours
       SELECT short_contours ENCLOSING remainder_edges {
          RANGE = [maxNumMinEdge + 1, 9999999999 ]
       } TEMP = short_contours
       SELECT short_edges INSIDE short_contours { } TEMP=max_edge_err
    }
    /* Work around: translate polygons into dimensional check output */
    SIZE max_edge_err { OVERSIZE = 2* 0.0002  } TEMP = max_edge_error
    INTERNAL max_edge_error {
       SPACING < 3* 0.0002 
       SET_CORNERS_TO_SPACING=FALSE
       COMMENT = "$layer_name MinEdgeLen: maximum number of consecutive short edges ( minEdgeLength um)= maxNumMinEdge"
    } (13 ) 
  }
}
 
/*check basic spacing*/
if (sameNetMinSpacing > 0 && sameNetMinSpacing != minSpacing) {
  if (sameNetMinSpacing > minSpacing) {
    /* Special condition for U-shaped Metal spacing rule */
    NOTCH metal2_pin  {
        SPACING < sameNetMinSpacing
        BOX_CORNER = FALSE 
        SET_CORNERS_TO_SPACING=FALSE
        NON_PARALLEL = TRUE
        OUTPUT_EDGES = TRUE
    } TEMP = errs_to_be_waived
    NOTCH metal2_top  {
	SPACING < sameNetMinSpacing
	BOX_CORNER = FALSE 
        SET_CORNERS_TO_SPACING=FALSE
	NON_PARALLEL = TRUE
        OUTPUT_EDGES = TRUE
    } TEMP = all_errs
    BOOLEAN all_errs NOT errs_to_be_waived { } TEMP=err_edge
    EXTERNAL err_edge metal2_top  {
	SPACING < sameNetMinSpacing
	BOX_CORNER = FALSE 
        SET_CORNERS_TO_SPACING=FALSE
	NON_PARALLEL = TRUE
    } TEMP = notch_err
    SIZE notch_err { OVERSIZE = 0.0002 *10 } TEMP = neighbors
    BOOLEAN neighbors AND metal2_top  { } TEMP = neighbors
    VERTEX neighbors { 
       CONCAVE = TRUE
       CONVEX = TRUE
       SIZE = 0.0002 
    } TEMP = corners
    SELECT_EDGE neighbors INTERACT notch_err { } TEMP = target_edges
    BOOLEAN target_edges AND notch_err { } TEMP = target_edges
    BOOLEAN target_edges NOT corners { } TEMP = target_edges
    VERTEX neighbors {
       CONCAVE = TRUE
       SIZE = 2* 0.0002 
    } TEMP = corners
    SELECT target_edges INTERACT corners { RANGE = [2, 2] } TEMP = target_edges
    SELECT notch_err TOUCHING target_edges {
      COMMENT = "$layer_name U-ShpNotch: U-shape notch minimum spacing = sameNetMinSpacing um" 
    } (13 )
  } else {
    NOTCH metal2  {
        COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = sameNetMinSpacing um" 
	SPACING < sameNetMinSpacing
	BOX_CORNER = FALSE 
	NON_PARALLEL = TRUE
    } (13 )
  }
  if (minSpacing > 0) {
    if (stubMode == 0 && stubSpacing > 0 && stubSpacing < minSpacing) {
	EXTERNAL metal2  {
	    COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um"
            LONGEDGE > stubThreshold + 0.0001 
	    LONGEDGE_TO_EDGE < minSpacing
	    SPACING <= 0
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            CHECK_SAME_POLYGON = TRUE 
	} (13 )
    } else {
        EXTERNAL metal2  {
	    COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um" 
	    SPACING < minSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
	    CHECK_SAME_POLYGON = FALSE
        } (13 )
    }
  }
} else {
  if (minSpacing > 0) {
    if (stubMode == 0 && stubSpacing > 0 && stubSpacing < minSpacing) {
        EXTERNAL metal2  {
            COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um"
            LONGEDGE > stubThreshold + 0.0001  
            LONGEDGE_TO_EDGE < minSpacing
            SPACING <= 0 
            BOX_CORNER = FALSE 
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            CHECK_SAME_POLYGON = TRUE 
        } (13 )
    } else {
        EXTERNAL metal2  {
	    COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um" 
            SPACING < minSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
	    CHECK_SAME_POLYGON = TRUE 
        } (13 )
    }
  }
}
 
/*check dogbone */
if (sameNetMinSpacing > 0 && sameNetWidthThreshold) {
  NOTCH metal2  {
    SPACING < sameNetMinSpacing
    BOX_CORNER = FALSE 
    NON_PARALLEL = TRUE
  } TEMP = dog_bone
 
  if (!layer_empty(dog_bone)) {
    SIZE dog_bone {EDGESIZE = sameNetWidthThreshold} TEMP = dog_ext
    BOOLEAN dog_ext NOT dog_bone {} TEMP = dog_ext
    BOOLEAN dog_ext AND metal2  {} TEMP = dog_ext
    if (!layer_empty(dog_ext)) {
      SELECT dog_ext EDGE_TOUCH dog_bone { OUTSIDE RANGE = [1, 9999999999 ] } TEMP = dog_ext
      NOTCH metal2  {
        SPACING < sameNetMinSpacing
        BOX_CORNER = FALSE 
        NON_PARALLEL = TRUE
	OUTPUT_EDGES = TRUE
      } TEMP = dog_bone
      SELECT dog_ext OUTSIDE dog_bone {} TEMP = dog_ext
      INTERNAL dog_ext {
	COMMENT = "$layer_name dogBone   : notch spacing = sameNetMinSpacing um width sameNetWidthThreshold um" 
	SPACING < sameNetWidthThreshold
      } (13 )
    }
  }
}
/*check basic fat spacing*/
if (fatWireThreshold > 0 && fatTblDimension == 0) {
    SIZE fat_candidate { UNDER_OVER = fatWireThreshold / 2.0 - 0.0001  } TEMP = m_fat
    BOOLEAN m_fat AND metal2  {  } TEMP = m_fat
    BOOLEAN metal2  NOT m_fat {  } TEMP = m_thin
    if (ignoreBlockage == 0) {
        /* the blockages on the metal_blockage layer are treated as thin blockages */
        BOOLEAN m_thin OR metal2_blockage  {  } TEMP = m_thin
    }
 
    if (fatFatMinSpacing > 0) {
	EXTERNAL m_fat {
	    COMMENT = "$layer_name FatWireSpc: fat & fat ( fatWireThreshold um) minimum spacing = fatFatMinSpacing um"
	    SPACING < fatFatMinSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = FALSE
	    CHECK_SAME_POLYGON = TRUE 
       } (13 )
    }
 
    if (fatThinMinSpacing > 0) {
	EXTERNAL m_fat m_thin {
	    COMMENT = "$layer_name FatWireSpc: fat & thin ( fatWireThreshold um) minimum spacing fatThinMinSpacing um"
	    SPACING < fatThinMinSpacing
 	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = FALSE
        } (13 )
    }
}
 
/*check thin blockage spacing*/
if (minSpacing > 0 && ignoreBlockage == 0) {
    if (!layer_empty (metal2_blockage )) {
	EXTERNAL metal2_blockage  metal2  {
	    COMMENT = "$layer_name Spacing   : metal & thin blockage minimum spacing = minSpacing um"
	    SPACING < minSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
            TOUCH = TRUE
        } (13 )
    }
}
/*check blockage overlap*/
/*check shorts between top_level routing and fram_blockages*/
if (minSpacing>0 || checkCrossHierShort>0) {
   if (ignoreBlockage == 0) {
      BOOLEAN metal2_blockage  or metal2_rbkg  {} TEMP=all_blockage
   } else {
      COPY metal2_rbkg  {} TEMP=all_blockage
   }
   BOOLEAN all_blockage AND metal2_top  {} TEMP = overlap_shape1
   EXTERNAL all_blockage metal2_top  {
      SPACING <= 0
      TOUCH = TRUE
   } TEMP = overlap_shape2
   if (checkCrossHierShort>0) {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
         COMMENT = "$layer_name Short Cross Hierarchy"
      } (13 )
   } else {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
         COMMENT = "$layer_name Overlap   : metal & blockage overlap"
      } (13 )
   }
}
 
if (fatPolyContactRule > 0) {
  /* Fat Poly Contact Rule: not new fat wire formed */
  if (readCellView > 0) {
     SIZE metal1 { UNDER_OVER = fatPolyContactRule / 2.0 - 0.0001  } TEMP = fat
     BOOLEAN fat AND metal1 {  } TEMP = fat 
  } else {
     SIZE metal1_top { UNDER_OVER = fatPolyContactRule / 2.0 - 0.0001  } TEMP = fat
     BOOLEAN fat AND metal1_top {  } TEMP = fat 
  }
  SIZE metal1_pin { UNDER_OVER = fatPolyContactRule / 2.0 - 0.0001  } TEMP = fat_pin
  BOOLEAN fat_pin AND metal1_pin {  } TEMP = fat_pin
  BOOLEAN fat NOT fat_pin {
    COMMENT = "$layer_name FatPolyContactRule: fatPolyContactRule um" 
  } (13 )
}
/* Special End-of-Line Spacing Rule */
if (stubMode == 0 && stubSpacing > 0 && stubSpacing < minSpacing) {
  EXTERNAL metal2  {
     COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 0)"
     LONGEDGE > stubThreshold + 0.0001 
     LONGEDGE_TO_EDGE <= 0 
     SPACING < stubSpacing 
     SET_CORNERS_TO_SPACING = FALSE
     PARALLEL_POINT_PROJECTION = FALSE
  } (13 )
} else if (stubMode > 0 && stubSpacing > minSpacing) {
  if (stubMode == 4) {
     INTERNAL metal2  {
        SEGMENT[90,90] < stubThreshold
        OUTPUT_EDGES = TRUE
     } TEMP = end_of_line
  } else {
     INTERNAL metal2  {
        SEGMENT[90,90] <= stubThreshold
        OUTPUT_EDGES = TRUE
     } TEMP = end_of_line
  }
  /* Quick filter to reduce the size of possible end of line */
  if (sideStubExt > 0) {
    SIZE end_of_line {
       VSIZE_HEAD = sideStubExt
       VSIZE_TAIL = sideStubExt
       OUTPUT_EDGES = TRUE
    } TEMP = eol_ext
  } else {
    COPY end_of_line { } TEMP=eol_ext
  }
  if (stub2StubSpacing > stubSpacing) {
     SET temporary_1 = stub2StubSpacing;
  } else {
     SET temporary_1 = stubSpacing; 
  }
  EXTERNAL eol_ext metal2  {
     SPACING < temporary_1
     TOUCH = TRUE
     OVERLAP = TRUE 
     SET_CORNERS_TO_SPACING = FALSE
     PARALLEL_POINT_PROJECTION = FALSE
     OUTPUT_EDGES = TRUE
  } TEMP=err_edge
  SELECT eol_ext INTERACT err_edge { } TEMP=eol_ext
  SELECT end_of_line INTERACT eol_ext { } TEMP=end_of_line 
  /* Reduce the size of METAL_LAYER */
  if (stubMode==3) {
     SIZE end_of_line {
        VSIZE_HEAD = stubSpacing 
        VSIZE_TAIL = stubSpacing 
        VSIZE_INSIDE = sideStubThreshold
        VSIZE_OUTSIDE = stubSpacing
     } TEMP = eol_filter 
  } else {
     if (stubMode == 1 && stubRange > 0) {
        SIZE end_of_line {
           VSIZE_HEAD = stubSpacing- 0.0001 
           VSIZE_TAIL = stubSpacing- 0.0001 
           VSIZE_OUTSIDE = stubSpacing- 0.0001 
        } TEMP = eol_filter
     } else {
        SIZE end_of_line {
           VSIZE_HEAD = stubSpacing- 0.0001 
           VSIZE_TAIL = stubSpacing- 0.0001 
           VSIZE_INSIDE = sideStubThreshold- 0.0001 
           VSIZE_OUTSIDE = stubSpacing- 0.0001 
        } TEMP = eol_filter
     }
  }
  SELECT metal2  INTERACT eol_filter { } TEMP=target_top
  /* Get the side edges and the whole eol of line set */
  SELECT_EDGE target_top INTERACT end_of_line { 
    POINT_TOUCH = TRUE
  } TEMP = eol_set
  VERTEX target_top { 
     CONCAVE = TRUE 
     CONVEX = TRUE
     SIZE = 0.0002 
  } TEMP = corners
  SELECT corners OUTSIDE end_of_line {} TEMP =corners 
  BOOLEAN eol_set NOT corners { } TEMP=eol_set
  BOOLEAN eol_set NOT end_of_line { } TEMP=side_edge
  /* find out the real end of line */
  if (stubRange > 0) {
     if (stubMode == 1) {
         COPY side_edge { } TEMP = all_side_edge
         LENGTH side_edge { SPACING <= stubRange- 0.0001  } TEMP=side_edge
     } else {
         LENGTH side_edge { SPACING < stubRange- 0.0002  } TEMP=eol_filter
         BOOLEAN side_edge NOT eol_filter { } TEMP=side_edge
     }
     SELECT end_of_line INTERACT side_edge { RANGE = [1,2] } TEMP = end_of_line
  } 
  if (stubMode == 1) {
    if (stub2StubSpacing > 0) {
       if (sideStubExt < 0) {
          SIZE end_of_line {
            VSIZE_HEAD = sideStubExt / 2
            VSIZE_TAIL = sideStubExt / 2
            OUTPUT_EDGES = TRUE
          } TEMP = eol_ext_tip
	 
          EXTERNAL eol_ext_tip {
            COMMENT = "$layer_name specEoLSpc: stub2Stubspacing= stub2StubSpacing um (mode = 1)"
            SPACING < stub2StubSpacing
            SET_CORNERS_TO_SPACING = FALSE
            PARALLEL_POINT_PROJECTION = TRUE
          } (13 )
       } else {
          EXTERNAL end_of_line {
            COMMENT = "$layer_name specEoLSpc: stub2Stubspacing= stub2StubSpacing um (mode = 1)"
            SPACING < stub2StubSpacing
            SET_CORNERS_TO_SPACING = FALSE
            PARALLEL_POINT_PROJECTION = FALSE
          } (13 )
       }
    }
    if (stubRange > 0) {
       SIZE end_of_line {
         VSIZE_INSIDE = 0.0002 
       } TEMP = eol_poly
       SELECT_EDGE eol_poly TOUCHING target_top { } TEMP=eol_edge
       EXTERNAL eol_edge target_top {
         COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
         CONVEX_TO_CONVEX < stubSpacing
         CONVEX_TO_CONVEX [POINT_PROJECTION] < stubSpacing
         CONVEX_TO_EDGE < stubSpacing
         CONCAVE_TO_CONVEX < stubSpacing
         LONGEDGE > 0.0002 
         LONGEDGE_TO_EDGE < stubSpacing
         SPACING <= 0
         SET_CORNERS_TO_SPACING = TRUE
         PARALLEL_POINT_PROJECTION = TRUE
       } (13 )
       SELECT all_side_edge INTERACT end_of_line { } TEMP = side_edge
       SIZE side_edge {
         VSIZE_HEAD = 0.0002 
         VSIZE_TAIL = 0.0002 
       } TEMP = side_edge_ext
       BOOLEAN side_edge_ext NOT side_edge { } TEMP = side_edge_ext
       SELECT side_edge_ext INTERACT end_of_line { } TEMP = side_edge_ext
       EXTERNAL side_edge_ext target_top {
         COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
         SPACING < stubSpacing
         SET_CORNERS_TO_SPACING = FALSE
         PARALLEL_POINT_PROJECTION = FALSE
       } (13 )
    } else {
       if (stub2StubSpacing > 0) {
         VECTORIZE target_top {
            DIRECTED=TRUE
         } TEMP=target_edges
         BOOLEAN target_edges NOT end_of_line { } TEMP = target_edges
         EXTERNAL end_of_line target_edges {
            COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
            SPACING < stubSpacing
            TOUCH=TRUE
            OVERLAP=TRUE
            SET_CORNERS_TO_SPACING=FALSE
            PARALLEL_POINT_PROJECTION=FALSE
         } (13 )
       } else {
         if (sideStubExt > 0) {
            SIZE end_of_line {
               VSIZE_HEAD = sideStubExt
               VSIZE_TAIL = sideStubExt
               OUTPUT_EDGES = TRUE
            } TEMP = end_of_line
            EXTERNAL end_of_line target_top {
               COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing ,crnKeepOut= sideStubExt um (mode = 1)"
               SPACING < stubSpacing
               TOUCH=TRUE
               OVERLAP=TRUE
               SET_CORNERS_TO_SPACING=FALSE
               PARALLEL_POINT_PROJECTION=FALSE
            } (13 )
         } else {
            EXTERNAL end_of_line target_top {
               COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
               SPACING < stubSpacing
               TOUCH=TRUE
               OVERLAP=TRUE
               SET_CORNERS_TO_SPACING=FALSE
               PARALLEL_POINT_PROJECTION=FALSE
            } (13 )
         }
       }
    }
  } else { /* stubMode == 2,3,4 */
    /* stubMode 2 eol classify and reduction */
    if (stubMode !=3 && sideStubExt > 0) {
      if (stubMode == 4) {
        SIZE end_of_line {
           VSIZE_HEAD = sideStubExt
           VSIZE_TAIL = sideStubExt
           OUTPUT_EDGES = TRUE
        } TEMP = eol_ext
        EXTERNAL eol_ext target_top {
           SPACING < stubSpacing
           SET_CORNERS_TO_SPACING=FALSE
           PARALLEL_POINT_PROJECTION=FALSE
           OUTPUT_EDGES = TRUE
        } TEMP=err_edge
        SELECT eol_ext INTERACT err_edge { } TEMP=eol_ext
      } else {
        EXTERNAL end_of_line target_top {
           SPACING < stubSpacing
           SET_CORNERS_TO_SPACING=FALSE
           PARALLEL_POINT_PROJECTION=FALSE
           OUTPUT_EDGES = TRUE
        } TEMP=err_edge
        SELECT end_of_line INTERACT err_edge { } TEMP=eol_body
        SIZE end_of_line {
           VSIZE_HEAD = sideStubExt
           VSIZE_TAIL = sideStubExt
           OUTPUT_EDGES = TRUE
        } TEMP = eol_ext
        BOOLEAN eol_ext NOT end_of_line {} TEMP=eol_ext
        EXTERNAL eol_ext target_top {
           SPACING < stubSpacing
           SET_CORNERS_TO_SPACING=FALSE
           PARALLEL_POINT_PROJECTION=FALSE
           OUTPUT_EDGES = TRUE
        } TEMP=err_edge
        SELECT eol_ext INTERACT err_edge { } TEMP=eol_ext
        BOOLEAN eol_body OR eol_ext { } TEMP=eol_ext
      } 
    } else {
      COPY end_of_line { } TEMP=eol_ext
    }
    SELECT side_edge INTERACT eol_ext { } TEMP=side_edge
    SIZE eol_ext {
       VSIZE_INSIDE = sideStubThreshold 
       VSIZE_OUTSIDE = sideStubExt
    } TEMP = eol_range
    if (sideStubExt > 0) {
       SIZE side_edge {
          VSIZE_HEAD = sideStubExt
          VSIZE_TAIL = sideStubExt
          OUTPUT_EDGES = TRUE
       } TEMP = check_edge
    } else {
       COPY side_edge { } TEMP = check_edge
    }
    BOOLEAN check_edge AND eol_range { } TEMP=check_edge
    EXTERNAL check_edge target_top {
       SPACING < temporary_1
       SET_CORNERS_TO_SPACING = FALSE
       SHADOW_OTHER_LAYER = TRUE
       PARALLEL_POINT_PROJECTION = FALSE
       OUTPUT_EDGES = TRUE
    } TEMP=err_edge
    if (0 && stubMode!=4) { /* Temporarily do not check mode 2,3 side edge length */
       LENGTH side_edge { SPACING < stubSpacing- 0.0001 *2 } TEMP=err_edge_1
       BOOLEAN err_edge OR err_edge_1 { } TEMP=err_edge
    }
    SELECT check_edge INTERACT err_edge { } TEMP=side_edge
    if (stubMode!=3) {
       SELECT eol_ext INTERACT side_edge {} TEMP=err_eol
       EXTERNAL err_eol target_top {
          COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing ,crnKeepOut= sideStubExt um (mode = stubMode )"
          SPACING < temporary_1
          PARALLEL_POINT_PROJECTION=FALSE
          SET_CORNERS_TO_SPACING=FALSE
       } (13 )
    } else { /* stubMode == 3 */
       SELECT eol_ext INTERACT side_edge { RANGE = [2, 2] } TEMP=err_eol
       EXTERNAL err_eol target_top {
          COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 3)"
          SPACING < temporary_1
          PARALLEL_POINT_PROJECTION=FALSE
          SET_CORNERS_TO_SPACING=FALSE
       } (13 )
    }
  }
} /* stubMode > 0, not aligned */
/* Avoid empty optimization result parsing error */
if (addEmptyMetalCheck) {
   BOOLEAN empty OR empty {
      COMMENT = "$layer_name Empty: Dummy Output"
   } (13 )
   SET addEmptyMetalCheck=0;
}
/* reset variables */


 
SET minWidth = 0;
SET maxWidth = 0;
SET minArea = 0;
SET minEnclosedArea = 0;
SET minSpacing = 0;
SET sameNetMinSpacing = 0;
SET maxNumMinEdge = 0;
SET maxTotalMinEdgeLength = 0;
SET minEdgeLength = 0;
SET minEdgeLength2 = 0;
SET minEdgeLength3 = 0;
SET stubRange = 0;
SET stubSpacing = 0;
SET stub2StubSpacing = 0;
SET sideStubExt = 0;
SET sideStubThreshold = 0;
SET stubThreshold = 0;
SET fatPolyContactRule = 0;
SET fatWireThreshold = 0;
SET fatThinMinSpacing = 0;
SET fatFatMinSpacing = 0;
SET fatTblDimension = 0;
@ 292 "adrc/adrc.ev" 2

SET minSpacing = 0.056;
SET fatTblThresh_protru = 0.15;
SET fatTblLength_protru = 0.1;
SET fatTblWidth_protru = 0.06;
@ 1 "adrc/adrc_protru.ev" 1
/*protrusion length rule*/
SIZE metal2     { UNDER_OVER = fatTblThresh_protru / 2.0 - 0.0001  } TEMP = fat
BOOLEAN fat AND metal2  {  } TEMP = fat 
BOOLEAN metal2  NOT fat {  } TEMP = fat_nbr
SIZE fat { OVERSIZE = fatTblLength_protru + 0.0001  } TEMP = fat_ext
BOOLEAN fat_nbr AND fat_ext {} TEMP = fat_nbr
SELECT fat_nbr INTERACT fat TEMP = fat_nbr
/* Get the correct fat extension */
SELECT_EDGE fat_nbr TOUCHING fat { } TEMP = ext_filter
SIZE ext_filter { VSIZE_INSIDE = 0.0001  } TEMP = ext_filter
SIZE ext_filter INSIDE fat_nbr {
   OVERSIZE = fatTblLength_protru- 0.0001 
   INCREMENT = minSpacing
} TEMP=dummy TEMP = fat_nbr
  
VERTEX fat_nbr {
   CONCAVE = TRUE
   SIZE = 0.0002 
} TEMP = corners
SELECT fat_nbr OUTSIDE corners { } TEMP = fat_nbr1
BOOLEAN fat_nbr NOT fat_nbr1 { } TEMP = fat_nbr2
SELECT_CONTAINS fat_nbr1 {
   WIDTH =  0.0002 
   HEIGHT = fatTblLength_protru
} TEMP = good_fat_nbr1
BOOLEAN fat_nbr1 NOT good_fat_nbr1 { } TEMP = fat_nbr1
/* check with L or T shape of fat extension */
SELECT_EDGE fat_nbr2 INTERACT corners { } TEMP = side_edge
LENGTH side_edge { SPACING < fatTblLength_protru } TEMP = vio_edge
SELECT fat_nbr2 INTERACT vio_edge { } TEMP = fat_nbr2
BOOLEAN fat_nbr1 OR fat_nbr2 { } TEMP = fat_nbr
INTERAL fat_nbr {
   SPACING < fatTblWidth_protru
} TEMP = possible_err
if (!layer_empty(possible_err)) {
   SELECT fat_nbr INTERACT possible_err { } TEMP=fat_nbr
   SELECT fat INTERACT fat_nbr {} TEMP=fat
   BOOLEAN fat OR fat_nbr {} TEMP=fat
   INTERNAL fat {
      COMMENT = "$layer_name ProtrusionLength : threshold fatTblThresh_protru um, length  fatTblLength_protru um, width fatTblWidth_protru um"
      SPACING < fatTblWidth_protru
   } (13 )
}
/* protrusion leng rule check */
SET fatTblThresh_protru = 0;
SET fatTblLength_protru = 0;
SET fatTblWidth_protru = 0;
SET minSpacing = 0;
@ 297 "adrc/adrc.ev" 2


SET minSpacing = 0.056;
SET fatTblThresh_protru = 0.3;
SET fatTblLength_protru = 0.15;
SET fatTblWidth_protru = 0.07;
@ 1 "adrc/adrc_protru.ev" 1
/*protrusion length rule*/
SIZE metal2     { UNDER_OVER = fatTblThresh_protru / 2.0 - 0.0001  } TEMP = fat
BOOLEAN fat AND metal2  {  } TEMP = fat 
BOOLEAN metal2  NOT fat {  } TEMP = fat_nbr
SIZE fat { OVERSIZE = fatTblLength_protru + 0.0001  } TEMP = fat_ext
BOOLEAN fat_nbr AND fat_ext {} TEMP = fat_nbr
SELECT fat_nbr INTERACT fat TEMP = fat_nbr
/* Get the correct fat extension */
SELECT_EDGE fat_nbr TOUCHING fat { } TEMP = ext_filter
SIZE ext_filter { VSIZE_INSIDE = 0.0001  } TEMP = ext_filter
SIZE ext_filter INSIDE fat_nbr {
   OVERSIZE = fatTblLength_protru- 0.0001 
   INCREMENT = minSpacing
} TEMP=dummy TEMP = fat_nbr
  
VERTEX fat_nbr {
   CONCAVE = TRUE
   SIZE = 0.0002 
} TEMP = corners
SELECT fat_nbr OUTSIDE corners { } TEMP = fat_nbr1
BOOLEAN fat_nbr NOT fat_nbr1 { } TEMP = fat_nbr2
SELECT_CONTAINS fat_nbr1 {
   WIDTH =  0.0002 
   HEIGHT = fatTblLength_protru
} TEMP = good_fat_nbr1
BOOLEAN fat_nbr1 NOT good_fat_nbr1 { } TEMP = fat_nbr1
/* check with L or T shape of fat extension */
SELECT_EDGE fat_nbr2 INTERACT corners { } TEMP = side_edge
LENGTH side_edge { SPACING < fatTblLength_protru } TEMP = vio_edge
SELECT fat_nbr2 INTERACT vio_edge { } TEMP = fat_nbr2
BOOLEAN fat_nbr1 OR fat_nbr2 { } TEMP = fat_nbr
INTERAL fat_nbr {
   SPACING < fatTblWidth_protru
} TEMP = possible_err
if (!layer_empty(possible_err)) {
   SELECT fat_nbr INTERACT possible_err { } TEMP=fat_nbr
   SELECT fat INTERACT fat_nbr {} TEMP=fat
   BOOLEAN fat OR fat_nbr {} TEMP=fat
   INTERNAL fat {
      COMMENT = "$layer_name ProtrusionLength : threshold fatTblThresh_protru um, length  fatTblLength_protru um, width fatTblWidth_protru um"
      SPACING < fatTblWidth_protru
   } (13 )
}
/* protrusion leng rule check */
SET fatTblThresh_protru = 0;
SET fatTblLength_protru = 0;
SET fatTblWidth_protru = 0;
SET minSpacing = 0;
@ 303 "adrc/adrc.ev" 2


SET minSpacing = 0.056;
SET fatTblThresh_protru = 1.5;
SET fatTblLength_protru = 0.7;
SET fatTblWidth_protru = 0.15;
@ 1 "adrc/adrc_protru.ev" 1
/*protrusion length rule*/
SIZE metal2     { UNDER_OVER = fatTblThresh_protru / 2.0 - 0.0001  } TEMP = fat
BOOLEAN fat AND metal2  {  } TEMP = fat 
BOOLEAN metal2  NOT fat {  } TEMP = fat_nbr
SIZE fat { OVERSIZE = fatTblLength_protru + 0.0001  } TEMP = fat_ext
BOOLEAN fat_nbr AND fat_ext {} TEMP = fat_nbr
SELECT fat_nbr INTERACT fat TEMP = fat_nbr
/* Get the correct fat extension */
SELECT_EDGE fat_nbr TOUCHING fat { } TEMP = ext_filter
SIZE ext_filter { VSIZE_INSIDE = 0.0001  } TEMP = ext_filter
SIZE ext_filter INSIDE fat_nbr {
   OVERSIZE = fatTblLength_protru- 0.0001 
   INCREMENT = minSpacing
} TEMP=dummy TEMP = fat_nbr
  
VERTEX fat_nbr {
   CONCAVE = TRUE
   SIZE = 0.0002 
} TEMP = corners
SELECT fat_nbr OUTSIDE corners { } TEMP = fat_nbr1
BOOLEAN fat_nbr NOT fat_nbr1 { } TEMP = fat_nbr2
SELECT_CONTAINS fat_nbr1 {
   WIDTH =  0.0002 
   HEIGHT = fatTblLength_protru
} TEMP = good_fat_nbr1
BOOLEAN fat_nbr1 NOT good_fat_nbr1 { } TEMP = fat_nbr1
/* check with L or T shape of fat extension */
SELECT_EDGE fat_nbr2 INTERACT corners { } TEMP = side_edge
LENGTH side_edge { SPACING < fatTblLength_protru } TEMP = vio_edge
SELECT fat_nbr2 INTERACT vio_edge { } TEMP = fat_nbr2
BOOLEAN fat_nbr1 OR fat_nbr2 { } TEMP = fat_nbr
INTERAL fat_nbr {
   SPACING < fatTblWidth_protru
} TEMP = possible_err
if (!layer_empty(possible_err)) {
   SELECT fat_nbr INTERACT possible_err { } TEMP=fat_nbr
   SELECT fat INTERACT fat_nbr {} TEMP=fat
   BOOLEAN fat OR fat_nbr {} TEMP=fat
   INTERNAL fat {
      COMMENT = "$layer_name ProtrusionLength : threshold fatTblThresh_protru um, length  fatTblLength_protru um, width fatTblWidth_protru um"
      SPACING < fatTblWidth_protru
   } (13 )
}
/* protrusion leng rule check */
SET fatTblThresh_protru = 0;
SET fatTblLength_protru = 0;
SET fatTblWidth_protru = 0;
SET minSpacing = 0;
@ 309 "adrc/adrc.ev" 2


SET minSpacing = 0.056;
SET fatTblThresh_protru = 3;
SET fatTblLength_protru = 1.5;
SET fatTblWidth_protru = 0.3;
@ 1 "adrc/adrc_protru.ev" 1
/*protrusion length rule*/
SIZE metal2     { UNDER_OVER = fatTblThresh_protru / 2.0 - 0.0001  } TEMP = fat
BOOLEAN fat AND metal2  {  } TEMP = fat 
BOOLEAN metal2  NOT fat {  } TEMP = fat_nbr
SIZE fat { OVERSIZE = fatTblLength_protru + 0.0001  } TEMP = fat_ext
BOOLEAN fat_nbr AND fat_ext {} TEMP = fat_nbr
SELECT fat_nbr INTERACT fat TEMP = fat_nbr
/* Get the correct fat extension */
SELECT_EDGE fat_nbr TOUCHING fat { } TEMP = ext_filter
SIZE ext_filter { VSIZE_INSIDE = 0.0001  } TEMP = ext_filter
SIZE ext_filter INSIDE fat_nbr {
   OVERSIZE = fatTblLength_protru- 0.0001 
   INCREMENT = minSpacing
} TEMP=dummy TEMP = fat_nbr
  
VERTEX fat_nbr {
   CONCAVE = TRUE
   SIZE = 0.0002 
} TEMP = corners
SELECT fat_nbr OUTSIDE corners { } TEMP = fat_nbr1
BOOLEAN fat_nbr NOT fat_nbr1 { } TEMP = fat_nbr2
SELECT_CONTAINS fat_nbr1 {
   WIDTH =  0.0002 
   HEIGHT = fatTblLength_protru
} TEMP = good_fat_nbr1
BOOLEAN fat_nbr1 NOT good_fat_nbr1 { } TEMP = fat_nbr1
/* check with L or T shape of fat extension */
SELECT_EDGE fat_nbr2 INTERACT corners { } TEMP = side_edge
LENGTH side_edge { SPACING < fatTblLength_protru } TEMP = vio_edge
SELECT fat_nbr2 INTERACT vio_edge { } TEMP = fat_nbr2
BOOLEAN fat_nbr1 OR fat_nbr2 { } TEMP = fat_nbr
INTERAL fat_nbr {
   SPACING < fatTblWidth_protru
} TEMP = possible_err
if (!layer_empty(possible_err)) {
   SELECT fat_nbr INTERACT possible_err { } TEMP=fat_nbr
   SELECT fat INTERACT fat_nbr {} TEMP=fat
   BOOLEAN fat OR fat_nbr {} TEMP=fat
   INTERNAL fat {
      COMMENT = "$layer_name ProtrusionLength : threshold fatTblThresh_protru um, length  fatTblLength_protru um, width fatTblWidth_protru um"
      SPACING < fatTblWidth_protru
   } (13 )
}
/* protrusion leng rule check */
SET fatTblThresh_protru = 0;
SET fatTblLength_protru = 0;
SET fatTblWidth_protru = 0;
SET minSpacing = 0;
@ 315 "adrc/adrc.ev" 2





/* Start of Met2 fat table spacing rules */
SET fatTblSpacingMode = 0;
SET parallelLengthMode = 0;
SET router_parallelLengthNetMode = 0;

SET fatTblThreshold = 0.155;
SET fatTblParallelLength = 0.15;
SET minWidth = 0.056;

SET fatTblThreshold_Start = 0;
SET fatTblSpacing = 0.064;
@ 1 "adrc/adrc_fatMetal.ev" 1
/*check fat metal table*/
if (fatTblThreshold > 0) {
    if ((fatTblThreshold / 2.0) > 0.0001 ) {
       SIZE fat_candidate  { UNDER_OVER = fatTblThreshold / 2.0 - 0.0001  } TEMP = fat_candidate
       if (fatTblNextThreshold > 0) {
          SIZE fat_candidate { UNDER_OVER = fatTblNextThreshold / 2.0 - 0.0001  } TEMP = fat_next
          BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
          BOOLEAN fat AND fat_target { } TEMP = fat
          SET fatTblNextThreshold = 0;
       } else {
          BOOLEAN fat_candidate AND fat_target {  } TEMP = fat 
       }
    } else {
      COPY fat_target {  } TEMP = fat 
    }
    COPY fat_target { } TEMP = spc_target
    if (fatTblThreshold_Start > 0  || fatTblThreshold_End > 0) {
       if (fatTblThreshold_Start > 0) {
          SIZE fat_target { UNDER_OVER = fatTblThreshold_Start / 2.0 - 0.0001  } TEMP = spc_target
       }
       if (fatTblThreshold_End > 0 && fatTblThreshold_End > fatTblThreshold_Start) {
          SIZE spc_target { UNDER_OVER = fatTblThreshold_End / 2.0 - 0.0001  } TEMP = fat_end
          BOOLEAN spc_target NOT fat_end { } TEMP = spc_target
       }
       BOOLEAN spc_target AND fat_target {  } TEMP = spc_target
       if (ignoreBlockage == 0 && fatTblThreshold_Start < fatTblThreshold_1) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal2_blockage  {  } TEMP = spc_target
       }
       SET fatTblThreshold_Start = 0;
       SET fatTblThreshold_End = 0;
       SET fatTblThreshold_1 = 0;
    } else {
       if (ignoreBlockage == 0) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal2_blockage  {  } TEMP = spc_target
       }
    }
 
    if (fatTblEnclosedArea > 0) {
       SELECT holes INTERACT fat { } TEMP = fat_holes
       AREA fat_holes { 
          RANGE = [0.0001 * 0.0001 , fatTblEnclosedArea - 0.0001 * 0.0001 ]
       } TEMP = fat_holes
       if (fatTblMinEnclosedAreaMode==0) {
          SIZE fat_holes { OVER_UNDER = fatTblThreshold / 2.0 + 0.0001  } TEMP = ovun_holes
          SELECT ovun_holes INTERACT fat_holes { RANGE = [2, 9999999999 ] } TEMP = merged_holes
          BOOLEAN fat_candidate AND fat_target { } TEMP = fat_metal
          BOOLEAN metal2  NOT fat_metal { } TEMP = thin_metal
          BOOLEAN thin_metal NOT ovun_holes { } TEMP = thin_metal
          SELECT ovun_holes INTERACT thin_metal { } TEMP = thin_holes
          BOOLEAN thin_holes OR merged_holes { } TEMP = thin_holes
          BOOLEAN fat_holes NOT thin_holes { } TEMP = fat_holes
       }
       COPY fat_holes { 
	  COMMENT = "$layer_name EnclsArea : fat metal ( fatTblThreshold um) minimum enclosed area (mode fatTblMinEnclosedAreaMode ) = fatTblEnclosedArea um*um"
       } (13 )
       SET fatTblEnclosedArea = 0;
    }
    if (fatTblSpacing > 0) {
       /*check fat metal*/ 
       if (fatTblParallelLength > 0) {
          if (router_parallelLengthNetMode == 1 || parallelLengthMode == 1) {
             AREA spc_target { RANGE = [fatTblParallelLength * minWidth + 0.0001 , 9999999999 ] } TEMP = spc_target1
             COPY spc_target1 { } TEMP = spc_target2
          } else {
             COPY spc_target { } TEMP = spc_target2
          }
          if (parallelLengthMode == 1) {
             SELECT metal2  INTERACT fat { } TEMP = fat_all 
             BOOLEAN fat_all OR fat { } TEMP = fat2
             SELECT metal2  INTERACT spc_target2 { } TEMP = spc_target_all
             BOOLEAN spc_target_all OR spc_target2 { } TEMP = spc_target2
          } else {
             COPY fat { } TEMP = fat2
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING <= fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
                OUTPUT_EDGES = TRUE
             } TEMP = vio_edge
             SELECT vio_edge INTERACT fat { } TEMP = vio_edge
             SELECT vio_edge INTERACT spc_target1 { } TEMP = vio_edge
             SELECT violation INTERACT vio_edge { } TEMP = violation
          } else {
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
          }
          BOOLEAN violation NOT fat_target { } TEMP = violation
          if (fatTblParallelLength < fatTblSpacing) {
             SELECT_EDGE violation TOUCHING fat2 {
                VSIZE_INSIDE = fatTblParallelLength - 0.0002 
             } TEMP = vio_filter
             SELECT_CONTAINS vio_filter { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = vio_filter
             SELECT violation INTERACT vio_filter { } TEMP = violation
          } else {
             SELECT_CONTAINS violation { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = violation
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING = [fatTblSpacing, fatTblSpacing]
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
             } TEMP = violation3
             BOOLEAN violation3 NOT fat_target { } TEMP = violation3
             BOOLEAN violation NOT violation3 { } TEMP= violation
          }
          SELECT_EDGE fat2 TOUCHING violation { } TEMP=fat_viol
          BOOLEAN fat_viol AND violation { } TEMP=fat_viol
          SELECT_EDGE spc_target2 TOUCHING violation { } TEMP=spc_target2
          BOOLEAN spc_target2 AND violation { } TEMP= spc_target2
	  if (ignoreChildCell == 1) {
             EXTERNAL fat_viol spc_target2 {
		SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		TOUCH = FALSE
		POINT_TOUCH = FALSE
		NON_PARALLEL = TRUE
	     } TEMP = spc_mode0_out
             BOOLEAN spc_mode0_out NOT spc_mode0_child_out { } TEMP = spc_mode0_diff_out
             SELECT spc_mode0_out INTERACT spc_mode0_diff_out { } TEMP = spc_mode0_out
	     SELECT_EDGE fat2 TOUCHING spc_mode0_out { } TEMP=fat_viol
	     BOOLEAN fat_viol AND spc_mode0_out { } TEMP=fat_viol
	     SELECT_EDGE spc_target2 TOUCHING spc_mode0_out { } TEMP=spc_target2
	     BOOLEAN spc_target2 AND spc_mode0_out { } TEMP=spc_target2
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (13 )  		
	  } else {
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing 
	        SET_CORNERS_TO_SPACING = FALSE
	        PARALLEL_POINT_PROJECTION = FALSE
	        TOUCH = FALSE
	        POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (13 )
	  }
	  if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	     if (ignoreChildCell == 1) {
		EXTERNAL fat spc_target {
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} TEMP = spc_mode1_out
	        BOOLEAN spc_mode1_out NOT spc_mode1_child_out { } TEMP = spc_mode1_diff_out
	        SELECT spc_mode1_out INTERACT spc_mode1_diff_out { } TEMP = spc_mode1_out
                SELECT_EDGE fat TOUCHING spc_mode1_out { } TEMP=fat_viol
	        BOOLEAN fat_viol AND spc_mode1_out { } TEMP=fat_viol
	        SELECT_EDGE spc_target TOUCHING spc_mode1_out { } TEMP=spc_target2
	        BOOLEAN spc_target2 AND spc_mode1_out { } TEMP=spc_target2
	        EXTERNAL fat_viol spc_target2 {
	           COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um " 	    
		   SPACING < fatTblSpacing_dg
                   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} (13 )
	     } else {
	        EXTERNAL fat spc_target {
		   COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um "
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
	    	   PARALLEL_POINT_PROJECTION = FALSE
	           TOUCH = FALSE
	     	   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } (13 ) 
	     }
          }
       } else {
	  if (ignoreChildCell == 1) {
              EXTERNAL fat spc_target {
                 SPACING < fatTblSpacing
                 BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
              } TEMP = spc_out
	      BOOLEAN spc_out NOT spc_child_out { } TEMP = spc_diff_out
	      SELECT spc_out INTERACT spc_diff_out { } TEMP = spc_out
	      SELECT_EDGE fat TOUCHING spc_out { } TEMP=fat_viol
	      BOOLEAN fat_viol AND spc_out { } TEMP=fat_viol
              SELECT_EDGE spc_target TOUCHING spc_out { } TEMP=spc_target2
	      BOOLEAN spc_target2 AND spc_out { } TEMP=spc_target2
	      EXTERNAL fat_viol spc_target2 {
		 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
		 BOX_CORNER = FALSE 
		 NON_PARALLEL = TRUE
		 POINT_TOUCH = FALSE
	      } (13 ) 
	  } else {
	      EXTERNAL fat spc_target {
                 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
	         BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
	      } (13 ) 
	  }
       }
       /*check metal in the extension range*/ 
       if (fatTblExtensionRange > 0) {
	  if (fatWireExtensionMode == 0) {
	     SIZE fat { OVERSIZE = fatTblExtensionRange } TEMP = fat_tmp
             BOOLEAN fat_tmp AND metal2  { } TEMP = fat_tmp
  	     BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
             SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_ext
             BOOLEAN fat_ext OR fat { } TEMP = fat_ext
	     if (fatTblParallelLength > 0) {
                if (fatTblParallelLength > fatTblExtensionRange) {
                   SIZE fat { OVERSIZE = fatTblParallelLength } TEMP = fat_tmp
                   BOOLEAN fat_tmp AND metal2  { } TEMP = fat_tmp
  	           BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
                   SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_parallel
                   BOOLEAN fat_parallel OR fat { } TEMP = fat_parallel
                } else {
                   COPY fat_ext { } TEMP = fat_parallel
                }
		EXTERNAL fat_parallel spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
	           NON_PARALLEL = TRUE
	        } TEMP = vio_filter_set
		EXTERNAL fat_ext spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } TEMP = vio_set
                if (fatTblParallelLength < fatTblSpacing) {
                   SELECT_EDGE vio_filter_set TOUCHING fat_parallel {
                      VSIZE_INSIDE = fatTblParallelLength - 0.0002 
                   } TEMP = vio_filter_set_filter
                   SELECT_CONTAINS vio_filter_set_filter { 
                      WIDTH =  0.0002 
                      HEIGHT = fatTblParallelLength + 0.0001 
                   } TEMP = vio_filter_set_filter
                   SELECT vio_filter_set INTERACT vio_filter_set_filter { } TEMP = vio_filter
                } else {
	           SELECT_CONTAINS vio_filter_set { 
	              WIDTH =  0.0002 
	              HEIGHT = fatTblParallelLength + 0.0001 
	           } TEMP = vio_filter
                }
                SELECT vio_set INSIDE vio_filter { } TEMP = mode0_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out1 NOT mode0_child_out1 { } TEMP = mode0_diff_out1
                   SELECT mode0_out1 INTERACT mode0_diff_out1 { } TEMP = mode0_out1
                }
                COPY mode0_out1 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing  = fatTblSpacing um"
                } (13 )
		if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	           EXTERNAL fat_ext spc_target {
		      SPACING < fatTblSpacing_dg
	              SET_CORNERS_TO_SPACING = FALSE
		      PARALLEL_POINT_PROJECTION = FALSE
		      TOUCH = TRUE
		      POINT_TOUCH = FALSE
		      NON_PARALLEL = TRUE
	           } TEMP = mode0_out2
                   if (ignoreChildCell == 1) {
                      BOOLEAN mode0_out2 NOT mode0_child_out2 { } TEMP = mode0_diff_out2
                      SELECT mode0_out2 INTERACT mode0_diff_out2 { } TEMP = mode0_out2
                   }
                   COPY mode0_out2 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing (mode 1/2) = fatTblSpacing um/ fatTblSpacing_dg um "
                   } (13 )
	        } 
	     } else {
	        EXTERNAL fat_ext spc_target {
		   SPACING < fatTblSpacing
		   NON_PARALLEL = TRUE
		   SET_CORNERS_TO_SPACING = FALSE
		   POINT_TOUCH = FALSE
		} TEMP = mode0_out3
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out3 NOT mode0_child_out3 { } TEMP = mode0_diff_out3
                   SELECT mode0_out3 INTERACT mode0_diff_out3 { } TEMP = mode0_out3
                }
                COPY mode0_out3 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range ( fatTblExtensionRange um) minimum spacing = fatTblSpacing um"
                } (13 )
	     }
	  } else if (fatWireExtensionMode == 1) {
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal2  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             if (fatTblParallelLength > 0) {
                EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
		   BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   CHECK_SAME_POLYGON = TRUE 
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
	        SELECT fat_ext INTERACT spacing {  } TEMP = fat_ext
		BOOLEAN fat_ext OR spacing {  } TEMP = combined_fat_ext
                EXTERNAL combined_fat_ext fat {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
                } TEMP = fat_spacing
		BOOLEAN fat_spacing AND fat_ran {  } TEMP = fat_spacing
		BOOLEAN combined_fat_ext OR fat_spacing {  } TEMP = combined_fat_ext
                SELECT_CONTAINS combined_fat_ext { 
                   WIDTH =  0.0002 
                   HEIGHT = fatTblParallelLength + 0.0001 
                } TEMP = combined_fat_ext
		SELECT spacing INTERACT combined_fat_ext { 
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out1 NOT mode1_child_out1 { } TEMP = mode1_diff_out1
                   SELECT mode1_out1 INTERACT mode1_diff_out1 { } TEMP = mode1_out1 
                }
                COPY mode1_out1 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (13 ) 
	     } else {
               	EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
	           BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
	           CHECK_SAME_POLYGON = TRUE 
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
                SELECT spacing INTERACT fat_ext {
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out2
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out2 NOT mode1_child_out2 { } TEMP = mode1_diff_out2
                   SELECT mode1_out2 INTERACT mode1_diff_out2 { } TEMP = mode1_out2
                }
                COPY mode1_out2 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (13 )
	     }
	  } else if (fatWireExtensionMode == 2) {
	     SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
             BOOLEAN fat_ran AND metal2  {  } TEMP = fat_ext
             BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	      	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
             } TEMP = spacing
 	     SELECT spacing INSIDE fat_ran {  } TEMP = spacing
	     SELECT spacing OUTSIDE fat {  } TEMP = spacing
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode2_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode2_out NOT mode2_child_out { } TEMP = mode2_diff_out
                SELECT mode2_out INTERACT mode2_diff_out { } TEMP = mode2_out 
             }
             COPY mode2_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 2, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (13 )
	  } else if (fatWireExtensionMode == 3) {
             SIZE fat {
	        GROW_LEFT = fatTblExtensionRange
	        GROW_RIGHT = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal2  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	       	PARALLEL = TRUE

	       	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		HORIZONTAL_ONLY = TRUE
             } TEMP = spacing_hor
	     SELECT spacing_hor INSIDE fat_ran {  } TEMP = spacing_hor
	     SELECT spacing_hor OUTSIDE fat {  } TEMP = spacing_hor
             SIZE fat {
	        GROW_TOP = fatTblExtensionRange
	        GROW_BOTTOM = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal2  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	        POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		VERTICAL_ONLY = TRUE
             } TEMP = spacing_ver
	     SELECT spacing_ver INSIDE fat_ran {  } TEMP = spacing_ver
	     SELECT spacing_ver OUTSIDE fat {  } TEMP = spacing_ver
  	     BOOLEAN spacing_hor OR spacing_ver {  } TEMP = spacing
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal2  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
  	     /* check overlapped projection length */
 	     if (fatTblParallelLength > 0) {
                POLYGON_FEATURES fat_ext {
                   EQUATIONS {
                      vnum = EV_VNUM_IN;
                      if ( vnum > 0) {
                         bdLeft = EV_VXCOORD_IN[0];
                         bdRight = EV_VXCOORD_IN[0];
                         bdBottom = EV_VYCOORD_IN[0];
                         bdTop = EV_VYCOORD_IN[0];
                         FOR (i = 1; i < vnum; i++) {
                            if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
                            else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
                            if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
                            else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
                         } /* FOR i */
                         if ( (bdRight - bdLeft) >= fatTblParallelLength ||
                  	      (bdTop - bdBottom) >= fatTblParallelLength) {
                            FOR (i = 0; i < vnum; i++) {
                               EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
                               EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
                            }
                            EV_VNUM_OUT = vnum;
                 	    EV_SAVE_POLYGON();
                         }
                      }
                   }
                } TEMP = fat_ext /* POLYGON_FEATURE */
             }
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode3_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode3_out NOT mode3_child_out { } TEMP = mode3_diff_out
                SELECT mode3_out INTERACT mode3_diff_out { } TEMP = mode3_out
             }
             COPY mode3_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 3, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (13 )
          }
       }
       SET fatTblSpacing = 0;
    }
}
@ 331 "adrc/adrc.ev" 2


SET fatTblThreshold = 0.305;
SET fatTblParallelLength = 0.3;
SET minWidth = 0.056;

SET fatTblThreshold_Start = 0;
SET fatTblSpacing = 0.12;
@ 1 "adrc/adrc_fatMetal.ev" 1
/*check fat metal table*/
if (fatTblThreshold > 0) {
    if ((fatTblThreshold / 2.0) > 0.0001 ) {
       SIZE fat_candidate  { UNDER_OVER = fatTblThreshold / 2.0 - 0.0001  } TEMP = fat_candidate
       if (fatTblNextThreshold > 0) {
          SIZE fat_candidate { UNDER_OVER = fatTblNextThreshold / 2.0 - 0.0001  } TEMP = fat_next
          BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
          BOOLEAN fat AND fat_target { } TEMP = fat
          SET fatTblNextThreshold = 0;
       } else {
          BOOLEAN fat_candidate AND fat_target {  } TEMP = fat 
       }
    } else {
      COPY fat_target {  } TEMP = fat 
    }
    COPY fat_target { } TEMP = spc_target
    if (fatTblThreshold_Start > 0  || fatTblThreshold_End > 0) {
       if (fatTblThreshold_Start > 0) {
          SIZE fat_target { UNDER_OVER = fatTblThreshold_Start / 2.0 - 0.0001  } TEMP = spc_target
       }
       if (fatTblThreshold_End > 0 && fatTblThreshold_End > fatTblThreshold_Start) {
          SIZE spc_target { UNDER_OVER = fatTblThreshold_End / 2.0 - 0.0001  } TEMP = fat_end
          BOOLEAN spc_target NOT fat_end { } TEMP = spc_target
       }
       BOOLEAN spc_target AND fat_target {  } TEMP = spc_target
       if (ignoreBlockage == 0 && fatTblThreshold_Start < fatTblThreshold_1) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal2_blockage  {  } TEMP = spc_target
       }
       SET fatTblThreshold_Start = 0;
       SET fatTblThreshold_End = 0;
       SET fatTblThreshold_1 = 0;
    } else {
       if (ignoreBlockage == 0) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal2_blockage  {  } TEMP = spc_target
       }
    }
 
    if (fatTblEnclosedArea > 0) {
       SELECT holes INTERACT fat { } TEMP = fat_holes
       AREA fat_holes { 
          RANGE = [0.0001 * 0.0001 , fatTblEnclosedArea - 0.0001 * 0.0001 ]
       } TEMP = fat_holes
       if (fatTblMinEnclosedAreaMode==0) {
          SIZE fat_holes { OVER_UNDER = fatTblThreshold / 2.0 + 0.0001  } TEMP = ovun_holes
          SELECT ovun_holes INTERACT fat_holes { RANGE = [2, 9999999999 ] } TEMP = merged_holes
          BOOLEAN fat_candidate AND fat_target { } TEMP = fat_metal
          BOOLEAN metal2  NOT fat_metal { } TEMP = thin_metal
          BOOLEAN thin_metal NOT ovun_holes { } TEMP = thin_metal
          SELECT ovun_holes INTERACT thin_metal { } TEMP = thin_holes
          BOOLEAN thin_holes OR merged_holes { } TEMP = thin_holes
          BOOLEAN fat_holes NOT thin_holes { } TEMP = fat_holes
       }
       COPY fat_holes { 
	  COMMENT = "$layer_name EnclsArea : fat metal ( fatTblThreshold um) minimum enclosed area (mode fatTblMinEnclosedAreaMode ) = fatTblEnclosedArea um*um"
       } (13 )
       SET fatTblEnclosedArea = 0;
    }
    if (fatTblSpacing > 0) {
       /*check fat metal*/ 
       if (fatTblParallelLength > 0) {
          if (router_parallelLengthNetMode == 1 || parallelLengthMode == 1) {
             AREA spc_target { RANGE = [fatTblParallelLength * minWidth + 0.0001 , 9999999999 ] } TEMP = spc_target1
             COPY spc_target1 { } TEMP = spc_target2
          } else {
             COPY spc_target { } TEMP = spc_target2
          }
          if (parallelLengthMode == 1) {
             SELECT metal2  INTERACT fat { } TEMP = fat_all 
             BOOLEAN fat_all OR fat { } TEMP = fat2
             SELECT metal2  INTERACT spc_target2 { } TEMP = spc_target_all
             BOOLEAN spc_target_all OR spc_target2 { } TEMP = spc_target2
          } else {
             COPY fat { } TEMP = fat2
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING <= fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
                OUTPUT_EDGES = TRUE
             } TEMP = vio_edge
             SELECT vio_edge INTERACT fat { } TEMP = vio_edge
             SELECT vio_edge INTERACT spc_target1 { } TEMP = vio_edge
             SELECT violation INTERACT vio_edge { } TEMP = violation
          } else {
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
          }
          BOOLEAN violation NOT fat_target { } TEMP = violation
          if (fatTblParallelLength < fatTblSpacing) {
             SELECT_EDGE violation TOUCHING fat2 {
                VSIZE_INSIDE = fatTblParallelLength - 0.0002 
             } TEMP = vio_filter
             SELECT_CONTAINS vio_filter { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = vio_filter
             SELECT violation INTERACT vio_filter { } TEMP = violation
          } else {
             SELECT_CONTAINS violation { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = violation
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING = [fatTblSpacing, fatTblSpacing]
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
             } TEMP = violation3
             BOOLEAN violation3 NOT fat_target { } TEMP = violation3
             BOOLEAN violation NOT violation3 { } TEMP= violation
          }
          SELECT_EDGE fat2 TOUCHING violation { } TEMP=fat_viol
          BOOLEAN fat_viol AND violation { } TEMP=fat_viol
          SELECT_EDGE spc_target2 TOUCHING violation { } TEMP=spc_target2
          BOOLEAN spc_target2 AND violation { } TEMP= spc_target2
	  if (ignoreChildCell == 1) {
             EXTERNAL fat_viol spc_target2 {
		SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		TOUCH = FALSE
		POINT_TOUCH = FALSE
		NON_PARALLEL = TRUE
	     } TEMP = spc_mode0_out
             BOOLEAN spc_mode0_out NOT spc_mode0_child_out { } TEMP = spc_mode0_diff_out
             SELECT spc_mode0_out INTERACT spc_mode0_diff_out { } TEMP = spc_mode0_out
	     SELECT_EDGE fat2 TOUCHING spc_mode0_out { } TEMP=fat_viol
	     BOOLEAN fat_viol AND spc_mode0_out { } TEMP=fat_viol
	     SELECT_EDGE spc_target2 TOUCHING spc_mode0_out { } TEMP=spc_target2
	     BOOLEAN spc_target2 AND spc_mode0_out { } TEMP=spc_target2
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (13 )  		
	  } else {
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing 
	        SET_CORNERS_TO_SPACING = FALSE
	        PARALLEL_POINT_PROJECTION = FALSE
	        TOUCH = FALSE
	        POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (13 )
	  }
	  if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	     if (ignoreChildCell == 1) {
		EXTERNAL fat spc_target {
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} TEMP = spc_mode1_out
	        BOOLEAN spc_mode1_out NOT spc_mode1_child_out { } TEMP = spc_mode1_diff_out
	        SELECT spc_mode1_out INTERACT spc_mode1_diff_out { } TEMP = spc_mode1_out
                SELECT_EDGE fat TOUCHING spc_mode1_out { } TEMP=fat_viol
	        BOOLEAN fat_viol AND spc_mode1_out { } TEMP=fat_viol
	        SELECT_EDGE spc_target TOUCHING spc_mode1_out { } TEMP=spc_target2
	        BOOLEAN spc_target2 AND spc_mode1_out { } TEMP=spc_target2
	        EXTERNAL fat_viol spc_target2 {
	           COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um " 	    
		   SPACING < fatTblSpacing_dg
                   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} (13 )
	     } else {
	        EXTERNAL fat spc_target {
		   COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um "
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
	    	   PARALLEL_POINT_PROJECTION = FALSE
	           TOUCH = FALSE
	     	   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } (13 ) 
	     }
          }
       } else {
	  if (ignoreChildCell == 1) {
              EXTERNAL fat spc_target {
                 SPACING < fatTblSpacing
                 BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
              } TEMP = spc_out
	      BOOLEAN spc_out NOT spc_child_out { } TEMP = spc_diff_out
	      SELECT spc_out INTERACT spc_diff_out { } TEMP = spc_out
	      SELECT_EDGE fat TOUCHING spc_out { } TEMP=fat_viol
	      BOOLEAN fat_viol AND spc_out { } TEMP=fat_viol
              SELECT_EDGE spc_target TOUCHING spc_out { } TEMP=spc_target2
	      BOOLEAN spc_target2 AND spc_out { } TEMP=spc_target2
	      EXTERNAL fat_viol spc_target2 {
		 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
		 BOX_CORNER = FALSE 
		 NON_PARALLEL = TRUE
		 POINT_TOUCH = FALSE
	      } (13 ) 
	  } else {
	      EXTERNAL fat spc_target {
                 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
	         BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
	      } (13 ) 
	  }
       }
       /*check metal in the extension range*/ 
       if (fatTblExtensionRange > 0) {
	  if (fatWireExtensionMode == 0) {
	     SIZE fat { OVERSIZE = fatTblExtensionRange } TEMP = fat_tmp
             BOOLEAN fat_tmp AND metal2  { } TEMP = fat_tmp
  	     BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
             SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_ext
             BOOLEAN fat_ext OR fat { } TEMP = fat_ext
	     if (fatTblParallelLength > 0) {
                if (fatTblParallelLength > fatTblExtensionRange) {
                   SIZE fat { OVERSIZE = fatTblParallelLength } TEMP = fat_tmp
                   BOOLEAN fat_tmp AND metal2  { } TEMP = fat_tmp
  	           BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
                   SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_parallel
                   BOOLEAN fat_parallel OR fat { } TEMP = fat_parallel
                } else {
                   COPY fat_ext { } TEMP = fat_parallel
                }
		EXTERNAL fat_parallel spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
	           NON_PARALLEL = TRUE
	        } TEMP = vio_filter_set
		EXTERNAL fat_ext spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } TEMP = vio_set
                if (fatTblParallelLength < fatTblSpacing) {
                   SELECT_EDGE vio_filter_set TOUCHING fat_parallel {
                      VSIZE_INSIDE = fatTblParallelLength - 0.0002 
                   } TEMP = vio_filter_set_filter
                   SELECT_CONTAINS vio_filter_set_filter { 
                      WIDTH =  0.0002 
                      HEIGHT = fatTblParallelLength + 0.0001 
                   } TEMP = vio_filter_set_filter
                   SELECT vio_filter_set INTERACT vio_filter_set_filter { } TEMP = vio_filter
                } else {
	           SELECT_CONTAINS vio_filter_set { 
	              WIDTH =  0.0002 
	              HEIGHT = fatTblParallelLength + 0.0001 
	           } TEMP = vio_filter
                }
                SELECT vio_set INSIDE vio_filter { } TEMP = mode0_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out1 NOT mode0_child_out1 { } TEMP = mode0_diff_out1
                   SELECT mode0_out1 INTERACT mode0_diff_out1 { } TEMP = mode0_out1
                }
                COPY mode0_out1 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing  = fatTblSpacing um"
                } (13 )
		if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	           EXTERNAL fat_ext spc_target {
		      SPACING < fatTblSpacing_dg
	              SET_CORNERS_TO_SPACING = FALSE
		      PARALLEL_POINT_PROJECTION = FALSE
		      TOUCH = TRUE
		      POINT_TOUCH = FALSE
		      NON_PARALLEL = TRUE
	           } TEMP = mode0_out2
                   if (ignoreChildCell == 1) {
                      BOOLEAN mode0_out2 NOT mode0_child_out2 { } TEMP = mode0_diff_out2
                      SELECT mode0_out2 INTERACT mode0_diff_out2 { } TEMP = mode0_out2
                   }
                   COPY mode0_out2 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing (mode 1/2) = fatTblSpacing um/ fatTblSpacing_dg um "
                   } (13 )
	        } 
	     } else {
	        EXTERNAL fat_ext spc_target {
		   SPACING < fatTblSpacing
		   NON_PARALLEL = TRUE
		   SET_CORNERS_TO_SPACING = FALSE
		   POINT_TOUCH = FALSE
		} TEMP = mode0_out3
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out3 NOT mode0_child_out3 { } TEMP = mode0_diff_out3
                   SELECT mode0_out3 INTERACT mode0_diff_out3 { } TEMP = mode0_out3
                }
                COPY mode0_out3 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range ( fatTblExtensionRange um) minimum spacing = fatTblSpacing um"
                } (13 )
	     }
	  } else if (fatWireExtensionMode == 1) {
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal2  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             if (fatTblParallelLength > 0) {
                EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
		   BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   CHECK_SAME_POLYGON = TRUE 
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
	        SELECT fat_ext INTERACT spacing {  } TEMP = fat_ext
		BOOLEAN fat_ext OR spacing {  } TEMP = combined_fat_ext
                EXTERNAL combined_fat_ext fat {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
                } TEMP = fat_spacing
		BOOLEAN fat_spacing AND fat_ran {  } TEMP = fat_spacing
		BOOLEAN combined_fat_ext OR fat_spacing {  } TEMP = combined_fat_ext
                SELECT_CONTAINS combined_fat_ext { 
                   WIDTH =  0.0002 
                   HEIGHT = fatTblParallelLength + 0.0001 
                } TEMP = combined_fat_ext
		SELECT spacing INTERACT combined_fat_ext { 
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out1 NOT mode1_child_out1 { } TEMP = mode1_diff_out1
                   SELECT mode1_out1 INTERACT mode1_diff_out1 { } TEMP = mode1_out1 
                }
                COPY mode1_out1 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (13 ) 
	     } else {
               	EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
	           BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
	           CHECK_SAME_POLYGON = TRUE 
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
                SELECT spacing INTERACT fat_ext {
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out2
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out2 NOT mode1_child_out2 { } TEMP = mode1_diff_out2
                   SELECT mode1_out2 INTERACT mode1_diff_out2 { } TEMP = mode1_out2
                }
                COPY mode1_out2 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (13 )
	     }
	  } else if (fatWireExtensionMode == 2) {
	     SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
             BOOLEAN fat_ran AND metal2  {  } TEMP = fat_ext
             BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	      	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
             } TEMP = spacing
 	     SELECT spacing INSIDE fat_ran {  } TEMP = spacing
	     SELECT spacing OUTSIDE fat {  } TEMP = spacing
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode2_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode2_out NOT mode2_child_out { } TEMP = mode2_diff_out
                SELECT mode2_out INTERACT mode2_diff_out { } TEMP = mode2_out 
             }
             COPY mode2_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 2, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (13 )
	  } else if (fatWireExtensionMode == 3) {
             SIZE fat {
	        GROW_LEFT = fatTblExtensionRange
	        GROW_RIGHT = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal2  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	       	PARALLEL = TRUE

	       	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		HORIZONTAL_ONLY = TRUE
             } TEMP = spacing_hor
	     SELECT spacing_hor INSIDE fat_ran {  } TEMP = spacing_hor
	     SELECT spacing_hor OUTSIDE fat {  } TEMP = spacing_hor
             SIZE fat {
	        GROW_TOP = fatTblExtensionRange
	        GROW_BOTTOM = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal2  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	        POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		VERTICAL_ONLY = TRUE
             } TEMP = spacing_ver
	     SELECT spacing_ver INSIDE fat_ran {  } TEMP = spacing_ver
	     SELECT spacing_ver OUTSIDE fat {  } TEMP = spacing_ver
  	     BOOLEAN spacing_hor OR spacing_ver {  } TEMP = spacing
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal2  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
  	     /* check overlapped projection length */
 	     if (fatTblParallelLength > 0) {
                POLYGON_FEATURES fat_ext {
                   EQUATIONS {
                      vnum = EV_VNUM_IN;
                      if ( vnum > 0) {
                         bdLeft = EV_VXCOORD_IN[0];
                         bdRight = EV_VXCOORD_IN[0];
                         bdBottom = EV_VYCOORD_IN[0];
                         bdTop = EV_VYCOORD_IN[0];
                         FOR (i = 1; i < vnum; i++) {
                            if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
                            else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
                            if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
                            else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
                         } /* FOR i */
                         if ( (bdRight - bdLeft) >= fatTblParallelLength ||
                  	      (bdTop - bdBottom) >= fatTblParallelLength) {
                            FOR (i = 0; i < vnum; i++) {
                               EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
                               EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
                            }
                            EV_VNUM_OUT = vnum;
                 	    EV_SAVE_POLYGON();
                         }
                      }
                   }
                } TEMP = fat_ext /* POLYGON_FEATURE */
             }
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode3_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode3_out NOT mode3_child_out { } TEMP = mode3_diff_out
                SELECT mode3_out INTERACT mode3_diff_out { } TEMP = mode3_out
             }
             COPY mode3_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 3, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (13 )
          }
       }
       SET fatTblSpacing = 0;
    }
}
@ 339 "adrc/adrc.ev" 2


SET fatTblThreshold = 1.505;
SET fatTblParallelLength = 1.5;
SET minWidth = 0.056;

SET fatTblThreshold_Start = 0;
SET fatTblSpacing = 0.6;
@ 1 "adrc/adrc_fatMetal.ev" 1
/*check fat metal table*/
if (fatTblThreshold > 0) {
    if ((fatTblThreshold / 2.0) > 0.0001 ) {
       SIZE fat_candidate  { UNDER_OVER = fatTblThreshold / 2.0 - 0.0001  } TEMP = fat_candidate
       if (fatTblNextThreshold > 0) {
          SIZE fat_candidate { UNDER_OVER = fatTblNextThreshold / 2.0 - 0.0001  } TEMP = fat_next
          BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
          BOOLEAN fat AND fat_target { } TEMP = fat
          SET fatTblNextThreshold = 0;
       } else {
          BOOLEAN fat_candidate AND fat_target {  } TEMP = fat 
       }
    } else {
      COPY fat_target {  } TEMP = fat 
    }
    COPY fat_target { } TEMP = spc_target
    if (fatTblThreshold_Start > 0  || fatTblThreshold_End > 0) {
       if (fatTblThreshold_Start > 0) {
          SIZE fat_target { UNDER_OVER = fatTblThreshold_Start / 2.0 - 0.0001  } TEMP = spc_target
       }
       if (fatTblThreshold_End > 0 && fatTblThreshold_End > fatTblThreshold_Start) {
          SIZE spc_target { UNDER_OVER = fatTblThreshold_End / 2.0 - 0.0001  } TEMP = fat_end
          BOOLEAN spc_target NOT fat_end { } TEMP = spc_target
       }
       BOOLEAN spc_target AND fat_target {  } TEMP = spc_target
       if (ignoreBlockage == 0 && fatTblThreshold_Start < fatTblThreshold_1) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal2_blockage  {  } TEMP = spc_target
       }
       SET fatTblThreshold_Start = 0;
       SET fatTblThreshold_End = 0;
       SET fatTblThreshold_1 = 0;
    } else {
       if (ignoreBlockage == 0) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal2_blockage  {  } TEMP = spc_target
       }
    }
 
    if (fatTblEnclosedArea > 0) {
       SELECT holes INTERACT fat { } TEMP = fat_holes
       AREA fat_holes { 
          RANGE = [0.0001 * 0.0001 , fatTblEnclosedArea - 0.0001 * 0.0001 ]
       } TEMP = fat_holes
       if (fatTblMinEnclosedAreaMode==0) {
          SIZE fat_holes { OVER_UNDER = fatTblThreshold / 2.0 + 0.0001  } TEMP = ovun_holes
          SELECT ovun_holes INTERACT fat_holes { RANGE = [2, 9999999999 ] } TEMP = merged_holes
          BOOLEAN fat_candidate AND fat_target { } TEMP = fat_metal
          BOOLEAN metal2  NOT fat_metal { } TEMP = thin_metal
          BOOLEAN thin_metal NOT ovun_holes { } TEMP = thin_metal
          SELECT ovun_holes INTERACT thin_metal { } TEMP = thin_holes
          BOOLEAN thin_holes OR merged_holes { } TEMP = thin_holes
          BOOLEAN fat_holes NOT thin_holes { } TEMP = fat_holes
       }
       COPY fat_holes { 
	  COMMENT = "$layer_name EnclsArea : fat metal ( fatTblThreshold um) minimum enclosed area (mode fatTblMinEnclosedAreaMode ) = fatTblEnclosedArea um*um"
       } (13 )
       SET fatTblEnclosedArea = 0;
    }
    if (fatTblSpacing > 0) {
       /*check fat metal*/ 
       if (fatTblParallelLength > 0) {
          if (router_parallelLengthNetMode == 1 || parallelLengthMode == 1) {
             AREA spc_target { RANGE = [fatTblParallelLength * minWidth + 0.0001 , 9999999999 ] } TEMP = spc_target1
             COPY spc_target1 { } TEMP = spc_target2
          } else {
             COPY spc_target { } TEMP = spc_target2
          }
          if (parallelLengthMode == 1) {
             SELECT metal2  INTERACT fat { } TEMP = fat_all 
             BOOLEAN fat_all OR fat { } TEMP = fat2
             SELECT metal2  INTERACT spc_target2 { } TEMP = spc_target_all
             BOOLEAN spc_target_all OR spc_target2 { } TEMP = spc_target2
          } else {
             COPY fat { } TEMP = fat2
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING <= fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
                OUTPUT_EDGES = TRUE
             } TEMP = vio_edge
             SELECT vio_edge INTERACT fat { } TEMP = vio_edge
             SELECT vio_edge INTERACT spc_target1 { } TEMP = vio_edge
             SELECT violation INTERACT vio_edge { } TEMP = violation
          } else {
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
          }
          BOOLEAN violation NOT fat_target { } TEMP = violation
          if (fatTblParallelLength < fatTblSpacing) {
             SELECT_EDGE violation TOUCHING fat2 {
                VSIZE_INSIDE = fatTblParallelLength - 0.0002 
             } TEMP = vio_filter
             SELECT_CONTAINS vio_filter { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = vio_filter
             SELECT violation INTERACT vio_filter { } TEMP = violation
          } else {
             SELECT_CONTAINS violation { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = violation
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING = [fatTblSpacing, fatTblSpacing]
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
             } TEMP = violation3
             BOOLEAN violation3 NOT fat_target { } TEMP = violation3
             BOOLEAN violation NOT violation3 { } TEMP= violation
          }
          SELECT_EDGE fat2 TOUCHING violation { } TEMP=fat_viol
          BOOLEAN fat_viol AND violation { } TEMP=fat_viol
          SELECT_EDGE spc_target2 TOUCHING violation { } TEMP=spc_target2
          BOOLEAN spc_target2 AND violation { } TEMP= spc_target2
	  if (ignoreChildCell == 1) {
             EXTERNAL fat_viol spc_target2 {
		SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		TOUCH = FALSE
		POINT_TOUCH = FALSE
		NON_PARALLEL = TRUE
	     } TEMP = spc_mode0_out
             BOOLEAN spc_mode0_out NOT spc_mode0_child_out { } TEMP = spc_mode0_diff_out
             SELECT spc_mode0_out INTERACT spc_mode0_diff_out { } TEMP = spc_mode0_out
	     SELECT_EDGE fat2 TOUCHING spc_mode0_out { } TEMP=fat_viol
	     BOOLEAN fat_viol AND spc_mode0_out { } TEMP=fat_viol
	     SELECT_EDGE spc_target2 TOUCHING spc_mode0_out { } TEMP=spc_target2
	     BOOLEAN spc_target2 AND spc_mode0_out { } TEMP=spc_target2
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (13 )  		
	  } else {
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing 
	        SET_CORNERS_TO_SPACING = FALSE
	        PARALLEL_POINT_PROJECTION = FALSE
	        TOUCH = FALSE
	        POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (13 )
	  }
	  if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	     if (ignoreChildCell == 1) {
		EXTERNAL fat spc_target {
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} TEMP = spc_mode1_out
	        BOOLEAN spc_mode1_out NOT spc_mode1_child_out { } TEMP = spc_mode1_diff_out
	        SELECT spc_mode1_out INTERACT spc_mode1_diff_out { } TEMP = spc_mode1_out
                SELECT_EDGE fat TOUCHING spc_mode1_out { } TEMP=fat_viol
	        BOOLEAN fat_viol AND spc_mode1_out { } TEMP=fat_viol
	        SELECT_EDGE spc_target TOUCHING spc_mode1_out { } TEMP=spc_target2
	        BOOLEAN spc_target2 AND spc_mode1_out { } TEMP=spc_target2
	        EXTERNAL fat_viol spc_target2 {
	           COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um " 	    
		   SPACING < fatTblSpacing_dg
                   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} (13 )
	     } else {
	        EXTERNAL fat spc_target {
		   COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um "
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
	    	   PARALLEL_POINT_PROJECTION = FALSE
	           TOUCH = FALSE
	     	   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } (13 ) 
	     }
          }
       } else {
	  if (ignoreChildCell == 1) {
              EXTERNAL fat spc_target {
                 SPACING < fatTblSpacing
                 BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
              } TEMP = spc_out
	      BOOLEAN spc_out NOT spc_child_out { } TEMP = spc_diff_out
	      SELECT spc_out INTERACT spc_diff_out { } TEMP = spc_out
	      SELECT_EDGE fat TOUCHING spc_out { } TEMP=fat_viol
	      BOOLEAN fat_viol AND spc_out { } TEMP=fat_viol
              SELECT_EDGE spc_target TOUCHING spc_out { } TEMP=spc_target2
	      BOOLEAN spc_target2 AND spc_out { } TEMP=spc_target2
	      EXTERNAL fat_viol spc_target2 {
		 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
		 BOX_CORNER = FALSE 
		 NON_PARALLEL = TRUE
		 POINT_TOUCH = FALSE
	      } (13 ) 
	  } else {
	      EXTERNAL fat spc_target {
                 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
	         BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
	      } (13 ) 
	  }
       }
       /*check metal in the extension range*/ 
       if (fatTblExtensionRange > 0) {
	  if (fatWireExtensionMode == 0) {
	     SIZE fat { OVERSIZE = fatTblExtensionRange } TEMP = fat_tmp
             BOOLEAN fat_tmp AND metal2  { } TEMP = fat_tmp
  	     BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
             SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_ext
             BOOLEAN fat_ext OR fat { } TEMP = fat_ext
	     if (fatTblParallelLength > 0) {
                if (fatTblParallelLength > fatTblExtensionRange) {
                   SIZE fat { OVERSIZE = fatTblParallelLength } TEMP = fat_tmp
                   BOOLEAN fat_tmp AND metal2  { } TEMP = fat_tmp
  	           BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
                   SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_parallel
                   BOOLEAN fat_parallel OR fat { } TEMP = fat_parallel
                } else {
                   COPY fat_ext { } TEMP = fat_parallel
                }
		EXTERNAL fat_parallel spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
	           NON_PARALLEL = TRUE
	        } TEMP = vio_filter_set
		EXTERNAL fat_ext spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } TEMP = vio_set
                if (fatTblParallelLength < fatTblSpacing) {
                   SELECT_EDGE vio_filter_set TOUCHING fat_parallel {
                      VSIZE_INSIDE = fatTblParallelLength - 0.0002 
                   } TEMP = vio_filter_set_filter
                   SELECT_CONTAINS vio_filter_set_filter { 
                      WIDTH =  0.0002 
                      HEIGHT = fatTblParallelLength + 0.0001 
                   } TEMP = vio_filter_set_filter
                   SELECT vio_filter_set INTERACT vio_filter_set_filter { } TEMP = vio_filter
                } else {
	           SELECT_CONTAINS vio_filter_set { 
	              WIDTH =  0.0002 
	              HEIGHT = fatTblParallelLength + 0.0001 
	           } TEMP = vio_filter
                }
                SELECT vio_set INSIDE vio_filter { } TEMP = mode0_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out1 NOT mode0_child_out1 { } TEMP = mode0_diff_out1
                   SELECT mode0_out1 INTERACT mode0_diff_out1 { } TEMP = mode0_out1
                }
                COPY mode0_out1 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing  = fatTblSpacing um"
                } (13 )
		if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	           EXTERNAL fat_ext spc_target {
		      SPACING < fatTblSpacing_dg
	              SET_CORNERS_TO_SPACING = FALSE
		      PARALLEL_POINT_PROJECTION = FALSE
		      TOUCH = TRUE
		      POINT_TOUCH = FALSE
		      NON_PARALLEL = TRUE
	           } TEMP = mode0_out2
                   if (ignoreChildCell == 1) {
                      BOOLEAN mode0_out2 NOT mode0_child_out2 { } TEMP = mode0_diff_out2
                      SELECT mode0_out2 INTERACT mode0_diff_out2 { } TEMP = mode0_out2
                   }
                   COPY mode0_out2 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing (mode 1/2) = fatTblSpacing um/ fatTblSpacing_dg um "
                   } (13 )
	        } 
	     } else {
	        EXTERNAL fat_ext spc_target {
		   SPACING < fatTblSpacing
		   NON_PARALLEL = TRUE
		   SET_CORNERS_TO_SPACING = FALSE
		   POINT_TOUCH = FALSE
		} TEMP = mode0_out3
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out3 NOT mode0_child_out3 { } TEMP = mode0_diff_out3
                   SELECT mode0_out3 INTERACT mode0_diff_out3 { } TEMP = mode0_out3
                }
                COPY mode0_out3 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range ( fatTblExtensionRange um) minimum spacing = fatTblSpacing um"
                } (13 )
	     }
	  } else if (fatWireExtensionMode == 1) {
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal2  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             if (fatTblParallelLength > 0) {
                EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
		   BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   CHECK_SAME_POLYGON = TRUE 
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
	        SELECT fat_ext INTERACT spacing {  } TEMP = fat_ext
		BOOLEAN fat_ext OR spacing {  } TEMP = combined_fat_ext
                EXTERNAL combined_fat_ext fat {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
                } TEMP = fat_spacing
		BOOLEAN fat_spacing AND fat_ran {  } TEMP = fat_spacing
		BOOLEAN combined_fat_ext OR fat_spacing {  } TEMP = combined_fat_ext
                SELECT_CONTAINS combined_fat_ext { 
                   WIDTH =  0.0002 
                   HEIGHT = fatTblParallelLength + 0.0001 
                } TEMP = combined_fat_ext
		SELECT spacing INTERACT combined_fat_ext { 
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out1 NOT mode1_child_out1 { } TEMP = mode1_diff_out1
                   SELECT mode1_out1 INTERACT mode1_diff_out1 { } TEMP = mode1_out1 
                }
                COPY mode1_out1 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (13 ) 
	     } else {
               	EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
	           BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
	           CHECK_SAME_POLYGON = TRUE 
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
                SELECT spacing INTERACT fat_ext {
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out2
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out2 NOT mode1_child_out2 { } TEMP = mode1_diff_out2
                   SELECT mode1_out2 INTERACT mode1_diff_out2 { } TEMP = mode1_out2
                }
                COPY mode1_out2 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (13 )
	     }
	  } else if (fatWireExtensionMode == 2) {
	     SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
             BOOLEAN fat_ran AND metal2  {  } TEMP = fat_ext
             BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	      	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
             } TEMP = spacing
 	     SELECT spacing INSIDE fat_ran {  } TEMP = spacing
	     SELECT spacing OUTSIDE fat {  } TEMP = spacing
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode2_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode2_out NOT mode2_child_out { } TEMP = mode2_diff_out
                SELECT mode2_out INTERACT mode2_diff_out { } TEMP = mode2_out 
             }
             COPY mode2_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 2, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (13 )
	  } else if (fatWireExtensionMode == 3) {
             SIZE fat {
	        GROW_LEFT = fatTblExtensionRange
	        GROW_RIGHT = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal2  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	       	PARALLEL = TRUE

	       	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		HORIZONTAL_ONLY = TRUE
             } TEMP = spacing_hor
	     SELECT spacing_hor INSIDE fat_ran {  } TEMP = spacing_hor
	     SELECT spacing_hor OUTSIDE fat {  } TEMP = spacing_hor
             SIZE fat {
	        GROW_TOP = fatTblExtensionRange
	        GROW_BOTTOM = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal2  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	        POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		VERTICAL_ONLY = TRUE
             } TEMP = spacing_ver
	     SELECT spacing_ver INSIDE fat_ran {  } TEMP = spacing_ver
	     SELECT spacing_ver OUTSIDE fat {  } TEMP = spacing_ver
  	     BOOLEAN spacing_hor OR spacing_ver {  } TEMP = spacing
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal2  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
  	     /* check overlapped projection length */
 	     if (fatTblParallelLength > 0) {
                POLYGON_FEATURES fat_ext {
                   EQUATIONS {
                      vnum = EV_VNUM_IN;
                      if ( vnum > 0) {
                         bdLeft = EV_VXCOORD_IN[0];
                         bdRight = EV_VXCOORD_IN[0];
                         bdBottom = EV_VYCOORD_IN[0];
                         bdTop = EV_VYCOORD_IN[0];
                         FOR (i = 1; i < vnum; i++) {
                            if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
                            else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
                            if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
                            else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
                         } /* FOR i */
                         if ( (bdRight - bdLeft) >= fatTblParallelLength ||
                  	      (bdTop - bdBottom) >= fatTblParallelLength) {
                            FOR (i = 0; i < vnum; i++) {
                               EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
                               EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
                            }
                            EV_VNUM_OUT = vnum;
                 	    EV_SAVE_POLYGON();
                         }
                      }
                   }
                } TEMP = fat_ext /* POLYGON_FEATURE */
             }
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode3_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode3_out NOT mode3_child_out { } TEMP = mode3_diff_out
                SELECT mode3_out INTERACT mode3_diff_out { } TEMP = mode3_out
             }
             COPY mode3_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 3, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (13 )
          }
       }
       SET fatTblSpacing = 0;
    }
}
@ 347 "adrc/adrc.ev" 2


SET fatTblThreshold = 3.005;
SET fatTblParallelLength = 3;
SET minWidth = 0.056;

SET fatTblThreshold_Start = 0;
SET fatTblSpacing = 0.7;
@ 1 "adrc/adrc_fatMetal.ev" 1
/*check fat metal table*/
if (fatTblThreshold > 0) {
    if ((fatTblThreshold / 2.0) > 0.0001 ) {
       SIZE fat_candidate  { UNDER_OVER = fatTblThreshold / 2.0 - 0.0001  } TEMP = fat_candidate
       if (fatTblNextThreshold > 0) {
          SIZE fat_candidate { UNDER_OVER = fatTblNextThreshold / 2.0 - 0.0001  } TEMP = fat_next
          BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
          BOOLEAN fat AND fat_target { } TEMP = fat
          SET fatTblNextThreshold = 0;
       } else {
          BOOLEAN fat_candidate AND fat_target {  } TEMP = fat 
       }
    } else {
      COPY fat_target {  } TEMP = fat 
    }
    COPY fat_target { } TEMP = spc_target
    if (fatTblThreshold_Start > 0  || fatTblThreshold_End > 0) {
       if (fatTblThreshold_Start > 0) {
          SIZE fat_target { UNDER_OVER = fatTblThreshold_Start / 2.0 - 0.0001  } TEMP = spc_target
       }
       if (fatTblThreshold_End > 0 && fatTblThreshold_End > fatTblThreshold_Start) {
          SIZE spc_target { UNDER_OVER = fatTblThreshold_End / 2.0 - 0.0001  } TEMP = fat_end
          BOOLEAN spc_target NOT fat_end { } TEMP = spc_target
       }
       BOOLEAN spc_target AND fat_target {  } TEMP = spc_target
       if (ignoreBlockage == 0 && fatTblThreshold_Start < fatTblThreshold_1) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal2_blockage  {  } TEMP = spc_target
       }
       SET fatTblThreshold_Start = 0;
       SET fatTblThreshold_End = 0;
       SET fatTblThreshold_1 = 0;
    } else {
       if (ignoreBlockage == 0) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal2_blockage  {  } TEMP = spc_target
       }
    }
 
    if (fatTblEnclosedArea > 0) {
       SELECT holes INTERACT fat { } TEMP = fat_holes
       AREA fat_holes { 
          RANGE = [0.0001 * 0.0001 , fatTblEnclosedArea - 0.0001 * 0.0001 ]
       } TEMP = fat_holes
       if (fatTblMinEnclosedAreaMode==0) {
          SIZE fat_holes { OVER_UNDER = fatTblThreshold / 2.0 + 0.0001  } TEMP = ovun_holes
          SELECT ovun_holes INTERACT fat_holes { RANGE = [2, 9999999999 ] } TEMP = merged_holes
          BOOLEAN fat_candidate AND fat_target { } TEMP = fat_metal
          BOOLEAN metal2  NOT fat_metal { } TEMP = thin_metal
          BOOLEAN thin_metal NOT ovun_holes { } TEMP = thin_metal
          SELECT ovun_holes INTERACT thin_metal { } TEMP = thin_holes
          BOOLEAN thin_holes OR merged_holes { } TEMP = thin_holes
          BOOLEAN fat_holes NOT thin_holes { } TEMP = fat_holes
       }
       COPY fat_holes { 
	  COMMENT = "$layer_name EnclsArea : fat metal ( fatTblThreshold um) minimum enclosed area (mode fatTblMinEnclosedAreaMode ) = fatTblEnclosedArea um*um"
       } (13 )
       SET fatTblEnclosedArea = 0;
    }
    if (fatTblSpacing > 0) {
       /*check fat metal*/ 
       if (fatTblParallelLength > 0) {
          if (router_parallelLengthNetMode == 1 || parallelLengthMode == 1) {
             AREA spc_target { RANGE = [fatTblParallelLength * minWidth + 0.0001 , 9999999999 ] } TEMP = spc_target1
             COPY spc_target1 { } TEMP = spc_target2
          } else {
             COPY spc_target { } TEMP = spc_target2
          }
          if (parallelLengthMode == 1) {
             SELECT metal2  INTERACT fat { } TEMP = fat_all 
             BOOLEAN fat_all OR fat { } TEMP = fat2
             SELECT metal2  INTERACT spc_target2 { } TEMP = spc_target_all
             BOOLEAN spc_target_all OR spc_target2 { } TEMP = spc_target2
          } else {
             COPY fat { } TEMP = fat2
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING <= fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
                OUTPUT_EDGES = TRUE
             } TEMP = vio_edge
             SELECT vio_edge INTERACT fat { } TEMP = vio_edge
             SELECT vio_edge INTERACT spc_target1 { } TEMP = vio_edge
             SELECT violation INTERACT vio_edge { } TEMP = violation
          } else {
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
          }
          BOOLEAN violation NOT fat_target { } TEMP = violation
          if (fatTblParallelLength < fatTblSpacing) {
             SELECT_EDGE violation TOUCHING fat2 {
                VSIZE_INSIDE = fatTblParallelLength - 0.0002 
             } TEMP = vio_filter
             SELECT_CONTAINS vio_filter { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = vio_filter
             SELECT violation INTERACT vio_filter { } TEMP = violation
          } else {
             SELECT_CONTAINS violation { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = violation
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING = [fatTblSpacing, fatTblSpacing]
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
             } TEMP = violation3
             BOOLEAN violation3 NOT fat_target { } TEMP = violation3
             BOOLEAN violation NOT violation3 { } TEMP= violation
          }
          SELECT_EDGE fat2 TOUCHING violation { } TEMP=fat_viol
          BOOLEAN fat_viol AND violation { } TEMP=fat_viol
          SELECT_EDGE spc_target2 TOUCHING violation { } TEMP=spc_target2
          BOOLEAN spc_target2 AND violation { } TEMP= spc_target2
	  if (ignoreChildCell == 1) {
             EXTERNAL fat_viol spc_target2 {
		SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		TOUCH = FALSE
		POINT_TOUCH = FALSE
		NON_PARALLEL = TRUE
	     } TEMP = spc_mode0_out
             BOOLEAN spc_mode0_out NOT spc_mode0_child_out { } TEMP = spc_mode0_diff_out
             SELECT spc_mode0_out INTERACT spc_mode0_diff_out { } TEMP = spc_mode0_out
	     SELECT_EDGE fat2 TOUCHING spc_mode0_out { } TEMP=fat_viol
	     BOOLEAN fat_viol AND spc_mode0_out { } TEMP=fat_viol
	     SELECT_EDGE spc_target2 TOUCHING spc_mode0_out { } TEMP=spc_target2
	     BOOLEAN spc_target2 AND spc_mode0_out { } TEMP=spc_target2
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (13 )  		
	  } else {
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing 
	        SET_CORNERS_TO_SPACING = FALSE
	        PARALLEL_POINT_PROJECTION = FALSE
	        TOUCH = FALSE
	        POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (13 )
	  }
	  if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	     if (ignoreChildCell == 1) {
		EXTERNAL fat spc_target {
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} TEMP = spc_mode1_out
	        BOOLEAN spc_mode1_out NOT spc_mode1_child_out { } TEMP = spc_mode1_diff_out
	        SELECT spc_mode1_out INTERACT spc_mode1_diff_out { } TEMP = spc_mode1_out
                SELECT_EDGE fat TOUCHING spc_mode1_out { } TEMP=fat_viol
	        BOOLEAN fat_viol AND spc_mode1_out { } TEMP=fat_viol
	        SELECT_EDGE spc_target TOUCHING spc_mode1_out { } TEMP=spc_target2
	        BOOLEAN spc_target2 AND spc_mode1_out { } TEMP=spc_target2
	        EXTERNAL fat_viol spc_target2 {
	           COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um " 	    
		   SPACING < fatTblSpacing_dg
                   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} (13 )
	     } else {
	        EXTERNAL fat spc_target {
		   COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um "
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
	    	   PARALLEL_POINT_PROJECTION = FALSE
	           TOUCH = FALSE
	     	   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } (13 ) 
	     }
          }
       } else {
	  if (ignoreChildCell == 1) {
              EXTERNAL fat spc_target {
                 SPACING < fatTblSpacing
                 BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
              } TEMP = spc_out
	      BOOLEAN spc_out NOT spc_child_out { } TEMP = spc_diff_out
	      SELECT spc_out INTERACT spc_diff_out { } TEMP = spc_out
	      SELECT_EDGE fat TOUCHING spc_out { } TEMP=fat_viol
	      BOOLEAN fat_viol AND spc_out { } TEMP=fat_viol
              SELECT_EDGE spc_target TOUCHING spc_out { } TEMP=spc_target2
	      BOOLEAN spc_target2 AND spc_out { } TEMP=spc_target2
	      EXTERNAL fat_viol spc_target2 {
		 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
		 BOX_CORNER = FALSE 
		 NON_PARALLEL = TRUE
		 POINT_TOUCH = FALSE
	      } (13 ) 
	  } else {
	      EXTERNAL fat spc_target {
                 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
	         BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
	      } (13 ) 
	  }
       }
       /*check metal in the extension range*/ 
       if (fatTblExtensionRange > 0) {
	  if (fatWireExtensionMode == 0) {
	     SIZE fat { OVERSIZE = fatTblExtensionRange } TEMP = fat_tmp
             BOOLEAN fat_tmp AND metal2  { } TEMP = fat_tmp
  	     BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
             SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_ext
             BOOLEAN fat_ext OR fat { } TEMP = fat_ext
	     if (fatTblParallelLength > 0) {
                if (fatTblParallelLength > fatTblExtensionRange) {
                   SIZE fat { OVERSIZE = fatTblParallelLength } TEMP = fat_tmp
                   BOOLEAN fat_tmp AND metal2  { } TEMP = fat_tmp
  	           BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
                   SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_parallel
                   BOOLEAN fat_parallel OR fat { } TEMP = fat_parallel
                } else {
                   COPY fat_ext { } TEMP = fat_parallel
                }
		EXTERNAL fat_parallel spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
	           NON_PARALLEL = TRUE
	        } TEMP = vio_filter_set
		EXTERNAL fat_ext spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } TEMP = vio_set
                if (fatTblParallelLength < fatTblSpacing) {
                   SELECT_EDGE vio_filter_set TOUCHING fat_parallel {
                      VSIZE_INSIDE = fatTblParallelLength - 0.0002 
                   } TEMP = vio_filter_set_filter
                   SELECT_CONTAINS vio_filter_set_filter { 
                      WIDTH =  0.0002 
                      HEIGHT = fatTblParallelLength + 0.0001 
                   } TEMP = vio_filter_set_filter
                   SELECT vio_filter_set INTERACT vio_filter_set_filter { } TEMP = vio_filter
                } else {
	           SELECT_CONTAINS vio_filter_set { 
	              WIDTH =  0.0002 
	              HEIGHT = fatTblParallelLength + 0.0001 
	           } TEMP = vio_filter
                }
                SELECT vio_set INSIDE vio_filter { } TEMP = mode0_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out1 NOT mode0_child_out1 { } TEMP = mode0_diff_out1
                   SELECT mode0_out1 INTERACT mode0_diff_out1 { } TEMP = mode0_out1
                }
                COPY mode0_out1 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing  = fatTblSpacing um"
                } (13 )
		if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	           EXTERNAL fat_ext spc_target {
		      SPACING < fatTblSpacing_dg
	              SET_CORNERS_TO_SPACING = FALSE
		      PARALLEL_POINT_PROJECTION = FALSE
		      TOUCH = TRUE
		      POINT_TOUCH = FALSE
		      NON_PARALLEL = TRUE
	           } TEMP = mode0_out2
                   if (ignoreChildCell == 1) {
                      BOOLEAN mode0_out2 NOT mode0_child_out2 { } TEMP = mode0_diff_out2
                      SELECT mode0_out2 INTERACT mode0_diff_out2 { } TEMP = mode0_out2
                   }
                   COPY mode0_out2 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing (mode 1/2) = fatTblSpacing um/ fatTblSpacing_dg um "
                   } (13 )
	        } 
	     } else {
	        EXTERNAL fat_ext spc_target {
		   SPACING < fatTblSpacing
		   NON_PARALLEL = TRUE
		   SET_CORNERS_TO_SPACING = FALSE
		   POINT_TOUCH = FALSE
		} TEMP = mode0_out3
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out3 NOT mode0_child_out3 { } TEMP = mode0_diff_out3
                   SELECT mode0_out3 INTERACT mode0_diff_out3 { } TEMP = mode0_out3
                }
                COPY mode0_out3 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range ( fatTblExtensionRange um) minimum spacing = fatTblSpacing um"
                } (13 )
	     }
	  } else if (fatWireExtensionMode == 1) {
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal2  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             if (fatTblParallelLength > 0) {
                EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
		   BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   CHECK_SAME_POLYGON = TRUE 
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
	        SELECT fat_ext INTERACT spacing {  } TEMP = fat_ext
		BOOLEAN fat_ext OR spacing {  } TEMP = combined_fat_ext
                EXTERNAL combined_fat_ext fat {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
                } TEMP = fat_spacing
		BOOLEAN fat_spacing AND fat_ran {  } TEMP = fat_spacing
		BOOLEAN combined_fat_ext OR fat_spacing {  } TEMP = combined_fat_ext
                SELECT_CONTAINS combined_fat_ext { 
                   WIDTH =  0.0002 
                   HEIGHT = fatTblParallelLength + 0.0001 
                } TEMP = combined_fat_ext
		SELECT spacing INTERACT combined_fat_ext { 
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out1 NOT mode1_child_out1 { } TEMP = mode1_diff_out1
                   SELECT mode1_out1 INTERACT mode1_diff_out1 { } TEMP = mode1_out1 
                }
                COPY mode1_out1 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (13 ) 
	     } else {
               	EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
	           BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
	           CHECK_SAME_POLYGON = TRUE 
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
                SELECT spacing INTERACT fat_ext {
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out2
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out2 NOT mode1_child_out2 { } TEMP = mode1_diff_out2
                   SELECT mode1_out2 INTERACT mode1_diff_out2 { } TEMP = mode1_out2
                }
                COPY mode1_out2 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (13 )
	     }
	  } else if (fatWireExtensionMode == 2) {
	     SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
             BOOLEAN fat_ran AND metal2  {  } TEMP = fat_ext
             BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	      	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
             } TEMP = spacing
 	     SELECT spacing INSIDE fat_ran {  } TEMP = spacing
	     SELECT spacing OUTSIDE fat {  } TEMP = spacing
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode2_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode2_out NOT mode2_child_out { } TEMP = mode2_diff_out
                SELECT mode2_out INTERACT mode2_diff_out { } TEMP = mode2_out 
             }
             COPY mode2_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 2, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (13 )
	  } else if (fatWireExtensionMode == 3) {
             SIZE fat {
	        GROW_LEFT = fatTblExtensionRange
	        GROW_RIGHT = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal2  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	       	PARALLEL = TRUE

	       	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		HORIZONTAL_ONLY = TRUE
             } TEMP = spacing_hor
	     SELECT spacing_hor INSIDE fat_ran {  } TEMP = spacing_hor
	     SELECT spacing_hor OUTSIDE fat {  } TEMP = spacing_hor
             SIZE fat {
	        GROW_TOP = fatTblExtensionRange
	        GROW_BOTTOM = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal2  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	        POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		VERTICAL_ONLY = TRUE
             } TEMP = spacing_ver
	     SELECT spacing_ver INSIDE fat_ran {  } TEMP = spacing_ver
	     SELECT spacing_ver OUTSIDE fat {  } TEMP = spacing_ver
  	     BOOLEAN spacing_hor OR spacing_ver {  } TEMP = spacing
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal2  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
  	     /* check overlapped projection length */
 	     if (fatTblParallelLength > 0) {
                POLYGON_FEATURES fat_ext {
                   EQUATIONS {
                      vnum = EV_VNUM_IN;
                      if ( vnum > 0) {
                         bdLeft = EV_VXCOORD_IN[0];
                         bdRight = EV_VXCOORD_IN[0];
                         bdBottom = EV_VYCOORD_IN[0];
                         bdTop = EV_VYCOORD_IN[0];
                         FOR (i = 1; i < vnum; i++) {
                            if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
                            else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
                            if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
                            else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
                         } /* FOR i */
                         if ( (bdRight - bdLeft) >= fatTblParallelLength ||
                  	      (bdTop - bdBottom) >= fatTblParallelLength) {
                            FOR (i = 0; i < vnum; i++) {
                               EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
                               EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
                            }
                            EV_VNUM_OUT = vnum;
                 	    EV_SAVE_POLYGON();
                         }
                      }
                   }
                } TEMP = fat_ext /* POLYGON_FEATURE */
             }
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode3_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode3_out NOT mode3_child_out { } TEMP = mode3_diff_out
                SELECT mode3_out INTERACT mode3_diff_out { } TEMP = mode3_out
             }
             COPY mode3_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 3, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (13 )
          }
       }
       SET fatTblSpacing = 0;
    }
}
@ 355 "adrc/adrc.ev" 2


SET fatTblThreshold = 0;
SET fatTblEnclosedArea = 0;
SET fatTblExtensionRange = 0;
SET fatTblParallelLength = 0;
SET minWidth = 0;

/* End of Met2 fat table spacing rules */










/*metal 3*/
SET layer_name = "Met3";










SET minWidth = 0.056;
SET maxWidth = 5;
SET minArea = 0.016;
SET minEnclosedArea = 0.2;
SET minSpacing = 0.056;
SET sameNetMinSpacing = 0.056;
SET stub2StubSpacing = 0;

SET fatTblDimension = 5;
@ 1 "adrc/adrc_check_metal.ev" 1
/* Data Preparation */
if (fatTblDimension > 1 || fatWireThreshold > 0 || maxWidth > 0) {
  if (ignoreBlockage) {
      /* Let the real blockage be treated as thin */
      BOOLEAN metal3  NOT metal3_rbkg  {} TEMP=fat_candidate
  } else {
      COPY metal3  {} TEMP=fat_candidate
  }
  COPY fat_candidate {} TEMP=fat_target
}
/*Check width*/
if (minWidth > 0) {
    INTERNAL metal3  { 
        COMMENT = "$layer_name MinWidth  : minimum width = minWidth um" 
        SPACING < minWidth
        POINT_TOUCH = FALSE
    } (15 )
}
 
if (maxWidth > 0) {
    SIZE  fat_candidate {
        COMMENT = "$layer_name MaxWidth  : maximum width = maxWidth um"
 	UNDER_OVER = maxWidth / 2 
    } (15 ) 
}
 
/*Check area*/
if (minArea > 0) {
    AREA metal3  { 
	COMMENT = "$layer_name MinArea   : minimum area = minArea um*um"
	RANGE = [0.0001 * 0.0001 , minArea - 0.0001 * 0.0001 ]
    } (15 )
}
/* check min length of bounding box on polygon */
if (minLength > 0) {
  if (minLengthMode == 1) {
    INTERNAL metal3  {
        SPACING < minLength
        VERTICAL_ONLY = TRUE
        SET_CORNERS_TO_SPACING = FALSE
    } TEMP = ver_short
    BOOLEAN metal3  NOT ver_short { } TEMP = ver_long
    INTERNAL metal3  {
        SPACING < minLength
        HORIZONTAL_ONLY = TRUE
        SET_CORNERS_TO_SPACING = FALSE
    } TEMP = hor_short
    BOOLEAN metal3  NOT hor_short { } TEMP = hor_long
    SELECT CUT_LAYER1 INSIDE ver_long { } TEMP = good_cut
    BOOLEAN CUT_LAYER1 NOT good_cut { } TEMP = fail_cut_1
    SELECT fail_cut_1 INSIDE hor_long { } TEMP = good_cut
    BOOLEAN fail_cut_1 NOT good_cut { } TEMP = fail_cut_1
    SELECT CUT_LAYER2 INSIDE ver_long { } TEMP = good_cut
    BOOLEAN CUT_LAYER2 NOT good_cut { } TEMP = fail_cut_2
    SELECT fail_cut_2 INSIDE hor_long { } TEMP = good_cut
    BOOLEAN fail_cut_2 NOT good_cut { } TEMP = fail_cut_2
    BOOLEAN fail_cut_1 OR fail_cut_2 { } TEMP = fail_cut
    BOOLEAN hor_short NOT ver_long { } TEMP = hor_short
    BOOLEAN ver_short NOT hor_long { } TEMP = ver_short
    SELECT ver_short INTERACT fail_cut { } TEMP = ver_fail
    SELECT hor_short INTERACT fail_cut { } TEMP = hor_fail
    BOOLEAN ver_fail OR hor_fail { } TEMP = all_fail
    INTERNAL all_fail {
        COMMENT = "$layer_name MinLength : minimum length = minLength um"
        SPACING < minLength
        VERTICAL_ONLY = TRUE
        SET_CORNERS_TO_SPACING = FALSE
    } (15 )
  } else {
    POLYGON_FEATURES metal3  {
      COMMENT = "$layer_name MinLength : minimum length = minLength um"
      EQUATIONS {
        vnum = EV_VNUM_IN;
        if ( vnum > 0) {
	  bdLeft = EV_VXCOORD_IN[0];
	  bdRight = EV_VXCOORD_IN[0];
	  bdBottom = EV_VYCOORD_IN[0];
	  bdTop = EV_VYCOORD_IN[0];
          FOR (i = 1; i < vnum; i++) {
	    if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
            else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
	    if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
            else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
          }
	  if ( (bdRight - bdLeft) < minLength &&
	       (bdTop - bdBottom) < minLength) {
	    FOR (i = 0; i < vnum; i++) {
              EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
	      EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
            }
	    EV_VNUM_OUT = vnum;
	    EV_SAVE_POLYGON();
          }
        }
      }
    } (15 ) 
  }
  SET minLength = 0;
}
/* check max length of bounding box on polygon */
if (maxLength > 0) {
  POLYGON_FEATURES metal3  {
    COMMENT = "$layer_name MaxLength : maximum length = maxLength um"
    EQUATIONS {
      vnum = EV_VNUM_IN;
      if ( vnum > 0) {
	bdLeft = EV_VXCOORD_IN[0];
	bdRight = EV_VXCOORD_IN[0];
	bdBottom = EV_VYCOORD_IN[0];
	bdTop = EV_VYCOORD_IN[0];
        FOR (i = 1; i < vnum; i++) {
	  if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
          else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
	  if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
          else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
        }
	if ( (bdRight - bdLeft + bdTop - bdBottom) > maxLength ) {
          EV_VXCOORD_OUT[0] = bdLeft;
	  EV_VYCOORD_OUT[0] = bdBottom;
          EV_VXCOORD_OUT[1] = bdLeft;
	  EV_VYCOORD_OUT[1] = bdTop;
          EV_VXCOORD_OUT[2] = bdRight;
	  EV_VYCOORD_OUT[2] = bdTop;
          EV_VXCOORD_OUT[3] = bdRight;
	  EV_VYCOORD_OUT[3] = bdBottom;
          EV_VXCOORD_OUT[4] = bdLeft;
	  EV_VYCOORD_OUT[4] = bdBottom;
	  EV_VNUM_OUT = 5;
	  EV_SAVE_POLYGON();
        }
      }
    }
  } (15 ) 
  SET maxLength = 0;
}
 
/*Check enclosed area*/
if (minEnclosedArea > 0) {
    SELECT metal3  INSIDE_HOLE {
        INNER_HOLE_ONLY
    } TEMP = holes
    BOOLEAN holes NOT metal3  { } TEMP = holes
 
    AREA holes {
        COMMENT = "$layer_name EnclsArea : minimum enclosed area = minEnclosedArea um*um"
        RANGE = [0.0001 * 0.0001 , minEnclosedArea - 0.0001 * 0.0001 ]
    } (15 )
    /* check min length of bounding box on polygon */
    if (minEnclosedWidth > 0) {
      POLYGON_FEATURES holes {
        COMMENT = "$layer_name EnclsWidth: minimum enclosed Width = minEnclosedWidth um"
        EQUATIONS {
          vnum = EV_VNUM_IN;
          if ( vnum > 0) {
            bdLeft = EV_VXCOORD_IN[0];
            bdRight = EV_VXCOORD_IN[0];
            bdBottom = EV_VYCOORD_IN[0];
            bdTop = EV_VYCOORD_IN[0];
            FOR (i = 1; i < vnum; i++) {
              if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
              else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
              if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
              else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
            }
            if ( (bdRight - bdLeft) < minEnclosedWidth &&
                 (bdTop - bdBottom) < minEnclosedWidth) {
              FOR (i = 0; i < vnum; i++) {
                EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
                EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
              }
              EV_VNUM_OUT = vnum;
              EV_SAVE_POLYGON();
            }
          }
        }
      } (15 ) 
    }
}
 
/*check special notch rule*/
if ((minEdgeLength2 > 0.0001  && minEdgeLength3 > 0.0001 ) || minEdgeMode==2) {
  if (minEdgeMode==2) {
    SET minEdgeLength3 = minEdgeLength ;
  }
  NOTCH metal3  {
     SPACING < minEdgeLength3
     SET_CORNERS_TO_SPACING=FALSE
     PARALLEL = TRUE
     OUTPUT_EDGES = TRUE
  } TEMP = notch_vectors
  SELECT_VECTOR notch_vectors {
     LENGTH_RANGE = [0.0001 , minEdgeLength2 - 0.0001 ]
  } TEMP = short_edges
  EXTERNAL short_edges metal3  {
     SPACING < minEdgeLength3
     SET_CORNERS_TO_SPACING=FALSE
     PARALLEL = TRUE
  } TEMP = notch_err
  /* Choose the real U-shaped notch */
  SIZE notch_err { OVERSIZE = 0.0002 *10 } TEMP = neighbors 
  BOOLEAN neighbors AND metal3  { } TEMP = neighbors
  VERTEX neighbors { 
     CONCAVE = TRUE
     CONVEX = TRUE
     SIZE = 0.0002 
  } TEMP = corners
  SELECT_EDGE neighbors INTERACT notch_err { } TEMP = target_edges
  BOOLEAN target_edges NOT corners { } TEMP = target_edges
  VERTEX neighbors { 
     CONCAVE = TRUE
     SIZE = 2* 0.0002 
  } TEMP = corners
  SELECT target_edges INTERACT corners { RANGE = [2, 2] } TEMP=target_edges
  SELECT notch_err INTERACT target_edges {
     COMMENT = "$layer_name SpeclNotch: sameNetSp = minEdgeLength3 um (sideLen minEdgeLength2 um)" 
  } (15 )
}
/*check consecutive short edges*/
if (minEdgeLength > 0.0001  && minEdgeMode != 2) { 
  INTERNAL metal3_top  {
     SEGMENT < minEdgeLength
     FLAG_ACUTE_ANGLE = FALSE
     FLAG_ACUTE_EDGE = FALSE
     OUTPUT_EDGES = TRUE
  } TEMP = short_edges
  if ((minEdgeMode == 0 && maxTotalMinEdgeLength>0) || maxNumMinEdge > 0) {
    SET temporary_1 = 0.0002 *2;
    SET temporary_2 = 2*temporary_1+ 0.0001 ;
    SELECT metal3_top  INTERACT short_edges { } TEMP = target_top
    CLASSIFY_EDGES target_top {
       LENGTH = temporary_1
       DMIN   = temporary_2
       INSIDE_CORNER  TEMP = inside_corner_edges
       OUTSIDE_CORNER TEMP = outside_corner_edges
       REMAINDER      TEMP = remainder_edges
    }
    if (minEdgeMode == 0 && (maxNumMinEdge>0 || maxTotalMinEdgeLength > 0)) {
       SELECT short_edges ENCLOSING inside_corner_edges { } TEMP = short_edges
    }
  }
  if (maxTotalMinEdgeLength > 0) {
    LENGTH short_edges {
       RANGE = [maxTotalMinEdgeLength + 0.0001 , 9999999999 ]
    } TEMP = max_length_err
    /* Work around: translate polygons into dimensional check output */
    SIZE max_length_err { OVERSIZE = 2* 0.0002  } TEMP = max_length_err
    INTERNAL max_length_err {
       SPACING < 3* 0.0002 
       SET_CORNERS_TO_SPACING=FALSE
       COMMENT = "$layer_name MinEdgeLen: maximum total length ( minEdgeLength um)= maxTotalMinEdgeLength um"
    } (15 )
  }
  if (maxTotalMinEdgeLength == 0 || maxNumMinEdge > 0) {
    if (maxNumMinEdge==0)  {
       COPY short_edges {} TEMP=max_edge_err
    } else {
       SIZE short_edges {
         VSIZE_HEAD = - 0.0002 
        VSIZE_TAIL = - 0.0002 
       } TEMP = short_edges
       SIZE short_edges {
          OVERSIZE = 5* 0.0002 
          SIZE_ENDPOINTS = FALSE
       } TEMP = short_contours
       SELECT short_contours ENCLOSING remainder_edges {
          RANGE = [maxNumMinEdge + 1, 9999999999 ]
       } TEMP = short_contours
       SELECT short_edges INSIDE short_contours { } TEMP=max_edge_err
    }
    /* Work around: translate polygons into dimensional check output */
    SIZE max_edge_err { OVERSIZE = 2* 0.0002  } TEMP = max_edge_error
    INTERNAL max_edge_error {
       SPACING < 3* 0.0002 
       SET_CORNERS_TO_SPACING=FALSE
       COMMENT = "$layer_name MinEdgeLen: maximum number of consecutive short edges ( minEdgeLength um)= maxNumMinEdge"
    } (15 ) 
  }
}
 
/*check basic spacing*/
if (sameNetMinSpacing > 0 && sameNetMinSpacing != minSpacing) {
  if (sameNetMinSpacing > minSpacing) {
    /* Special condition for U-shaped Metal spacing rule */
    NOTCH metal3_pin  {
        SPACING < sameNetMinSpacing
        BOX_CORNER = FALSE 
        SET_CORNERS_TO_SPACING=FALSE
        NON_PARALLEL = TRUE
        OUTPUT_EDGES = TRUE
    } TEMP = errs_to_be_waived
    NOTCH metal3_top  {
	SPACING < sameNetMinSpacing
	BOX_CORNER = FALSE 
        SET_CORNERS_TO_SPACING=FALSE
	NON_PARALLEL = TRUE
        OUTPUT_EDGES = TRUE
    } TEMP = all_errs
    BOOLEAN all_errs NOT errs_to_be_waived { } TEMP=err_edge
    EXTERNAL err_edge metal3_top  {
	SPACING < sameNetMinSpacing
	BOX_CORNER = FALSE 
        SET_CORNERS_TO_SPACING=FALSE
	NON_PARALLEL = TRUE
    } TEMP = notch_err
    SIZE notch_err { OVERSIZE = 0.0002 *10 } TEMP = neighbors
    BOOLEAN neighbors AND metal3_top  { } TEMP = neighbors
    VERTEX neighbors { 
       CONCAVE = TRUE
       CONVEX = TRUE
       SIZE = 0.0002 
    } TEMP = corners
    SELECT_EDGE neighbors INTERACT notch_err { } TEMP = target_edges
    BOOLEAN target_edges AND notch_err { } TEMP = target_edges
    BOOLEAN target_edges NOT corners { } TEMP = target_edges
    VERTEX neighbors {
       CONCAVE = TRUE
       SIZE = 2* 0.0002 
    } TEMP = corners
    SELECT target_edges INTERACT corners { RANGE = [2, 2] } TEMP = target_edges
    SELECT notch_err TOUCHING target_edges {
      COMMENT = "$layer_name U-ShpNotch: U-shape notch minimum spacing = sameNetMinSpacing um" 
    } (15 )
  } else {
    NOTCH metal3  {
        COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = sameNetMinSpacing um" 
	SPACING < sameNetMinSpacing
	BOX_CORNER = FALSE 
	NON_PARALLEL = TRUE
    } (15 )
  }
  if (minSpacing > 0) {
    if (stubMode == 0 && stubSpacing > 0 && stubSpacing < minSpacing) {
	EXTERNAL metal3  {
	    COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um"
            LONGEDGE > stubThreshold + 0.0001 
	    LONGEDGE_TO_EDGE < minSpacing
	    SPACING <= 0
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            CHECK_SAME_POLYGON = TRUE 
	} (15 )
    } else {
        EXTERNAL metal3  {
	    COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um" 
	    SPACING < minSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
	    CHECK_SAME_POLYGON = FALSE
        } (15 )
    }
  }
} else {
  if (minSpacing > 0) {
    if (stubMode == 0 && stubSpacing > 0 && stubSpacing < minSpacing) {
        EXTERNAL metal3  {
            COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um"
            LONGEDGE > stubThreshold + 0.0001  
            LONGEDGE_TO_EDGE < minSpacing
            SPACING <= 0 
            BOX_CORNER = FALSE 
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            CHECK_SAME_POLYGON = TRUE 
        } (15 )
    } else {
        EXTERNAL metal3  {
	    COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um" 
            SPACING < minSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
	    CHECK_SAME_POLYGON = TRUE 
        } (15 )
    }
  }
}
 
/*check dogbone */
if (sameNetMinSpacing > 0 && sameNetWidthThreshold) {
  NOTCH metal3  {
    SPACING < sameNetMinSpacing
    BOX_CORNER = FALSE 
    NON_PARALLEL = TRUE
  } TEMP = dog_bone
 
  if (!layer_empty(dog_bone)) {
    SIZE dog_bone {EDGESIZE = sameNetWidthThreshold} TEMP = dog_ext
    BOOLEAN dog_ext NOT dog_bone {} TEMP = dog_ext
    BOOLEAN dog_ext AND metal3  {} TEMP = dog_ext
    if (!layer_empty(dog_ext)) {
      SELECT dog_ext EDGE_TOUCH dog_bone { OUTSIDE RANGE = [1, 9999999999 ] } TEMP = dog_ext
      NOTCH metal3  {
        SPACING < sameNetMinSpacing
        BOX_CORNER = FALSE 
        NON_PARALLEL = TRUE
	OUTPUT_EDGES = TRUE
      } TEMP = dog_bone
      SELECT dog_ext OUTSIDE dog_bone {} TEMP = dog_ext
      INTERNAL dog_ext {
	COMMENT = "$layer_name dogBone   : notch spacing = sameNetMinSpacing um width sameNetWidthThreshold um" 
	SPACING < sameNetWidthThreshold
      } (15 )
    }
  }
}
/*check basic fat spacing*/
if (fatWireThreshold > 0 && fatTblDimension == 0) {
    SIZE fat_candidate { UNDER_OVER = fatWireThreshold / 2.0 - 0.0001  } TEMP = m_fat
    BOOLEAN m_fat AND metal3  {  } TEMP = m_fat
    BOOLEAN metal3  NOT m_fat {  } TEMP = m_thin
    if (ignoreBlockage == 0) {
        /* the blockages on the metal_blockage layer are treated as thin blockages */
        BOOLEAN m_thin OR metal3_blockage  {  } TEMP = m_thin
    }
 
    if (fatFatMinSpacing > 0) {
	EXTERNAL m_fat {
	    COMMENT = "$layer_name FatWireSpc: fat & fat ( fatWireThreshold um) minimum spacing = fatFatMinSpacing um"
	    SPACING < fatFatMinSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = FALSE
	    CHECK_SAME_POLYGON = TRUE 
       } (15 )
    }
 
    if (fatThinMinSpacing > 0) {
	EXTERNAL m_fat m_thin {
	    COMMENT = "$layer_name FatWireSpc: fat & thin ( fatWireThreshold um) minimum spacing fatThinMinSpacing um"
	    SPACING < fatThinMinSpacing
 	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = FALSE
        } (15 )
    }
}
 
/*check thin blockage spacing*/
if (minSpacing > 0 && ignoreBlockage == 0) {
    if (!layer_empty (metal3_blockage )) {
	EXTERNAL metal3_blockage  metal3  {
	    COMMENT = "$layer_name Spacing   : metal & thin blockage minimum spacing = minSpacing um"
	    SPACING < minSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
            TOUCH = TRUE
        } (15 )
    }
}
/*check blockage overlap*/
/*check shorts between top_level routing and fram_blockages*/
if (minSpacing>0 || checkCrossHierShort>0) {
   if (ignoreBlockage == 0) {
      BOOLEAN metal3_blockage  or metal3_rbkg  {} TEMP=all_blockage
   } else {
      COPY metal3_rbkg  {} TEMP=all_blockage
   }
   BOOLEAN all_blockage AND metal3_top  {} TEMP = overlap_shape1
   EXTERNAL all_blockage metal3_top  {
      SPACING <= 0
      TOUCH = TRUE
   } TEMP = overlap_shape2
   if (checkCrossHierShort>0) {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
         COMMENT = "$layer_name Short Cross Hierarchy"
      } (15 )
   } else {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
         COMMENT = "$layer_name Overlap   : metal & blockage overlap"
      } (15 )
   }
}
 
if (fatPolyContactRule > 0) {
  /* Fat Poly Contact Rule: not new fat wire formed */
  if (readCellView > 0) {
     SIZE metal1 { UNDER_OVER = fatPolyContactRule / 2.0 - 0.0001  } TEMP = fat
     BOOLEAN fat AND metal1 {  } TEMP = fat 
  } else {
     SIZE metal1_top { UNDER_OVER = fatPolyContactRule / 2.0 - 0.0001  } TEMP = fat
     BOOLEAN fat AND metal1_top {  } TEMP = fat 
  }
  SIZE metal1_pin { UNDER_OVER = fatPolyContactRule / 2.0 - 0.0001  } TEMP = fat_pin
  BOOLEAN fat_pin AND metal1_pin {  } TEMP = fat_pin
  BOOLEAN fat NOT fat_pin {
    COMMENT = "$layer_name FatPolyContactRule: fatPolyContactRule um" 
  } (15 )
}
/* Special End-of-Line Spacing Rule */
if (stubMode == 0 && stubSpacing > 0 && stubSpacing < minSpacing) {
  EXTERNAL metal3  {
     COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 0)"
     LONGEDGE > stubThreshold + 0.0001 
     LONGEDGE_TO_EDGE <= 0 
     SPACING < stubSpacing 
     SET_CORNERS_TO_SPACING = FALSE
     PARALLEL_POINT_PROJECTION = FALSE
  } (15 )
} else if (stubMode > 0 && stubSpacing > minSpacing) {
  if (stubMode == 4) {
     INTERNAL metal3  {
        SEGMENT[90,90] < stubThreshold
        OUTPUT_EDGES = TRUE
     } TEMP = end_of_line
  } else {
     INTERNAL metal3  {
        SEGMENT[90,90] <= stubThreshold
        OUTPUT_EDGES = TRUE
     } TEMP = end_of_line
  }
  /* Quick filter to reduce the size of possible end of line */
  if (sideStubExt > 0) {
    SIZE end_of_line {
       VSIZE_HEAD = sideStubExt
       VSIZE_TAIL = sideStubExt
       OUTPUT_EDGES = TRUE
    } TEMP = eol_ext
  } else {
    COPY end_of_line { } TEMP=eol_ext
  }
  if (stub2StubSpacing > stubSpacing) {
     SET temporary_1 = stub2StubSpacing;
  } else {
     SET temporary_1 = stubSpacing; 
  }
  EXTERNAL eol_ext metal3  {
     SPACING < temporary_1
     TOUCH = TRUE
     OVERLAP = TRUE 
     SET_CORNERS_TO_SPACING = FALSE
     PARALLEL_POINT_PROJECTION = FALSE
     OUTPUT_EDGES = TRUE
  } TEMP=err_edge
  SELECT eol_ext INTERACT err_edge { } TEMP=eol_ext
  SELECT end_of_line INTERACT eol_ext { } TEMP=end_of_line 
  /* Reduce the size of METAL_LAYER */
  if (stubMode==3) {
     SIZE end_of_line {
        VSIZE_HEAD = stubSpacing 
        VSIZE_TAIL = stubSpacing 
        VSIZE_INSIDE = sideStubThreshold
        VSIZE_OUTSIDE = stubSpacing
     } TEMP = eol_filter 
  } else {
     if (stubMode == 1 && stubRange > 0) {
        SIZE end_of_line {
           VSIZE_HEAD = stubSpacing- 0.0001 
           VSIZE_TAIL = stubSpacing- 0.0001 
           VSIZE_OUTSIDE = stubSpacing- 0.0001 
        } TEMP = eol_filter
     } else {
        SIZE end_of_line {
           VSIZE_HEAD = stubSpacing- 0.0001 
           VSIZE_TAIL = stubSpacing- 0.0001 
           VSIZE_INSIDE = sideStubThreshold- 0.0001 
           VSIZE_OUTSIDE = stubSpacing- 0.0001 
        } TEMP = eol_filter
     }
  }
  SELECT metal3  INTERACT eol_filter { } TEMP=target_top
  /* Get the side edges and the whole eol of line set */
  SELECT_EDGE target_top INTERACT end_of_line { 
    POINT_TOUCH = TRUE
  } TEMP = eol_set
  VERTEX target_top { 
     CONCAVE = TRUE 
     CONVEX = TRUE
     SIZE = 0.0002 
  } TEMP = corners
  SELECT corners OUTSIDE end_of_line {} TEMP =corners 
  BOOLEAN eol_set NOT corners { } TEMP=eol_set
  BOOLEAN eol_set NOT end_of_line { } TEMP=side_edge
  /* find out the real end of line */
  if (stubRange > 0) {
     if (stubMode == 1) {
         COPY side_edge { } TEMP = all_side_edge
         LENGTH side_edge { SPACING <= stubRange- 0.0001  } TEMP=side_edge
     } else {
         LENGTH side_edge { SPACING < stubRange- 0.0002  } TEMP=eol_filter
         BOOLEAN side_edge NOT eol_filter { } TEMP=side_edge
     }
     SELECT end_of_line INTERACT side_edge { RANGE = [1,2] } TEMP = end_of_line
  } 
  if (stubMode == 1) {
    if (stub2StubSpacing > 0) {
       if (sideStubExt < 0) {
          SIZE end_of_line {
            VSIZE_HEAD = sideStubExt / 2
            VSIZE_TAIL = sideStubExt / 2
            OUTPUT_EDGES = TRUE
          } TEMP = eol_ext_tip
	 
          EXTERNAL eol_ext_tip {
            COMMENT = "$layer_name specEoLSpc: stub2Stubspacing= stub2StubSpacing um (mode = 1)"
            SPACING < stub2StubSpacing
            SET_CORNERS_TO_SPACING = FALSE
            PARALLEL_POINT_PROJECTION = TRUE
          } (15 )
       } else {
          EXTERNAL end_of_line {
            COMMENT = "$layer_name specEoLSpc: stub2Stubspacing= stub2StubSpacing um (mode = 1)"
            SPACING < stub2StubSpacing
            SET_CORNERS_TO_SPACING = FALSE
            PARALLEL_POINT_PROJECTION = FALSE
          } (15 )
       }
    }
    if (stubRange > 0) {
       SIZE end_of_line {
         VSIZE_INSIDE = 0.0002 
       } TEMP = eol_poly
       SELECT_EDGE eol_poly TOUCHING target_top { } TEMP=eol_edge
       EXTERNAL eol_edge target_top {
         COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
         CONVEX_TO_CONVEX < stubSpacing
         CONVEX_TO_CONVEX [POINT_PROJECTION] < stubSpacing
         CONVEX_TO_EDGE < stubSpacing
         CONCAVE_TO_CONVEX < stubSpacing
         LONGEDGE > 0.0002 
         LONGEDGE_TO_EDGE < stubSpacing
         SPACING <= 0
         SET_CORNERS_TO_SPACING = TRUE
         PARALLEL_POINT_PROJECTION = TRUE
       } (15 )
       SELECT all_side_edge INTERACT end_of_line { } TEMP = side_edge
       SIZE side_edge {
         VSIZE_HEAD = 0.0002 
         VSIZE_TAIL = 0.0002 
       } TEMP = side_edge_ext
       BOOLEAN side_edge_ext NOT side_edge { } TEMP = side_edge_ext
       SELECT side_edge_ext INTERACT end_of_line { } TEMP = side_edge_ext
       EXTERNAL side_edge_ext target_top {
         COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
         SPACING < stubSpacing
         SET_CORNERS_TO_SPACING = FALSE
         PARALLEL_POINT_PROJECTION = FALSE
       } (15 )
    } else {
       if (stub2StubSpacing > 0) {
         VECTORIZE target_top {
            DIRECTED=TRUE
         } TEMP=target_edges
         BOOLEAN target_edges NOT end_of_line { } TEMP = target_edges
         EXTERNAL end_of_line target_edges {
            COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
            SPACING < stubSpacing
            TOUCH=TRUE
            OVERLAP=TRUE
            SET_CORNERS_TO_SPACING=FALSE
            PARALLEL_POINT_PROJECTION=FALSE
         } (15 )
       } else {
         if (sideStubExt > 0) {
            SIZE end_of_line {
               VSIZE_HEAD = sideStubExt
               VSIZE_TAIL = sideStubExt
               OUTPUT_EDGES = TRUE
            } TEMP = end_of_line
            EXTERNAL end_of_line target_top {
               COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing ,crnKeepOut= sideStubExt um (mode = 1)"
               SPACING < stubSpacing
               TOUCH=TRUE
               OVERLAP=TRUE
               SET_CORNERS_TO_SPACING=FALSE
               PARALLEL_POINT_PROJECTION=FALSE
            } (15 )
         } else {
            EXTERNAL end_of_line target_top {
               COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
               SPACING < stubSpacing
               TOUCH=TRUE
               OVERLAP=TRUE
               SET_CORNERS_TO_SPACING=FALSE
               PARALLEL_POINT_PROJECTION=FALSE
            } (15 )
         }
       }
    }
  } else { /* stubMode == 2,3,4 */
    /* stubMode 2 eol classify and reduction */
    if (stubMode !=3 && sideStubExt > 0) {
      if (stubMode == 4) {
        SIZE end_of_line {
           VSIZE_HEAD = sideStubExt
           VSIZE_TAIL = sideStubExt
           OUTPUT_EDGES = TRUE
        } TEMP = eol_ext
        EXTERNAL eol_ext target_top {
           SPACING < stubSpacing
           SET_CORNERS_TO_SPACING=FALSE
           PARALLEL_POINT_PROJECTION=FALSE
           OUTPUT_EDGES = TRUE
        } TEMP=err_edge
        SELECT eol_ext INTERACT err_edge { } TEMP=eol_ext
      } else {
        EXTERNAL end_of_line target_top {
           SPACING < stubSpacing
           SET_CORNERS_TO_SPACING=FALSE
           PARALLEL_POINT_PROJECTION=FALSE
           OUTPUT_EDGES = TRUE
        } TEMP=err_edge
        SELECT end_of_line INTERACT err_edge { } TEMP=eol_body
        SIZE end_of_line {
           VSIZE_HEAD = sideStubExt
           VSIZE_TAIL = sideStubExt
           OUTPUT_EDGES = TRUE
        } TEMP = eol_ext
        BOOLEAN eol_ext NOT end_of_line {} TEMP=eol_ext
        EXTERNAL eol_ext target_top {
           SPACING < stubSpacing
           SET_CORNERS_TO_SPACING=FALSE
           PARALLEL_POINT_PROJECTION=FALSE
           OUTPUT_EDGES = TRUE
        } TEMP=err_edge
        SELECT eol_ext INTERACT err_edge { } TEMP=eol_ext
        BOOLEAN eol_body OR eol_ext { } TEMP=eol_ext
      } 
    } else {
      COPY end_of_line { } TEMP=eol_ext
    }
    SELECT side_edge INTERACT eol_ext { } TEMP=side_edge
    SIZE eol_ext {
       VSIZE_INSIDE = sideStubThreshold 
       VSIZE_OUTSIDE = sideStubExt
    } TEMP = eol_range
    if (sideStubExt > 0) {
       SIZE side_edge {
          VSIZE_HEAD = sideStubExt
          VSIZE_TAIL = sideStubExt
          OUTPUT_EDGES = TRUE
       } TEMP = check_edge
    } else {
       COPY side_edge { } TEMP = check_edge
    }
    BOOLEAN check_edge AND eol_range { } TEMP=check_edge
    EXTERNAL check_edge target_top {
       SPACING < temporary_1
       SET_CORNERS_TO_SPACING = FALSE
       SHADOW_OTHER_LAYER = TRUE
       PARALLEL_POINT_PROJECTION = FALSE
       OUTPUT_EDGES = TRUE
    } TEMP=err_edge
    if (0 && stubMode!=4) { /* Temporarily do not check mode 2,3 side edge length */
       LENGTH side_edge { SPACING < stubSpacing- 0.0001 *2 } TEMP=err_edge_1
       BOOLEAN err_edge OR err_edge_1 { } TEMP=err_edge
    }
    SELECT check_edge INTERACT err_edge { } TEMP=side_edge
    if (stubMode!=3) {
       SELECT eol_ext INTERACT side_edge {} TEMP=err_eol
       EXTERNAL err_eol target_top {
          COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing ,crnKeepOut= sideStubExt um (mode = stubMode )"
          SPACING < temporary_1
          PARALLEL_POINT_PROJECTION=FALSE
          SET_CORNERS_TO_SPACING=FALSE
       } (15 )
    } else { /* stubMode == 3 */
       SELECT eol_ext INTERACT side_edge { RANGE = [2, 2] } TEMP=err_eol
       EXTERNAL err_eol target_top {
          COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 3)"
          SPACING < temporary_1
          PARALLEL_POINT_PROJECTION=FALSE
          SET_CORNERS_TO_SPACING=FALSE
       } (15 )
    }
  }
} /* stubMode > 0, not aligned */
/* Avoid empty optimization result parsing error */
if (addEmptyMetalCheck) {
   BOOLEAN empty OR empty {
      COMMENT = "$layer_name Empty: Dummy Output"
   } (15 )
   SET addEmptyMetalCheck=0;
}
/* reset variables */


 
SET minWidth = 0;
SET maxWidth = 0;
SET minArea = 0;
SET minEnclosedArea = 0;
SET minSpacing = 0;
SET sameNetMinSpacing = 0;
SET maxNumMinEdge = 0;
SET maxTotalMinEdgeLength = 0;
SET minEdgeLength = 0;
SET minEdgeLength2 = 0;
SET minEdgeLength3 = 0;
SET stubRange = 0;
SET stubSpacing = 0;
SET stub2StubSpacing = 0;
SET sideStubExt = 0;
SET sideStubThreshold = 0;
SET stubThreshold = 0;
SET fatPolyContactRule = 0;
SET fatWireThreshold = 0;
SET fatThinMinSpacing = 0;
SET fatFatMinSpacing = 0;
SET fatTblDimension = 0;
@ 395 "adrc/adrc.ev" 2

SET minSpacing = 0.056;
SET fatTblThresh_protru = 0.15;
SET fatTblLength_protru = 0.1;
SET fatTblWidth_protru = 0.06;
@ 1 "adrc/adrc_protru.ev" 1
/*protrusion length rule*/
SIZE metal3     { UNDER_OVER = fatTblThresh_protru / 2.0 - 0.0001  } TEMP = fat
BOOLEAN fat AND metal3  {  } TEMP = fat 
BOOLEAN metal3  NOT fat {  } TEMP = fat_nbr
SIZE fat { OVERSIZE = fatTblLength_protru + 0.0001  } TEMP = fat_ext
BOOLEAN fat_nbr AND fat_ext {} TEMP = fat_nbr
SELECT fat_nbr INTERACT fat TEMP = fat_nbr
/* Get the correct fat extension */
SELECT_EDGE fat_nbr TOUCHING fat { } TEMP = ext_filter
SIZE ext_filter { VSIZE_INSIDE = 0.0001  } TEMP = ext_filter
SIZE ext_filter INSIDE fat_nbr {
   OVERSIZE = fatTblLength_protru- 0.0001 
   INCREMENT = minSpacing
} TEMP=dummy TEMP = fat_nbr
  
VERTEX fat_nbr {
   CONCAVE = TRUE
   SIZE = 0.0002 
} TEMP = corners
SELECT fat_nbr OUTSIDE corners { } TEMP = fat_nbr1
BOOLEAN fat_nbr NOT fat_nbr1 { } TEMP = fat_nbr2
SELECT_CONTAINS fat_nbr1 {
   WIDTH =  0.0002 
   HEIGHT = fatTblLength_protru
} TEMP = good_fat_nbr1
BOOLEAN fat_nbr1 NOT good_fat_nbr1 { } TEMP = fat_nbr1
/* check with L or T shape of fat extension */
SELECT_EDGE fat_nbr2 INTERACT corners { } TEMP = side_edge
LENGTH side_edge { SPACING < fatTblLength_protru } TEMP = vio_edge
SELECT fat_nbr2 INTERACT vio_edge { } TEMP = fat_nbr2
BOOLEAN fat_nbr1 OR fat_nbr2 { } TEMP = fat_nbr
INTERAL fat_nbr {
   SPACING < fatTblWidth_protru
} TEMP = possible_err
if (!layer_empty(possible_err)) {
   SELECT fat_nbr INTERACT possible_err { } TEMP=fat_nbr
   SELECT fat INTERACT fat_nbr {} TEMP=fat
   BOOLEAN fat OR fat_nbr {} TEMP=fat
   INTERNAL fat {
      COMMENT = "$layer_name ProtrusionLength : threshold fatTblThresh_protru um, length  fatTblLength_protru um, width fatTblWidth_protru um"
      SPACING < fatTblWidth_protru
   } (15 )
}
/* protrusion leng rule check */
SET fatTblThresh_protru = 0;
SET fatTblLength_protru = 0;
SET fatTblWidth_protru = 0;
SET minSpacing = 0;
@ 400 "adrc/adrc.ev" 2


SET minSpacing = 0.056;
SET fatTblThresh_protru = 0.3;
SET fatTblLength_protru = 0.15;
SET fatTblWidth_protru = 0.07;
@ 1 "adrc/adrc_protru.ev" 1
/*protrusion length rule*/
SIZE metal3     { UNDER_OVER = fatTblThresh_protru / 2.0 - 0.0001  } TEMP = fat
BOOLEAN fat AND metal3  {  } TEMP = fat 
BOOLEAN metal3  NOT fat {  } TEMP = fat_nbr
SIZE fat { OVERSIZE = fatTblLength_protru + 0.0001  } TEMP = fat_ext
BOOLEAN fat_nbr AND fat_ext {} TEMP = fat_nbr
SELECT fat_nbr INTERACT fat TEMP = fat_nbr
/* Get the correct fat extension */
SELECT_EDGE fat_nbr TOUCHING fat { } TEMP = ext_filter
SIZE ext_filter { VSIZE_INSIDE = 0.0001  } TEMP = ext_filter
SIZE ext_filter INSIDE fat_nbr {
   OVERSIZE = fatTblLength_protru- 0.0001 
   INCREMENT = minSpacing
} TEMP=dummy TEMP = fat_nbr
  
VERTEX fat_nbr {
   CONCAVE = TRUE
   SIZE = 0.0002 
} TEMP = corners
SELECT fat_nbr OUTSIDE corners { } TEMP = fat_nbr1
BOOLEAN fat_nbr NOT fat_nbr1 { } TEMP = fat_nbr2
SELECT_CONTAINS fat_nbr1 {
   WIDTH =  0.0002 
   HEIGHT = fatTblLength_protru
} TEMP = good_fat_nbr1
BOOLEAN fat_nbr1 NOT good_fat_nbr1 { } TEMP = fat_nbr1
/* check with L or T shape of fat extension */
SELECT_EDGE fat_nbr2 INTERACT corners { } TEMP = side_edge
LENGTH side_edge { SPACING < fatTblLength_protru } TEMP = vio_edge
SELECT fat_nbr2 INTERACT vio_edge { } TEMP = fat_nbr2
BOOLEAN fat_nbr1 OR fat_nbr2 { } TEMP = fat_nbr
INTERAL fat_nbr {
   SPACING < fatTblWidth_protru
} TEMP = possible_err
if (!layer_empty(possible_err)) {
   SELECT fat_nbr INTERACT possible_err { } TEMP=fat_nbr
   SELECT fat INTERACT fat_nbr {} TEMP=fat
   BOOLEAN fat OR fat_nbr {} TEMP=fat
   INTERNAL fat {
      COMMENT = "$layer_name ProtrusionLength : threshold fatTblThresh_protru um, length  fatTblLength_protru um, width fatTblWidth_protru um"
      SPACING < fatTblWidth_protru
   } (15 )
}
/* protrusion leng rule check */
SET fatTblThresh_protru = 0;
SET fatTblLength_protru = 0;
SET fatTblWidth_protru = 0;
SET minSpacing = 0;
@ 406 "adrc/adrc.ev" 2


SET minSpacing = 0.056;
SET fatTblThresh_protru = 1.5;
SET fatTblLength_protru = 0.7;
SET fatTblWidth_protru = 0.15;
@ 1 "adrc/adrc_protru.ev" 1
/*protrusion length rule*/
SIZE metal3     { UNDER_OVER = fatTblThresh_protru / 2.0 - 0.0001  } TEMP = fat
BOOLEAN fat AND metal3  {  } TEMP = fat 
BOOLEAN metal3  NOT fat {  } TEMP = fat_nbr
SIZE fat { OVERSIZE = fatTblLength_protru + 0.0001  } TEMP = fat_ext
BOOLEAN fat_nbr AND fat_ext {} TEMP = fat_nbr
SELECT fat_nbr INTERACT fat TEMP = fat_nbr
/* Get the correct fat extension */
SELECT_EDGE fat_nbr TOUCHING fat { } TEMP = ext_filter
SIZE ext_filter { VSIZE_INSIDE = 0.0001  } TEMP = ext_filter
SIZE ext_filter INSIDE fat_nbr {
   OVERSIZE = fatTblLength_protru- 0.0001 
   INCREMENT = minSpacing
} TEMP=dummy TEMP = fat_nbr
  
VERTEX fat_nbr {
   CONCAVE = TRUE
   SIZE = 0.0002 
} TEMP = corners
SELECT fat_nbr OUTSIDE corners { } TEMP = fat_nbr1
BOOLEAN fat_nbr NOT fat_nbr1 { } TEMP = fat_nbr2
SELECT_CONTAINS fat_nbr1 {
   WIDTH =  0.0002 
   HEIGHT = fatTblLength_protru
} TEMP = good_fat_nbr1
BOOLEAN fat_nbr1 NOT good_fat_nbr1 { } TEMP = fat_nbr1
/* check with L or T shape of fat extension */
SELECT_EDGE fat_nbr2 INTERACT corners { } TEMP = side_edge
LENGTH side_edge { SPACING < fatTblLength_protru } TEMP = vio_edge
SELECT fat_nbr2 INTERACT vio_edge { } TEMP = fat_nbr2
BOOLEAN fat_nbr1 OR fat_nbr2 { } TEMP = fat_nbr
INTERAL fat_nbr {
   SPACING < fatTblWidth_protru
} TEMP = possible_err
if (!layer_empty(possible_err)) {
   SELECT fat_nbr INTERACT possible_err { } TEMP=fat_nbr
   SELECT fat INTERACT fat_nbr {} TEMP=fat
   BOOLEAN fat OR fat_nbr {} TEMP=fat
   INTERNAL fat {
      COMMENT = "$layer_name ProtrusionLength : threshold fatTblThresh_protru um, length  fatTblLength_protru um, width fatTblWidth_protru um"
      SPACING < fatTblWidth_protru
   } (15 )
}
/* protrusion leng rule check */
SET fatTblThresh_protru = 0;
SET fatTblLength_protru = 0;
SET fatTblWidth_protru = 0;
SET minSpacing = 0;
@ 412 "adrc/adrc.ev" 2


SET minSpacing = 0.056;
SET fatTblThresh_protru = 3;
SET fatTblLength_protru = 1.5;
SET fatTblWidth_protru = 0.3;
@ 1 "adrc/adrc_protru.ev" 1
/*protrusion length rule*/
SIZE metal3     { UNDER_OVER = fatTblThresh_protru / 2.0 - 0.0001  } TEMP = fat
BOOLEAN fat AND metal3  {  } TEMP = fat 
BOOLEAN metal3  NOT fat {  } TEMP = fat_nbr
SIZE fat { OVERSIZE = fatTblLength_protru + 0.0001  } TEMP = fat_ext
BOOLEAN fat_nbr AND fat_ext {} TEMP = fat_nbr
SELECT fat_nbr INTERACT fat TEMP = fat_nbr
/* Get the correct fat extension */
SELECT_EDGE fat_nbr TOUCHING fat { } TEMP = ext_filter
SIZE ext_filter { VSIZE_INSIDE = 0.0001  } TEMP = ext_filter
SIZE ext_filter INSIDE fat_nbr {
   OVERSIZE = fatTblLength_protru- 0.0001 
   INCREMENT = minSpacing
} TEMP=dummy TEMP = fat_nbr
  
VERTEX fat_nbr {
   CONCAVE = TRUE
   SIZE = 0.0002 
} TEMP = corners
SELECT fat_nbr OUTSIDE corners { } TEMP = fat_nbr1
BOOLEAN fat_nbr NOT fat_nbr1 { } TEMP = fat_nbr2
SELECT_CONTAINS fat_nbr1 {
   WIDTH =  0.0002 
   HEIGHT = fatTblLength_protru
} TEMP = good_fat_nbr1
BOOLEAN fat_nbr1 NOT good_fat_nbr1 { } TEMP = fat_nbr1
/* check with L or T shape of fat extension */
SELECT_EDGE fat_nbr2 INTERACT corners { } TEMP = side_edge
LENGTH side_edge { SPACING < fatTblLength_protru } TEMP = vio_edge
SELECT fat_nbr2 INTERACT vio_edge { } TEMP = fat_nbr2
BOOLEAN fat_nbr1 OR fat_nbr2 { } TEMP = fat_nbr
INTERAL fat_nbr {
   SPACING < fatTblWidth_protru
} TEMP = possible_err
if (!layer_empty(possible_err)) {
   SELECT fat_nbr INTERACT possible_err { } TEMP=fat_nbr
   SELECT fat INTERACT fat_nbr {} TEMP=fat
   BOOLEAN fat OR fat_nbr {} TEMP=fat
   INTERNAL fat {
      COMMENT = "$layer_name ProtrusionLength : threshold fatTblThresh_protru um, length  fatTblLength_protru um, width fatTblWidth_protru um"
      SPACING < fatTblWidth_protru
   } (15 )
}
/* protrusion leng rule check */
SET fatTblThresh_protru = 0;
SET fatTblLength_protru = 0;
SET fatTblWidth_protru = 0;
SET minSpacing = 0;
@ 418 "adrc/adrc.ev" 2





/* Start of Met3 fat table spacing rules */
SET fatTblSpacingMode = 0;
SET parallelLengthMode = 0;
SET router_parallelLengthNetMode = 0;

SET fatTblThreshold = 0.155;
SET fatTblParallelLength = 0.155;
SET minWidth = 0.056;

SET fatTblThreshold_Start = 0;
SET fatTblSpacing = 0.064;
@ 1 "adrc/adrc_fatMetal.ev" 1
/*check fat metal table*/
if (fatTblThreshold > 0) {
    if ((fatTblThreshold / 2.0) > 0.0001 ) {
       SIZE fat_candidate  { UNDER_OVER = fatTblThreshold / 2.0 - 0.0001  } TEMP = fat_candidate
       if (fatTblNextThreshold > 0) {
          SIZE fat_candidate { UNDER_OVER = fatTblNextThreshold / 2.0 - 0.0001  } TEMP = fat_next
          BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
          BOOLEAN fat AND fat_target { } TEMP = fat
          SET fatTblNextThreshold = 0;
       } else {
          BOOLEAN fat_candidate AND fat_target {  } TEMP = fat 
       }
    } else {
      COPY fat_target {  } TEMP = fat 
    }
    COPY fat_target { } TEMP = spc_target
    if (fatTblThreshold_Start > 0  || fatTblThreshold_End > 0) {
       if (fatTblThreshold_Start > 0) {
          SIZE fat_target { UNDER_OVER = fatTblThreshold_Start / 2.0 - 0.0001  } TEMP = spc_target
       }
       if (fatTblThreshold_End > 0 && fatTblThreshold_End > fatTblThreshold_Start) {
          SIZE spc_target { UNDER_OVER = fatTblThreshold_End / 2.0 - 0.0001  } TEMP = fat_end
          BOOLEAN spc_target NOT fat_end { } TEMP = spc_target
       }
       BOOLEAN spc_target AND fat_target {  } TEMP = spc_target
       if (ignoreBlockage == 0 && fatTblThreshold_Start < fatTblThreshold_1) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal3_blockage  {  } TEMP = spc_target
       }
       SET fatTblThreshold_Start = 0;
       SET fatTblThreshold_End = 0;
       SET fatTblThreshold_1 = 0;
    } else {
       if (ignoreBlockage == 0) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal3_blockage  {  } TEMP = spc_target
       }
    }
 
    if (fatTblEnclosedArea > 0) {
       SELECT holes INTERACT fat { } TEMP = fat_holes
       AREA fat_holes { 
          RANGE = [0.0001 * 0.0001 , fatTblEnclosedArea - 0.0001 * 0.0001 ]
       } TEMP = fat_holes
       if (fatTblMinEnclosedAreaMode==0) {
          SIZE fat_holes { OVER_UNDER = fatTblThreshold / 2.0 + 0.0001  } TEMP = ovun_holes
          SELECT ovun_holes INTERACT fat_holes { RANGE = [2, 9999999999 ] } TEMP = merged_holes
          BOOLEAN fat_candidate AND fat_target { } TEMP = fat_metal
          BOOLEAN metal3  NOT fat_metal { } TEMP = thin_metal
          BOOLEAN thin_metal NOT ovun_holes { } TEMP = thin_metal
          SELECT ovun_holes INTERACT thin_metal { } TEMP = thin_holes
          BOOLEAN thin_holes OR merged_holes { } TEMP = thin_holes
          BOOLEAN fat_holes NOT thin_holes { } TEMP = fat_holes
       }
       COPY fat_holes { 
	  COMMENT = "$layer_name EnclsArea : fat metal ( fatTblThreshold um) minimum enclosed area (mode fatTblMinEnclosedAreaMode ) = fatTblEnclosedArea um*um"
       } (15 )
       SET fatTblEnclosedArea = 0;
    }
    if (fatTblSpacing > 0) {
       /*check fat metal*/ 
       if (fatTblParallelLength > 0) {
          if (router_parallelLengthNetMode == 1 || parallelLengthMode == 1) {
             AREA spc_target { RANGE = [fatTblParallelLength * minWidth + 0.0001 , 9999999999 ] } TEMP = spc_target1
             COPY spc_target1 { } TEMP = spc_target2
          } else {
             COPY spc_target { } TEMP = spc_target2
          }
          if (parallelLengthMode == 1) {
             SELECT metal3  INTERACT fat { } TEMP = fat_all 
             BOOLEAN fat_all OR fat { } TEMP = fat2
             SELECT metal3  INTERACT spc_target2 { } TEMP = spc_target_all
             BOOLEAN spc_target_all OR spc_target2 { } TEMP = spc_target2
          } else {
             COPY fat { } TEMP = fat2
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING <= fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
                OUTPUT_EDGES = TRUE
             } TEMP = vio_edge
             SELECT vio_edge INTERACT fat { } TEMP = vio_edge
             SELECT vio_edge INTERACT spc_target1 { } TEMP = vio_edge
             SELECT violation INTERACT vio_edge { } TEMP = violation
          } else {
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
          }
          BOOLEAN violation NOT fat_target { } TEMP = violation
          if (fatTblParallelLength < fatTblSpacing) {
             SELECT_EDGE violation TOUCHING fat2 {
                VSIZE_INSIDE = fatTblParallelLength - 0.0002 
             } TEMP = vio_filter
             SELECT_CONTAINS vio_filter { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = vio_filter
             SELECT violation INTERACT vio_filter { } TEMP = violation
          } else {
             SELECT_CONTAINS violation { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = violation
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING = [fatTblSpacing, fatTblSpacing]
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
             } TEMP = violation3
             BOOLEAN violation3 NOT fat_target { } TEMP = violation3
             BOOLEAN violation NOT violation3 { } TEMP= violation
          }
          SELECT_EDGE fat2 TOUCHING violation { } TEMP=fat_viol
          BOOLEAN fat_viol AND violation { } TEMP=fat_viol
          SELECT_EDGE spc_target2 TOUCHING violation { } TEMP=spc_target2
          BOOLEAN spc_target2 AND violation { } TEMP= spc_target2
	  if (ignoreChildCell == 1) {
             EXTERNAL fat_viol spc_target2 {
		SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		TOUCH = FALSE
		POINT_TOUCH = FALSE
		NON_PARALLEL = TRUE
	     } TEMP = spc_mode0_out
             BOOLEAN spc_mode0_out NOT spc_mode0_child_out { } TEMP = spc_mode0_diff_out
             SELECT spc_mode0_out INTERACT spc_mode0_diff_out { } TEMP = spc_mode0_out
	     SELECT_EDGE fat2 TOUCHING spc_mode0_out { } TEMP=fat_viol
	     BOOLEAN fat_viol AND spc_mode0_out { } TEMP=fat_viol
	     SELECT_EDGE spc_target2 TOUCHING spc_mode0_out { } TEMP=spc_target2
	     BOOLEAN spc_target2 AND spc_mode0_out { } TEMP=spc_target2
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (15 )  		
	  } else {
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing 
	        SET_CORNERS_TO_SPACING = FALSE
	        PARALLEL_POINT_PROJECTION = FALSE
	        TOUCH = FALSE
	        POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (15 )
	  }
	  if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	     if (ignoreChildCell == 1) {
		EXTERNAL fat spc_target {
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} TEMP = spc_mode1_out
	        BOOLEAN spc_mode1_out NOT spc_mode1_child_out { } TEMP = spc_mode1_diff_out
	        SELECT spc_mode1_out INTERACT spc_mode1_diff_out { } TEMP = spc_mode1_out
                SELECT_EDGE fat TOUCHING spc_mode1_out { } TEMP=fat_viol
	        BOOLEAN fat_viol AND spc_mode1_out { } TEMP=fat_viol
	        SELECT_EDGE spc_target TOUCHING spc_mode1_out { } TEMP=spc_target2
	        BOOLEAN spc_target2 AND spc_mode1_out { } TEMP=spc_target2
	        EXTERNAL fat_viol spc_target2 {
	           COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um " 	    
		   SPACING < fatTblSpacing_dg
                   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} (15 )
	     } else {
	        EXTERNAL fat spc_target {
		   COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um "
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
	    	   PARALLEL_POINT_PROJECTION = FALSE
	           TOUCH = FALSE
	     	   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } (15 ) 
	     }
          }
       } else {
	  if (ignoreChildCell == 1) {
              EXTERNAL fat spc_target {
                 SPACING < fatTblSpacing
                 BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
              } TEMP = spc_out
	      BOOLEAN spc_out NOT spc_child_out { } TEMP = spc_diff_out
	      SELECT spc_out INTERACT spc_diff_out { } TEMP = spc_out
	      SELECT_EDGE fat TOUCHING spc_out { } TEMP=fat_viol
	      BOOLEAN fat_viol AND spc_out { } TEMP=fat_viol
              SELECT_EDGE spc_target TOUCHING spc_out { } TEMP=spc_target2
	      BOOLEAN spc_target2 AND spc_out { } TEMP=spc_target2
	      EXTERNAL fat_viol spc_target2 {
		 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
		 BOX_CORNER = FALSE 
		 NON_PARALLEL = TRUE
		 POINT_TOUCH = FALSE
	      } (15 ) 
	  } else {
	      EXTERNAL fat spc_target {
                 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
	         BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
	      } (15 ) 
	  }
       }
       /*check metal in the extension range*/ 
       if (fatTblExtensionRange > 0) {
	  if (fatWireExtensionMode == 0) {
	     SIZE fat { OVERSIZE = fatTblExtensionRange } TEMP = fat_tmp
             BOOLEAN fat_tmp AND metal3  { } TEMP = fat_tmp
  	     BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
             SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_ext
             BOOLEAN fat_ext OR fat { } TEMP = fat_ext
	     if (fatTblParallelLength > 0) {
                if (fatTblParallelLength > fatTblExtensionRange) {
                   SIZE fat { OVERSIZE = fatTblParallelLength } TEMP = fat_tmp
                   BOOLEAN fat_tmp AND metal3  { } TEMP = fat_tmp
  	           BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
                   SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_parallel
                   BOOLEAN fat_parallel OR fat { } TEMP = fat_parallel
                } else {
                   COPY fat_ext { } TEMP = fat_parallel
                }
		EXTERNAL fat_parallel spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
	           NON_PARALLEL = TRUE
	        } TEMP = vio_filter_set
		EXTERNAL fat_ext spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } TEMP = vio_set
                if (fatTblParallelLength < fatTblSpacing) {
                   SELECT_EDGE vio_filter_set TOUCHING fat_parallel {
                      VSIZE_INSIDE = fatTblParallelLength - 0.0002 
                   } TEMP = vio_filter_set_filter
                   SELECT_CONTAINS vio_filter_set_filter { 
                      WIDTH =  0.0002 
                      HEIGHT = fatTblParallelLength + 0.0001 
                   } TEMP = vio_filter_set_filter
                   SELECT vio_filter_set INTERACT vio_filter_set_filter { } TEMP = vio_filter
                } else {
	           SELECT_CONTAINS vio_filter_set { 
	              WIDTH =  0.0002 
	              HEIGHT = fatTblParallelLength + 0.0001 
	           } TEMP = vio_filter
                }
                SELECT vio_set INSIDE vio_filter { } TEMP = mode0_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out1 NOT mode0_child_out1 { } TEMP = mode0_diff_out1
                   SELECT mode0_out1 INTERACT mode0_diff_out1 { } TEMP = mode0_out1
                }
                COPY mode0_out1 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing  = fatTblSpacing um"
                } (15 )
		if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	           EXTERNAL fat_ext spc_target {
		      SPACING < fatTblSpacing_dg
	              SET_CORNERS_TO_SPACING = FALSE
		      PARALLEL_POINT_PROJECTION = FALSE
		      TOUCH = TRUE
		      POINT_TOUCH = FALSE
		      NON_PARALLEL = TRUE
	           } TEMP = mode0_out2
                   if (ignoreChildCell == 1) {
                      BOOLEAN mode0_out2 NOT mode0_child_out2 { } TEMP = mode0_diff_out2
                      SELECT mode0_out2 INTERACT mode0_diff_out2 { } TEMP = mode0_out2
                   }
                   COPY mode0_out2 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing (mode 1/2) = fatTblSpacing um/ fatTblSpacing_dg um "
                   } (15 )
	        } 
	     } else {
	        EXTERNAL fat_ext spc_target {
		   SPACING < fatTblSpacing
		   NON_PARALLEL = TRUE
		   SET_CORNERS_TO_SPACING = FALSE
		   POINT_TOUCH = FALSE
		} TEMP = mode0_out3
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out3 NOT mode0_child_out3 { } TEMP = mode0_diff_out3
                   SELECT mode0_out3 INTERACT mode0_diff_out3 { } TEMP = mode0_out3
                }
                COPY mode0_out3 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range ( fatTblExtensionRange um) minimum spacing = fatTblSpacing um"
                } (15 )
	     }
	  } else if (fatWireExtensionMode == 1) {
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal3  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             if (fatTblParallelLength > 0) {
                EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
		   BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   CHECK_SAME_POLYGON = TRUE 
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
	        SELECT fat_ext INTERACT spacing {  } TEMP = fat_ext
		BOOLEAN fat_ext OR spacing {  } TEMP = combined_fat_ext
                EXTERNAL combined_fat_ext fat {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
                } TEMP = fat_spacing
		BOOLEAN fat_spacing AND fat_ran {  } TEMP = fat_spacing
		BOOLEAN combined_fat_ext OR fat_spacing {  } TEMP = combined_fat_ext
                SELECT_CONTAINS combined_fat_ext { 
                   WIDTH =  0.0002 
                   HEIGHT = fatTblParallelLength + 0.0001 
                } TEMP = combined_fat_ext
		SELECT spacing INTERACT combined_fat_ext { 
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out1 NOT mode1_child_out1 { } TEMP = mode1_diff_out1
                   SELECT mode1_out1 INTERACT mode1_diff_out1 { } TEMP = mode1_out1 
                }
                COPY mode1_out1 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (15 ) 
	     } else {
               	EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
	           BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
	           CHECK_SAME_POLYGON = TRUE 
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
                SELECT spacing INTERACT fat_ext {
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out2
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out2 NOT mode1_child_out2 { } TEMP = mode1_diff_out2
                   SELECT mode1_out2 INTERACT mode1_diff_out2 { } TEMP = mode1_out2
                }
                COPY mode1_out2 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (15 )
	     }
	  } else if (fatWireExtensionMode == 2) {
	     SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
             BOOLEAN fat_ran AND metal3  {  } TEMP = fat_ext
             BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	      	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
             } TEMP = spacing
 	     SELECT spacing INSIDE fat_ran {  } TEMP = spacing
	     SELECT spacing OUTSIDE fat {  } TEMP = spacing
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode2_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode2_out NOT mode2_child_out { } TEMP = mode2_diff_out
                SELECT mode2_out INTERACT mode2_diff_out { } TEMP = mode2_out 
             }
             COPY mode2_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 2, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (15 )
	  } else if (fatWireExtensionMode == 3) {
             SIZE fat {
	        GROW_LEFT = fatTblExtensionRange
	        GROW_RIGHT = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal3  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	       	PARALLEL = TRUE

	       	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		HORIZONTAL_ONLY = TRUE
             } TEMP = spacing_hor
	     SELECT spacing_hor INSIDE fat_ran {  } TEMP = spacing_hor
	     SELECT spacing_hor OUTSIDE fat {  } TEMP = spacing_hor
             SIZE fat {
	        GROW_TOP = fatTblExtensionRange
	        GROW_BOTTOM = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal3  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	        POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		VERTICAL_ONLY = TRUE
             } TEMP = spacing_ver
	     SELECT spacing_ver INSIDE fat_ran {  } TEMP = spacing_ver
	     SELECT spacing_ver OUTSIDE fat {  } TEMP = spacing_ver
  	     BOOLEAN spacing_hor OR spacing_ver {  } TEMP = spacing
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal3  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
  	     /* check overlapped projection length */
 	     if (fatTblParallelLength > 0) {
                POLYGON_FEATURES fat_ext {
                   EQUATIONS {
                      vnum = EV_VNUM_IN;
                      if ( vnum > 0) {
                         bdLeft = EV_VXCOORD_IN[0];
                         bdRight = EV_VXCOORD_IN[0];
                         bdBottom = EV_VYCOORD_IN[0];
                         bdTop = EV_VYCOORD_IN[0];
                         FOR (i = 1; i < vnum; i++) {
                            if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
                            else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
                            if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
                            else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
                         } /* FOR i */
                         if ( (bdRight - bdLeft) >= fatTblParallelLength ||
                  	      (bdTop - bdBottom) >= fatTblParallelLength) {
                            FOR (i = 0; i < vnum; i++) {
                               EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
                               EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
                            }
                            EV_VNUM_OUT = vnum;
                 	    EV_SAVE_POLYGON();
                         }
                      }
                   }
                } TEMP = fat_ext /* POLYGON_FEATURE */
             }
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode3_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode3_out NOT mode3_child_out { } TEMP = mode3_diff_out
                SELECT mode3_out INTERACT mode3_diff_out { } TEMP = mode3_out
             }
             COPY mode3_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 3, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (15 )
          }
       }
       SET fatTblSpacing = 0;
    }
}
@ 434 "adrc/adrc.ev" 2


SET fatTblThreshold = 0.305;
SET fatTblParallelLength = 0.305;
SET minWidth = 0.056;

SET fatTblThreshold_Start = 0;
SET fatTblSpacing = 0.12;
@ 1 "adrc/adrc_fatMetal.ev" 1
/*check fat metal table*/
if (fatTblThreshold > 0) {
    if ((fatTblThreshold / 2.0) > 0.0001 ) {
       SIZE fat_candidate  { UNDER_OVER = fatTblThreshold / 2.0 - 0.0001  } TEMP = fat_candidate
       if (fatTblNextThreshold > 0) {
          SIZE fat_candidate { UNDER_OVER = fatTblNextThreshold / 2.0 - 0.0001  } TEMP = fat_next
          BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
          BOOLEAN fat AND fat_target { } TEMP = fat
          SET fatTblNextThreshold = 0;
       } else {
          BOOLEAN fat_candidate AND fat_target {  } TEMP = fat 
       }
    } else {
      COPY fat_target {  } TEMP = fat 
    }
    COPY fat_target { } TEMP = spc_target
    if (fatTblThreshold_Start > 0  || fatTblThreshold_End > 0) {
       if (fatTblThreshold_Start > 0) {
          SIZE fat_target { UNDER_OVER = fatTblThreshold_Start / 2.0 - 0.0001  } TEMP = spc_target
       }
       if (fatTblThreshold_End > 0 && fatTblThreshold_End > fatTblThreshold_Start) {
          SIZE spc_target { UNDER_OVER = fatTblThreshold_End / 2.0 - 0.0001  } TEMP = fat_end
          BOOLEAN spc_target NOT fat_end { } TEMP = spc_target
       }
       BOOLEAN spc_target AND fat_target {  } TEMP = spc_target
       if (ignoreBlockage == 0 && fatTblThreshold_Start < fatTblThreshold_1) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal3_blockage  {  } TEMP = spc_target
       }
       SET fatTblThreshold_Start = 0;
       SET fatTblThreshold_End = 0;
       SET fatTblThreshold_1 = 0;
    } else {
       if (ignoreBlockage == 0) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal3_blockage  {  } TEMP = spc_target
       }
    }
 
    if (fatTblEnclosedArea > 0) {
       SELECT holes INTERACT fat { } TEMP = fat_holes
       AREA fat_holes { 
          RANGE = [0.0001 * 0.0001 , fatTblEnclosedArea - 0.0001 * 0.0001 ]
       } TEMP = fat_holes
       if (fatTblMinEnclosedAreaMode==0) {
          SIZE fat_holes { OVER_UNDER = fatTblThreshold / 2.0 + 0.0001  } TEMP = ovun_holes
          SELECT ovun_holes INTERACT fat_holes { RANGE = [2, 9999999999 ] } TEMP = merged_holes
          BOOLEAN fat_candidate AND fat_target { } TEMP = fat_metal
          BOOLEAN metal3  NOT fat_metal { } TEMP = thin_metal
          BOOLEAN thin_metal NOT ovun_holes { } TEMP = thin_metal
          SELECT ovun_holes INTERACT thin_metal { } TEMP = thin_holes
          BOOLEAN thin_holes OR merged_holes { } TEMP = thin_holes
          BOOLEAN fat_holes NOT thin_holes { } TEMP = fat_holes
       }
       COPY fat_holes { 
	  COMMENT = "$layer_name EnclsArea : fat metal ( fatTblThreshold um) minimum enclosed area (mode fatTblMinEnclosedAreaMode ) = fatTblEnclosedArea um*um"
       } (15 )
       SET fatTblEnclosedArea = 0;
    }
    if (fatTblSpacing > 0) {
       /*check fat metal*/ 
       if (fatTblParallelLength > 0) {
          if (router_parallelLengthNetMode == 1 || parallelLengthMode == 1) {
             AREA spc_target { RANGE = [fatTblParallelLength * minWidth + 0.0001 , 9999999999 ] } TEMP = spc_target1
             COPY spc_target1 { } TEMP = spc_target2
          } else {
             COPY spc_target { } TEMP = spc_target2
          }
          if (parallelLengthMode == 1) {
             SELECT metal3  INTERACT fat { } TEMP = fat_all 
             BOOLEAN fat_all OR fat { } TEMP = fat2
             SELECT metal3  INTERACT spc_target2 { } TEMP = spc_target_all
             BOOLEAN spc_target_all OR spc_target2 { } TEMP = spc_target2
          } else {
             COPY fat { } TEMP = fat2
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING <= fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
                OUTPUT_EDGES = TRUE
             } TEMP = vio_edge
             SELECT vio_edge INTERACT fat { } TEMP = vio_edge
             SELECT vio_edge INTERACT spc_target1 { } TEMP = vio_edge
             SELECT violation INTERACT vio_edge { } TEMP = violation
          } else {
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
          }
          BOOLEAN violation NOT fat_target { } TEMP = violation
          if (fatTblParallelLength < fatTblSpacing) {
             SELECT_EDGE violation TOUCHING fat2 {
                VSIZE_INSIDE = fatTblParallelLength - 0.0002 
             } TEMP = vio_filter
             SELECT_CONTAINS vio_filter { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = vio_filter
             SELECT violation INTERACT vio_filter { } TEMP = violation
          } else {
             SELECT_CONTAINS violation { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = violation
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING = [fatTblSpacing, fatTblSpacing]
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
             } TEMP = violation3
             BOOLEAN violation3 NOT fat_target { } TEMP = violation3
             BOOLEAN violation NOT violation3 { } TEMP= violation
          }
          SELECT_EDGE fat2 TOUCHING violation { } TEMP=fat_viol
          BOOLEAN fat_viol AND violation { } TEMP=fat_viol
          SELECT_EDGE spc_target2 TOUCHING violation { } TEMP=spc_target2
          BOOLEAN spc_target2 AND violation { } TEMP= spc_target2
	  if (ignoreChildCell == 1) {
             EXTERNAL fat_viol spc_target2 {
		SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		TOUCH = FALSE
		POINT_TOUCH = FALSE
		NON_PARALLEL = TRUE
	     } TEMP = spc_mode0_out
             BOOLEAN spc_mode0_out NOT spc_mode0_child_out { } TEMP = spc_mode0_diff_out
             SELECT spc_mode0_out INTERACT spc_mode0_diff_out { } TEMP = spc_mode0_out
	     SELECT_EDGE fat2 TOUCHING spc_mode0_out { } TEMP=fat_viol
	     BOOLEAN fat_viol AND spc_mode0_out { } TEMP=fat_viol
	     SELECT_EDGE spc_target2 TOUCHING spc_mode0_out { } TEMP=spc_target2
	     BOOLEAN spc_target2 AND spc_mode0_out { } TEMP=spc_target2
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (15 )  		
	  } else {
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing 
	        SET_CORNERS_TO_SPACING = FALSE
	        PARALLEL_POINT_PROJECTION = FALSE
	        TOUCH = FALSE
	        POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (15 )
	  }
	  if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	     if (ignoreChildCell == 1) {
		EXTERNAL fat spc_target {
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} TEMP = spc_mode1_out
	        BOOLEAN spc_mode1_out NOT spc_mode1_child_out { } TEMP = spc_mode1_diff_out
	        SELECT spc_mode1_out INTERACT spc_mode1_diff_out { } TEMP = spc_mode1_out
                SELECT_EDGE fat TOUCHING spc_mode1_out { } TEMP=fat_viol
	        BOOLEAN fat_viol AND spc_mode1_out { } TEMP=fat_viol
	        SELECT_EDGE spc_target TOUCHING spc_mode1_out { } TEMP=spc_target2
	        BOOLEAN spc_target2 AND spc_mode1_out { } TEMP=spc_target2
	        EXTERNAL fat_viol spc_target2 {
	           COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um " 	    
		   SPACING < fatTblSpacing_dg
                   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} (15 )
	     } else {
	        EXTERNAL fat spc_target {
		   COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um "
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
	    	   PARALLEL_POINT_PROJECTION = FALSE
	           TOUCH = FALSE
	     	   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } (15 ) 
	     }
          }
       } else {
	  if (ignoreChildCell == 1) {
              EXTERNAL fat spc_target {
                 SPACING < fatTblSpacing
                 BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
              } TEMP = spc_out
	      BOOLEAN spc_out NOT spc_child_out { } TEMP = spc_diff_out
	      SELECT spc_out INTERACT spc_diff_out { } TEMP = spc_out
	      SELECT_EDGE fat TOUCHING spc_out { } TEMP=fat_viol
	      BOOLEAN fat_viol AND spc_out { } TEMP=fat_viol
              SELECT_EDGE spc_target TOUCHING spc_out { } TEMP=spc_target2
	      BOOLEAN spc_target2 AND spc_out { } TEMP=spc_target2
	      EXTERNAL fat_viol spc_target2 {
		 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
		 BOX_CORNER = FALSE 
		 NON_PARALLEL = TRUE
		 POINT_TOUCH = FALSE
	      } (15 ) 
	  } else {
	      EXTERNAL fat spc_target {
                 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
	         BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
	      } (15 ) 
	  }
       }
       /*check metal in the extension range*/ 
       if (fatTblExtensionRange > 0) {
	  if (fatWireExtensionMode == 0) {
	     SIZE fat { OVERSIZE = fatTblExtensionRange } TEMP = fat_tmp
             BOOLEAN fat_tmp AND metal3  { } TEMP = fat_tmp
  	     BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
             SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_ext
             BOOLEAN fat_ext OR fat { } TEMP = fat_ext
	     if (fatTblParallelLength > 0) {
                if (fatTblParallelLength > fatTblExtensionRange) {
                   SIZE fat { OVERSIZE = fatTblParallelLength } TEMP = fat_tmp
                   BOOLEAN fat_tmp AND metal3  { } TEMP = fat_tmp
  	           BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
                   SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_parallel
                   BOOLEAN fat_parallel OR fat { } TEMP = fat_parallel
                } else {
                   COPY fat_ext { } TEMP = fat_parallel
                }
		EXTERNAL fat_parallel spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
	           NON_PARALLEL = TRUE
	        } TEMP = vio_filter_set
		EXTERNAL fat_ext spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } TEMP = vio_set
                if (fatTblParallelLength < fatTblSpacing) {
                   SELECT_EDGE vio_filter_set TOUCHING fat_parallel {
                      VSIZE_INSIDE = fatTblParallelLength - 0.0002 
                   } TEMP = vio_filter_set_filter
                   SELECT_CONTAINS vio_filter_set_filter { 
                      WIDTH =  0.0002 
                      HEIGHT = fatTblParallelLength + 0.0001 
                   } TEMP = vio_filter_set_filter
                   SELECT vio_filter_set INTERACT vio_filter_set_filter { } TEMP = vio_filter
                } else {
	           SELECT_CONTAINS vio_filter_set { 
	              WIDTH =  0.0002 
	              HEIGHT = fatTblParallelLength + 0.0001 
	           } TEMP = vio_filter
                }
                SELECT vio_set INSIDE vio_filter { } TEMP = mode0_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out1 NOT mode0_child_out1 { } TEMP = mode0_diff_out1
                   SELECT mode0_out1 INTERACT mode0_diff_out1 { } TEMP = mode0_out1
                }
                COPY mode0_out1 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing  = fatTblSpacing um"
                } (15 )
		if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	           EXTERNAL fat_ext spc_target {
		      SPACING < fatTblSpacing_dg
	              SET_CORNERS_TO_SPACING = FALSE
		      PARALLEL_POINT_PROJECTION = FALSE
		      TOUCH = TRUE
		      POINT_TOUCH = FALSE
		      NON_PARALLEL = TRUE
	           } TEMP = mode0_out2
                   if (ignoreChildCell == 1) {
                      BOOLEAN mode0_out2 NOT mode0_child_out2 { } TEMP = mode0_diff_out2
                      SELECT mode0_out2 INTERACT mode0_diff_out2 { } TEMP = mode0_out2
                   }
                   COPY mode0_out2 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing (mode 1/2) = fatTblSpacing um/ fatTblSpacing_dg um "
                   } (15 )
	        } 
	     } else {
	        EXTERNAL fat_ext spc_target {
		   SPACING < fatTblSpacing
		   NON_PARALLEL = TRUE
		   SET_CORNERS_TO_SPACING = FALSE
		   POINT_TOUCH = FALSE
		} TEMP = mode0_out3
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out3 NOT mode0_child_out3 { } TEMP = mode0_diff_out3
                   SELECT mode0_out3 INTERACT mode0_diff_out3 { } TEMP = mode0_out3
                }
                COPY mode0_out3 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range ( fatTblExtensionRange um) minimum spacing = fatTblSpacing um"
                } (15 )
	     }
	  } else if (fatWireExtensionMode == 1) {
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal3  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             if (fatTblParallelLength > 0) {
                EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
		   BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   CHECK_SAME_POLYGON = TRUE 
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
	        SELECT fat_ext INTERACT spacing {  } TEMP = fat_ext
		BOOLEAN fat_ext OR spacing {  } TEMP = combined_fat_ext
                EXTERNAL combined_fat_ext fat {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
                } TEMP = fat_spacing
		BOOLEAN fat_spacing AND fat_ran {  } TEMP = fat_spacing
		BOOLEAN combined_fat_ext OR fat_spacing {  } TEMP = combined_fat_ext
                SELECT_CONTAINS combined_fat_ext { 
                   WIDTH =  0.0002 
                   HEIGHT = fatTblParallelLength + 0.0001 
                } TEMP = combined_fat_ext
		SELECT spacing INTERACT combined_fat_ext { 
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out1 NOT mode1_child_out1 { } TEMP = mode1_diff_out1
                   SELECT mode1_out1 INTERACT mode1_diff_out1 { } TEMP = mode1_out1 
                }
                COPY mode1_out1 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (15 ) 
	     } else {
               	EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
	           BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
	           CHECK_SAME_POLYGON = TRUE 
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
                SELECT spacing INTERACT fat_ext {
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out2
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out2 NOT mode1_child_out2 { } TEMP = mode1_diff_out2
                   SELECT mode1_out2 INTERACT mode1_diff_out2 { } TEMP = mode1_out2
                }
                COPY mode1_out2 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (15 )
	     }
	  } else if (fatWireExtensionMode == 2) {
	     SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
             BOOLEAN fat_ran AND metal3  {  } TEMP = fat_ext
             BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	      	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
             } TEMP = spacing
 	     SELECT spacing INSIDE fat_ran {  } TEMP = spacing
	     SELECT spacing OUTSIDE fat {  } TEMP = spacing
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode2_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode2_out NOT mode2_child_out { } TEMP = mode2_diff_out
                SELECT mode2_out INTERACT mode2_diff_out { } TEMP = mode2_out 
             }
             COPY mode2_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 2, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (15 )
	  } else if (fatWireExtensionMode == 3) {
             SIZE fat {
	        GROW_LEFT = fatTblExtensionRange
	        GROW_RIGHT = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal3  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	       	PARALLEL = TRUE

	       	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		HORIZONTAL_ONLY = TRUE
             } TEMP = spacing_hor
	     SELECT spacing_hor INSIDE fat_ran {  } TEMP = spacing_hor
	     SELECT spacing_hor OUTSIDE fat {  } TEMP = spacing_hor
             SIZE fat {
	        GROW_TOP = fatTblExtensionRange
	        GROW_BOTTOM = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal3  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	        POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		VERTICAL_ONLY = TRUE
             } TEMP = spacing_ver
	     SELECT spacing_ver INSIDE fat_ran {  } TEMP = spacing_ver
	     SELECT spacing_ver OUTSIDE fat {  } TEMP = spacing_ver
  	     BOOLEAN spacing_hor OR spacing_ver {  } TEMP = spacing
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal3  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
  	     /* check overlapped projection length */
 	     if (fatTblParallelLength > 0) {
                POLYGON_FEATURES fat_ext {
                   EQUATIONS {
                      vnum = EV_VNUM_IN;
                      if ( vnum > 0) {
                         bdLeft = EV_VXCOORD_IN[0];
                         bdRight = EV_VXCOORD_IN[0];
                         bdBottom = EV_VYCOORD_IN[0];
                         bdTop = EV_VYCOORD_IN[0];
                         FOR (i = 1; i < vnum; i++) {
                            if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
                            else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
                            if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
                            else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
                         } /* FOR i */
                         if ( (bdRight - bdLeft) >= fatTblParallelLength ||
                  	      (bdTop - bdBottom) >= fatTblParallelLength) {
                            FOR (i = 0; i < vnum; i++) {
                               EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
                               EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
                            }
                            EV_VNUM_OUT = vnum;
                 	    EV_SAVE_POLYGON();
                         }
                      }
                   }
                } TEMP = fat_ext /* POLYGON_FEATURE */
             }
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode3_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode3_out NOT mode3_child_out { } TEMP = mode3_diff_out
                SELECT mode3_out INTERACT mode3_diff_out { } TEMP = mode3_out
             }
             COPY mode3_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 3, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (15 )
          }
       }
       SET fatTblSpacing = 0;
    }
}
@ 442 "adrc/adrc.ev" 2


SET fatTblThreshold = 1.505;
SET fatTblParallelLength = 1.505;
SET minWidth = 0.056;

SET fatTblThreshold_Start = 0;
SET fatTblSpacing = 0.6;
@ 1 "adrc/adrc_fatMetal.ev" 1
/*check fat metal table*/
if (fatTblThreshold > 0) {
    if ((fatTblThreshold / 2.0) > 0.0001 ) {
       SIZE fat_candidate  { UNDER_OVER = fatTblThreshold / 2.0 - 0.0001  } TEMP = fat_candidate
       if (fatTblNextThreshold > 0) {
          SIZE fat_candidate { UNDER_OVER = fatTblNextThreshold / 2.0 - 0.0001  } TEMP = fat_next
          BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
          BOOLEAN fat AND fat_target { } TEMP = fat
          SET fatTblNextThreshold = 0;
       } else {
          BOOLEAN fat_candidate AND fat_target {  } TEMP = fat 
       }
    } else {
      COPY fat_target {  } TEMP = fat 
    }
    COPY fat_target { } TEMP = spc_target
    if (fatTblThreshold_Start > 0  || fatTblThreshold_End > 0) {
       if (fatTblThreshold_Start > 0) {
          SIZE fat_target { UNDER_OVER = fatTblThreshold_Start / 2.0 - 0.0001  } TEMP = spc_target
       }
       if (fatTblThreshold_End > 0 && fatTblThreshold_End > fatTblThreshold_Start) {
          SIZE spc_target { UNDER_OVER = fatTblThreshold_End / 2.0 - 0.0001  } TEMP = fat_end
          BOOLEAN spc_target NOT fat_end { } TEMP = spc_target
       }
       BOOLEAN spc_target AND fat_target {  } TEMP = spc_target
       if (ignoreBlockage == 0 && fatTblThreshold_Start < fatTblThreshold_1) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal3_blockage  {  } TEMP = spc_target
       }
       SET fatTblThreshold_Start = 0;
       SET fatTblThreshold_End = 0;
       SET fatTblThreshold_1 = 0;
    } else {
       if (ignoreBlockage == 0) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal3_blockage  {  } TEMP = spc_target
       }
    }
 
    if (fatTblEnclosedArea > 0) {
       SELECT holes INTERACT fat { } TEMP = fat_holes
       AREA fat_holes { 
          RANGE = [0.0001 * 0.0001 , fatTblEnclosedArea - 0.0001 * 0.0001 ]
       } TEMP = fat_holes
       if (fatTblMinEnclosedAreaMode==0) {
          SIZE fat_holes { OVER_UNDER = fatTblThreshold / 2.0 + 0.0001  } TEMP = ovun_holes
          SELECT ovun_holes INTERACT fat_holes { RANGE = [2, 9999999999 ] } TEMP = merged_holes
          BOOLEAN fat_candidate AND fat_target { } TEMP = fat_metal
          BOOLEAN metal3  NOT fat_metal { } TEMP = thin_metal
          BOOLEAN thin_metal NOT ovun_holes { } TEMP = thin_metal
          SELECT ovun_holes INTERACT thin_metal { } TEMP = thin_holes
          BOOLEAN thin_holes OR merged_holes { } TEMP = thin_holes
          BOOLEAN fat_holes NOT thin_holes { } TEMP = fat_holes
       }
       COPY fat_holes { 
	  COMMENT = "$layer_name EnclsArea : fat metal ( fatTblThreshold um) minimum enclosed area (mode fatTblMinEnclosedAreaMode ) = fatTblEnclosedArea um*um"
       } (15 )
       SET fatTblEnclosedArea = 0;
    }
    if (fatTblSpacing > 0) {
       /*check fat metal*/ 
       if (fatTblParallelLength > 0) {
          if (router_parallelLengthNetMode == 1 || parallelLengthMode == 1) {
             AREA spc_target { RANGE = [fatTblParallelLength * minWidth + 0.0001 , 9999999999 ] } TEMP = spc_target1
             COPY spc_target1 { } TEMP = spc_target2
          } else {
             COPY spc_target { } TEMP = spc_target2
          }
          if (parallelLengthMode == 1) {
             SELECT metal3  INTERACT fat { } TEMP = fat_all 
             BOOLEAN fat_all OR fat { } TEMP = fat2
             SELECT metal3  INTERACT spc_target2 { } TEMP = spc_target_all
             BOOLEAN spc_target_all OR spc_target2 { } TEMP = spc_target2
          } else {
             COPY fat { } TEMP = fat2
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING <= fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
                OUTPUT_EDGES = TRUE
             } TEMP = vio_edge
             SELECT vio_edge INTERACT fat { } TEMP = vio_edge
             SELECT vio_edge INTERACT spc_target1 { } TEMP = vio_edge
             SELECT violation INTERACT vio_edge { } TEMP = violation
          } else {
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
          }
          BOOLEAN violation NOT fat_target { } TEMP = violation
          if (fatTblParallelLength < fatTblSpacing) {
             SELECT_EDGE violation TOUCHING fat2 {
                VSIZE_INSIDE = fatTblParallelLength - 0.0002 
             } TEMP = vio_filter
             SELECT_CONTAINS vio_filter { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = vio_filter
             SELECT violation INTERACT vio_filter { } TEMP = violation
          } else {
             SELECT_CONTAINS violation { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = violation
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING = [fatTblSpacing, fatTblSpacing]
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
             } TEMP = violation3
             BOOLEAN violation3 NOT fat_target { } TEMP = violation3
             BOOLEAN violation NOT violation3 { } TEMP= violation
          }
          SELECT_EDGE fat2 TOUCHING violation { } TEMP=fat_viol
          BOOLEAN fat_viol AND violation { } TEMP=fat_viol
          SELECT_EDGE spc_target2 TOUCHING violation { } TEMP=spc_target2
          BOOLEAN spc_target2 AND violation { } TEMP= spc_target2
	  if (ignoreChildCell == 1) {
             EXTERNAL fat_viol spc_target2 {
		SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		TOUCH = FALSE
		POINT_TOUCH = FALSE
		NON_PARALLEL = TRUE
	     } TEMP = spc_mode0_out
             BOOLEAN spc_mode0_out NOT spc_mode0_child_out { } TEMP = spc_mode0_diff_out
             SELECT spc_mode0_out INTERACT spc_mode0_diff_out { } TEMP = spc_mode0_out
	     SELECT_EDGE fat2 TOUCHING spc_mode0_out { } TEMP=fat_viol
	     BOOLEAN fat_viol AND spc_mode0_out { } TEMP=fat_viol
	     SELECT_EDGE spc_target2 TOUCHING spc_mode0_out { } TEMP=spc_target2
	     BOOLEAN spc_target2 AND spc_mode0_out { } TEMP=spc_target2
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (15 )  		
	  } else {
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing 
	        SET_CORNERS_TO_SPACING = FALSE
	        PARALLEL_POINT_PROJECTION = FALSE
	        TOUCH = FALSE
	        POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (15 )
	  }
	  if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	     if (ignoreChildCell == 1) {
		EXTERNAL fat spc_target {
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} TEMP = spc_mode1_out
	        BOOLEAN spc_mode1_out NOT spc_mode1_child_out { } TEMP = spc_mode1_diff_out
	        SELECT spc_mode1_out INTERACT spc_mode1_diff_out { } TEMP = spc_mode1_out
                SELECT_EDGE fat TOUCHING spc_mode1_out { } TEMP=fat_viol
	        BOOLEAN fat_viol AND spc_mode1_out { } TEMP=fat_viol
	        SELECT_EDGE spc_target TOUCHING spc_mode1_out { } TEMP=spc_target2
	        BOOLEAN spc_target2 AND spc_mode1_out { } TEMP=spc_target2
	        EXTERNAL fat_viol spc_target2 {
	           COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um " 	    
		   SPACING < fatTblSpacing_dg
                   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} (15 )
	     } else {
	        EXTERNAL fat spc_target {
		   COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um "
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
	    	   PARALLEL_POINT_PROJECTION = FALSE
	           TOUCH = FALSE
	     	   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } (15 ) 
	     }
          }
       } else {
	  if (ignoreChildCell == 1) {
              EXTERNAL fat spc_target {
                 SPACING < fatTblSpacing
                 BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
              } TEMP = spc_out
	      BOOLEAN spc_out NOT spc_child_out { } TEMP = spc_diff_out
	      SELECT spc_out INTERACT spc_diff_out { } TEMP = spc_out
	      SELECT_EDGE fat TOUCHING spc_out { } TEMP=fat_viol
	      BOOLEAN fat_viol AND spc_out { } TEMP=fat_viol
              SELECT_EDGE spc_target TOUCHING spc_out { } TEMP=spc_target2
	      BOOLEAN spc_target2 AND spc_out { } TEMP=spc_target2
	      EXTERNAL fat_viol spc_target2 {
		 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
		 BOX_CORNER = FALSE 
		 NON_PARALLEL = TRUE
		 POINT_TOUCH = FALSE
	      } (15 ) 
	  } else {
	      EXTERNAL fat spc_target {
                 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
	         BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
	      } (15 ) 
	  }
       }
       /*check metal in the extension range*/ 
       if (fatTblExtensionRange > 0) {
	  if (fatWireExtensionMode == 0) {
	     SIZE fat { OVERSIZE = fatTblExtensionRange } TEMP = fat_tmp
             BOOLEAN fat_tmp AND metal3  { } TEMP = fat_tmp
  	     BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
             SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_ext
             BOOLEAN fat_ext OR fat { } TEMP = fat_ext
	     if (fatTblParallelLength > 0) {
                if (fatTblParallelLength > fatTblExtensionRange) {
                   SIZE fat { OVERSIZE = fatTblParallelLength } TEMP = fat_tmp
                   BOOLEAN fat_tmp AND metal3  { } TEMP = fat_tmp
  	           BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
                   SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_parallel
                   BOOLEAN fat_parallel OR fat { } TEMP = fat_parallel
                } else {
                   COPY fat_ext { } TEMP = fat_parallel
                }
		EXTERNAL fat_parallel spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
	           NON_PARALLEL = TRUE
	        } TEMP = vio_filter_set
		EXTERNAL fat_ext spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } TEMP = vio_set
                if (fatTblParallelLength < fatTblSpacing) {
                   SELECT_EDGE vio_filter_set TOUCHING fat_parallel {
                      VSIZE_INSIDE = fatTblParallelLength - 0.0002 
                   } TEMP = vio_filter_set_filter
                   SELECT_CONTAINS vio_filter_set_filter { 
                      WIDTH =  0.0002 
                      HEIGHT = fatTblParallelLength + 0.0001 
                   } TEMP = vio_filter_set_filter
                   SELECT vio_filter_set INTERACT vio_filter_set_filter { } TEMP = vio_filter
                } else {
	           SELECT_CONTAINS vio_filter_set { 
	              WIDTH =  0.0002 
	              HEIGHT = fatTblParallelLength + 0.0001 
	           } TEMP = vio_filter
                }
                SELECT vio_set INSIDE vio_filter { } TEMP = mode0_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out1 NOT mode0_child_out1 { } TEMP = mode0_diff_out1
                   SELECT mode0_out1 INTERACT mode0_diff_out1 { } TEMP = mode0_out1
                }
                COPY mode0_out1 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing  = fatTblSpacing um"
                } (15 )
		if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	           EXTERNAL fat_ext spc_target {
		      SPACING < fatTblSpacing_dg
	              SET_CORNERS_TO_SPACING = FALSE
		      PARALLEL_POINT_PROJECTION = FALSE
		      TOUCH = TRUE
		      POINT_TOUCH = FALSE
		      NON_PARALLEL = TRUE
	           } TEMP = mode0_out2
                   if (ignoreChildCell == 1) {
                      BOOLEAN mode0_out2 NOT mode0_child_out2 { } TEMP = mode0_diff_out2
                      SELECT mode0_out2 INTERACT mode0_diff_out2 { } TEMP = mode0_out2
                   }
                   COPY mode0_out2 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing (mode 1/2) = fatTblSpacing um/ fatTblSpacing_dg um "
                   } (15 )
	        } 
	     } else {
	        EXTERNAL fat_ext spc_target {
		   SPACING < fatTblSpacing
		   NON_PARALLEL = TRUE
		   SET_CORNERS_TO_SPACING = FALSE
		   POINT_TOUCH = FALSE
		} TEMP = mode0_out3
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out3 NOT mode0_child_out3 { } TEMP = mode0_diff_out3
                   SELECT mode0_out3 INTERACT mode0_diff_out3 { } TEMP = mode0_out3
                }
                COPY mode0_out3 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range ( fatTblExtensionRange um) minimum spacing = fatTblSpacing um"
                } (15 )
	     }
	  } else if (fatWireExtensionMode == 1) {
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal3  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             if (fatTblParallelLength > 0) {
                EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
		   BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   CHECK_SAME_POLYGON = TRUE 
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
	        SELECT fat_ext INTERACT spacing {  } TEMP = fat_ext
		BOOLEAN fat_ext OR spacing {  } TEMP = combined_fat_ext
                EXTERNAL combined_fat_ext fat {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
                } TEMP = fat_spacing
		BOOLEAN fat_spacing AND fat_ran {  } TEMP = fat_spacing
		BOOLEAN combined_fat_ext OR fat_spacing {  } TEMP = combined_fat_ext
                SELECT_CONTAINS combined_fat_ext { 
                   WIDTH =  0.0002 
                   HEIGHT = fatTblParallelLength + 0.0001 
                } TEMP = combined_fat_ext
		SELECT spacing INTERACT combined_fat_ext { 
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out1 NOT mode1_child_out1 { } TEMP = mode1_diff_out1
                   SELECT mode1_out1 INTERACT mode1_diff_out1 { } TEMP = mode1_out1 
                }
                COPY mode1_out1 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (15 ) 
	     } else {
               	EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
	           BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
	           CHECK_SAME_POLYGON = TRUE 
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
                SELECT spacing INTERACT fat_ext {
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out2
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out2 NOT mode1_child_out2 { } TEMP = mode1_diff_out2
                   SELECT mode1_out2 INTERACT mode1_diff_out2 { } TEMP = mode1_out2
                }
                COPY mode1_out2 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (15 )
	     }
	  } else if (fatWireExtensionMode == 2) {
	     SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
             BOOLEAN fat_ran AND metal3  {  } TEMP = fat_ext
             BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	      	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
             } TEMP = spacing
 	     SELECT spacing INSIDE fat_ran {  } TEMP = spacing
	     SELECT spacing OUTSIDE fat {  } TEMP = spacing
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode2_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode2_out NOT mode2_child_out { } TEMP = mode2_diff_out
                SELECT mode2_out INTERACT mode2_diff_out { } TEMP = mode2_out 
             }
             COPY mode2_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 2, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (15 )
	  } else if (fatWireExtensionMode == 3) {
             SIZE fat {
	        GROW_LEFT = fatTblExtensionRange
	        GROW_RIGHT = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal3  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	       	PARALLEL = TRUE

	       	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		HORIZONTAL_ONLY = TRUE
             } TEMP = spacing_hor
	     SELECT spacing_hor INSIDE fat_ran {  } TEMP = spacing_hor
	     SELECT spacing_hor OUTSIDE fat {  } TEMP = spacing_hor
             SIZE fat {
	        GROW_TOP = fatTblExtensionRange
	        GROW_BOTTOM = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal3  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	        POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		VERTICAL_ONLY = TRUE
             } TEMP = spacing_ver
	     SELECT spacing_ver INSIDE fat_ran {  } TEMP = spacing_ver
	     SELECT spacing_ver OUTSIDE fat {  } TEMP = spacing_ver
  	     BOOLEAN spacing_hor OR spacing_ver {  } TEMP = spacing
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal3  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
  	     /* check overlapped projection length */
 	     if (fatTblParallelLength > 0) {
                POLYGON_FEATURES fat_ext {
                   EQUATIONS {
                      vnum = EV_VNUM_IN;
                      if ( vnum > 0) {
                         bdLeft = EV_VXCOORD_IN[0];
                         bdRight = EV_VXCOORD_IN[0];
                         bdBottom = EV_VYCOORD_IN[0];
                         bdTop = EV_VYCOORD_IN[0];
                         FOR (i = 1; i < vnum; i++) {
                            if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
                            else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
                            if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
                            else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
                         } /* FOR i */
                         if ( (bdRight - bdLeft) >= fatTblParallelLength ||
                  	      (bdTop - bdBottom) >= fatTblParallelLength) {
                            FOR (i = 0; i < vnum; i++) {
                               EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
                               EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
                            }
                            EV_VNUM_OUT = vnum;
                 	    EV_SAVE_POLYGON();
                         }
                      }
                   }
                } TEMP = fat_ext /* POLYGON_FEATURE */
             }
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode3_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode3_out NOT mode3_child_out { } TEMP = mode3_diff_out
                SELECT mode3_out INTERACT mode3_diff_out { } TEMP = mode3_out
             }
             COPY mode3_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 3, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (15 )
          }
       }
       SET fatTblSpacing = 0;
    }
}
@ 450 "adrc/adrc.ev" 2


SET fatTblThreshold = 3.005;
SET fatTblParallelLength = 3.005;
SET minWidth = 0.056;

SET fatTblThreshold_Start = 0;
SET fatTblSpacing = 0.7;
@ 1 "adrc/adrc_fatMetal.ev" 1
/*check fat metal table*/
if (fatTblThreshold > 0) {
    if ((fatTblThreshold / 2.0) > 0.0001 ) {
       SIZE fat_candidate  { UNDER_OVER = fatTblThreshold / 2.0 - 0.0001  } TEMP = fat_candidate
       if (fatTblNextThreshold > 0) {
          SIZE fat_candidate { UNDER_OVER = fatTblNextThreshold / 2.0 - 0.0001  } TEMP = fat_next
          BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
          BOOLEAN fat AND fat_target { } TEMP = fat
          SET fatTblNextThreshold = 0;
       } else {
          BOOLEAN fat_candidate AND fat_target {  } TEMP = fat 
       }
    } else {
      COPY fat_target {  } TEMP = fat 
    }
    COPY fat_target { } TEMP = spc_target
    if (fatTblThreshold_Start > 0  || fatTblThreshold_End > 0) {
       if (fatTblThreshold_Start > 0) {
          SIZE fat_target { UNDER_OVER = fatTblThreshold_Start / 2.0 - 0.0001  } TEMP = spc_target
       }
       if (fatTblThreshold_End > 0 && fatTblThreshold_End > fatTblThreshold_Start) {
          SIZE spc_target { UNDER_OVER = fatTblThreshold_End / 2.0 - 0.0001  } TEMP = fat_end
          BOOLEAN spc_target NOT fat_end { } TEMP = spc_target
       }
       BOOLEAN spc_target AND fat_target {  } TEMP = spc_target
       if (ignoreBlockage == 0 && fatTblThreshold_Start < fatTblThreshold_1) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal3_blockage  {  } TEMP = spc_target
       }
       SET fatTblThreshold_Start = 0;
       SET fatTblThreshold_End = 0;
       SET fatTblThreshold_1 = 0;
    } else {
       if (ignoreBlockage == 0) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal3_blockage  {  } TEMP = spc_target
       }
    }
 
    if (fatTblEnclosedArea > 0) {
       SELECT holes INTERACT fat { } TEMP = fat_holes
       AREA fat_holes { 
          RANGE = [0.0001 * 0.0001 , fatTblEnclosedArea - 0.0001 * 0.0001 ]
       } TEMP = fat_holes
       if (fatTblMinEnclosedAreaMode==0) {
          SIZE fat_holes { OVER_UNDER = fatTblThreshold / 2.0 + 0.0001  } TEMP = ovun_holes
          SELECT ovun_holes INTERACT fat_holes { RANGE = [2, 9999999999 ] } TEMP = merged_holes
          BOOLEAN fat_candidate AND fat_target { } TEMP = fat_metal
          BOOLEAN metal3  NOT fat_metal { } TEMP = thin_metal
          BOOLEAN thin_metal NOT ovun_holes { } TEMP = thin_metal
          SELECT ovun_holes INTERACT thin_metal { } TEMP = thin_holes
          BOOLEAN thin_holes OR merged_holes { } TEMP = thin_holes
          BOOLEAN fat_holes NOT thin_holes { } TEMP = fat_holes
       }
       COPY fat_holes { 
	  COMMENT = "$layer_name EnclsArea : fat metal ( fatTblThreshold um) minimum enclosed area (mode fatTblMinEnclosedAreaMode ) = fatTblEnclosedArea um*um"
       } (15 )
       SET fatTblEnclosedArea = 0;
    }
    if (fatTblSpacing > 0) {
       /*check fat metal*/ 
       if (fatTblParallelLength > 0) {
          if (router_parallelLengthNetMode == 1 || parallelLengthMode == 1) {
             AREA spc_target { RANGE = [fatTblParallelLength * minWidth + 0.0001 , 9999999999 ] } TEMP = spc_target1
             COPY spc_target1 { } TEMP = spc_target2
          } else {
             COPY spc_target { } TEMP = spc_target2
          }
          if (parallelLengthMode == 1) {
             SELECT metal3  INTERACT fat { } TEMP = fat_all 
             BOOLEAN fat_all OR fat { } TEMP = fat2
             SELECT metal3  INTERACT spc_target2 { } TEMP = spc_target_all
             BOOLEAN spc_target_all OR spc_target2 { } TEMP = spc_target2
          } else {
             COPY fat { } TEMP = fat2
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING <= fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
                OUTPUT_EDGES = TRUE
             } TEMP = vio_edge
             SELECT vio_edge INTERACT fat { } TEMP = vio_edge
             SELECT vio_edge INTERACT spc_target1 { } TEMP = vio_edge
             SELECT violation INTERACT vio_edge { } TEMP = violation
          } else {
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
          }
          BOOLEAN violation NOT fat_target { } TEMP = violation
          if (fatTblParallelLength < fatTblSpacing) {
             SELECT_EDGE violation TOUCHING fat2 {
                VSIZE_INSIDE = fatTblParallelLength - 0.0002 
             } TEMP = vio_filter
             SELECT_CONTAINS vio_filter { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = vio_filter
             SELECT violation INTERACT vio_filter { } TEMP = violation
          } else {
             SELECT_CONTAINS violation { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = violation
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING = [fatTblSpacing, fatTblSpacing]
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
             } TEMP = violation3
             BOOLEAN violation3 NOT fat_target { } TEMP = violation3
             BOOLEAN violation NOT violation3 { } TEMP= violation
          }
          SELECT_EDGE fat2 TOUCHING violation { } TEMP=fat_viol
          BOOLEAN fat_viol AND violation { } TEMP=fat_viol
          SELECT_EDGE spc_target2 TOUCHING violation { } TEMP=spc_target2
          BOOLEAN spc_target2 AND violation { } TEMP= spc_target2
	  if (ignoreChildCell == 1) {
             EXTERNAL fat_viol spc_target2 {
		SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		TOUCH = FALSE
		POINT_TOUCH = FALSE
		NON_PARALLEL = TRUE
	     } TEMP = spc_mode0_out
             BOOLEAN spc_mode0_out NOT spc_mode0_child_out { } TEMP = spc_mode0_diff_out
             SELECT spc_mode0_out INTERACT spc_mode0_diff_out { } TEMP = spc_mode0_out
	     SELECT_EDGE fat2 TOUCHING spc_mode0_out { } TEMP=fat_viol
	     BOOLEAN fat_viol AND spc_mode0_out { } TEMP=fat_viol
	     SELECT_EDGE spc_target2 TOUCHING spc_mode0_out { } TEMP=spc_target2
	     BOOLEAN spc_target2 AND spc_mode0_out { } TEMP=spc_target2
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (15 )  		
	  } else {
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing 
	        SET_CORNERS_TO_SPACING = FALSE
	        PARALLEL_POINT_PROJECTION = FALSE
	        TOUCH = FALSE
	        POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (15 )
	  }
	  if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	     if (ignoreChildCell == 1) {
		EXTERNAL fat spc_target {
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} TEMP = spc_mode1_out
	        BOOLEAN spc_mode1_out NOT spc_mode1_child_out { } TEMP = spc_mode1_diff_out
	        SELECT spc_mode1_out INTERACT spc_mode1_diff_out { } TEMP = spc_mode1_out
                SELECT_EDGE fat TOUCHING spc_mode1_out { } TEMP=fat_viol
	        BOOLEAN fat_viol AND spc_mode1_out { } TEMP=fat_viol
	        SELECT_EDGE spc_target TOUCHING spc_mode1_out { } TEMP=spc_target2
	        BOOLEAN spc_target2 AND spc_mode1_out { } TEMP=spc_target2
	        EXTERNAL fat_viol spc_target2 {
	           COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um " 	    
		   SPACING < fatTblSpacing_dg
                   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} (15 )
	     } else {
	        EXTERNAL fat spc_target {
		   COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um "
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
	    	   PARALLEL_POINT_PROJECTION = FALSE
	           TOUCH = FALSE
	     	   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } (15 ) 
	     }
          }
       } else {
	  if (ignoreChildCell == 1) {
              EXTERNAL fat spc_target {
                 SPACING < fatTblSpacing
                 BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
              } TEMP = spc_out
	      BOOLEAN spc_out NOT spc_child_out { } TEMP = spc_diff_out
	      SELECT spc_out INTERACT spc_diff_out { } TEMP = spc_out
	      SELECT_EDGE fat TOUCHING spc_out { } TEMP=fat_viol
	      BOOLEAN fat_viol AND spc_out { } TEMP=fat_viol
              SELECT_EDGE spc_target TOUCHING spc_out { } TEMP=spc_target2
	      BOOLEAN spc_target2 AND spc_out { } TEMP=spc_target2
	      EXTERNAL fat_viol spc_target2 {
		 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
		 BOX_CORNER = FALSE 
		 NON_PARALLEL = TRUE
		 POINT_TOUCH = FALSE
	      } (15 ) 
	  } else {
	      EXTERNAL fat spc_target {
                 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
	         BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
	      } (15 ) 
	  }
       }
       /*check metal in the extension range*/ 
       if (fatTblExtensionRange > 0) {
	  if (fatWireExtensionMode == 0) {
	     SIZE fat { OVERSIZE = fatTblExtensionRange } TEMP = fat_tmp
             BOOLEAN fat_tmp AND metal3  { } TEMP = fat_tmp
  	     BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
             SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_ext
             BOOLEAN fat_ext OR fat { } TEMP = fat_ext
	     if (fatTblParallelLength > 0) {
                if (fatTblParallelLength > fatTblExtensionRange) {
                   SIZE fat { OVERSIZE = fatTblParallelLength } TEMP = fat_tmp
                   BOOLEAN fat_tmp AND metal3  { } TEMP = fat_tmp
  	           BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
                   SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_parallel
                   BOOLEAN fat_parallel OR fat { } TEMP = fat_parallel
                } else {
                   COPY fat_ext { } TEMP = fat_parallel
                }
		EXTERNAL fat_parallel spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
	           NON_PARALLEL = TRUE
	        } TEMP = vio_filter_set
		EXTERNAL fat_ext spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } TEMP = vio_set
                if (fatTblParallelLength < fatTblSpacing) {
                   SELECT_EDGE vio_filter_set TOUCHING fat_parallel {
                      VSIZE_INSIDE = fatTblParallelLength - 0.0002 
                   } TEMP = vio_filter_set_filter
                   SELECT_CONTAINS vio_filter_set_filter { 
                      WIDTH =  0.0002 
                      HEIGHT = fatTblParallelLength + 0.0001 
                   } TEMP = vio_filter_set_filter
                   SELECT vio_filter_set INTERACT vio_filter_set_filter { } TEMP = vio_filter
                } else {
	           SELECT_CONTAINS vio_filter_set { 
	              WIDTH =  0.0002 
	              HEIGHT = fatTblParallelLength + 0.0001 
	           } TEMP = vio_filter
                }
                SELECT vio_set INSIDE vio_filter { } TEMP = mode0_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out1 NOT mode0_child_out1 { } TEMP = mode0_diff_out1
                   SELECT mode0_out1 INTERACT mode0_diff_out1 { } TEMP = mode0_out1
                }
                COPY mode0_out1 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing  = fatTblSpacing um"
                } (15 )
		if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	           EXTERNAL fat_ext spc_target {
		      SPACING < fatTblSpacing_dg
	              SET_CORNERS_TO_SPACING = FALSE
		      PARALLEL_POINT_PROJECTION = FALSE
		      TOUCH = TRUE
		      POINT_TOUCH = FALSE
		      NON_PARALLEL = TRUE
	           } TEMP = mode0_out2
                   if (ignoreChildCell == 1) {
                      BOOLEAN mode0_out2 NOT mode0_child_out2 { } TEMP = mode0_diff_out2
                      SELECT mode0_out2 INTERACT mode0_diff_out2 { } TEMP = mode0_out2
                   }
                   COPY mode0_out2 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing (mode 1/2) = fatTblSpacing um/ fatTblSpacing_dg um "
                   } (15 )
	        } 
	     } else {
	        EXTERNAL fat_ext spc_target {
		   SPACING < fatTblSpacing
		   NON_PARALLEL = TRUE
		   SET_CORNERS_TO_SPACING = FALSE
		   POINT_TOUCH = FALSE
		} TEMP = mode0_out3
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out3 NOT mode0_child_out3 { } TEMP = mode0_diff_out3
                   SELECT mode0_out3 INTERACT mode0_diff_out3 { } TEMP = mode0_out3
                }
                COPY mode0_out3 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range ( fatTblExtensionRange um) minimum spacing = fatTblSpacing um"
                } (15 )
	     }
	  } else if (fatWireExtensionMode == 1) {
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal3  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             if (fatTblParallelLength > 0) {
                EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
		   BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   CHECK_SAME_POLYGON = TRUE 
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
	        SELECT fat_ext INTERACT spacing {  } TEMP = fat_ext
		BOOLEAN fat_ext OR spacing {  } TEMP = combined_fat_ext
                EXTERNAL combined_fat_ext fat {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
                } TEMP = fat_spacing
		BOOLEAN fat_spacing AND fat_ran {  } TEMP = fat_spacing
		BOOLEAN combined_fat_ext OR fat_spacing {  } TEMP = combined_fat_ext
                SELECT_CONTAINS combined_fat_ext { 
                   WIDTH =  0.0002 
                   HEIGHT = fatTblParallelLength + 0.0001 
                } TEMP = combined_fat_ext
		SELECT spacing INTERACT combined_fat_ext { 
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out1 NOT mode1_child_out1 { } TEMP = mode1_diff_out1
                   SELECT mode1_out1 INTERACT mode1_diff_out1 { } TEMP = mode1_out1 
                }
                COPY mode1_out1 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (15 ) 
	     } else {
               	EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
	           BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
	           CHECK_SAME_POLYGON = TRUE 
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
                SELECT spacing INTERACT fat_ext {
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out2
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out2 NOT mode1_child_out2 { } TEMP = mode1_diff_out2
                   SELECT mode1_out2 INTERACT mode1_diff_out2 { } TEMP = mode1_out2
                }
                COPY mode1_out2 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (15 )
	     }
	  } else if (fatWireExtensionMode == 2) {
	     SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
             BOOLEAN fat_ran AND metal3  {  } TEMP = fat_ext
             BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	      	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
             } TEMP = spacing
 	     SELECT spacing INSIDE fat_ran {  } TEMP = spacing
	     SELECT spacing OUTSIDE fat {  } TEMP = spacing
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode2_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode2_out NOT mode2_child_out { } TEMP = mode2_diff_out
                SELECT mode2_out INTERACT mode2_diff_out { } TEMP = mode2_out 
             }
             COPY mode2_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 2, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (15 )
	  } else if (fatWireExtensionMode == 3) {
             SIZE fat {
	        GROW_LEFT = fatTblExtensionRange
	        GROW_RIGHT = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal3  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	       	PARALLEL = TRUE

	       	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		HORIZONTAL_ONLY = TRUE
             } TEMP = spacing_hor
	     SELECT spacing_hor INSIDE fat_ran {  } TEMP = spacing_hor
	     SELECT spacing_hor OUTSIDE fat {  } TEMP = spacing_hor
             SIZE fat {
	        GROW_TOP = fatTblExtensionRange
	        GROW_BOTTOM = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal3  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	        POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		VERTICAL_ONLY = TRUE
             } TEMP = spacing_ver
	     SELECT spacing_ver INSIDE fat_ran {  } TEMP = spacing_ver
	     SELECT spacing_ver OUTSIDE fat {  } TEMP = spacing_ver
  	     BOOLEAN spacing_hor OR spacing_ver {  } TEMP = spacing
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal3  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
  	     /* check overlapped projection length */
 	     if (fatTblParallelLength > 0) {
                POLYGON_FEATURES fat_ext {
                   EQUATIONS {
                      vnum = EV_VNUM_IN;
                      if ( vnum > 0) {
                         bdLeft = EV_VXCOORD_IN[0];
                         bdRight = EV_VXCOORD_IN[0];
                         bdBottom = EV_VYCOORD_IN[0];
                         bdTop = EV_VYCOORD_IN[0];
                         FOR (i = 1; i < vnum; i++) {
                            if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
                            else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
                            if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
                            else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
                         } /* FOR i */
                         if ( (bdRight - bdLeft) >= fatTblParallelLength ||
                  	      (bdTop - bdBottom) >= fatTblParallelLength) {
                            FOR (i = 0; i < vnum; i++) {
                               EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
                               EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
                            }
                            EV_VNUM_OUT = vnum;
                 	    EV_SAVE_POLYGON();
                         }
                      }
                   }
                } TEMP = fat_ext /* POLYGON_FEATURE */
             }
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode3_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode3_out NOT mode3_child_out { } TEMP = mode3_diff_out
                SELECT mode3_out INTERACT mode3_diff_out { } TEMP = mode3_out
             }
             COPY mode3_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 3, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (15 )
          }
       }
       SET fatTblSpacing = 0;
    }
}
@ 458 "adrc/adrc.ev" 2


SET fatTblThreshold = 0;
SET fatTblEnclosedArea = 0;
SET fatTblExtensionRange = 0;
SET fatTblParallelLength = 0;
SET minWidth = 0;

/* End of Met3 fat table spacing rules */










/*metal 4*/
SET layer_name = "Met4";










SET minWidth = 0.056;
SET maxWidth = 5;
SET minArea = 0.016;
SET minEnclosedArea = 0.2;
SET minSpacing = 0.056;
SET sameNetMinSpacing = 0.056;
SET stub2StubSpacing = 0;

SET fatTblDimension = 5;
@ 1 "adrc/adrc_check_metal.ev" 1
/* Data Preparation */
if (fatTblDimension > 1 || fatWireThreshold > 0 || maxWidth > 0) {
  if (ignoreBlockage) {
      /* Let the real blockage be treated as thin */
      BOOLEAN metal4  NOT metal4_rbkg  {} TEMP=fat_candidate
  } else {
      COPY metal4  {} TEMP=fat_candidate
  }
  COPY fat_candidate {} TEMP=fat_target
}
/*Check width*/
if (minWidth > 0) {
    INTERNAL metal4  { 
        COMMENT = "$layer_name MinWidth  : minimum width = minWidth um" 
        SPACING < minWidth
        POINT_TOUCH = FALSE
    } (17 )
}
 
if (maxWidth > 0) {
    SIZE  fat_candidate {
        COMMENT = "$layer_name MaxWidth  : maximum width = maxWidth um"
 	UNDER_OVER = maxWidth / 2 
    } (17 ) 
}
 
/*Check area*/
if (minArea > 0) {
    AREA metal4  { 
	COMMENT = "$layer_name MinArea   : minimum area = minArea um*um"
	RANGE = [0.0001 * 0.0001 , minArea - 0.0001 * 0.0001 ]
    } (17 )
}
/* check min length of bounding box on polygon */
if (minLength > 0) {
  if (minLengthMode == 1) {
    INTERNAL metal4  {
        SPACING < minLength
        VERTICAL_ONLY = TRUE
        SET_CORNERS_TO_SPACING = FALSE
    } TEMP = ver_short
    BOOLEAN metal4  NOT ver_short { } TEMP = ver_long
    INTERNAL metal4  {
        SPACING < minLength
        HORIZONTAL_ONLY = TRUE
        SET_CORNERS_TO_SPACING = FALSE
    } TEMP = hor_short
    BOOLEAN metal4  NOT hor_short { } TEMP = hor_long
    SELECT CUT_LAYER1 INSIDE ver_long { } TEMP = good_cut
    BOOLEAN CUT_LAYER1 NOT good_cut { } TEMP = fail_cut_1
    SELECT fail_cut_1 INSIDE hor_long { } TEMP = good_cut
    BOOLEAN fail_cut_1 NOT good_cut { } TEMP = fail_cut_1
    SELECT CUT_LAYER2 INSIDE ver_long { } TEMP = good_cut
    BOOLEAN CUT_LAYER2 NOT good_cut { } TEMP = fail_cut_2
    SELECT fail_cut_2 INSIDE hor_long { } TEMP = good_cut
    BOOLEAN fail_cut_2 NOT good_cut { } TEMP = fail_cut_2
    BOOLEAN fail_cut_1 OR fail_cut_2 { } TEMP = fail_cut
    BOOLEAN hor_short NOT ver_long { } TEMP = hor_short
    BOOLEAN ver_short NOT hor_long { } TEMP = ver_short
    SELECT ver_short INTERACT fail_cut { } TEMP = ver_fail
    SELECT hor_short INTERACT fail_cut { } TEMP = hor_fail
    BOOLEAN ver_fail OR hor_fail { } TEMP = all_fail
    INTERNAL all_fail {
        COMMENT = "$layer_name MinLength : minimum length = minLength um"
        SPACING < minLength
        VERTICAL_ONLY = TRUE
        SET_CORNERS_TO_SPACING = FALSE
    } (17 )
  } else {
    POLYGON_FEATURES metal4  {
      COMMENT = "$layer_name MinLength : minimum length = minLength um"
      EQUATIONS {
        vnum = EV_VNUM_IN;
        if ( vnum > 0) {
	  bdLeft = EV_VXCOORD_IN[0];
	  bdRight = EV_VXCOORD_IN[0];
	  bdBottom = EV_VYCOORD_IN[0];
	  bdTop = EV_VYCOORD_IN[0];
          FOR (i = 1; i < vnum; i++) {
	    if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
            else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
	    if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
            else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
          }
	  if ( (bdRight - bdLeft) < minLength &&
	       (bdTop - bdBottom) < minLength) {
	    FOR (i = 0; i < vnum; i++) {
              EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
	      EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
            }
	    EV_VNUM_OUT = vnum;
	    EV_SAVE_POLYGON();
          }
        }
      }
    } (17 ) 
  }
  SET minLength = 0;
}
/* check max length of bounding box on polygon */
if (maxLength > 0) {
  POLYGON_FEATURES metal4  {
    COMMENT = "$layer_name MaxLength : maximum length = maxLength um"
    EQUATIONS {
      vnum = EV_VNUM_IN;
      if ( vnum > 0) {
	bdLeft = EV_VXCOORD_IN[0];
	bdRight = EV_VXCOORD_IN[0];
	bdBottom = EV_VYCOORD_IN[0];
	bdTop = EV_VYCOORD_IN[0];
        FOR (i = 1; i < vnum; i++) {
	  if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
          else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
	  if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
          else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
        }
	if ( (bdRight - bdLeft + bdTop - bdBottom) > maxLength ) {
          EV_VXCOORD_OUT[0] = bdLeft;
	  EV_VYCOORD_OUT[0] = bdBottom;
          EV_VXCOORD_OUT[1] = bdLeft;
	  EV_VYCOORD_OUT[1] = bdTop;
          EV_VXCOORD_OUT[2] = bdRight;
	  EV_VYCOORD_OUT[2] = bdTop;
          EV_VXCOORD_OUT[3] = bdRight;
	  EV_VYCOORD_OUT[3] = bdBottom;
          EV_VXCOORD_OUT[4] = bdLeft;
	  EV_VYCOORD_OUT[4] = bdBottom;
	  EV_VNUM_OUT = 5;
	  EV_SAVE_POLYGON();
        }
      }
    }
  } (17 ) 
  SET maxLength = 0;
}
 
/*Check enclosed area*/
if (minEnclosedArea > 0) {
    SELECT metal4  INSIDE_HOLE {
        INNER_HOLE_ONLY
    } TEMP = holes
    BOOLEAN holes NOT metal4  { } TEMP = holes
 
    AREA holes {
        COMMENT = "$layer_name EnclsArea : minimum enclosed area = minEnclosedArea um*um"
        RANGE = [0.0001 * 0.0001 , minEnclosedArea - 0.0001 * 0.0001 ]
    } (17 )
    /* check min length of bounding box on polygon */
    if (minEnclosedWidth > 0) {
      POLYGON_FEATURES holes {
        COMMENT = "$layer_name EnclsWidth: minimum enclosed Width = minEnclosedWidth um"
        EQUATIONS {
          vnum = EV_VNUM_IN;
          if ( vnum > 0) {
            bdLeft = EV_VXCOORD_IN[0];
            bdRight = EV_VXCOORD_IN[0];
            bdBottom = EV_VYCOORD_IN[0];
            bdTop = EV_VYCOORD_IN[0];
            FOR (i = 1; i < vnum; i++) {
              if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
              else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
              if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
              else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
            }
            if ( (bdRight - bdLeft) < minEnclosedWidth &&
                 (bdTop - bdBottom) < minEnclosedWidth) {
              FOR (i = 0; i < vnum; i++) {
                EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
                EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
              }
              EV_VNUM_OUT = vnum;
              EV_SAVE_POLYGON();
            }
          }
        }
      } (17 ) 
    }
}
 
/*check special notch rule*/
if ((minEdgeLength2 > 0.0001  && minEdgeLength3 > 0.0001 ) || minEdgeMode==2) {
  if (minEdgeMode==2) {
    SET minEdgeLength3 = minEdgeLength ;
  }
  NOTCH metal4  {
     SPACING < minEdgeLength3
     SET_CORNERS_TO_SPACING=FALSE
     PARALLEL = TRUE
     OUTPUT_EDGES = TRUE
  } TEMP = notch_vectors
  SELECT_VECTOR notch_vectors {
     LENGTH_RANGE = [0.0001 , minEdgeLength2 - 0.0001 ]
  } TEMP = short_edges
  EXTERNAL short_edges metal4  {
     SPACING < minEdgeLength3
     SET_CORNERS_TO_SPACING=FALSE
     PARALLEL = TRUE
  } TEMP = notch_err
  /* Choose the real U-shaped notch */
  SIZE notch_err { OVERSIZE = 0.0002 *10 } TEMP = neighbors 
  BOOLEAN neighbors AND metal4  { } TEMP = neighbors
  VERTEX neighbors { 
     CONCAVE = TRUE
     CONVEX = TRUE
     SIZE = 0.0002 
  } TEMP = corners
  SELECT_EDGE neighbors INTERACT notch_err { } TEMP = target_edges
  BOOLEAN target_edges NOT corners { } TEMP = target_edges
  VERTEX neighbors { 
     CONCAVE = TRUE
     SIZE = 2* 0.0002 
  } TEMP = corners
  SELECT target_edges INTERACT corners { RANGE = [2, 2] } TEMP=target_edges
  SELECT notch_err INTERACT target_edges {
     COMMENT = "$layer_name SpeclNotch: sameNetSp = minEdgeLength3 um (sideLen minEdgeLength2 um)" 
  } (17 )
}
/*check consecutive short edges*/
if (minEdgeLength > 0.0001  && minEdgeMode != 2) { 
  INTERNAL metal4_top  {
     SEGMENT < minEdgeLength
     FLAG_ACUTE_ANGLE = FALSE
     FLAG_ACUTE_EDGE = FALSE
     OUTPUT_EDGES = TRUE
  } TEMP = short_edges
  if ((minEdgeMode == 0 && maxTotalMinEdgeLength>0) || maxNumMinEdge > 0) {
    SET temporary_1 = 0.0002 *2;
    SET temporary_2 = 2*temporary_1+ 0.0001 ;
    SELECT metal4_top  INTERACT short_edges { } TEMP = target_top
    CLASSIFY_EDGES target_top {
       LENGTH = temporary_1
       DMIN   = temporary_2
       INSIDE_CORNER  TEMP = inside_corner_edges
       OUTSIDE_CORNER TEMP = outside_corner_edges
       REMAINDER      TEMP = remainder_edges
    }
    if (minEdgeMode == 0 && (maxNumMinEdge>0 || maxTotalMinEdgeLength > 0)) {
       SELECT short_edges ENCLOSING inside_corner_edges { } TEMP = short_edges
    }
  }
  if (maxTotalMinEdgeLength > 0) {
    LENGTH short_edges {
       RANGE = [maxTotalMinEdgeLength + 0.0001 , 9999999999 ]
    } TEMP = max_length_err
    /* Work around: translate polygons into dimensional check output */
    SIZE max_length_err { OVERSIZE = 2* 0.0002  } TEMP = max_length_err
    INTERNAL max_length_err {
       SPACING < 3* 0.0002 
       SET_CORNERS_TO_SPACING=FALSE
       COMMENT = "$layer_name MinEdgeLen: maximum total length ( minEdgeLength um)= maxTotalMinEdgeLength um"
    } (17 )
  }
  if (maxTotalMinEdgeLength == 0 || maxNumMinEdge > 0) {
    if (maxNumMinEdge==0)  {
       COPY short_edges {} TEMP=max_edge_err
    } else {
       SIZE short_edges {
         VSIZE_HEAD = - 0.0002 
        VSIZE_TAIL = - 0.0002 
       } TEMP = short_edges
       SIZE short_edges {
          OVERSIZE = 5* 0.0002 
          SIZE_ENDPOINTS = FALSE
       } TEMP = short_contours
       SELECT short_contours ENCLOSING remainder_edges {
          RANGE = [maxNumMinEdge + 1, 9999999999 ]
       } TEMP = short_contours
       SELECT short_edges INSIDE short_contours { } TEMP=max_edge_err
    }
    /* Work around: translate polygons into dimensional check output */
    SIZE max_edge_err { OVERSIZE = 2* 0.0002  } TEMP = max_edge_error
    INTERNAL max_edge_error {
       SPACING < 3* 0.0002 
       SET_CORNERS_TO_SPACING=FALSE
       COMMENT = "$layer_name MinEdgeLen: maximum number of consecutive short edges ( minEdgeLength um)= maxNumMinEdge"
    } (17 ) 
  }
}
 
/*check basic spacing*/
if (sameNetMinSpacing > 0 && sameNetMinSpacing != minSpacing) {
  if (sameNetMinSpacing > minSpacing) {
    /* Special condition for U-shaped Metal spacing rule */
    NOTCH metal4_pin  {
        SPACING < sameNetMinSpacing
        BOX_CORNER = FALSE 
        SET_CORNERS_TO_SPACING=FALSE
        NON_PARALLEL = TRUE
        OUTPUT_EDGES = TRUE
    } TEMP = errs_to_be_waived
    NOTCH metal4_top  {
	SPACING < sameNetMinSpacing
	BOX_CORNER = FALSE 
        SET_CORNERS_TO_SPACING=FALSE
	NON_PARALLEL = TRUE
        OUTPUT_EDGES = TRUE
    } TEMP = all_errs
    BOOLEAN all_errs NOT errs_to_be_waived { } TEMP=err_edge
    EXTERNAL err_edge metal4_top  {
	SPACING < sameNetMinSpacing
	BOX_CORNER = FALSE 
        SET_CORNERS_TO_SPACING=FALSE
	NON_PARALLEL = TRUE
    } TEMP = notch_err
    SIZE notch_err { OVERSIZE = 0.0002 *10 } TEMP = neighbors
    BOOLEAN neighbors AND metal4_top  { } TEMP = neighbors
    VERTEX neighbors { 
       CONCAVE = TRUE
       CONVEX = TRUE
       SIZE = 0.0002 
    } TEMP = corners
    SELECT_EDGE neighbors INTERACT notch_err { } TEMP = target_edges
    BOOLEAN target_edges AND notch_err { } TEMP = target_edges
    BOOLEAN target_edges NOT corners { } TEMP = target_edges
    VERTEX neighbors {
       CONCAVE = TRUE
       SIZE = 2* 0.0002 
    } TEMP = corners
    SELECT target_edges INTERACT corners { RANGE = [2, 2] } TEMP = target_edges
    SELECT notch_err TOUCHING target_edges {
      COMMENT = "$layer_name U-ShpNotch: U-shape notch minimum spacing = sameNetMinSpacing um" 
    } (17 )
  } else {
    NOTCH metal4  {
        COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = sameNetMinSpacing um" 
	SPACING < sameNetMinSpacing
	BOX_CORNER = FALSE 
	NON_PARALLEL = TRUE
    } (17 )
  }
  if (minSpacing > 0) {
    if (stubMode == 0 && stubSpacing > 0 && stubSpacing < minSpacing) {
	EXTERNAL metal4  {
	    COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um"
            LONGEDGE > stubThreshold + 0.0001 
	    LONGEDGE_TO_EDGE < minSpacing
	    SPACING <= 0
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            CHECK_SAME_POLYGON = TRUE 
	} (17 )
    } else {
        EXTERNAL metal4  {
	    COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um" 
	    SPACING < minSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
	    CHECK_SAME_POLYGON = FALSE
        } (17 )
    }
  }
} else {
  if (minSpacing > 0) {
    if (stubMode == 0 && stubSpacing > 0 && stubSpacing < minSpacing) {
        EXTERNAL metal4  {
            COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um"
            LONGEDGE > stubThreshold + 0.0001  
            LONGEDGE_TO_EDGE < minSpacing
            SPACING <= 0 
            BOX_CORNER = FALSE 
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            CHECK_SAME_POLYGON = TRUE 
        } (17 )
    } else {
        EXTERNAL metal4  {
	    COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um" 
            SPACING < minSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
	    CHECK_SAME_POLYGON = TRUE 
        } (17 )
    }
  }
}
 
/*check dogbone */
if (sameNetMinSpacing > 0 && sameNetWidthThreshold) {
  NOTCH metal4  {
    SPACING < sameNetMinSpacing
    BOX_CORNER = FALSE 
    NON_PARALLEL = TRUE
  } TEMP = dog_bone
 
  if (!layer_empty(dog_bone)) {
    SIZE dog_bone {EDGESIZE = sameNetWidthThreshold} TEMP = dog_ext
    BOOLEAN dog_ext NOT dog_bone {} TEMP = dog_ext
    BOOLEAN dog_ext AND metal4  {} TEMP = dog_ext
    if (!layer_empty(dog_ext)) {
      SELECT dog_ext EDGE_TOUCH dog_bone { OUTSIDE RANGE = [1, 9999999999 ] } TEMP = dog_ext
      NOTCH metal4  {
        SPACING < sameNetMinSpacing
        BOX_CORNER = FALSE 
        NON_PARALLEL = TRUE
	OUTPUT_EDGES = TRUE
      } TEMP = dog_bone
      SELECT dog_ext OUTSIDE dog_bone {} TEMP = dog_ext
      INTERNAL dog_ext {
	COMMENT = "$layer_name dogBone   : notch spacing = sameNetMinSpacing um width sameNetWidthThreshold um" 
	SPACING < sameNetWidthThreshold
      } (17 )
    }
  }
}
/*check basic fat spacing*/
if (fatWireThreshold > 0 && fatTblDimension == 0) {
    SIZE fat_candidate { UNDER_OVER = fatWireThreshold / 2.0 - 0.0001  } TEMP = m_fat
    BOOLEAN m_fat AND metal4  {  } TEMP = m_fat
    BOOLEAN metal4  NOT m_fat {  } TEMP = m_thin
    if (ignoreBlockage == 0) {
        /* the blockages on the metal_blockage layer are treated as thin blockages */
        BOOLEAN m_thin OR metal4_blockage  {  } TEMP = m_thin
    }
 
    if (fatFatMinSpacing > 0) {
	EXTERNAL m_fat {
	    COMMENT = "$layer_name FatWireSpc: fat & fat ( fatWireThreshold um) minimum spacing = fatFatMinSpacing um"
	    SPACING < fatFatMinSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = FALSE
	    CHECK_SAME_POLYGON = TRUE 
       } (17 )
    }
 
    if (fatThinMinSpacing > 0) {
	EXTERNAL m_fat m_thin {
	    COMMENT = "$layer_name FatWireSpc: fat & thin ( fatWireThreshold um) minimum spacing fatThinMinSpacing um"
	    SPACING < fatThinMinSpacing
 	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = FALSE
        } (17 )
    }
}
 
/*check thin blockage spacing*/
if (minSpacing > 0 && ignoreBlockage == 0) {
    if (!layer_empty (metal4_blockage )) {
	EXTERNAL metal4_blockage  metal4  {
	    COMMENT = "$layer_name Spacing   : metal & thin blockage minimum spacing = minSpacing um"
	    SPACING < minSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
            TOUCH = TRUE
        } (17 )
    }
}
/*check blockage overlap*/
/*check shorts between top_level routing and fram_blockages*/
if (minSpacing>0 || checkCrossHierShort>0) {
   if (ignoreBlockage == 0) {
      BOOLEAN metal4_blockage  or metal4_rbkg  {} TEMP=all_blockage
   } else {
      COPY metal4_rbkg  {} TEMP=all_blockage
   }
   BOOLEAN all_blockage AND metal4_top  {} TEMP = overlap_shape1
   EXTERNAL all_blockage metal4_top  {
      SPACING <= 0
      TOUCH = TRUE
   } TEMP = overlap_shape2
   if (checkCrossHierShort>0) {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
         COMMENT = "$layer_name Short Cross Hierarchy"
      } (17 )
   } else {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
         COMMENT = "$layer_name Overlap   : metal & blockage overlap"
      } (17 )
   }
}
 
if (fatPolyContactRule > 0) {
  /* Fat Poly Contact Rule: not new fat wire formed */
  if (readCellView > 0) {
     SIZE metal1 { UNDER_OVER = fatPolyContactRule / 2.0 - 0.0001  } TEMP = fat
     BOOLEAN fat AND metal1 {  } TEMP = fat 
  } else {
     SIZE metal1_top { UNDER_OVER = fatPolyContactRule / 2.0 - 0.0001  } TEMP = fat
     BOOLEAN fat AND metal1_top {  } TEMP = fat 
  }
  SIZE metal1_pin { UNDER_OVER = fatPolyContactRule / 2.0 - 0.0001  } TEMP = fat_pin
  BOOLEAN fat_pin AND metal1_pin {  } TEMP = fat_pin
  BOOLEAN fat NOT fat_pin {
    COMMENT = "$layer_name FatPolyContactRule: fatPolyContactRule um" 
  } (17 )
}
/* Special End-of-Line Spacing Rule */
if (stubMode == 0 && stubSpacing > 0 && stubSpacing < minSpacing) {
  EXTERNAL metal4  {
     COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 0)"
     LONGEDGE > stubThreshold + 0.0001 
     LONGEDGE_TO_EDGE <= 0 
     SPACING < stubSpacing 
     SET_CORNERS_TO_SPACING = FALSE
     PARALLEL_POINT_PROJECTION = FALSE
  } (17 )
} else if (stubMode > 0 && stubSpacing > minSpacing) {
  if (stubMode == 4) {
     INTERNAL metal4  {
        SEGMENT[90,90] < stubThreshold
        OUTPUT_EDGES = TRUE
     } TEMP = end_of_line
  } else {
     INTERNAL metal4  {
        SEGMENT[90,90] <= stubThreshold
        OUTPUT_EDGES = TRUE
     } TEMP = end_of_line
  }
  /* Quick filter to reduce the size of possible end of line */
  if (sideStubExt > 0) {
    SIZE end_of_line {
       VSIZE_HEAD = sideStubExt
       VSIZE_TAIL = sideStubExt
       OUTPUT_EDGES = TRUE
    } TEMP = eol_ext
  } else {
    COPY end_of_line { } TEMP=eol_ext
  }
  if (stub2StubSpacing > stubSpacing) {
     SET temporary_1 = stub2StubSpacing;
  } else {
     SET temporary_1 = stubSpacing; 
  }
  EXTERNAL eol_ext metal4  {
     SPACING < temporary_1
     TOUCH = TRUE
     OVERLAP = TRUE 
     SET_CORNERS_TO_SPACING = FALSE
     PARALLEL_POINT_PROJECTION = FALSE
     OUTPUT_EDGES = TRUE
  } TEMP=err_edge
  SELECT eol_ext INTERACT err_edge { } TEMP=eol_ext
  SELECT end_of_line INTERACT eol_ext { } TEMP=end_of_line 
  /* Reduce the size of METAL_LAYER */
  if (stubMode==3) {
     SIZE end_of_line {
        VSIZE_HEAD = stubSpacing 
        VSIZE_TAIL = stubSpacing 
        VSIZE_INSIDE = sideStubThreshold
        VSIZE_OUTSIDE = stubSpacing
     } TEMP = eol_filter 
  } else {
     if (stubMode == 1 && stubRange > 0) {
        SIZE end_of_line {
           VSIZE_HEAD = stubSpacing- 0.0001 
           VSIZE_TAIL = stubSpacing- 0.0001 
           VSIZE_OUTSIDE = stubSpacing- 0.0001 
        } TEMP = eol_filter
     } else {
        SIZE end_of_line {
           VSIZE_HEAD = stubSpacing- 0.0001 
           VSIZE_TAIL = stubSpacing- 0.0001 
           VSIZE_INSIDE = sideStubThreshold- 0.0001 
           VSIZE_OUTSIDE = stubSpacing- 0.0001 
        } TEMP = eol_filter
     }
  }
  SELECT metal4  INTERACT eol_filter { } TEMP=target_top
  /* Get the side edges and the whole eol of line set */
  SELECT_EDGE target_top INTERACT end_of_line { 
    POINT_TOUCH = TRUE
  } TEMP = eol_set
  VERTEX target_top { 
     CONCAVE = TRUE 
     CONVEX = TRUE
     SIZE = 0.0002 
  } TEMP = corners
  SELECT corners OUTSIDE end_of_line {} TEMP =corners 
  BOOLEAN eol_set NOT corners { } TEMP=eol_set
  BOOLEAN eol_set NOT end_of_line { } TEMP=side_edge
  /* find out the real end of line */
  if (stubRange > 0) {
     if (stubMode == 1) {
         COPY side_edge { } TEMP = all_side_edge
         LENGTH side_edge { SPACING <= stubRange- 0.0001  } TEMP=side_edge
     } else {
         LENGTH side_edge { SPACING < stubRange- 0.0002  } TEMP=eol_filter
         BOOLEAN side_edge NOT eol_filter { } TEMP=side_edge
     }
     SELECT end_of_line INTERACT side_edge { RANGE = [1,2] } TEMP = end_of_line
  } 
  if (stubMode == 1) {
    if (stub2StubSpacing > 0) {
       if (sideStubExt < 0) {
          SIZE end_of_line {
            VSIZE_HEAD = sideStubExt / 2
            VSIZE_TAIL = sideStubExt / 2
            OUTPUT_EDGES = TRUE
          } TEMP = eol_ext_tip
	 
          EXTERNAL eol_ext_tip {
            COMMENT = "$layer_name specEoLSpc: stub2Stubspacing= stub2StubSpacing um (mode = 1)"
            SPACING < stub2StubSpacing
            SET_CORNERS_TO_SPACING = FALSE
            PARALLEL_POINT_PROJECTION = TRUE
          } (17 )
       } else {
          EXTERNAL end_of_line {
            COMMENT = "$layer_name specEoLSpc: stub2Stubspacing= stub2StubSpacing um (mode = 1)"
            SPACING < stub2StubSpacing
            SET_CORNERS_TO_SPACING = FALSE
            PARALLEL_POINT_PROJECTION = FALSE
          } (17 )
       }
    }
    if (stubRange > 0) {
       SIZE end_of_line {
         VSIZE_INSIDE = 0.0002 
       } TEMP = eol_poly
       SELECT_EDGE eol_poly TOUCHING target_top { } TEMP=eol_edge
       EXTERNAL eol_edge target_top {
         COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
         CONVEX_TO_CONVEX < stubSpacing
         CONVEX_TO_CONVEX [POINT_PROJECTION] < stubSpacing
         CONVEX_TO_EDGE < stubSpacing
         CONCAVE_TO_CONVEX < stubSpacing
         LONGEDGE > 0.0002 
         LONGEDGE_TO_EDGE < stubSpacing
         SPACING <= 0
         SET_CORNERS_TO_SPACING = TRUE
         PARALLEL_POINT_PROJECTION = TRUE
       } (17 )
       SELECT all_side_edge INTERACT end_of_line { } TEMP = side_edge
       SIZE side_edge {
         VSIZE_HEAD = 0.0002 
         VSIZE_TAIL = 0.0002 
       } TEMP = side_edge_ext
       BOOLEAN side_edge_ext NOT side_edge { } TEMP = side_edge_ext
       SELECT side_edge_ext INTERACT end_of_line { } TEMP = side_edge_ext
       EXTERNAL side_edge_ext target_top {
         COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
         SPACING < stubSpacing
         SET_CORNERS_TO_SPACING = FALSE
         PARALLEL_POINT_PROJECTION = FALSE
       } (17 )
    } else {
       if (stub2StubSpacing > 0) {
         VECTORIZE target_top {
            DIRECTED=TRUE
         } TEMP=target_edges
         BOOLEAN target_edges NOT end_of_line { } TEMP = target_edges
         EXTERNAL end_of_line target_edges {
            COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
            SPACING < stubSpacing
            TOUCH=TRUE
            OVERLAP=TRUE
            SET_CORNERS_TO_SPACING=FALSE
            PARALLEL_POINT_PROJECTION=FALSE
         } (17 )
       } else {
         if (sideStubExt > 0) {
            SIZE end_of_line {
               VSIZE_HEAD = sideStubExt
               VSIZE_TAIL = sideStubExt
               OUTPUT_EDGES = TRUE
            } TEMP = end_of_line
            EXTERNAL end_of_line target_top {
               COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing ,crnKeepOut= sideStubExt um (mode = 1)"
               SPACING < stubSpacing
               TOUCH=TRUE
               OVERLAP=TRUE
               SET_CORNERS_TO_SPACING=FALSE
               PARALLEL_POINT_PROJECTION=FALSE
            } (17 )
         } else {
            EXTERNAL end_of_line target_top {
               COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
               SPACING < stubSpacing
               TOUCH=TRUE
               OVERLAP=TRUE
               SET_CORNERS_TO_SPACING=FALSE
               PARALLEL_POINT_PROJECTION=FALSE
            } (17 )
         }
       }
    }
  } else { /* stubMode == 2,3,4 */
    /* stubMode 2 eol classify and reduction */
    if (stubMode !=3 && sideStubExt > 0) {
      if (stubMode == 4) {
        SIZE end_of_line {
           VSIZE_HEAD = sideStubExt
           VSIZE_TAIL = sideStubExt
           OUTPUT_EDGES = TRUE
        } TEMP = eol_ext
        EXTERNAL eol_ext target_top {
           SPACING < stubSpacing
           SET_CORNERS_TO_SPACING=FALSE
           PARALLEL_POINT_PROJECTION=FALSE
           OUTPUT_EDGES = TRUE
        } TEMP=err_edge
        SELECT eol_ext INTERACT err_edge { } TEMP=eol_ext
      } else {
        EXTERNAL end_of_line target_top {
           SPACING < stubSpacing
           SET_CORNERS_TO_SPACING=FALSE
           PARALLEL_POINT_PROJECTION=FALSE
           OUTPUT_EDGES = TRUE
        } TEMP=err_edge
        SELECT end_of_line INTERACT err_edge { } TEMP=eol_body
        SIZE end_of_line {
           VSIZE_HEAD = sideStubExt
           VSIZE_TAIL = sideStubExt
           OUTPUT_EDGES = TRUE
        } TEMP = eol_ext
        BOOLEAN eol_ext NOT end_of_line {} TEMP=eol_ext
        EXTERNAL eol_ext target_top {
           SPACING < stubSpacing
           SET_CORNERS_TO_SPACING=FALSE
           PARALLEL_POINT_PROJECTION=FALSE
           OUTPUT_EDGES = TRUE
        } TEMP=err_edge
        SELECT eol_ext INTERACT err_edge { } TEMP=eol_ext
        BOOLEAN eol_body OR eol_ext { } TEMP=eol_ext
      } 
    } else {
      COPY end_of_line { } TEMP=eol_ext
    }
    SELECT side_edge INTERACT eol_ext { } TEMP=side_edge
    SIZE eol_ext {
       VSIZE_INSIDE = sideStubThreshold 
       VSIZE_OUTSIDE = sideStubExt
    } TEMP = eol_range
    if (sideStubExt > 0) {
       SIZE side_edge {
          VSIZE_HEAD = sideStubExt
          VSIZE_TAIL = sideStubExt
          OUTPUT_EDGES = TRUE
       } TEMP = check_edge
    } else {
       COPY side_edge { } TEMP = check_edge
    }
    BOOLEAN check_edge AND eol_range { } TEMP=check_edge
    EXTERNAL check_edge target_top {
       SPACING < temporary_1
       SET_CORNERS_TO_SPACING = FALSE
       SHADOW_OTHER_LAYER = TRUE
       PARALLEL_POINT_PROJECTION = FALSE
       OUTPUT_EDGES = TRUE
    } TEMP=err_edge
    if (0 && stubMode!=4) { /* Temporarily do not check mode 2,3 side edge length */
       LENGTH side_edge { SPACING < stubSpacing- 0.0001 *2 } TEMP=err_edge_1
       BOOLEAN err_edge OR err_edge_1 { } TEMP=err_edge
    }
    SELECT check_edge INTERACT err_edge { } TEMP=side_edge
    if (stubMode!=3) {
       SELECT eol_ext INTERACT side_edge {} TEMP=err_eol
       EXTERNAL err_eol target_top {
          COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing ,crnKeepOut= sideStubExt um (mode = stubMode )"
          SPACING < temporary_1
          PARALLEL_POINT_PROJECTION=FALSE
          SET_CORNERS_TO_SPACING=FALSE
       } (17 )
    } else { /* stubMode == 3 */
       SELECT eol_ext INTERACT side_edge { RANGE = [2, 2] } TEMP=err_eol
       EXTERNAL err_eol target_top {
          COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 3)"
          SPACING < temporary_1
          PARALLEL_POINT_PROJECTION=FALSE
          SET_CORNERS_TO_SPACING=FALSE
       } (17 )
    }
  }
} /* stubMode > 0, not aligned */
/* Avoid empty optimization result parsing error */
if (addEmptyMetalCheck) {
   BOOLEAN empty OR empty {
      COMMENT = "$layer_name Empty: Dummy Output"
   } (17 )
   SET addEmptyMetalCheck=0;
}
/* reset variables */


 
SET minWidth = 0;
SET maxWidth = 0;
SET minArea = 0;
SET minEnclosedArea = 0;
SET minSpacing = 0;
SET sameNetMinSpacing = 0;
SET maxNumMinEdge = 0;
SET maxTotalMinEdgeLength = 0;
SET minEdgeLength = 0;
SET minEdgeLength2 = 0;
SET minEdgeLength3 = 0;
SET stubRange = 0;
SET stubSpacing = 0;
SET stub2StubSpacing = 0;
SET sideStubExt = 0;
SET sideStubThreshold = 0;
SET stubThreshold = 0;
SET fatPolyContactRule = 0;
SET fatWireThreshold = 0;
SET fatThinMinSpacing = 0;
SET fatFatMinSpacing = 0;
SET fatTblDimension = 0;
@ 498 "adrc/adrc.ev" 2

SET minSpacing = 0.056;
SET fatTblThresh_protru = 0.15;
SET fatTblLength_protru = 0.1;
SET fatTblWidth_protru = 0.06;
@ 1 "adrc/adrc_protru.ev" 1
/*protrusion length rule*/
SIZE metal4     { UNDER_OVER = fatTblThresh_protru / 2.0 - 0.0001  } TEMP = fat
BOOLEAN fat AND metal4  {  } TEMP = fat 
BOOLEAN metal4  NOT fat {  } TEMP = fat_nbr
SIZE fat { OVERSIZE = fatTblLength_protru + 0.0001  } TEMP = fat_ext
BOOLEAN fat_nbr AND fat_ext {} TEMP = fat_nbr
SELECT fat_nbr INTERACT fat TEMP = fat_nbr
/* Get the correct fat extension */
SELECT_EDGE fat_nbr TOUCHING fat { } TEMP = ext_filter
SIZE ext_filter { VSIZE_INSIDE = 0.0001  } TEMP = ext_filter
SIZE ext_filter INSIDE fat_nbr {
   OVERSIZE = fatTblLength_protru- 0.0001 
   INCREMENT = minSpacing
} TEMP=dummy TEMP = fat_nbr
  
VERTEX fat_nbr {
   CONCAVE = TRUE
   SIZE = 0.0002 
} TEMP = corners
SELECT fat_nbr OUTSIDE corners { } TEMP = fat_nbr1
BOOLEAN fat_nbr NOT fat_nbr1 { } TEMP = fat_nbr2
SELECT_CONTAINS fat_nbr1 {
   WIDTH =  0.0002 
   HEIGHT = fatTblLength_protru
} TEMP = good_fat_nbr1
BOOLEAN fat_nbr1 NOT good_fat_nbr1 { } TEMP = fat_nbr1
/* check with L or T shape of fat extension */
SELECT_EDGE fat_nbr2 INTERACT corners { } TEMP = side_edge
LENGTH side_edge { SPACING < fatTblLength_protru } TEMP = vio_edge
SELECT fat_nbr2 INTERACT vio_edge { } TEMP = fat_nbr2
BOOLEAN fat_nbr1 OR fat_nbr2 { } TEMP = fat_nbr
INTERAL fat_nbr {
   SPACING < fatTblWidth_protru
} TEMP = possible_err
if (!layer_empty(possible_err)) {
   SELECT fat_nbr INTERACT possible_err { } TEMP=fat_nbr
   SELECT fat INTERACT fat_nbr {} TEMP=fat
   BOOLEAN fat OR fat_nbr {} TEMP=fat
   INTERNAL fat {
      COMMENT = "$layer_name ProtrusionLength : threshold fatTblThresh_protru um, length  fatTblLength_protru um, width fatTblWidth_protru um"
      SPACING < fatTblWidth_protru
   } (17 )
}
/* protrusion leng rule check */
SET fatTblThresh_protru = 0;
SET fatTblLength_protru = 0;
SET fatTblWidth_protru = 0;
SET minSpacing = 0;
@ 503 "adrc/adrc.ev" 2


SET minSpacing = 0.056;
SET fatTblThresh_protru = 0.3;
SET fatTblLength_protru = 0.15;
SET fatTblWidth_protru = 0.07;
@ 1 "adrc/adrc_protru.ev" 1
/*protrusion length rule*/
SIZE metal4     { UNDER_OVER = fatTblThresh_protru / 2.0 - 0.0001  } TEMP = fat
BOOLEAN fat AND metal4  {  } TEMP = fat 
BOOLEAN metal4  NOT fat {  } TEMP = fat_nbr
SIZE fat { OVERSIZE = fatTblLength_protru + 0.0001  } TEMP = fat_ext
BOOLEAN fat_nbr AND fat_ext {} TEMP = fat_nbr
SELECT fat_nbr INTERACT fat TEMP = fat_nbr
/* Get the correct fat extension */
SELECT_EDGE fat_nbr TOUCHING fat { } TEMP = ext_filter
SIZE ext_filter { VSIZE_INSIDE = 0.0001  } TEMP = ext_filter
SIZE ext_filter INSIDE fat_nbr {
   OVERSIZE = fatTblLength_protru- 0.0001 
   INCREMENT = minSpacing
} TEMP=dummy TEMP = fat_nbr
  
VERTEX fat_nbr {
   CONCAVE = TRUE
   SIZE = 0.0002 
} TEMP = corners
SELECT fat_nbr OUTSIDE corners { } TEMP = fat_nbr1
BOOLEAN fat_nbr NOT fat_nbr1 { } TEMP = fat_nbr2
SELECT_CONTAINS fat_nbr1 {
   WIDTH =  0.0002 
   HEIGHT = fatTblLength_protru
} TEMP = good_fat_nbr1
BOOLEAN fat_nbr1 NOT good_fat_nbr1 { } TEMP = fat_nbr1
/* check with L or T shape of fat extension */
SELECT_EDGE fat_nbr2 INTERACT corners { } TEMP = side_edge
LENGTH side_edge { SPACING < fatTblLength_protru } TEMP = vio_edge
SELECT fat_nbr2 INTERACT vio_edge { } TEMP = fat_nbr2
BOOLEAN fat_nbr1 OR fat_nbr2 { } TEMP = fat_nbr
INTERAL fat_nbr {
   SPACING < fatTblWidth_protru
} TEMP = possible_err
if (!layer_empty(possible_err)) {
   SELECT fat_nbr INTERACT possible_err { } TEMP=fat_nbr
   SELECT fat INTERACT fat_nbr {} TEMP=fat
   BOOLEAN fat OR fat_nbr {} TEMP=fat
   INTERNAL fat {
      COMMENT = "$layer_name ProtrusionLength : threshold fatTblThresh_protru um, length  fatTblLength_protru um, width fatTblWidth_protru um"
      SPACING < fatTblWidth_protru
   } (17 )
}
/* protrusion leng rule check */
SET fatTblThresh_protru = 0;
SET fatTblLength_protru = 0;
SET fatTblWidth_protru = 0;
SET minSpacing = 0;
@ 509 "adrc/adrc.ev" 2


SET minSpacing = 0.056;
SET fatTblThresh_protru = 1.5;
SET fatTblLength_protru = 0.7;
SET fatTblWidth_protru = 0.15;
@ 1 "adrc/adrc_protru.ev" 1
/*protrusion length rule*/
SIZE metal4     { UNDER_OVER = fatTblThresh_protru / 2.0 - 0.0001  } TEMP = fat
BOOLEAN fat AND metal4  {  } TEMP = fat 
BOOLEAN metal4  NOT fat {  } TEMP = fat_nbr
SIZE fat { OVERSIZE = fatTblLength_protru + 0.0001  } TEMP = fat_ext
BOOLEAN fat_nbr AND fat_ext {} TEMP = fat_nbr
SELECT fat_nbr INTERACT fat TEMP = fat_nbr
/* Get the correct fat extension */
SELECT_EDGE fat_nbr TOUCHING fat { } TEMP = ext_filter
SIZE ext_filter { VSIZE_INSIDE = 0.0001  } TEMP = ext_filter
SIZE ext_filter INSIDE fat_nbr {
   OVERSIZE = fatTblLength_protru- 0.0001 
   INCREMENT = minSpacing
} TEMP=dummy TEMP = fat_nbr
  
VERTEX fat_nbr {
   CONCAVE = TRUE
   SIZE = 0.0002 
} TEMP = corners
SELECT fat_nbr OUTSIDE corners { } TEMP = fat_nbr1
BOOLEAN fat_nbr NOT fat_nbr1 { } TEMP = fat_nbr2
SELECT_CONTAINS fat_nbr1 {
   WIDTH =  0.0002 
   HEIGHT = fatTblLength_protru
} TEMP = good_fat_nbr1
BOOLEAN fat_nbr1 NOT good_fat_nbr1 { } TEMP = fat_nbr1
/* check with L or T shape of fat extension */
SELECT_EDGE fat_nbr2 INTERACT corners { } TEMP = side_edge
LENGTH side_edge { SPACING < fatTblLength_protru } TEMP = vio_edge
SELECT fat_nbr2 INTERACT vio_edge { } TEMP = fat_nbr2
BOOLEAN fat_nbr1 OR fat_nbr2 { } TEMP = fat_nbr
INTERAL fat_nbr {
   SPACING < fatTblWidth_protru
} TEMP = possible_err
if (!layer_empty(possible_err)) {
   SELECT fat_nbr INTERACT possible_err { } TEMP=fat_nbr
   SELECT fat INTERACT fat_nbr {} TEMP=fat
   BOOLEAN fat OR fat_nbr {} TEMP=fat
   INTERNAL fat {
      COMMENT = "$layer_name ProtrusionLength : threshold fatTblThresh_protru um, length  fatTblLength_protru um, width fatTblWidth_protru um"
      SPACING < fatTblWidth_protru
   } (17 )
}
/* protrusion leng rule check */
SET fatTblThresh_protru = 0;
SET fatTblLength_protru = 0;
SET fatTblWidth_protru = 0;
SET minSpacing = 0;
@ 515 "adrc/adrc.ev" 2


SET minSpacing = 0.056;
SET fatTblThresh_protru = 3;
SET fatTblLength_protru = 1.5;
SET fatTblWidth_protru = 0.3;
@ 1 "adrc/adrc_protru.ev" 1
/*protrusion length rule*/
SIZE metal4     { UNDER_OVER = fatTblThresh_protru / 2.0 - 0.0001  } TEMP = fat
BOOLEAN fat AND metal4  {  } TEMP = fat 
BOOLEAN metal4  NOT fat {  } TEMP = fat_nbr
SIZE fat { OVERSIZE = fatTblLength_protru + 0.0001  } TEMP = fat_ext
BOOLEAN fat_nbr AND fat_ext {} TEMP = fat_nbr
SELECT fat_nbr INTERACT fat TEMP = fat_nbr
/* Get the correct fat extension */
SELECT_EDGE fat_nbr TOUCHING fat { } TEMP = ext_filter
SIZE ext_filter { VSIZE_INSIDE = 0.0001  } TEMP = ext_filter
SIZE ext_filter INSIDE fat_nbr {
   OVERSIZE = fatTblLength_protru- 0.0001 
   INCREMENT = minSpacing
} TEMP=dummy TEMP = fat_nbr
  
VERTEX fat_nbr {
   CONCAVE = TRUE
   SIZE = 0.0002 
} TEMP = corners
SELECT fat_nbr OUTSIDE corners { } TEMP = fat_nbr1
BOOLEAN fat_nbr NOT fat_nbr1 { } TEMP = fat_nbr2
SELECT_CONTAINS fat_nbr1 {
   WIDTH =  0.0002 
   HEIGHT = fatTblLength_protru
} TEMP = good_fat_nbr1
BOOLEAN fat_nbr1 NOT good_fat_nbr1 { } TEMP = fat_nbr1
/* check with L or T shape of fat extension */
SELECT_EDGE fat_nbr2 INTERACT corners { } TEMP = side_edge
LENGTH side_edge { SPACING < fatTblLength_protru } TEMP = vio_edge
SELECT fat_nbr2 INTERACT vio_edge { } TEMP = fat_nbr2
BOOLEAN fat_nbr1 OR fat_nbr2 { } TEMP = fat_nbr
INTERAL fat_nbr {
   SPACING < fatTblWidth_protru
} TEMP = possible_err
if (!layer_empty(possible_err)) {
   SELECT fat_nbr INTERACT possible_err { } TEMP=fat_nbr
   SELECT fat INTERACT fat_nbr {} TEMP=fat
   BOOLEAN fat OR fat_nbr {} TEMP=fat
   INTERNAL fat {
      COMMENT = "$layer_name ProtrusionLength : threshold fatTblThresh_protru um, length  fatTblLength_protru um, width fatTblWidth_protru um"
      SPACING < fatTblWidth_protru
   } (17 )
}
/* protrusion leng rule check */
SET fatTblThresh_protru = 0;
SET fatTblLength_protru = 0;
SET fatTblWidth_protru = 0;
SET minSpacing = 0;
@ 521 "adrc/adrc.ev" 2





/* Start of Met4 fat table spacing rules */
SET fatTblSpacingMode = 0;
SET parallelLengthMode = 0;
SET router_parallelLengthNetMode = 0;

SET fatTblThreshold = 0.155;
SET fatTblParallelLength = 0.155;
SET minWidth = 0.056;

SET fatTblThreshold_Start = 0;
SET fatTblSpacing = 0.064;
@ 1 "adrc/adrc_fatMetal.ev" 1
/*check fat metal table*/
if (fatTblThreshold > 0) {
    if ((fatTblThreshold / 2.0) > 0.0001 ) {
       SIZE fat_candidate  { UNDER_OVER = fatTblThreshold / 2.0 - 0.0001  } TEMP = fat_candidate
       if (fatTblNextThreshold > 0) {
          SIZE fat_candidate { UNDER_OVER = fatTblNextThreshold / 2.0 - 0.0001  } TEMP = fat_next
          BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
          BOOLEAN fat AND fat_target { } TEMP = fat
          SET fatTblNextThreshold = 0;
       } else {
          BOOLEAN fat_candidate AND fat_target {  } TEMP = fat 
       }
    } else {
      COPY fat_target {  } TEMP = fat 
    }
    COPY fat_target { } TEMP = spc_target
    if (fatTblThreshold_Start > 0  || fatTblThreshold_End > 0) {
       if (fatTblThreshold_Start > 0) {
          SIZE fat_target { UNDER_OVER = fatTblThreshold_Start / 2.0 - 0.0001  } TEMP = spc_target
       }
       if (fatTblThreshold_End > 0 && fatTblThreshold_End > fatTblThreshold_Start) {
          SIZE spc_target { UNDER_OVER = fatTblThreshold_End / 2.0 - 0.0001  } TEMP = fat_end
          BOOLEAN spc_target NOT fat_end { } TEMP = spc_target
       }
       BOOLEAN spc_target AND fat_target {  } TEMP = spc_target
       if (ignoreBlockage == 0 && fatTblThreshold_Start < fatTblThreshold_1) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal4_blockage  {  } TEMP = spc_target
       }
       SET fatTblThreshold_Start = 0;
       SET fatTblThreshold_End = 0;
       SET fatTblThreshold_1 = 0;
    } else {
       if (ignoreBlockage == 0) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal4_blockage  {  } TEMP = spc_target
       }
    }
 
    if (fatTblEnclosedArea > 0) {
       SELECT holes INTERACT fat { } TEMP = fat_holes
       AREA fat_holes { 
          RANGE = [0.0001 * 0.0001 , fatTblEnclosedArea - 0.0001 * 0.0001 ]
       } TEMP = fat_holes
       if (fatTblMinEnclosedAreaMode==0) {
          SIZE fat_holes { OVER_UNDER = fatTblThreshold / 2.0 + 0.0001  } TEMP = ovun_holes
          SELECT ovun_holes INTERACT fat_holes { RANGE = [2, 9999999999 ] } TEMP = merged_holes
          BOOLEAN fat_candidate AND fat_target { } TEMP = fat_metal
          BOOLEAN metal4  NOT fat_metal { } TEMP = thin_metal
          BOOLEAN thin_metal NOT ovun_holes { } TEMP = thin_metal
          SELECT ovun_holes INTERACT thin_metal { } TEMP = thin_holes
          BOOLEAN thin_holes OR merged_holes { } TEMP = thin_holes
          BOOLEAN fat_holes NOT thin_holes { } TEMP = fat_holes
       }
       COPY fat_holes { 
	  COMMENT = "$layer_name EnclsArea : fat metal ( fatTblThreshold um) minimum enclosed area (mode fatTblMinEnclosedAreaMode ) = fatTblEnclosedArea um*um"
       } (17 )
       SET fatTblEnclosedArea = 0;
    }
    if (fatTblSpacing > 0) {
       /*check fat metal*/ 
       if (fatTblParallelLength > 0) {
          if (router_parallelLengthNetMode == 1 || parallelLengthMode == 1) {
             AREA spc_target { RANGE = [fatTblParallelLength * minWidth + 0.0001 , 9999999999 ] } TEMP = spc_target1
             COPY spc_target1 { } TEMP = spc_target2
          } else {
             COPY spc_target { } TEMP = spc_target2
          }
          if (parallelLengthMode == 1) {
             SELECT metal4  INTERACT fat { } TEMP = fat_all 
             BOOLEAN fat_all OR fat { } TEMP = fat2
             SELECT metal4  INTERACT spc_target2 { } TEMP = spc_target_all
             BOOLEAN spc_target_all OR spc_target2 { } TEMP = spc_target2
          } else {
             COPY fat { } TEMP = fat2
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING <= fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
                OUTPUT_EDGES = TRUE
             } TEMP = vio_edge
             SELECT vio_edge INTERACT fat { } TEMP = vio_edge
             SELECT vio_edge INTERACT spc_target1 { } TEMP = vio_edge
             SELECT violation INTERACT vio_edge { } TEMP = violation
          } else {
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
          }
          BOOLEAN violation NOT fat_target { } TEMP = violation
          if (fatTblParallelLength < fatTblSpacing) {
             SELECT_EDGE violation TOUCHING fat2 {
                VSIZE_INSIDE = fatTblParallelLength - 0.0002 
             } TEMP = vio_filter
             SELECT_CONTAINS vio_filter { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = vio_filter
             SELECT violation INTERACT vio_filter { } TEMP = violation
          } else {
             SELECT_CONTAINS violation { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = violation
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING = [fatTblSpacing, fatTblSpacing]
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
             } TEMP = violation3
             BOOLEAN violation3 NOT fat_target { } TEMP = violation3
             BOOLEAN violation NOT violation3 { } TEMP= violation
          }
          SELECT_EDGE fat2 TOUCHING violation { } TEMP=fat_viol
          BOOLEAN fat_viol AND violation { } TEMP=fat_viol
          SELECT_EDGE spc_target2 TOUCHING violation { } TEMP=spc_target2
          BOOLEAN spc_target2 AND violation { } TEMP= spc_target2
	  if (ignoreChildCell == 1) {
             EXTERNAL fat_viol spc_target2 {
		SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		TOUCH = FALSE
		POINT_TOUCH = FALSE
		NON_PARALLEL = TRUE
	     } TEMP = spc_mode0_out
             BOOLEAN spc_mode0_out NOT spc_mode0_child_out { } TEMP = spc_mode0_diff_out
             SELECT spc_mode0_out INTERACT spc_mode0_diff_out { } TEMP = spc_mode0_out
	     SELECT_EDGE fat2 TOUCHING spc_mode0_out { } TEMP=fat_viol
	     BOOLEAN fat_viol AND spc_mode0_out { } TEMP=fat_viol
	     SELECT_EDGE spc_target2 TOUCHING spc_mode0_out { } TEMP=spc_target2
	     BOOLEAN spc_target2 AND spc_mode0_out { } TEMP=spc_target2
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (17 )  		
	  } else {
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing 
	        SET_CORNERS_TO_SPACING = FALSE
	        PARALLEL_POINT_PROJECTION = FALSE
	        TOUCH = FALSE
	        POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (17 )
	  }
	  if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	     if (ignoreChildCell == 1) {
		EXTERNAL fat spc_target {
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} TEMP = spc_mode1_out
	        BOOLEAN spc_mode1_out NOT spc_mode1_child_out { } TEMP = spc_mode1_diff_out
	        SELECT spc_mode1_out INTERACT spc_mode1_diff_out { } TEMP = spc_mode1_out
                SELECT_EDGE fat TOUCHING spc_mode1_out { } TEMP=fat_viol
	        BOOLEAN fat_viol AND spc_mode1_out { } TEMP=fat_viol
	        SELECT_EDGE spc_target TOUCHING spc_mode1_out { } TEMP=spc_target2
	        BOOLEAN spc_target2 AND spc_mode1_out { } TEMP=spc_target2
	        EXTERNAL fat_viol spc_target2 {
	           COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um " 	    
		   SPACING < fatTblSpacing_dg
                   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} (17 )
	     } else {
	        EXTERNAL fat spc_target {
		   COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um "
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
	    	   PARALLEL_POINT_PROJECTION = FALSE
	           TOUCH = FALSE
	     	   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } (17 ) 
	     }
          }
       } else {
	  if (ignoreChildCell == 1) {
              EXTERNAL fat spc_target {
                 SPACING < fatTblSpacing
                 BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
              } TEMP = spc_out
	      BOOLEAN spc_out NOT spc_child_out { } TEMP = spc_diff_out
	      SELECT spc_out INTERACT spc_diff_out { } TEMP = spc_out
	      SELECT_EDGE fat TOUCHING spc_out { } TEMP=fat_viol
	      BOOLEAN fat_viol AND spc_out { } TEMP=fat_viol
              SELECT_EDGE spc_target TOUCHING spc_out { } TEMP=spc_target2
	      BOOLEAN spc_target2 AND spc_out { } TEMP=spc_target2
	      EXTERNAL fat_viol spc_target2 {
		 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
		 BOX_CORNER = FALSE 
		 NON_PARALLEL = TRUE
		 POINT_TOUCH = FALSE
	      } (17 ) 
	  } else {
	      EXTERNAL fat spc_target {
                 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
	         BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
	      } (17 ) 
	  }
       }
       /*check metal in the extension range*/ 
       if (fatTblExtensionRange > 0) {
	  if (fatWireExtensionMode == 0) {
	     SIZE fat { OVERSIZE = fatTblExtensionRange } TEMP = fat_tmp
             BOOLEAN fat_tmp AND metal4  { } TEMP = fat_tmp
  	     BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
             SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_ext
             BOOLEAN fat_ext OR fat { } TEMP = fat_ext
	     if (fatTblParallelLength > 0) {
                if (fatTblParallelLength > fatTblExtensionRange) {
                   SIZE fat { OVERSIZE = fatTblParallelLength } TEMP = fat_tmp
                   BOOLEAN fat_tmp AND metal4  { } TEMP = fat_tmp
  	           BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
                   SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_parallel
                   BOOLEAN fat_parallel OR fat { } TEMP = fat_parallel
                } else {
                   COPY fat_ext { } TEMP = fat_parallel
                }
		EXTERNAL fat_parallel spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
	           NON_PARALLEL = TRUE
	        } TEMP = vio_filter_set
		EXTERNAL fat_ext spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } TEMP = vio_set
                if (fatTblParallelLength < fatTblSpacing) {
                   SELECT_EDGE vio_filter_set TOUCHING fat_parallel {
                      VSIZE_INSIDE = fatTblParallelLength - 0.0002 
                   } TEMP = vio_filter_set_filter
                   SELECT_CONTAINS vio_filter_set_filter { 
                      WIDTH =  0.0002 
                      HEIGHT = fatTblParallelLength + 0.0001 
                   } TEMP = vio_filter_set_filter
                   SELECT vio_filter_set INTERACT vio_filter_set_filter { } TEMP = vio_filter
                } else {
	           SELECT_CONTAINS vio_filter_set { 
	              WIDTH =  0.0002 
	              HEIGHT = fatTblParallelLength + 0.0001 
	           } TEMP = vio_filter
                }
                SELECT vio_set INSIDE vio_filter { } TEMP = mode0_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out1 NOT mode0_child_out1 { } TEMP = mode0_diff_out1
                   SELECT mode0_out1 INTERACT mode0_diff_out1 { } TEMP = mode0_out1
                }
                COPY mode0_out1 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing  = fatTblSpacing um"
                } (17 )
		if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	           EXTERNAL fat_ext spc_target {
		      SPACING < fatTblSpacing_dg
	              SET_CORNERS_TO_SPACING = FALSE
		      PARALLEL_POINT_PROJECTION = FALSE
		      TOUCH = TRUE
		      POINT_TOUCH = FALSE
		      NON_PARALLEL = TRUE
	           } TEMP = mode0_out2
                   if (ignoreChildCell == 1) {
                      BOOLEAN mode0_out2 NOT mode0_child_out2 { } TEMP = mode0_diff_out2
                      SELECT mode0_out2 INTERACT mode0_diff_out2 { } TEMP = mode0_out2
                   }
                   COPY mode0_out2 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing (mode 1/2) = fatTblSpacing um/ fatTblSpacing_dg um "
                   } (17 )
	        } 
	     } else {
	        EXTERNAL fat_ext spc_target {
		   SPACING < fatTblSpacing
		   NON_PARALLEL = TRUE
		   SET_CORNERS_TO_SPACING = FALSE
		   POINT_TOUCH = FALSE
		} TEMP = mode0_out3
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out3 NOT mode0_child_out3 { } TEMP = mode0_diff_out3
                   SELECT mode0_out3 INTERACT mode0_diff_out3 { } TEMP = mode0_out3
                }
                COPY mode0_out3 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range ( fatTblExtensionRange um) minimum spacing = fatTblSpacing um"
                } (17 )
	     }
	  } else if (fatWireExtensionMode == 1) {
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal4  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             if (fatTblParallelLength > 0) {
                EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
		   BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   CHECK_SAME_POLYGON = TRUE 
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
	        SELECT fat_ext INTERACT spacing {  } TEMP = fat_ext
		BOOLEAN fat_ext OR spacing {  } TEMP = combined_fat_ext
                EXTERNAL combined_fat_ext fat {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
                } TEMP = fat_spacing
		BOOLEAN fat_spacing AND fat_ran {  } TEMP = fat_spacing
		BOOLEAN combined_fat_ext OR fat_spacing {  } TEMP = combined_fat_ext
                SELECT_CONTAINS combined_fat_ext { 
                   WIDTH =  0.0002 
                   HEIGHT = fatTblParallelLength + 0.0001 
                } TEMP = combined_fat_ext
		SELECT spacing INTERACT combined_fat_ext { 
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out1 NOT mode1_child_out1 { } TEMP = mode1_diff_out1
                   SELECT mode1_out1 INTERACT mode1_diff_out1 { } TEMP = mode1_out1 
                }
                COPY mode1_out1 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (17 ) 
	     } else {
               	EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
	           BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
	           CHECK_SAME_POLYGON = TRUE 
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
                SELECT spacing INTERACT fat_ext {
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out2
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out2 NOT mode1_child_out2 { } TEMP = mode1_diff_out2
                   SELECT mode1_out2 INTERACT mode1_diff_out2 { } TEMP = mode1_out2
                }
                COPY mode1_out2 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (17 )
	     }
	  } else if (fatWireExtensionMode == 2) {
	     SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
             BOOLEAN fat_ran AND metal4  {  } TEMP = fat_ext
             BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	      	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
             } TEMP = spacing
 	     SELECT spacing INSIDE fat_ran {  } TEMP = spacing
	     SELECT spacing OUTSIDE fat {  } TEMP = spacing
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode2_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode2_out NOT mode2_child_out { } TEMP = mode2_diff_out
                SELECT mode2_out INTERACT mode2_diff_out { } TEMP = mode2_out 
             }
             COPY mode2_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 2, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (17 )
	  } else if (fatWireExtensionMode == 3) {
             SIZE fat {
	        GROW_LEFT = fatTblExtensionRange
	        GROW_RIGHT = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal4  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	       	PARALLEL = TRUE

	       	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		HORIZONTAL_ONLY = TRUE
             } TEMP = spacing_hor
	     SELECT spacing_hor INSIDE fat_ran {  } TEMP = spacing_hor
	     SELECT spacing_hor OUTSIDE fat {  } TEMP = spacing_hor
             SIZE fat {
	        GROW_TOP = fatTblExtensionRange
	        GROW_BOTTOM = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal4  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	        POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		VERTICAL_ONLY = TRUE
             } TEMP = spacing_ver
	     SELECT spacing_ver INSIDE fat_ran {  } TEMP = spacing_ver
	     SELECT spacing_ver OUTSIDE fat {  } TEMP = spacing_ver
  	     BOOLEAN spacing_hor OR spacing_ver {  } TEMP = spacing
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal4  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
  	     /* check overlapped projection length */
 	     if (fatTblParallelLength > 0) {
                POLYGON_FEATURES fat_ext {
                   EQUATIONS {
                      vnum = EV_VNUM_IN;
                      if ( vnum > 0) {
                         bdLeft = EV_VXCOORD_IN[0];
                         bdRight = EV_VXCOORD_IN[0];
                         bdBottom = EV_VYCOORD_IN[0];
                         bdTop = EV_VYCOORD_IN[0];
                         FOR (i = 1; i < vnum; i++) {
                            if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
                            else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
                            if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
                            else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
                         } /* FOR i */
                         if ( (bdRight - bdLeft) >= fatTblParallelLength ||
                  	      (bdTop - bdBottom) >= fatTblParallelLength) {
                            FOR (i = 0; i < vnum; i++) {
                               EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
                               EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
                            }
                            EV_VNUM_OUT = vnum;
                 	    EV_SAVE_POLYGON();
                         }
                      }
                   }
                } TEMP = fat_ext /* POLYGON_FEATURE */
             }
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode3_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode3_out NOT mode3_child_out { } TEMP = mode3_diff_out
                SELECT mode3_out INTERACT mode3_diff_out { } TEMP = mode3_out
             }
             COPY mode3_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 3, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (17 )
          }
       }
       SET fatTblSpacing = 0;
    }
}
@ 537 "adrc/adrc.ev" 2


SET fatTblThreshold = 0.305;
SET fatTblParallelLength = 0.305;
SET minWidth = 0.056;

SET fatTblThreshold_Start = 0;
SET fatTblSpacing = 0.12;
@ 1 "adrc/adrc_fatMetal.ev" 1
/*check fat metal table*/
if (fatTblThreshold > 0) {
    if ((fatTblThreshold / 2.0) > 0.0001 ) {
       SIZE fat_candidate  { UNDER_OVER = fatTblThreshold / 2.0 - 0.0001  } TEMP = fat_candidate
       if (fatTblNextThreshold > 0) {
          SIZE fat_candidate { UNDER_OVER = fatTblNextThreshold / 2.0 - 0.0001  } TEMP = fat_next
          BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
          BOOLEAN fat AND fat_target { } TEMP = fat
          SET fatTblNextThreshold = 0;
       } else {
          BOOLEAN fat_candidate AND fat_target {  } TEMP = fat 
       }
    } else {
      COPY fat_target {  } TEMP = fat 
    }
    COPY fat_target { } TEMP = spc_target
    if (fatTblThreshold_Start > 0  || fatTblThreshold_End > 0) {
       if (fatTblThreshold_Start > 0) {
          SIZE fat_target { UNDER_OVER = fatTblThreshold_Start / 2.0 - 0.0001  } TEMP = spc_target
       }
       if (fatTblThreshold_End > 0 && fatTblThreshold_End > fatTblThreshold_Start) {
          SIZE spc_target { UNDER_OVER = fatTblThreshold_End / 2.0 - 0.0001  } TEMP = fat_end
          BOOLEAN spc_target NOT fat_end { } TEMP = spc_target
       }
       BOOLEAN spc_target AND fat_target {  } TEMP = spc_target
       if (ignoreBlockage == 0 && fatTblThreshold_Start < fatTblThreshold_1) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal4_blockage  {  } TEMP = spc_target
       }
       SET fatTblThreshold_Start = 0;
       SET fatTblThreshold_End = 0;
       SET fatTblThreshold_1 = 0;
    } else {
       if (ignoreBlockage == 0) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal4_blockage  {  } TEMP = spc_target
       }
    }
 
    if (fatTblEnclosedArea > 0) {
       SELECT holes INTERACT fat { } TEMP = fat_holes
       AREA fat_holes { 
          RANGE = [0.0001 * 0.0001 , fatTblEnclosedArea - 0.0001 * 0.0001 ]
       } TEMP = fat_holes
       if (fatTblMinEnclosedAreaMode==0) {
          SIZE fat_holes { OVER_UNDER = fatTblThreshold / 2.0 + 0.0001  } TEMP = ovun_holes
          SELECT ovun_holes INTERACT fat_holes { RANGE = [2, 9999999999 ] } TEMP = merged_holes
          BOOLEAN fat_candidate AND fat_target { } TEMP = fat_metal
          BOOLEAN metal4  NOT fat_metal { } TEMP = thin_metal
          BOOLEAN thin_metal NOT ovun_holes { } TEMP = thin_metal
          SELECT ovun_holes INTERACT thin_metal { } TEMP = thin_holes
          BOOLEAN thin_holes OR merged_holes { } TEMP = thin_holes
          BOOLEAN fat_holes NOT thin_holes { } TEMP = fat_holes
       }
       COPY fat_holes { 
	  COMMENT = "$layer_name EnclsArea : fat metal ( fatTblThreshold um) minimum enclosed area (mode fatTblMinEnclosedAreaMode ) = fatTblEnclosedArea um*um"
       } (17 )
       SET fatTblEnclosedArea = 0;
    }
    if (fatTblSpacing > 0) {
       /*check fat metal*/ 
       if (fatTblParallelLength > 0) {
          if (router_parallelLengthNetMode == 1 || parallelLengthMode == 1) {
             AREA spc_target { RANGE = [fatTblParallelLength * minWidth + 0.0001 , 9999999999 ] } TEMP = spc_target1
             COPY spc_target1 { } TEMP = spc_target2
          } else {
             COPY spc_target { } TEMP = spc_target2
          }
          if (parallelLengthMode == 1) {
             SELECT metal4  INTERACT fat { } TEMP = fat_all 
             BOOLEAN fat_all OR fat { } TEMP = fat2
             SELECT metal4  INTERACT spc_target2 { } TEMP = spc_target_all
             BOOLEAN spc_target_all OR spc_target2 { } TEMP = spc_target2
          } else {
             COPY fat { } TEMP = fat2
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING <= fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
                OUTPUT_EDGES = TRUE
             } TEMP = vio_edge
             SELECT vio_edge INTERACT fat { } TEMP = vio_edge
             SELECT vio_edge INTERACT spc_target1 { } TEMP = vio_edge
             SELECT violation INTERACT vio_edge { } TEMP = violation
          } else {
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
          }
          BOOLEAN violation NOT fat_target { } TEMP = violation
          if (fatTblParallelLength < fatTblSpacing) {
             SELECT_EDGE violation TOUCHING fat2 {
                VSIZE_INSIDE = fatTblParallelLength - 0.0002 
             } TEMP = vio_filter
             SELECT_CONTAINS vio_filter { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = vio_filter
             SELECT violation INTERACT vio_filter { } TEMP = violation
          } else {
             SELECT_CONTAINS violation { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = violation
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING = [fatTblSpacing, fatTblSpacing]
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
             } TEMP = violation3
             BOOLEAN violation3 NOT fat_target { } TEMP = violation3
             BOOLEAN violation NOT violation3 { } TEMP= violation
          }
          SELECT_EDGE fat2 TOUCHING violation { } TEMP=fat_viol
          BOOLEAN fat_viol AND violation { } TEMP=fat_viol
          SELECT_EDGE spc_target2 TOUCHING violation { } TEMP=spc_target2
          BOOLEAN spc_target2 AND violation { } TEMP= spc_target2
	  if (ignoreChildCell == 1) {
             EXTERNAL fat_viol spc_target2 {
		SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		TOUCH = FALSE
		POINT_TOUCH = FALSE
		NON_PARALLEL = TRUE
	     } TEMP = spc_mode0_out
             BOOLEAN spc_mode0_out NOT spc_mode0_child_out { } TEMP = spc_mode0_diff_out
             SELECT spc_mode0_out INTERACT spc_mode0_diff_out { } TEMP = spc_mode0_out
	     SELECT_EDGE fat2 TOUCHING spc_mode0_out { } TEMP=fat_viol
	     BOOLEAN fat_viol AND spc_mode0_out { } TEMP=fat_viol
	     SELECT_EDGE spc_target2 TOUCHING spc_mode0_out { } TEMP=spc_target2
	     BOOLEAN spc_target2 AND spc_mode0_out { } TEMP=spc_target2
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (17 )  		
	  } else {
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing 
	        SET_CORNERS_TO_SPACING = FALSE
	        PARALLEL_POINT_PROJECTION = FALSE
	        TOUCH = FALSE
	        POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (17 )
	  }
	  if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	     if (ignoreChildCell == 1) {
		EXTERNAL fat spc_target {
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} TEMP = spc_mode1_out
	        BOOLEAN spc_mode1_out NOT spc_mode1_child_out { } TEMP = spc_mode1_diff_out
	        SELECT spc_mode1_out INTERACT spc_mode1_diff_out { } TEMP = spc_mode1_out
                SELECT_EDGE fat TOUCHING spc_mode1_out { } TEMP=fat_viol
	        BOOLEAN fat_viol AND spc_mode1_out { } TEMP=fat_viol
	        SELECT_EDGE spc_target TOUCHING spc_mode1_out { } TEMP=spc_target2
	        BOOLEAN spc_target2 AND spc_mode1_out { } TEMP=spc_target2
	        EXTERNAL fat_viol spc_target2 {
	           COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um " 	    
		   SPACING < fatTblSpacing_dg
                   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} (17 )
	     } else {
	        EXTERNAL fat spc_target {
		   COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um "
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
	    	   PARALLEL_POINT_PROJECTION = FALSE
	           TOUCH = FALSE
	     	   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } (17 ) 
	     }
          }
       } else {
	  if (ignoreChildCell == 1) {
              EXTERNAL fat spc_target {
                 SPACING < fatTblSpacing
                 BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
              } TEMP = spc_out
	      BOOLEAN spc_out NOT spc_child_out { } TEMP = spc_diff_out
	      SELECT spc_out INTERACT spc_diff_out { } TEMP = spc_out
	      SELECT_EDGE fat TOUCHING spc_out { } TEMP=fat_viol
	      BOOLEAN fat_viol AND spc_out { } TEMP=fat_viol
              SELECT_EDGE spc_target TOUCHING spc_out { } TEMP=spc_target2
	      BOOLEAN spc_target2 AND spc_out { } TEMP=spc_target2
	      EXTERNAL fat_viol spc_target2 {
		 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
		 BOX_CORNER = FALSE 
		 NON_PARALLEL = TRUE
		 POINT_TOUCH = FALSE
	      } (17 ) 
	  } else {
	      EXTERNAL fat spc_target {
                 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
	         BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
	      } (17 ) 
	  }
       }
       /*check metal in the extension range*/ 
       if (fatTblExtensionRange > 0) {
	  if (fatWireExtensionMode == 0) {
	     SIZE fat { OVERSIZE = fatTblExtensionRange } TEMP = fat_tmp
             BOOLEAN fat_tmp AND metal4  { } TEMP = fat_tmp
  	     BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
             SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_ext
             BOOLEAN fat_ext OR fat { } TEMP = fat_ext
	     if (fatTblParallelLength > 0) {
                if (fatTblParallelLength > fatTblExtensionRange) {
                   SIZE fat { OVERSIZE = fatTblParallelLength } TEMP = fat_tmp
                   BOOLEAN fat_tmp AND metal4  { } TEMP = fat_tmp
  	           BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
                   SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_parallel
                   BOOLEAN fat_parallel OR fat { } TEMP = fat_parallel
                } else {
                   COPY fat_ext { } TEMP = fat_parallel
                }
		EXTERNAL fat_parallel spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
	           NON_PARALLEL = TRUE
	        } TEMP = vio_filter_set
		EXTERNAL fat_ext spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } TEMP = vio_set
                if (fatTblParallelLength < fatTblSpacing) {
                   SELECT_EDGE vio_filter_set TOUCHING fat_parallel {
                      VSIZE_INSIDE = fatTblParallelLength - 0.0002 
                   } TEMP = vio_filter_set_filter
                   SELECT_CONTAINS vio_filter_set_filter { 
                      WIDTH =  0.0002 
                      HEIGHT = fatTblParallelLength + 0.0001 
                   } TEMP = vio_filter_set_filter
                   SELECT vio_filter_set INTERACT vio_filter_set_filter { } TEMP = vio_filter
                } else {
	           SELECT_CONTAINS vio_filter_set { 
	              WIDTH =  0.0002 
	              HEIGHT = fatTblParallelLength + 0.0001 
	           } TEMP = vio_filter
                }
                SELECT vio_set INSIDE vio_filter { } TEMP = mode0_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out1 NOT mode0_child_out1 { } TEMP = mode0_diff_out1
                   SELECT mode0_out1 INTERACT mode0_diff_out1 { } TEMP = mode0_out1
                }
                COPY mode0_out1 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing  = fatTblSpacing um"
                } (17 )
		if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	           EXTERNAL fat_ext spc_target {
		      SPACING < fatTblSpacing_dg
	              SET_CORNERS_TO_SPACING = FALSE
		      PARALLEL_POINT_PROJECTION = FALSE
		      TOUCH = TRUE
		      POINT_TOUCH = FALSE
		      NON_PARALLEL = TRUE
	           } TEMP = mode0_out2
                   if (ignoreChildCell == 1) {
                      BOOLEAN mode0_out2 NOT mode0_child_out2 { } TEMP = mode0_diff_out2
                      SELECT mode0_out2 INTERACT mode0_diff_out2 { } TEMP = mode0_out2
                   }
                   COPY mode0_out2 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing (mode 1/2) = fatTblSpacing um/ fatTblSpacing_dg um "
                   } (17 )
	        } 
	     } else {
	        EXTERNAL fat_ext spc_target {
		   SPACING < fatTblSpacing
		   NON_PARALLEL = TRUE
		   SET_CORNERS_TO_SPACING = FALSE
		   POINT_TOUCH = FALSE
		} TEMP = mode0_out3
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out3 NOT mode0_child_out3 { } TEMP = mode0_diff_out3
                   SELECT mode0_out3 INTERACT mode0_diff_out3 { } TEMP = mode0_out3
                }
                COPY mode0_out3 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range ( fatTblExtensionRange um) minimum spacing = fatTblSpacing um"
                } (17 )
	     }
	  } else if (fatWireExtensionMode == 1) {
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal4  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             if (fatTblParallelLength > 0) {
                EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
		   BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   CHECK_SAME_POLYGON = TRUE 
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
	        SELECT fat_ext INTERACT spacing {  } TEMP = fat_ext
		BOOLEAN fat_ext OR spacing {  } TEMP = combined_fat_ext
                EXTERNAL combined_fat_ext fat {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
                } TEMP = fat_spacing
		BOOLEAN fat_spacing AND fat_ran {  } TEMP = fat_spacing
		BOOLEAN combined_fat_ext OR fat_spacing {  } TEMP = combined_fat_ext
                SELECT_CONTAINS combined_fat_ext { 
                   WIDTH =  0.0002 
                   HEIGHT = fatTblParallelLength + 0.0001 
                } TEMP = combined_fat_ext
		SELECT spacing INTERACT combined_fat_ext { 
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out1 NOT mode1_child_out1 { } TEMP = mode1_diff_out1
                   SELECT mode1_out1 INTERACT mode1_diff_out1 { } TEMP = mode1_out1 
                }
                COPY mode1_out1 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (17 ) 
	     } else {
               	EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
	           BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
	           CHECK_SAME_POLYGON = TRUE 
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
                SELECT spacing INTERACT fat_ext {
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out2
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out2 NOT mode1_child_out2 { } TEMP = mode1_diff_out2
                   SELECT mode1_out2 INTERACT mode1_diff_out2 { } TEMP = mode1_out2
                }
                COPY mode1_out2 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (17 )
	     }
	  } else if (fatWireExtensionMode == 2) {
	     SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
             BOOLEAN fat_ran AND metal4  {  } TEMP = fat_ext
             BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	      	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
             } TEMP = spacing
 	     SELECT spacing INSIDE fat_ran {  } TEMP = spacing
	     SELECT spacing OUTSIDE fat {  } TEMP = spacing
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode2_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode2_out NOT mode2_child_out { } TEMP = mode2_diff_out
                SELECT mode2_out INTERACT mode2_diff_out { } TEMP = mode2_out 
             }
             COPY mode2_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 2, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (17 )
	  } else if (fatWireExtensionMode == 3) {
             SIZE fat {
	        GROW_LEFT = fatTblExtensionRange
	        GROW_RIGHT = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal4  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	       	PARALLEL = TRUE

	       	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		HORIZONTAL_ONLY = TRUE
             } TEMP = spacing_hor
	     SELECT spacing_hor INSIDE fat_ran {  } TEMP = spacing_hor
	     SELECT spacing_hor OUTSIDE fat {  } TEMP = spacing_hor
             SIZE fat {
	        GROW_TOP = fatTblExtensionRange
	        GROW_BOTTOM = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal4  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	        POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		VERTICAL_ONLY = TRUE
             } TEMP = spacing_ver
	     SELECT spacing_ver INSIDE fat_ran {  } TEMP = spacing_ver
	     SELECT spacing_ver OUTSIDE fat {  } TEMP = spacing_ver
  	     BOOLEAN spacing_hor OR spacing_ver {  } TEMP = spacing
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal4  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
  	     /* check overlapped projection length */
 	     if (fatTblParallelLength > 0) {
                POLYGON_FEATURES fat_ext {
                   EQUATIONS {
                      vnum = EV_VNUM_IN;
                      if ( vnum > 0) {
                         bdLeft = EV_VXCOORD_IN[0];
                         bdRight = EV_VXCOORD_IN[0];
                         bdBottom = EV_VYCOORD_IN[0];
                         bdTop = EV_VYCOORD_IN[0];
                         FOR (i = 1; i < vnum; i++) {
                            if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
                            else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
                            if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
                            else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
                         } /* FOR i */
                         if ( (bdRight - bdLeft) >= fatTblParallelLength ||
                  	      (bdTop - bdBottom) >= fatTblParallelLength) {
                            FOR (i = 0; i < vnum; i++) {
                               EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
                               EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
                            }
                            EV_VNUM_OUT = vnum;
                 	    EV_SAVE_POLYGON();
                         }
                      }
                   }
                } TEMP = fat_ext /* POLYGON_FEATURE */
             }
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode3_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode3_out NOT mode3_child_out { } TEMP = mode3_diff_out
                SELECT mode3_out INTERACT mode3_diff_out { } TEMP = mode3_out
             }
             COPY mode3_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 3, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (17 )
          }
       }
       SET fatTblSpacing = 0;
    }
}
@ 545 "adrc/adrc.ev" 2


SET fatTblThreshold = 1.505;
SET fatTblParallelLength = 1.505;
SET minWidth = 0.056;

SET fatTblThreshold_Start = 0;
SET fatTblSpacing = 0.6;
@ 1 "adrc/adrc_fatMetal.ev" 1
/*check fat metal table*/
if (fatTblThreshold > 0) {
    if ((fatTblThreshold / 2.0) > 0.0001 ) {
       SIZE fat_candidate  { UNDER_OVER = fatTblThreshold / 2.0 - 0.0001  } TEMP = fat_candidate
       if (fatTblNextThreshold > 0) {
          SIZE fat_candidate { UNDER_OVER = fatTblNextThreshold / 2.0 - 0.0001  } TEMP = fat_next
          BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
          BOOLEAN fat AND fat_target { } TEMP = fat
          SET fatTblNextThreshold = 0;
       } else {
          BOOLEAN fat_candidate AND fat_target {  } TEMP = fat 
       }
    } else {
      COPY fat_target {  } TEMP = fat 
    }
    COPY fat_target { } TEMP = spc_target
    if (fatTblThreshold_Start > 0  || fatTblThreshold_End > 0) {
       if (fatTblThreshold_Start > 0) {
          SIZE fat_target { UNDER_OVER = fatTblThreshold_Start / 2.0 - 0.0001  } TEMP = spc_target
       }
       if (fatTblThreshold_End > 0 && fatTblThreshold_End > fatTblThreshold_Start) {
          SIZE spc_target { UNDER_OVER = fatTblThreshold_End / 2.0 - 0.0001  } TEMP = fat_end
          BOOLEAN spc_target NOT fat_end { } TEMP = spc_target
       }
       BOOLEAN spc_target AND fat_target {  } TEMP = spc_target
       if (ignoreBlockage == 0 && fatTblThreshold_Start < fatTblThreshold_1) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal4_blockage  {  } TEMP = spc_target
       }
       SET fatTblThreshold_Start = 0;
       SET fatTblThreshold_End = 0;
       SET fatTblThreshold_1 = 0;
    } else {
       if (ignoreBlockage == 0) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal4_blockage  {  } TEMP = spc_target
       }
    }
 
    if (fatTblEnclosedArea > 0) {
       SELECT holes INTERACT fat { } TEMP = fat_holes
       AREA fat_holes { 
          RANGE = [0.0001 * 0.0001 , fatTblEnclosedArea - 0.0001 * 0.0001 ]
       } TEMP = fat_holes
       if (fatTblMinEnclosedAreaMode==0) {
          SIZE fat_holes { OVER_UNDER = fatTblThreshold / 2.0 + 0.0001  } TEMP = ovun_holes
          SELECT ovun_holes INTERACT fat_holes { RANGE = [2, 9999999999 ] } TEMP = merged_holes
          BOOLEAN fat_candidate AND fat_target { } TEMP = fat_metal
          BOOLEAN metal4  NOT fat_metal { } TEMP = thin_metal
          BOOLEAN thin_metal NOT ovun_holes { } TEMP = thin_metal
          SELECT ovun_holes INTERACT thin_metal { } TEMP = thin_holes
          BOOLEAN thin_holes OR merged_holes { } TEMP = thin_holes
          BOOLEAN fat_holes NOT thin_holes { } TEMP = fat_holes
       }
       COPY fat_holes { 
	  COMMENT = "$layer_name EnclsArea : fat metal ( fatTblThreshold um) minimum enclosed area (mode fatTblMinEnclosedAreaMode ) = fatTblEnclosedArea um*um"
       } (17 )
       SET fatTblEnclosedArea = 0;
    }
    if (fatTblSpacing > 0) {
       /*check fat metal*/ 
       if (fatTblParallelLength > 0) {
          if (router_parallelLengthNetMode == 1 || parallelLengthMode == 1) {
             AREA spc_target { RANGE = [fatTblParallelLength * minWidth + 0.0001 , 9999999999 ] } TEMP = spc_target1
             COPY spc_target1 { } TEMP = spc_target2
          } else {
             COPY spc_target { } TEMP = spc_target2
          }
          if (parallelLengthMode == 1) {
             SELECT metal4  INTERACT fat { } TEMP = fat_all 
             BOOLEAN fat_all OR fat { } TEMP = fat2
             SELECT metal4  INTERACT spc_target2 { } TEMP = spc_target_all
             BOOLEAN spc_target_all OR spc_target2 { } TEMP = spc_target2
          } else {
             COPY fat { } TEMP = fat2
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING <= fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
                OUTPUT_EDGES = TRUE
             } TEMP = vio_edge
             SELECT vio_edge INTERACT fat { } TEMP = vio_edge
             SELECT vio_edge INTERACT spc_target1 { } TEMP = vio_edge
             SELECT violation INTERACT vio_edge { } TEMP = violation
          } else {
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
          }
          BOOLEAN violation NOT fat_target { } TEMP = violation
          if (fatTblParallelLength < fatTblSpacing) {
             SELECT_EDGE violation TOUCHING fat2 {
                VSIZE_INSIDE = fatTblParallelLength - 0.0002 
             } TEMP = vio_filter
             SELECT_CONTAINS vio_filter { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = vio_filter
             SELECT violation INTERACT vio_filter { } TEMP = violation
          } else {
             SELECT_CONTAINS violation { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = violation
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING = [fatTblSpacing, fatTblSpacing]
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
             } TEMP = violation3
             BOOLEAN violation3 NOT fat_target { } TEMP = violation3
             BOOLEAN violation NOT violation3 { } TEMP= violation
          }
          SELECT_EDGE fat2 TOUCHING violation { } TEMP=fat_viol
          BOOLEAN fat_viol AND violation { } TEMP=fat_viol
          SELECT_EDGE spc_target2 TOUCHING violation { } TEMP=spc_target2
          BOOLEAN spc_target2 AND violation { } TEMP= spc_target2
	  if (ignoreChildCell == 1) {
             EXTERNAL fat_viol spc_target2 {
		SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		TOUCH = FALSE
		POINT_TOUCH = FALSE
		NON_PARALLEL = TRUE
	     } TEMP = spc_mode0_out
             BOOLEAN spc_mode0_out NOT spc_mode0_child_out { } TEMP = spc_mode0_diff_out
             SELECT spc_mode0_out INTERACT spc_mode0_diff_out { } TEMP = spc_mode0_out
	     SELECT_EDGE fat2 TOUCHING spc_mode0_out { } TEMP=fat_viol
	     BOOLEAN fat_viol AND spc_mode0_out { } TEMP=fat_viol
	     SELECT_EDGE spc_target2 TOUCHING spc_mode0_out { } TEMP=spc_target2
	     BOOLEAN spc_target2 AND spc_mode0_out { } TEMP=spc_target2
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (17 )  		
	  } else {
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing 
	        SET_CORNERS_TO_SPACING = FALSE
	        PARALLEL_POINT_PROJECTION = FALSE
	        TOUCH = FALSE
	        POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (17 )
	  }
	  if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	     if (ignoreChildCell == 1) {
		EXTERNAL fat spc_target {
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} TEMP = spc_mode1_out
	        BOOLEAN spc_mode1_out NOT spc_mode1_child_out { } TEMP = spc_mode1_diff_out
	        SELECT spc_mode1_out INTERACT spc_mode1_diff_out { } TEMP = spc_mode1_out
                SELECT_EDGE fat TOUCHING spc_mode1_out { } TEMP=fat_viol
	        BOOLEAN fat_viol AND spc_mode1_out { } TEMP=fat_viol
	        SELECT_EDGE spc_target TOUCHING spc_mode1_out { } TEMP=spc_target2
	        BOOLEAN spc_target2 AND spc_mode1_out { } TEMP=spc_target2
	        EXTERNAL fat_viol spc_target2 {
	           COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um " 	    
		   SPACING < fatTblSpacing_dg
                   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} (17 )
	     } else {
	        EXTERNAL fat spc_target {
		   COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um "
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
	    	   PARALLEL_POINT_PROJECTION = FALSE
	           TOUCH = FALSE
	     	   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } (17 ) 
	     }
          }
       } else {
	  if (ignoreChildCell == 1) {
              EXTERNAL fat spc_target {
                 SPACING < fatTblSpacing
                 BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
              } TEMP = spc_out
	      BOOLEAN spc_out NOT spc_child_out { } TEMP = spc_diff_out
	      SELECT spc_out INTERACT spc_diff_out { } TEMP = spc_out
	      SELECT_EDGE fat TOUCHING spc_out { } TEMP=fat_viol
	      BOOLEAN fat_viol AND spc_out { } TEMP=fat_viol
              SELECT_EDGE spc_target TOUCHING spc_out { } TEMP=spc_target2
	      BOOLEAN spc_target2 AND spc_out { } TEMP=spc_target2
	      EXTERNAL fat_viol spc_target2 {
		 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
		 BOX_CORNER = FALSE 
		 NON_PARALLEL = TRUE
		 POINT_TOUCH = FALSE
	      } (17 ) 
	  } else {
	      EXTERNAL fat spc_target {
                 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
	         BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
	      } (17 ) 
	  }
       }
       /*check metal in the extension range*/ 
       if (fatTblExtensionRange > 0) {
	  if (fatWireExtensionMode == 0) {
	     SIZE fat { OVERSIZE = fatTblExtensionRange } TEMP = fat_tmp
             BOOLEAN fat_tmp AND metal4  { } TEMP = fat_tmp
  	     BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
             SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_ext
             BOOLEAN fat_ext OR fat { } TEMP = fat_ext
	     if (fatTblParallelLength > 0) {
                if (fatTblParallelLength > fatTblExtensionRange) {
                   SIZE fat { OVERSIZE = fatTblParallelLength } TEMP = fat_tmp
                   BOOLEAN fat_tmp AND metal4  { } TEMP = fat_tmp
  	           BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
                   SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_parallel
                   BOOLEAN fat_parallel OR fat { } TEMP = fat_parallel
                } else {
                   COPY fat_ext { } TEMP = fat_parallel
                }
		EXTERNAL fat_parallel spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
	           NON_PARALLEL = TRUE
	        } TEMP = vio_filter_set
		EXTERNAL fat_ext spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } TEMP = vio_set
                if (fatTblParallelLength < fatTblSpacing) {
                   SELECT_EDGE vio_filter_set TOUCHING fat_parallel {
                      VSIZE_INSIDE = fatTblParallelLength - 0.0002 
                   } TEMP = vio_filter_set_filter
                   SELECT_CONTAINS vio_filter_set_filter { 
                      WIDTH =  0.0002 
                      HEIGHT = fatTblParallelLength + 0.0001 
                   } TEMP = vio_filter_set_filter
                   SELECT vio_filter_set INTERACT vio_filter_set_filter { } TEMP = vio_filter
                } else {
	           SELECT_CONTAINS vio_filter_set { 
	              WIDTH =  0.0002 
	              HEIGHT = fatTblParallelLength + 0.0001 
	           } TEMP = vio_filter
                }
                SELECT vio_set INSIDE vio_filter { } TEMP = mode0_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out1 NOT mode0_child_out1 { } TEMP = mode0_diff_out1
                   SELECT mode0_out1 INTERACT mode0_diff_out1 { } TEMP = mode0_out1
                }
                COPY mode0_out1 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing  = fatTblSpacing um"
                } (17 )
		if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	           EXTERNAL fat_ext spc_target {
		      SPACING < fatTblSpacing_dg
	              SET_CORNERS_TO_SPACING = FALSE
		      PARALLEL_POINT_PROJECTION = FALSE
		      TOUCH = TRUE
		      POINT_TOUCH = FALSE
		      NON_PARALLEL = TRUE
	           } TEMP = mode0_out2
                   if (ignoreChildCell == 1) {
                      BOOLEAN mode0_out2 NOT mode0_child_out2 { } TEMP = mode0_diff_out2
                      SELECT mode0_out2 INTERACT mode0_diff_out2 { } TEMP = mode0_out2
                   }
                   COPY mode0_out2 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing (mode 1/2) = fatTblSpacing um/ fatTblSpacing_dg um "
                   } (17 )
	        } 
	     } else {
	        EXTERNAL fat_ext spc_target {
		   SPACING < fatTblSpacing
		   NON_PARALLEL = TRUE
		   SET_CORNERS_TO_SPACING = FALSE
		   POINT_TOUCH = FALSE
		} TEMP = mode0_out3
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out3 NOT mode0_child_out3 { } TEMP = mode0_diff_out3
                   SELECT mode0_out3 INTERACT mode0_diff_out3 { } TEMP = mode0_out3
                }
                COPY mode0_out3 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range ( fatTblExtensionRange um) minimum spacing = fatTblSpacing um"
                } (17 )
	     }
	  } else if (fatWireExtensionMode == 1) {
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal4  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             if (fatTblParallelLength > 0) {
                EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
		   BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   CHECK_SAME_POLYGON = TRUE 
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
	        SELECT fat_ext INTERACT spacing {  } TEMP = fat_ext
		BOOLEAN fat_ext OR spacing {  } TEMP = combined_fat_ext
                EXTERNAL combined_fat_ext fat {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
                } TEMP = fat_spacing
		BOOLEAN fat_spacing AND fat_ran {  } TEMP = fat_spacing
		BOOLEAN combined_fat_ext OR fat_spacing {  } TEMP = combined_fat_ext
                SELECT_CONTAINS combined_fat_ext { 
                   WIDTH =  0.0002 
                   HEIGHT = fatTblParallelLength + 0.0001 
                } TEMP = combined_fat_ext
		SELECT spacing INTERACT combined_fat_ext { 
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out1 NOT mode1_child_out1 { } TEMP = mode1_diff_out1
                   SELECT mode1_out1 INTERACT mode1_diff_out1 { } TEMP = mode1_out1 
                }
                COPY mode1_out1 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (17 ) 
	     } else {
               	EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
	           BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
	           CHECK_SAME_POLYGON = TRUE 
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
                SELECT spacing INTERACT fat_ext {
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out2
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out2 NOT mode1_child_out2 { } TEMP = mode1_diff_out2
                   SELECT mode1_out2 INTERACT mode1_diff_out2 { } TEMP = mode1_out2
                }
                COPY mode1_out2 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (17 )
	     }
	  } else if (fatWireExtensionMode == 2) {
	     SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
             BOOLEAN fat_ran AND metal4  {  } TEMP = fat_ext
             BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	      	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
             } TEMP = spacing
 	     SELECT spacing INSIDE fat_ran {  } TEMP = spacing
	     SELECT spacing OUTSIDE fat {  } TEMP = spacing
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode2_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode2_out NOT mode2_child_out { } TEMP = mode2_diff_out
                SELECT mode2_out INTERACT mode2_diff_out { } TEMP = mode2_out 
             }
             COPY mode2_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 2, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (17 )
	  } else if (fatWireExtensionMode == 3) {
             SIZE fat {
	        GROW_LEFT = fatTblExtensionRange
	        GROW_RIGHT = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal4  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	       	PARALLEL = TRUE

	       	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		HORIZONTAL_ONLY = TRUE
             } TEMP = spacing_hor
	     SELECT spacing_hor INSIDE fat_ran {  } TEMP = spacing_hor
	     SELECT spacing_hor OUTSIDE fat {  } TEMP = spacing_hor
             SIZE fat {
	        GROW_TOP = fatTblExtensionRange
	        GROW_BOTTOM = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal4  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	        POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		VERTICAL_ONLY = TRUE
             } TEMP = spacing_ver
	     SELECT spacing_ver INSIDE fat_ran {  } TEMP = spacing_ver
	     SELECT spacing_ver OUTSIDE fat {  } TEMP = spacing_ver
  	     BOOLEAN spacing_hor OR spacing_ver {  } TEMP = spacing
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal4  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
  	     /* check overlapped projection length */
 	     if (fatTblParallelLength > 0) {
                POLYGON_FEATURES fat_ext {
                   EQUATIONS {
                      vnum = EV_VNUM_IN;
                      if ( vnum > 0) {
                         bdLeft = EV_VXCOORD_IN[0];
                         bdRight = EV_VXCOORD_IN[0];
                         bdBottom = EV_VYCOORD_IN[0];
                         bdTop = EV_VYCOORD_IN[0];
                         FOR (i = 1; i < vnum; i++) {
                            if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
                            else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
                            if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
                            else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
                         } /* FOR i */
                         if ( (bdRight - bdLeft) >= fatTblParallelLength ||
                  	      (bdTop - bdBottom) >= fatTblParallelLength) {
                            FOR (i = 0; i < vnum; i++) {
                               EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
                               EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
                            }
                            EV_VNUM_OUT = vnum;
                 	    EV_SAVE_POLYGON();
                         }
                      }
                   }
                } TEMP = fat_ext /* POLYGON_FEATURE */
             }
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode3_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode3_out NOT mode3_child_out { } TEMP = mode3_diff_out
                SELECT mode3_out INTERACT mode3_diff_out { } TEMP = mode3_out
             }
             COPY mode3_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 3, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (17 )
          }
       }
       SET fatTblSpacing = 0;
    }
}
@ 553 "adrc/adrc.ev" 2


SET fatTblThreshold = 3.005;
SET fatTblParallelLength = 3.005;
SET minWidth = 0.056;

SET fatTblThreshold_Start = 0;
SET fatTblSpacing = 0.7;
@ 1 "adrc/adrc_fatMetal.ev" 1
/*check fat metal table*/
if (fatTblThreshold > 0) {
    if ((fatTblThreshold / 2.0) > 0.0001 ) {
       SIZE fat_candidate  { UNDER_OVER = fatTblThreshold / 2.0 - 0.0001  } TEMP = fat_candidate
       if (fatTblNextThreshold > 0) {
          SIZE fat_candidate { UNDER_OVER = fatTblNextThreshold / 2.0 - 0.0001  } TEMP = fat_next
          BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
          BOOLEAN fat AND fat_target { } TEMP = fat
          SET fatTblNextThreshold = 0;
       } else {
          BOOLEAN fat_candidate AND fat_target {  } TEMP = fat 
       }
    } else {
      COPY fat_target {  } TEMP = fat 
    }
    COPY fat_target { } TEMP = spc_target
    if (fatTblThreshold_Start > 0  || fatTblThreshold_End > 0) {
       if (fatTblThreshold_Start > 0) {
          SIZE fat_target { UNDER_OVER = fatTblThreshold_Start / 2.0 - 0.0001  } TEMP = spc_target
       }
       if (fatTblThreshold_End > 0 && fatTblThreshold_End > fatTblThreshold_Start) {
          SIZE spc_target { UNDER_OVER = fatTblThreshold_End / 2.0 - 0.0001  } TEMP = fat_end
          BOOLEAN spc_target NOT fat_end { } TEMP = spc_target
       }
       BOOLEAN spc_target AND fat_target {  } TEMP = spc_target
       if (ignoreBlockage == 0 && fatTblThreshold_Start < fatTblThreshold_1) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal4_blockage  {  } TEMP = spc_target
       }
       SET fatTblThreshold_Start = 0;
       SET fatTblThreshold_End = 0;
       SET fatTblThreshold_1 = 0;
    } else {
       if (ignoreBlockage == 0) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal4_blockage  {  } TEMP = spc_target
       }
    }
 
    if (fatTblEnclosedArea > 0) {
       SELECT holes INTERACT fat { } TEMP = fat_holes
       AREA fat_holes { 
          RANGE = [0.0001 * 0.0001 , fatTblEnclosedArea - 0.0001 * 0.0001 ]
       } TEMP = fat_holes
       if (fatTblMinEnclosedAreaMode==0) {
          SIZE fat_holes { OVER_UNDER = fatTblThreshold / 2.0 + 0.0001  } TEMP = ovun_holes
          SELECT ovun_holes INTERACT fat_holes { RANGE = [2, 9999999999 ] } TEMP = merged_holes
          BOOLEAN fat_candidate AND fat_target { } TEMP = fat_metal
          BOOLEAN metal4  NOT fat_metal { } TEMP = thin_metal
          BOOLEAN thin_metal NOT ovun_holes { } TEMP = thin_metal
          SELECT ovun_holes INTERACT thin_metal { } TEMP = thin_holes
          BOOLEAN thin_holes OR merged_holes { } TEMP = thin_holes
          BOOLEAN fat_holes NOT thin_holes { } TEMP = fat_holes
       }
       COPY fat_holes { 
	  COMMENT = "$layer_name EnclsArea : fat metal ( fatTblThreshold um) minimum enclosed area (mode fatTblMinEnclosedAreaMode ) = fatTblEnclosedArea um*um"
       } (17 )
       SET fatTblEnclosedArea = 0;
    }
    if (fatTblSpacing > 0) {
       /*check fat metal*/ 
       if (fatTblParallelLength > 0) {
          if (router_parallelLengthNetMode == 1 || parallelLengthMode == 1) {
             AREA spc_target { RANGE = [fatTblParallelLength * minWidth + 0.0001 , 9999999999 ] } TEMP = spc_target1
             COPY spc_target1 { } TEMP = spc_target2
          } else {
             COPY spc_target { } TEMP = spc_target2
          }
          if (parallelLengthMode == 1) {
             SELECT metal4  INTERACT fat { } TEMP = fat_all 
             BOOLEAN fat_all OR fat { } TEMP = fat2
             SELECT metal4  INTERACT spc_target2 { } TEMP = spc_target_all
             BOOLEAN spc_target_all OR spc_target2 { } TEMP = spc_target2
          } else {
             COPY fat { } TEMP = fat2
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING <= fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
                OUTPUT_EDGES = TRUE
             } TEMP = vio_edge
             SELECT vio_edge INTERACT fat { } TEMP = vio_edge
             SELECT vio_edge INTERACT spc_target1 { } TEMP = vio_edge
             SELECT violation INTERACT vio_edge { } TEMP = violation
          } else {
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
          }
          BOOLEAN violation NOT fat_target { } TEMP = violation
          if (fatTblParallelLength < fatTblSpacing) {
             SELECT_EDGE violation TOUCHING fat2 {
                VSIZE_INSIDE = fatTblParallelLength - 0.0002 
             } TEMP = vio_filter
             SELECT_CONTAINS vio_filter { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = vio_filter
             SELECT violation INTERACT vio_filter { } TEMP = violation
          } else {
             SELECT_CONTAINS violation { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = violation
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING = [fatTblSpacing, fatTblSpacing]
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
             } TEMP = violation3
             BOOLEAN violation3 NOT fat_target { } TEMP = violation3
             BOOLEAN violation NOT violation3 { } TEMP= violation
          }
          SELECT_EDGE fat2 TOUCHING violation { } TEMP=fat_viol
          BOOLEAN fat_viol AND violation { } TEMP=fat_viol
          SELECT_EDGE spc_target2 TOUCHING violation { } TEMP=spc_target2
          BOOLEAN spc_target2 AND violation { } TEMP= spc_target2
	  if (ignoreChildCell == 1) {
             EXTERNAL fat_viol spc_target2 {
		SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		TOUCH = FALSE
		POINT_TOUCH = FALSE
		NON_PARALLEL = TRUE
	     } TEMP = spc_mode0_out
             BOOLEAN spc_mode0_out NOT spc_mode0_child_out { } TEMP = spc_mode0_diff_out
             SELECT spc_mode0_out INTERACT spc_mode0_diff_out { } TEMP = spc_mode0_out
	     SELECT_EDGE fat2 TOUCHING spc_mode0_out { } TEMP=fat_viol
	     BOOLEAN fat_viol AND spc_mode0_out { } TEMP=fat_viol
	     SELECT_EDGE spc_target2 TOUCHING spc_mode0_out { } TEMP=spc_target2
	     BOOLEAN spc_target2 AND spc_mode0_out { } TEMP=spc_target2
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (17 )  		
	  } else {
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing 
	        SET_CORNERS_TO_SPACING = FALSE
	        PARALLEL_POINT_PROJECTION = FALSE
	        TOUCH = FALSE
	        POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (17 )
	  }
	  if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	     if (ignoreChildCell == 1) {
		EXTERNAL fat spc_target {
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} TEMP = spc_mode1_out
	        BOOLEAN spc_mode1_out NOT spc_mode1_child_out { } TEMP = spc_mode1_diff_out
	        SELECT spc_mode1_out INTERACT spc_mode1_diff_out { } TEMP = spc_mode1_out
                SELECT_EDGE fat TOUCHING spc_mode1_out { } TEMP=fat_viol
	        BOOLEAN fat_viol AND spc_mode1_out { } TEMP=fat_viol
	        SELECT_EDGE spc_target TOUCHING spc_mode1_out { } TEMP=spc_target2
	        BOOLEAN spc_target2 AND spc_mode1_out { } TEMP=spc_target2
	        EXTERNAL fat_viol spc_target2 {
	           COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um " 	    
		   SPACING < fatTblSpacing_dg
                   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} (17 )
	     } else {
	        EXTERNAL fat spc_target {
		   COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um "
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
	    	   PARALLEL_POINT_PROJECTION = FALSE
	           TOUCH = FALSE
	     	   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } (17 ) 
	     }
          }
       } else {
	  if (ignoreChildCell == 1) {
              EXTERNAL fat spc_target {
                 SPACING < fatTblSpacing
                 BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
              } TEMP = spc_out
	      BOOLEAN spc_out NOT spc_child_out { } TEMP = spc_diff_out
	      SELECT spc_out INTERACT spc_diff_out { } TEMP = spc_out
	      SELECT_EDGE fat TOUCHING spc_out { } TEMP=fat_viol
	      BOOLEAN fat_viol AND spc_out { } TEMP=fat_viol
              SELECT_EDGE spc_target TOUCHING spc_out { } TEMP=spc_target2
	      BOOLEAN spc_target2 AND spc_out { } TEMP=spc_target2
	      EXTERNAL fat_viol spc_target2 {
		 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
		 BOX_CORNER = FALSE 
		 NON_PARALLEL = TRUE
		 POINT_TOUCH = FALSE
	      } (17 ) 
	  } else {
	      EXTERNAL fat spc_target {
                 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
	         BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
	      } (17 ) 
	  }
       }
       /*check metal in the extension range*/ 
       if (fatTblExtensionRange > 0) {
	  if (fatWireExtensionMode == 0) {
	     SIZE fat { OVERSIZE = fatTblExtensionRange } TEMP = fat_tmp
             BOOLEAN fat_tmp AND metal4  { } TEMP = fat_tmp
  	     BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
             SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_ext
             BOOLEAN fat_ext OR fat { } TEMP = fat_ext
	     if (fatTblParallelLength > 0) {
                if (fatTblParallelLength > fatTblExtensionRange) {
                   SIZE fat { OVERSIZE = fatTblParallelLength } TEMP = fat_tmp
                   BOOLEAN fat_tmp AND metal4  { } TEMP = fat_tmp
  	           BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
                   SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_parallel
                   BOOLEAN fat_parallel OR fat { } TEMP = fat_parallel
                } else {
                   COPY fat_ext { } TEMP = fat_parallel
                }
		EXTERNAL fat_parallel spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
	           NON_PARALLEL = TRUE
	        } TEMP = vio_filter_set
		EXTERNAL fat_ext spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } TEMP = vio_set
                if (fatTblParallelLength < fatTblSpacing) {
                   SELECT_EDGE vio_filter_set TOUCHING fat_parallel {
                      VSIZE_INSIDE = fatTblParallelLength - 0.0002 
                   } TEMP = vio_filter_set_filter
                   SELECT_CONTAINS vio_filter_set_filter { 
                      WIDTH =  0.0002 
                      HEIGHT = fatTblParallelLength + 0.0001 
                   } TEMP = vio_filter_set_filter
                   SELECT vio_filter_set INTERACT vio_filter_set_filter { } TEMP = vio_filter
                } else {
	           SELECT_CONTAINS vio_filter_set { 
	              WIDTH =  0.0002 
	              HEIGHT = fatTblParallelLength + 0.0001 
	           } TEMP = vio_filter
                }
                SELECT vio_set INSIDE vio_filter { } TEMP = mode0_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out1 NOT mode0_child_out1 { } TEMP = mode0_diff_out1
                   SELECT mode0_out1 INTERACT mode0_diff_out1 { } TEMP = mode0_out1
                }
                COPY mode0_out1 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing  = fatTblSpacing um"
                } (17 )
		if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	           EXTERNAL fat_ext spc_target {
		      SPACING < fatTblSpacing_dg
	              SET_CORNERS_TO_SPACING = FALSE
		      PARALLEL_POINT_PROJECTION = FALSE
		      TOUCH = TRUE
		      POINT_TOUCH = FALSE
		      NON_PARALLEL = TRUE
	           } TEMP = mode0_out2
                   if (ignoreChildCell == 1) {
                      BOOLEAN mode0_out2 NOT mode0_child_out2 { } TEMP = mode0_diff_out2
                      SELECT mode0_out2 INTERACT mode0_diff_out2 { } TEMP = mode0_out2
                   }
                   COPY mode0_out2 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing (mode 1/2) = fatTblSpacing um/ fatTblSpacing_dg um "
                   } (17 )
	        } 
	     } else {
	        EXTERNAL fat_ext spc_target {
		   SPACING < fatTblSpacing
		   NON_PARALLEL = TRUE
		   SET_CORNERS_TO_SPACING = FALSE
		   POINT_TOUCH = FALSE
		} TEMP = mode0_out3
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out3 NOT mode0_child_out3 { } TEMP = mode0_diff_out3
                   SELECT mode0_out3 INTERACT mode0_diff_out3 { } TEMP = mode0_out3
                }
                COPY mode0_out3 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range ( fatTblExtensionRange um) minimum spacing = fatTblSpacing um"
                } (17 )
	     }
	  } else if (fatWireExtensionMode == 1) {
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal4  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             if (fatTblParallelLength > 0) {
                EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
		   BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   CHECK_SAME_POLYGON = TRUE 
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
	        SELECT fat_ext INTERACT spacing {  } TEMP = fat_ext
		BOOLEAN fat_ext OR spacing {  } TEMP = combined_fat_ext
                EXTERNAL combined_fat_ext fat {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
                } TEMP = fat_spacing
		BOOLEAN fat_spacing AND fat_ran {  } TEMP = fat_spacing
		BOOLEAN combined_fat_ext OR fat_spacing {  } TEMP = combined_fat_ext
                SELECT_CONTAINS combined_fat_ext { 
                   WIDTH =  0.0002 
                   HEIGHT = fatTblParallelLength + 0.0001 
                } TEMP = combined_fat_ext
		SELECT spacing INTERACT combined_fat_ext { 
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out1 NOT mode1_child_out1 { } TEMP = mode1_diff_out1
                   SELECT mode1_out1 INTERACT mode1_diff_out1 { } TEMP = mode1_out1 
                }
                COPY mode1_out1 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (17 ) 
	     } else {
               	EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
	           BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
	           CHECK_SAME_POLYGON = TRUE 
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
                SELECT spacing INTERACT fat_ext {
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out2
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out2 NOT mode1_child_out2 { } TEMP = mode1_diff_out2
                   SELECT mode1_out2 INTERACT mode1_diff_out2 { } TEMP = mode1_out2
                }
                COPY mode1_out2 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (17 )
	     }
	  } else if (fatWireExtensionMode == 2) {
	     SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
             BOOLEAN fat_ran AND metal4  {  } TEMP = fat_ext
             BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	      	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
             } TEMP = spacing
 	     SELECT spacing INSIDE fat_ran {  } TEMP = spacing
	     SELECT spacing OUTSIDE fat {  } TEMP = spacing
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode2_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode2_out NOT mode2_child_out { } TEMP = mode2_diff_out
                SELECT mode2_out INTERACT mode2_diff_out { } TEMP = mode2_out 
             }
             COPY mode2_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 2, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (17 )
	  } else if (fatWireExtensionMode == 3) {
             SIZE fat {
	        GROW_LEFT = fatTblExtensionRange
	        GROW_RIGHT = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal4  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	       	PARALLEL = TRUE

	       	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		HORIZONTAL_ONLY = TRUE
             } TEMP = spacing_hor
	     SELECT spacing_hor INSIDE fat_ran {  } TEMP = spacing_hor
	     SELECT spacing_hor OUTSIDE fat {  } TEMP = spacing_hor
             SIZE fat {
	        GROW_TOP = fatTblExtensionRange
	        GROW_BOTTOM = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal4  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	        POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		VERTICAL_ONLY = TRUE
             } TEMP = spacing_ver
	     SELECT spacing_ver INSIDE fat_ran {  } TEMP = spacing_ver
	     SELECT spacing_ver OUTSIDE fat {  } TEMP = spacing_ver
  	     BOOLEAN spacing_hor OR spacing_ver {  } TEMP = spacing
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal4  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
  	     /* check overlapped projection length */
 	     if (fatTblParallelLength > 0) {
                POLYGON_FEATURES fat_ext {
                   EQUATIONS {
                      vnum = EV_VNUM_IN;
                      if ( vnum > 0) {
                         bdLeft = EV_VXCOORD_IN[0];
                         bdRight = EV_VXCOORD_IN[0];
                         bdBottom = EV_VYCOORD_IN[0];
                         bdTop = EV_VYCOORD_IN[0];
                         FOR (i = 1; i < vnum; i++) {
                            if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
                            else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
                            if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
                            else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
                         } /* FOR i */
                         if ( (bdRight - bdLeft) >= fatTblParallelLength ||
                  	      (bdTop - bdBottom) >= fatTblParallelLength) {
                            FOR (i = 0; i < vnum; i++) {
                               EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
                               EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
                            }
                            EV_VNUM_OUT = vnum;
                 	    EV_SAVE_POLYGON();
                         }
                      }
                   }
                } TEMP = fat_ext /* POLYGON_FEATURE */
             }
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode3_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode3_out NOT mode3_child_out { } TEMP = mode3_diff_out
                SELECT mode3_out INTERACT mode3_diff_out { } TEMP = mode3_out
             }
             COPY mode3_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 3, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (17 )
          }
       }
       SET fatTblSpacing = 0;
    }
}
@ 561 "adrc/adrc.ev" 2


SET fatTblThreshold = 0;
SET fatTblEnclosedArea = 0;
SET fatTblExtensionRange = 0;
SET fatTblParallelLength = 0;
SET minWidth = 0;

/* End of Met4 fat table spacing rules */










/*metal 5*/
SET layer_name = "Met5";










SET minWidth = 0.056;
SET maxWidth = 5;
SET minArea = 0.016;
SET minEnclosedArea = 0.2;
SET minSpacing = 0.056;
SET sameNetMinSpacing = 0.056;
SET stub2StubSpacing = 0;

SET fatTblDimension = 5;
@ 1 "adrc/adrc_check_metal.ev" 1
/* Data Preparation */
if (fatTblDimension > 1 || fatWireThreshold > 0 || maxWidth > 0) {
  if (ignoreBlockage) {
      /* Let the real blockage be treated as thin */
      BOOLEAN metal5  NOT metal5_rbkg  {} TEMP=fat_candidate
  } else {
      COPY metal5  {} TEMP=fat_candidate
  }
  COPY fat_candidate {} TEMP=fat_target
}
/*Check width*/
if (minWidth > 0) {
    INTERNAL metal5  { 
        COMMENT = "$layer_name MinWidth  : minimum width = minWidth um" 
        SPACING < minWidth
        POINT_TOUCH = FALSE
    } (19 )
}
 
if (maxWidth > 0) {
    SIZE  fat_candidate {
        COMMENT = "$layer_name MaxWidth  : maximum width = maxWidth um"
 	UNDER_OVER = maxWidth / 2 
    } (19 ) 
}
 
/*Check area*/
if (minArea > 0) {
    AREA metal5  { 
	COMMENT = "$layer_name MinArea   : minimum area = minArea um*um"
	RANGE = [0.0001 * 0.0001 , minArea - 0.0001 * 0.0001 ]
    } (19 )
}
/* check min length of bounding box on polygon */
if (minLength > 0) {
  if (minLengthMode == 1) {
    INTERNAL metal5  {
        SPACING < minLength
        VERTICAL_ONLY = TRUE
        SET_CORNERS_TO_SPACING = FALSE
    } TEMP = ver_short
    BOOLEAN metal5  NOT ver_short { } TEMP = ver_long
    INTERNAL metal5  {
        SPACING < minLength
        HORIZONTAL_ONLY = TRUE
        SET_CORNERS_TO_SPACING = FALSE
    } TEMP = hor_short
    BOOLEAN metal5  NOT hor_short { } TEMP = hor_long
    SELECT CUT_LAYER1 INSIDE ver_long { } TEMP = good_cut
    BOOLEAN CUT_LAYER1 NOT good_cut { } TEMP = fail_cut_1
    SELECT fail_cut_1 INSIDE hor_long { } TEMP = good_cut
    BOOLEAN fail_cut_1 NOT good_cut { } TEMP = fail_cut_1
    SELECT CUT_LAYER2 INSIDE ver_long { } TEMP = good_cut
    BOOLEAN CUT_LAYER2 NOT good_cut { } TEMP = fail_cut_2
    SELECT fail_cut_2 INSIDE hor_long { } TEMP = good_cut
    BOOLEAN fail_cut_2 NOT good_cut { } TEMP = fail_cut_2
    BOOLEAN fail_cut_1 OR fail_cut_2 { } TEMP = fail_cut
    BOOLEAN hor_short NOT ver_long { } TEMP = hor_short
    BOOLEAN ver_short NOT hor_long { } TEMP = ver_short
    SELECT ver_short INTERACT fail_cut { } TEMP = ver_fail
    SELECT hor_short INTERACT fail_cut { } TEMP = hor_fail
    BOOLEAN ver_fail OR hor_fail { } TEMP = all_fail
    INTERNAL all_fail {
        COMMENT = "$layer_name MinLength : minimum length = minLength um"
        SPACING < minLength
        VERTICAL_ONLY = TRUE
        SET_CORNERS_TO_SPACING = FALSE
    } (19 )
  } else {
    POLYGON_FEATURES metal5  {
      COMMENT = "$layer_name MinLength : minimum length = minLength um"
      EQUATIONS {
        vnum = EV_VNUM_IN;
        if ( vnum > 0) {
	  bdLeft = EV_VXCOORD_IN[0];
	  bdRight = EV_VXCOORD_IN[0];
	  bdBottom = EV_VYCOORD_IN[0];
	  bdTop = EV_VYCOORD_IN[0];
          FOR (i = 1; i < vnum; i++) {
	    if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
            else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
	    if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
            else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
          }
	  if ( (bdRight - bdLeft) < minLength &&
	       (bdTop - bdBottom) < minLength) {
	    FOR (i = 0; i < vnum; i++) {
              EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
	      EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
            }
	    EV_VNUM_OUT = vnum;
	    EV_SAVE_POLYGON();
          }
        }
      }
    } (19 ) 
  }
  SET minLength = 0;
}
/* check max length of bounding box on polygon */
if (maxLength > 0) {
  POLYGON_FEATURES metal5  {
    COMMENT = "$layer_name MaxLength : maximum length = maxLength um"
    EQUATIONS {
      vnum = EV_VNUM_IN;
      if ( vnum > 0) {
	bdLeft = EV_VXCOORD_IN[0];
	bdRight = EV_VXCOORD_IN[0];
	bdBottom = EV_VYCOORD_IN[0];
	bdTop = EV_VYCOORD_IN[0];
        FOR (i = 1; i < vnum; i++) {
	  if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
          else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
	  if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
          else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
        }
	if ( (bdRight - bdLeft + bdTop - bdBottom) > maxLength ) {
          EV_VXCOORD_OUT[0] = bdLeft;
	  EV_VYCOORD_OUT[0] = bdBottom;
          EV_VXCOORD_OUT[1] = bdLeft;
	  EV_VYCOORD_OUT[1] = bdTop;
          EV_VXCOORD_OUT[2] = bdRight;
	  EV_VYCOORD_OUT[2] = bdTop;
          EV_VXCOORD_OUT[3] = bdRight;
	  EV_VYCOORD_OUT[3] = bdBottom;
          EV_VXCOORD_OUT[4] = bdLeft;
	  EV_VYCOORD_OUT[4] = bdBottom;
	  EV_VNUM_OUT = 5;
	  EV_SAVE_POLYGON();
        }
      }
    }
  } (19 ) 
  SET maxLength = 0;
}
 
/*Check enclosed area*/
if (minEnclosedArea > 0) {
    SELECT metal5  INSIDE_HOLE {
        INNER_HOLE_ONLY
    } TEMP = holes
    BOOLEAN holes NOT metal5  { } TEMP = holes
 
    AREA holes {
        COMMENT = "$layer_name EnclsArea : minimum enclosed area = minEnclosedArea um*um"
        RANGE = [0.0001 * 0.0001 , minEnclosedArea - 0.0001 * 0.0001 ]
    } (19 )
    /* check min length of bounding box on polygon */
    if (minEnclosedWidth > 0) {
      POLYGON_FEATURES holes {
        COMMENT = "$layer_name EnclsWidth: minimum enclosed Width = minEnclosedWidth um"
        EQUATIONS {
          vnum = EV_VNUM_IN;
          if ( vnum > 0) {
            bdLeft = EV_VXCOORD_IN[0];
            bdRight = EV_VXCOORD_IN[0];
            bdBottom = EV_VYCOORD_IN[0];
            bdTop = EV_VYCOORD_IN[0];
            FOR (i = 1; i < vnum; i++) {
              if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
              else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
              if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
              else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
            }
            if ( (bdRight - bdLeft) < minEnclosedWidth &&
                 (bdTop - bdBottom) < minEnclosedWidth) {
              FOR (i = 0; i < vnum; i++) {
                EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
                EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
              }
              EV_VNUM_OUT = vnum;
              EV_SAVE_POLYGON();
            }
          }
        }
      } (19 ) 
    }
}
 
/*check special notch rule*/
if ((minEdgeLength2 > 0.0001  && minEdgeLength3 > 0.0001 ) || minEdgeMode==2) {
  if (minEdgeMode==2) {
    SET minEdgeLength3 = minEdgeLength ;
  }
  NOTCH metal5  {
     SPACING < minEdgeLength3
     SET_CORNERS_TO_SPACING=FALSE
     PARALLEL = TRUE
     OUTPUT_EDGES = TRUE
  } TEMP = notch_vectors
  SELECT_VECTOR notch_vectors {
     LENGTH_RANGE = [0.0001 , minEdgeLength2 - 0.0001 ]
  } TEMP = short_edges
  EXTERNAL short_edges metal5  {
     SPACING < minEdgeLength3
     SET_CORNERS_TO_SPACING=FALSE
     PARALLEL = TRUE
  } TEMP = notch_err
  /* Choose the real U-shaped notch */
  SIZE notch_err { OVERSIZE = 0.0002 *10 } TEMP = neighbors 
  BOOLEAN neighbors AND metal5  { } TEMP = neighbors
  VERTEX neighbors { 
     CONCAVE = TRUE
     CONVEX = TRUE
     SIZE = 0.0002 
  } TEMP = corners
  SELECT_EDGE neighbors INTERACT notch_err { } TEMP = target_edges
  BOOLEAN target_edges NOT corners { } TEMP = target_edges
  VERTEX neighbors { 
     CONCAVE = TRUE
     SIZE = 2* 0.0002 
  } TEMP = corners
  SELECT target_edges INTERACT corners { RANGE = [2, 2] } TEMP=target_edges
  SELECT notch_err INTERACT target_edges {
     COMMENT = "$layer_name SpeclNotch: sameNetSp = minEdgeLength3 um (sideLen minEdgeLength2 um)" 
  } (19 )
}
/*check consecutive short edges*/
if (minEdgeLength > 0.0001  && minEdgeMode != 2) { 
  INTERNAL metal5_top  {
     SEGMENT < minEdgeLength
     FLAG_ACUTE_ANGLE = FALSE
     FLAG_ACUTE_EDGE = FALSE
     OUTPUT_EDGES = TRUE
  } TEMP = short_edges
  if ((minEdgeMode == 0 && maxTotalMinEdgeLength>0) || maxNumMinEdge > 0) {
    SET temporary_1 = 0.0002 *2;
    SET temporary_2 = 2*temporary_1+ 0.0001 ;
    SELECT metal5_top  INTERACT short_edges { } TEMP = target_top
    CLASSIFY_EDGES target_top {
       LENGTH = temporary_1
       DMIN   = temporary_2
       INSIDE_CORNER  TEMP = inside_corner_edges
       OUTSIDE_CORNER TEMP = outside_corner_edges
       REMAINDER      TEMP = remainder_edges
    }
    if (minEdgeMode == 0 && (maxNumMinEdge>0 || maxTotalMinEdgeLength > 0)) {
       SELECT short_edges ENCLOSING inside_corner_edges { } TEMP = short_edges
    }
  }
  if (maxTotalMinEdgeLength > 0) {
    LENGTH short_edges {
       RANGE = [maxTotalMinEdgeLength + 0.0001 , 9999999999 ]
    } TEMP = max_length_err
    /* Work around: translate polygons into dimensional check output */
    SIZE max_length_err { OVERSIZE = 2* 0.0002  } TEMP = max_length_err
    INTERNAL max_length_err {
       SPACING < 3* 0.0002 
       SET_CORNERS_TO_SPACING=FALSE
       COMMENT = "$layer_name MinEdgeLen: maximum total length ( minEdgeLength um)= maxTotalMinEdgeLength um"
    } (19 )
  }
  if (maxTotalMinEdgeLength == 0 || maxNumMinEdge > 0) {
    if (maxNumMinEdge==0)  {
       COPY short_edges {} TEMP=max_edge_err
    } else {
       SIZE short_edges {
         VSIZE_HEAD = - 0.0002 
        VSIZE_TAIL = - 0.0002 
       } TEMP = short_edges
       SIZE short_edges {
          OVERSIZE = 5* 0.0002 
          SIZE_ENDPOINTS = FALSE
       } TEMP = short_contours
       SELECT short_contours ENCLOSING remainder_edges {
          RANGE = [maxNumMinEdge + 1, 9999999999 ]
       } TEMP = short_contours
       SELECT short_edges INSIDE short_contours { } TEMP=max_edge_err
    }
    /* Work around: translate polygons into dimensional check output */
    SIZE max_edge_err { OVERSIZE = 2* 0.0002  } TEMP = max_edge_error
    INTERNAL max_edge_error {
       SPACING < 3* 0.0002 
       SET_CORNERS_TO_SPACING=FALSE
       COMMENT = "$layer_name MinEdgeLen: maximum number of consecutive short edges ( minEdgeLength um)= maxNumMinEdge"
    } (19 ) 
  }
}
 
/*check basic spacing*/
if (sameNetMinSpacing > 0 && sameNetMinSpacing != minSpacing) {
  if (sameNetMinSpacing > minSpacing) {
    /* Special condition for U-shaped Metal spacing rule */
    NOTCH metal5_pin  {
        SPACING < sameNetMinSpacing
        BOX_CORNER = FALSE 
        SET_CORNERS_TO_SPACING=FALSE
        NON_PARALLEL = TRUE
        OUTPUT_EDGES = TRUE
    } TEMP = errs_to_be_waived
    NOTCH metal5_top  {
	SPACING < sameNetMinSpacing
	BOX_CORNER = FALSE 
        SET_CORNERS_TO_SPACING=FALSE
	NON_PARALLEL = TRUE
        OUTPUT_EDGES = TRUE
    } TEMP = all_errs
    BOOLEAN all_errs NOT errs_to_be_waived { } TEMP=err_edge
    EXTERNAL err_edge metal5_top  {
	SPACING < sameNetMinSpacing
	BOX_CORNER = FALSE 
        SET_CORNERS_TO_SPACING=FALSE
	NON_PARALLEL = TRUE
    } TEMP = notch_err
    SIZE notch_err { OVERSIZE = 0.0002 *10 } TEMP = neighbors
    BOOLEAN neighbors AND metal5_top  { } TEMP = neighbors
    VERTEX neighbors { 
       CONCAVE = TRUE
       CONVEX = TRUE
       SIZE = 0.0002 
    } TEMP = corners
    SELECT_EDGE neighbors INTERACT notch_err { } TEMP = target_edges
    BOOLEAN target_edges AND notch_err { } TEMP = target_edges
    BOOLEAN target_edges NOT corners { } TEMP = target_edges
    VERTEX neighbors {
       CONCAVE = TRUE
       SIZE = 2* 0.0002 
    } TEMP = corners
    SELECT target_edges INTERACT corners { RANGE = [2, 2] } TEMP = target_edges
    SELECT notch_err TOUCHING target_edges {
      COMMENT = "$layer_name U-ShpNotch: U-shape notch minimum spacing = sameNetMinSpacing um" 
    } (19 )
  } else {
    NOTCH metal5  {
        COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = sameNetMinSpacing um" 
	SPACING < sameNetMinSpacing
	BOX_CORNER = FALSE 
	NON_PARALLEL = TRUE
    } (19 )
  }
  if (minSpacing > 0) {
    if (stubMode == 0 && stubSpacing > 0 && stubSpacing < minSpacing) {
	EXTERNAL metal5  {
	    COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um"
            LONGEDGE > stubThreshold + 0.0001 
	    LONGEDGE_TO_EDGE < minSpacing
	    SPACING <= 0
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            CHECK_SAME_POLYGON = TRUE 
	} (19 )
    } else {
        EXTERNAL metal5  {
	    COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um" 
	    SPACING < minSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
	    CHECK_SAME_POLYGON = FALSE
        } (19 )
    }
  }
} else {
  if (minSpacing > 0) {
    if (stubMode == 0 && stubSpacing > 0 && stubSpacing < minSpacing) {
        EXTERNAL metal5  {
            COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um"
            LONGEDGE > stubThreshold + 0.0001  
            LONGEDGE_TO_EDGE < minSpacing
            SPACING <= 0 
            BOX_CORNER = FALSE 
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            CHECK_SAME_POLYGON = TRUE 
        } (19 )
    } else {
        EXTERNAL metal5  {
	    COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um" 
            SPACING < minSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
	    CHECK_SAME_POLYGON = TRUE 
        } (19 )
    }
  }
}
 
/*check dogbone */
if (sameNetMinSpacing > 0 && sameNetWidthThreshold) {
  NOTCH metal5  {
    SPACING < sameNetMinSpacing
    BOX_CORNER = FALSE 
    NON_PARALLEL = TRUE
  } TEMP = dog_bone
 
  if (!layer_empty(dog_bone)) {
    SIZE dog_bone {EDGESIZE = sameNetWidthThreshold} TEMP = dog_ext
    BOOLEAN dog_ext NOT dog_bone {} TEMP = dog_ext
    BOOLEAN dog_ext AND metal5  {} TEMP = dog_ext
    if (!layer_empty(dog_ext)) {
      SELECT dog_ext EDGE_TOUCH dog_bone { OUTSIDE RANGE = [1, 9999999999 ] } TEMP = dog_ext
      NOTCH metal5  {
        SPACING < sameNetMinSpacing
        BOX_CORNER = FALSE 
        NON_PARALLEL = TRUE
	OUTPUT_EDGES = TRUE
      } TEMP = dog_bone
      SELECT dog_ext OUTSIDE dog_bone {} TEMP = dog_ext
      INTERNAL dog_ext {
	COMMENT = "$layer_name dogBone   : notch spacing = sameNetMinSpacing um width sameNetWidthThreshold um" 
	SPACING < sameNetWidthThreshold
      } (19 )
    }
  }
}
/*check basic fat spacing*/
if (fatWireThreshold > 0 && fatTblDimension == 0) {
    SIZE fat_candidate { UNDER_OVER = fatWireThreshold / 2.0 - 0.0001  } TEMP = m_fat
    BOOLEAN m_fat AND metal5  {  } TEMP = m_fat
    BOOLEAN metal5  NOT m_fat {  } TEMP = m_thin
    if (ignoreBlockage == 0) {
        /* the blockages on the metal_blockage layer are treated as thin blockages */
        BOOLEAN m_thin OR metal5_blockage  {  } TEMP = m_thin
    }
 
    if (fatFatMinSpacing > 0) {
	EXTERNAL m_fat {
	    COMMENT = "$layer_name FatWireSpc: fat & fat ( fatWireThreshold um) minimum spacing = fatFatMinSpacing um"
	    SPACING < fatFatMinSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = FALSE
	    CHECK_SAME_POLYGON = TRUE 
       } (19 )
    }
 
    if (fatThinMinSpacing > 0) {
	EXTERNAL m_fat m_thin {
	    COMMENT = "$layer_name FatWireSpc: fat & thin ( fatWireThreshold um) minimum spacing fatThinMinSpacing um"
	    SPACING < fatThinMinSpacing
 	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = FALSE
        } (19 )
    }
}
 
/*check thin blockage spacing*/
if (minSpacing > 0 && ignoreBlockage == 0) {
    if (!layer_empty (metal5_blockage )) {
	EXTERNAL metal5_blockage  metal5  {
	    COMMENT = "$layer_name Spacing   : metal & thin blockage minimum spacing = minSpacing um"
	    SPACING < minSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
            TOUCH = TRUE
        } (19 )
    }
}
/*check blockage overlap*/
/*check shorts between top_level routing and fram_blockages*/
if (minSpacing>0 || checkCrossHierShort>0) {
   if (ignoreBlockage == 0) {
      BOOLEAN metal5_blockage  or metal5_rbkg  {} TEMP=all_blockage
   } else {
      COPY metal5_rbkg  {} TEMP=all_blockage
   }
   BOOLEAN all_blockage AND metal5_top  {} TEMP = overlap_shape1
   EXTERNAL all_blockage metal5_top  {
      SPACING <= 0
      TOUCH = TRUE
   } TEMP = overlap_shape2
   if (checkCrossHierShort>0) {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
         COMMENT = "$layer_name Short Cross Hierarchy"
      } (19 )
   } else {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
         COMMENT = "$layer_name Overlap   : metal & blockage overlap"
      } (19 )
   }
}
 
if (fatPolyContactRule > 0) {
  /* Fat Poly Contact Rule: not new fat wire formed */
  if (readCellView > 0) {
     SIZE metal1 { UNDER_OVER = fatPolyContactRule / 2.0 - 0.0001  } TEMP = fat
     BOOLEAN fat AND metal1 {  } TEMP = fat 
  } else {
     SIZE metal1_top { UNDER_OVER = fatPolyContactRule / 2.0 - 0.0001  } TEMP = fat
     BOOLEAN fat AND metal1_top {  } TEMP = fat 
  }
  SIZE metal1_pin { UNDER_OVER = fatPolyContactRule / 2.0 - 0.0001  } TEMP = fat_pin
  BOOLEAN fat_pin AND metal1_pin {  } TEMP = fat_pin
  BOOLEAN fat NOT fat_pin {
    COMMENT = "$layer_name FatPolyContactRule: fatPolyContactRule um" 
  } (19 )
}
/* Special End-of-Line Spacing Rule */
if (stubMode == 0 && stubSpacing > 0 && stubSpacing < minSpacing) {
  EXTERNAL metal5  {
     COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 0)"
     LONGEDGE > stubThreshold + 0.0001 
     LONGEDGE_TO_EDGE <= 0 
     SPACING < stubSpacing 
     SET_CORNERS_TO_SPACING = FALSE
     PARALLEL_POINT_PROJECTION = FALSE
  } (19 )
} else if (stubMode > 0 && stubSpacing > minSpacing) {
  if (stubMode == 4) {
     INTERNAL metal5  {
        SEGMENT[90,90] < stubThreshold
        OUTPUT_EDGES = TRUE
     } TEMP = end_of_line
  } else {
     INTERNAL metal5  {
        SEGMENT[90,90] <= stubThreshold
        OUTPUT_EDGES = TRUE
     } TEMP = end_of_line
  }
  /* Quick filter to reduce the size of possible end of line */
  if (sideStubExt > 0) {
    SIZE end_of_line {
       VSIZE_HEAD = sideStubExt
       VSIZE_TAIL = sideStubExt
       OUTPUT_EDGES = TRUE
    } TEMP = eol_ext
  } else {
    COPY end_of_line { } TEMP=eol_ext
  }
  if (stub2StubSpacing > stubSpacing) {
     SET temporary_1 = stub2StubSpacing;
  } else {
     SET temporary_1 = stubSpacing; 
  }
  EXTERNAL eol_ext metal5  {
     SPACING < temporary_1
     TOUCH = TRUE
     OVERLAP = TRUE 
     SET_CORNERS_TO_SPACING = FALSE
     PARALLEL_POINT_PROJECTION = FALSE
     OUTPUT_EDGES = TRUE
  } TEMP=err_edge
  SELECT eol_ext INTERACT err_edge { } TEMP=eol_ext
  SELECT end_of_line INTERACT eol_ext { } TEMP=end_of_line 
  /* Reduce the size of METAL_LAYER */
  if (stubMode==3) {
     SIZE end_of_line {
        VSIZE_HEAD = stubSpacing 
        VSIZE_TAIL = stubSpacing 
        VSIZE_INSIDE = sideStubThreshold
        VSIZE_OUTSIDE = stubSpacing
     } TEMP = eol_filter 
  } else {
     if (stubMode == 1 && stubRange > 0) {
        SIZE end_of_line {
           VSIZE_HEAD = stubSpacing- 0.0001 
           VSIZE_TAIL = stubSpacing- 0.0001 
           VSIZE_OUTSIDE = stubSpacing- 0.0001 
        } TEMP = eol_filter
     } else {
        SIZE end_of_line {
           VSIZE_HEAD = stubSpacing- 0.0001 
           VSIZE_TAIL = stubSpacing- 0.0001 
           VSIZE_INSIDE = sideStubThreshold- 0.0001 
           VSIZE_OUTSIDE = stubSpacing- 0.0001 
        } TEMP = eol_filter
     }
  }
  SELECT metal5  INTERACT eol_filter { } TEMP=target_top
  /* Get the side edges and the whole eol of line set */
  SELECT_EDGE target_top INTERACT end_of_line { 
    POINT_TOUCH = TRUE
  } TEMP = eol_set
  VERTEX target_top { 
     CONCAVE = TRUE 
     CONVEX = TRUE
     SIZE = 0.0002 
  } TEMP = corners
  SELECT corners OUTSIDE end_of_line {} TEMP =corners 
  BOOLEAN eol_set NOT corners { } TEMP=eol_set
  BOOLEAN eol_set NOT end_of_line { } TEMP=side_edge
  /* find out the real end of line */
  if (stubRange > 0) {
     if (stubMode == 1) {
         COPY side_edge { } TEMP = all_side_edge
         LENGTH side_edge { SPACING <= stubRange- 0.0001  } TEMP=side_edge
     } else {
         LENGTH side_edge { SPACING < stubRange- 0.0002  } TEMP=eol_filter
         BOOLEAN side_edge NOT eol_filter { } TEMP=side_edge
     }
     SELECT end_of_line INTERACT side_edge { RANGE = [1,2] } TEMP = end_of_line
  } 
  if (stubMode == 1) {
    if (stub2StubSpacing > 0) {
       if (sideStubExt < 0) {
          SIZE end_of_line {
            VSIZE_HEAD = sideStubExt / 2
            VSIZE_TAIL = sideStubExt / 2
            OUTPUT_EDGES = TRUE
          } TEMP = eol_ext_tip
	 
          EXTERNAL eol_ext_tip {
            COMMENT = "$layer_name specEoLSpc: stub2Stubspacing= stub2StubSpacing um (mode = 1)"
            SPACING < stub2StubSpacing
            SET_CORNERS_TO_SPACING = FALSE
            PARALLEL_POINT_PROJECTION = TRUE
          } (19 )
       } else {
          EXTERNAL end_of_line {
            COMMENT = "$layer_name specEoLSpc: stub2Stubspacing= stub2StubSpacing um (mode = 1)"
            SPACING < stub2StubSpacing
            SET_CORNERS_TO_SPACING = FALSE
            PARALLEL_POINT_PROJECTION = FALSE
          } (19 )
       }
    }
    if (stubRange > 0) {
       SIZE end_of_line {
         VSIZE_INSIDE = 0.0002 
       } TEMP = eol_poly
       SELECT_EDGE eol_poly TOUCHING target_top { } TEMP=eol_edge
       EXTERNAL eol_edge target_top {
         COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
         CONVEX_TO_CONVEX < stubSpacing
         CONVEX_TO_CONVEX [POINT_PROJECTION] < stubSpacing
         CONVEX_TO_EDGE < stubSpacing
         CONCAVE_TO_CONVEX < stubSpacing
         LONGEDGE > 0.0002 
         LONGEDGE_TO_EDGE < stubSpacing
         SPACING <= 0
         SET_CORNERS_TO_SPACING = TRUE
         PARALLEL_POINT_PROJECTION = TRUE
       } (19 )
       SELECT all_side_edge INTERACT end_of_line { } TEMP = side_edge
       SIZE side_edge {
         VSIZE_HEAD = 0.0002 
         VSIZE_TAIL = 0.0002 
       } TEMP = side_edge_ext
       BOOLEAN side_edge_ext NOT side_edge { } TEMP = side_edge_ext
       SELECT side_edge_ext INTERACT end_of_line { } TEMP = side_edge_ext
       EXTERNAL side_edge_ext target_top {
         COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
         SPACING < stubSpacing
         SET_CORNERS_TO_SPACING = FALSE
         PARALLEL_POINT_PROJECTION = FALSE
       } (19 )
    } else {
       if (stub2StubSpacing > 0) {
         VECTORIZE target_top {
            DIRECTED=TRUE
         } TEMP=target_edges
         BOOLEAN target_edges NOT end_of_line { } TEMP = target_edges
         EXTERNAL end_of_line target_edges {
            COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
            SPACING < stubSpacing
            TOUCH=TRUE
            OVERLAP=TRUE
            SET_CORNERS_TO_SPACING=FALSE
            PARALLEL_POINT_PROJECTION=FALSE
         } (19 )
       } else {
         if (sideStubExt > 0) {
            SIZE end_of_line {
               VSIZE_HEAD = sideStubExt
               VSIZE_TAIL = sideStubExt
               OUTPUT_EDGES = TRUE
            } TEMP = end_of_line
            EXTERNAL end_of_line target_top {
               COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing ,crnKeepOut= sideStubExt um (mode = 1)"
               SPACING < stubSpacing
               TOUCH=TRUE
               OVERLAP=TRUE
               SET_CORNERS_TO_SPACING=FALSE
               PARALLEL_POINT_PROJECTION=FALSE
            } (19 )
         } else {
            EXTERNAL end_of_line target_top {
               COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
               SPACING < stubSpacing
               TOUCH=TRUE
               OVERLAP=TRUE
               SET_CORNERS_TO_SPACING=FALSE
               PARALLEL_POINT_PROJECTION=FALSE
            } (19 )
         }
       }
    }
  } else { /* stubMode == 2,3,4 */
    /* stubMode 2 eol classify and reduction */
    if (stubMode !=3 && sideStubExt > 0) {
      if (stubMode == 4) {
        SIZE end_of_line {
           VSIZE_HEAD = sideStubExt
           VSIZE_TAIL = sideStubExt
           OUTPUT_EDGES = TRUE
        } TEMP = eol_ext
        EXTERNAL eol_ext target_top {
           SPACING < stubSpacing
           SET_CORNERS_TO_SPACING=FALSE
           PARALLEL_POINT_PROJECTION=FALSE
           OUTPUT_EDGES = TRUE
        } TEMP=err_edge
        SELECT eol_ext INTERACT err_edge { } TEMP=eol_ext
      } else {
        EXTERNAL end_of_line target_top {
           SPACING < stubSpacing
           SET_CORNERS_TO_SPACING=FALSE
           PARALLEL_POINT_PROJECTION=FALSE
           OUTPUT_EDGES = TRUE
        } TEMP=err_edge
        SELECT end_of_line INTERACT err_edge { } TEMP=eol_body
        SIZE end_of_line {
           VSIZE_HEAD = sideStubExt
           VSIZE_TAIL = sideStubExt
           OUTPUT_EDGES = TRUE
        } TEMP = eol_ext
        BOOLEAN eol_ext NOT end_of_line {} TEMP=eol_ext
        EXTERNAL eol_ext target_top {
           SPACING < stubSpacing
           SET_CORNERS_TO_SPACING=FALSE
           PARALLEL_POINT_PROJECTION=FALSE
           OUTPUT_EDGES = TRUE
        } TEMP=err_edge
        SELECT eol_ext INTERACT err_edge { } TEMP=eol_ext
        BOOLEAN eol_body OR eol_ext { } TEMP=eol_ext
      } 
    } else {
      COPY end_of_line { } TEMP=eol_ext
    }
    SELECT side_edge INTERACT eol_ext { } TEMP=side_edge
    SIZE eol_ext {
       VSIZE_INSIDE = sideStubThreshold 
       VSIZE_OUTSIDE = sideStubExt
    } TEMP = eol_range
    if (sideStubExt > 0) {
       SIZE side_edge {
          VSIZE_HEAD = sideStubExt
          VSIZE_TAIL = sideStubExt
          OUTPUT_EDGES = TRUE
       } TEMP = check_edge
    } else {
       COPY side_edge { } TEMP = check_edge
    }
    BOOLEAN check_edge AND eol_range { } TEMP=check_edge
    EXTERNAL check_edge target_top {
       SPACING < temporary_1
       SET_CORNERS_TO_SPACING = FALSE
       SHADOW_OTHER_LAYER = TRUE
       PARALLEL_POINT_PROJECTION = FALSE
       OUTPUT_EDGES = TRUE
    } TEMP=err_edge
    if (0 && stubMode!=4) { /* Temporarily do not check mode 2,3 side edge length */
       LENGTH side_edge { SPACING < stubSpacing- 0.0001 *2 } TEMP=err_edge_1
       BOOLEAN err_edge OR err_edge_1 { } TEMP=err_edge
    }
    SELECT check_edge INTERACT err_edge { } TEMP=side_edge
    if (stubMode!=3) {
       SELECT eol_ext INTERACT side_edge {} TEMP=err_eol
       EXTERNAL err_eol target_top {
          COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing ,crnKeepOut= sideStubExt um (mode = stubMode )"
          SPACING < temporary_1
          PARALLEL_POINT_PROJECTION=FALSE
          SET_CORNERS_TO_SPACING=FALSE
       } (19 )
    } else { /* stubMode == 3 */
       SELECT eol_ext INTERACT side_edge { RANGE = [2, 2] } TEMP=err_eol
       EXTERNAL err_eol target_top {
          COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 3)"
          SPACING < temporary_1
          PARALLEL_POINT_PROJECTION=FALSE
          SET_CORNERS_TO_SPACING=FALSE
       } (19 )
    }
  }
} /* stubMode > 0, not aligned */
/* Avoid empty optimization result parsing error */
if (addEmptyMetalCheck) {
   BOOLEAN empty OR empty {
      COMMENT = "$layer_name Empty: Dummy Output"
   } (19 )
   SET addEmptyMetalCheck=0;
}
/* reset variables */


 
SET minWidth = 0;
SET maxWidth = 0;
SET minArea = 0;
SET minEnclosedArea = 0;
SET minSpacing = 0;
SET sameNetMinSpacing = 0;
SET maxNumMinEdge = 0;
SET maxTotalMinEdgeLength = 0;
SET minEdgeLength = 0;
SET minEdgeLength2 = 0;
SET minEdgeLength3 = 0;
SET stubRange = 0;
SET stubSpacing = 0;
SET stub2StubSpacing = 0;
SET sideStubExt = 0;
SET sideStubThreshold = 0;
SET stubThreshold = 0;
SET fatPolyContactRule = 0;
SET fatWireThreshold = 0;
SET fatThinMinSpacing = 0;
SET fatFatMinSpacing = 0;
SET fatTblDimension = 0;
@ 601 "adrc/adrc.ev" 2

SET minSpacing = 0.056;
SET fatTblThresh_protru = 0.15;
SET fatTblLength_protru = 0.1;
SET fatTblWidth_protru = 0.06;
@ 1 "adrc/adrc_protru.ev" 1
/*protrusion length rule*/
SIZE metal5     { UNDER_OVER = fatTblThresh_protru / 2.0 - 0.0001  } TEMP = fat
BOOLEAN fat AND metal5  {  } TEMP = fat 
BOOLEAN metal5  NOT fat {  } TEMP = fat_nbr
SIZE fat { OVERSIZE = fatTblLength_protru + 0.0001  } TEMP = fat_ext
BOOLEAN fat_nbr AND fat_ext {} TEMP = fat_nbr
SELECT fat_nbr INTERACT fat TEMP = fat_nbr
/* Get the correct fat extension */
SELECT_EDGE fat_nbr TOUCHING fat { } TEMP = ext_filter
SIZE ext_filter { VSIZE_INSIDE = 0.0001  } TEMP = ext_filter
SIZE ext_filter INSIDE fat_nbr {
   OVERSIZE = fatTblLength_protru- 0.0001 
   INCREMENT = minSpacing
} TEMP=dummy TEMP = fat_nbr
  
VERTEX fat_nbr {
   CONCAVE = TRUE
   SIZE = 0.0002 
} TEMP = corners
SELECT fat_nbr OUTSIDE corners { } TEMP = fat_nbr1
BOOLEAN fat_nbr NOT fat_nbr1 { } TEMP = fat_nbr2
SELECT_CONTAINS fat_nbr1 {
   WIDTH =  0.0002 
   HEIGHT = fatTblLength_protru
} TEMP = good_fat_nbr1
BOOLEAN fat_nbr1 NOT good_fat_nbr1 { } TEMP = fat_nbr1
/* check with L or T shape of fat extension */
SELECT_EDGE fat_nbr2 INTERACT corners { } TEMP = side_edge
LENGTH side_edge { SPACING < fatTblLength_protru } TEMP = vio_edge
SELECT fat_nbr2 INTERACT vio_edge { } TEMP = fat_nbr2
BOOLEAN fat_nbr1 OR fat_nbr2 { } TEMP = fat_nbr
INTERAL fat_nbr {
   SPACING < fatTblWidth_protru
} TEMP = possible_err
if (!layer_empty(possible_err)) {
   SELECT fat_nbr INTERACT possible_err { } TEMP=fat_nbr
   SELECT fat INTERACT fat_nbr {} TEMP=fat
   BOOLEAN fat OR fat_nbr {} TEMP=fat
   INTERNAL fat {
      COMMENT = "$layer_name ProtrusionLength : threshold fatTblThresh_protru um, length  fatTblLength_protru um, width fatTblWidth_protru um"
      SPACING < fatTblWidth_protru
   } (19 )
}
/* protrusion leng rule check */
SET fatTblThresh_protru = 0;
SET fatTblLength_protru = 0;
SET fatTblWidth_protru = 0;
SET minSpacing = 0;
@ 606 "adrc/adrc.ev" 2


SET minSpacing = 0.056;
SET fatTblThresh_protru = 0.3;
SET fatTblLength_protru = 0.15;
SET fatTblWidth_protru = 0.07;
@ 1 "adrc/adrc_protru.ev" 1
/*protrusion length rule*/
SIZE metal5     { UNDER_OVER = fatTblThresh_protru / 2.0 - 0.0001  } TEMP = fat
BOOLEAN fat AND metal5  {  } TEMP = fat 
BOOLEAN metal5  NOT fat {  } TEMP = fat_nbr
SIZE fat { OVERSIZE = fatTblLength_protru + 0.0001  } TEMP = fat_ext
BOOLEAN fat_nbr AND fat_ext {} TEMP = fat_nbr
SELECT fat_nbr INTERACT fat TEMP = fat_nbr
/* Get the correct fat extension */
SELECT_EDGE fat_nbr TOUCHING fat { } TEMP = ext_filter
SIZE ext_filter { VSIZE_INSIDE = 0.0001  } TEMP = ext_filter
SIZE ext_filter INSIDE fat_nbr {
   OVERSIZE = fatTblLength_protru- 0.0001 
   INCREMENT = minSpacing
} TEMP=dummy TEMP = fat_nbr
  
VERTEX fat_nbr {
   CONCAVE = TRUE
   SIZE = 0.0002 
} TEMP = corners
SELECT fat_nbr OUTSIDE corners { } TEMP = fat_nbr1
BOOLEAN fat_nbr NOT fat_nbr1 { } TEMP = fat_nbr2
SELECT_CONTAINS fat_nbr1 {
   WIDTH =  0.0002 
   HEIGHT = fatTblLength_protru
} TEMP = good_fat_nbr1
BOOLEAN fat_nbr1 NOT good_fat_nbr1 { } TEMP = fat_nbr1
/* check with L or T shape of fat extension */
SELECT_EDGE fat_nbr2 INTERACT corners { } TEMP = side_edge
LENGTH side_edge { SPACING < fatTblLength_protru } TEMP = vio_edge
SELECT fat_nbr2 INTERACT vio_edge { } TEMP = fat_nbr2
BOOLEAN fat_nbr1 OR fat_nbr2 { } TEMP = fat_nbr
INTERAL fat_nbr {
   SPACING < fatTblWidth_protru
} TEMP = possible_err
if (!layer_empty(possible_err)) {
   SELECT fat_nbr INTERACT possible_err { } TEMP=fat_nbr
   SELECT fat INTERACT fat_nbr {} TEMP=fat
   BOOLEAN fat OR fat_nbr {} TEMP=fat
   INTERNAL fat {
      COMMENT = "$layer_name ProtrusionLength : threshold fatTblThresh_protru um, length  fatTblLength_protru um, width fatTblWidth_protru um"
      SPACING < fatTblWidth_protru
   } (19 )
}
/* protrusion leng rule check */
SET fatTblThresh_protru = 0;
SET fatTblLength_protru = 0;
SET fatTblWidth_protru = 0;
SET minSpacing = 0;
@ 612 "adrc/adrc.ev" 2


SET minSpacing = 0.056;
SET fatTblThresh_protru = 1.5;
SET fatTblLength_protru = 0.7;
SET fatTblWidth_protru = 0.15;
@ 1 "adrc/adrc_protru.ev" 1
/*protrusion length rule*/
SIZE metal5     { UNDER_OVER = fatTblThresh_protru / 2.0 - 0.0001  } TEMP = fat
BOOLEAN fat AND metal5  {  } TEMP = fat 
BOOLEAN metal5  NOT fat {  } TEMP = fat_nbr
SIZE fat { OVERSIZE = fatTblLength_protru + 0.0001  } TEMP = fat_ext
BOOLEAN fat_nbr AND fat_ext {} TEMP = fat_nbr
SELECT fat_nbr INTERACT fat TEMP = fat_nbr
/* Get the correct fat extension */
SELECT_EDGE fat_nbr TOUCHING fat { } TEMP = ext_filter
SIZE ext_filter { VSIZE_INSIDE = 0.0001  } TEMP = ext_filter
SIZE ext_filter INSIDE fat_nbr {
   OVERSIZE = fatTblLength_protru- 0.0001 
   INCREMENT = minSpacing
} TEMP=dummy TEMP = fat_nbr
  
VERTEX fat_nbr {
   CONCAVE = TRUE
   SIZE = 0.0002 
} TEMP = corners
SELECT fat_nbr OUTSIDE corners { } TEMP = fat_nbr1
BOOLEAN fat_nbr NOT fat_nbr1 { } TEMP = fat_nbr2
SELECT_CONTAINS fat_nbr1 {
   WIDTH =  0.0002 
   HEIGHT = fatTblLength_protru
} TEMP = good_fat_nbr1
BOOLEAN fat_nbr1 NOT good_fat_nbr1 { } TEMP = fat_nbr1
/* check with L or T shape of fat extension */
SELECT_EDGE fat_nbr2 INTERACT corners { } TEMP = side_edge
LENGTH side_edge { SPACING < fatTblLength_protru } TEMP = vio_edge
SELECT fat_nbr2 INTERACT vio_edge { } TEMP = fat_nbr2
BOOLEAN fat_nbr1 OR fat_nbr2 { } TEMP = fat_nbr
INTERAL fat_nbr {
   SPACING < fatTblWidth_protru
} TEMP = possible_err
if (!layer_empty(possible_err)) {
   SELECT fat_nbr INTERACT possible_err { } TEMP=fat_nbr
   SELECT fat INTERACT fat_nbr {} TEMP=fat
   BOOLEAN fat OR fat_nbr {} TEMP=fat
   INTERNAL fat {
      COMMENT = "$layer_name ProtrusionLength : threshold fatTblThresh_protru um, length  fatTblLength_protru um, width fatTblWidth_protru um"
      SPACING < fatTblWidth_protru
   } (19 )
}
/* protrusion leng rule check */
SET fatTblThresh_protru = 0;
SET fatTblLength_protru = 0;
SET fatTblWidth_protru = 0;
SET minSpacing = 0;
@ 618 "adrc/adrc.ev" 2


SET minSpacing = 0.056;
SET fatTblThresh_protru = 3;
SET fatTblLength_protru = 1.5;
SET fatTblWidth_protru = 0.3;
@ 1 "adrc/adrc_protru.ev" 1
/*protrusion length rule*/
SIZE metal5     { UNDER_OVER = fatTblThresh_protru / 2.0 - 0.0001  } TEMP = fat
BOOLEAN fat AND metal5  {  } TEMP = fat 
BOOLEAN metal5  NOT fat {  } TEMP = fat_nbr
SIZE fat { OVERSIZE = fatTblLength_protru + 0.0001  } TEMP = fat_ext
BOOLEAN fat_nbr AND fat_ext {} TEMP = fat_nbr
SELECT fat_nbr INTERACT fat TEMP = fat_nbr
/* Get the correct fat extension */
SELECT_EDGE fat_nbr TOUCHING fat { } TEMP = ext_filter
SIZE ext_filter { VSIZE_INSIDE = 0.0001  } TEMP = ext_filter
SIZE ext_filter INSIDE fat_nbr {
   OVERSIZE = fatTblLength_protru- 0.0001 
   INCREMENT = minSpacing
} TEMP=dummy TEMP = fat_nbr
  
VERTEX fat_nbr {
   CONCAVE = TRUE
   SIZE = 0.0002 
} TEMP = corners
SELECT fat_nbr OUTSIDE corners { } TEMP = fat_nbr1
BOOLEAN fat_nbr NOT fat_nbr1 { } TEMP = fat_nbr2
SELECT_CONTAINS fat_nbr1 {
   WIDTH =  0.0002 
   HEIGHT = fatTblLength_protru
} TEMP = good_fat_nbr1
BOOLEAN fat_nbr1 NOT good_fat_nbr1 { } TEMP = fat_nbr1
/* check with L or T shape of fat extension */
SELECT_EDGE fat_nbr2 INTERACT corners { } TEMP = side_edge
LENGTH side_edge { SPACING < fatTblLength_protru } TEMP = vio_edge
SELECT fat_nbr2 INTERACT vio_edge { } TEMP = fat_nbr2
BOOLEAN fat_nbr1 OR fat_nbr2 { } TEMP = fat_nbr
INTERAL fat_nbr {
   SPACING < fatTblWidth_protru
} TEMP = possible_err
if (!layer_empty(possible_err)) {
   SELECT fat_nbr INTERACT possible_err { } TEMP=fat_nbr
   SELECT fat INTERACT fat_nbr {} TEMP=fat
   BOOLEAN fat OR fat_nbr {} TEMP=fat
   INTERNAL fat {
      COMMENT = "$layer_name ProtrusionLength : threshold fatTblThresh_protru um, length  fatTblLength_protru um, width fatTblWidth_protru um"
      SPACING < fatTblWidth_protru
   } (19 )
}
/* protrusion leng rule check */
SET fatTblThresh_protru = 0;
SET fatTblLength_protru = 0;
SET fatTblWidth_protru = 0;
SET minSpacing = 0;
@ 624 "adrc/adrc.ev" 2





/* Start of Met5 fat table spacing rules */
SET fatTblSpacingMode = 0;
SET parallelLengthMode = 0;
SET router_parallelLengthNetMode = 0;

SET fatTblThreshold = 0.155;
SET fatTblParallelLength = 0.155;
SET minWidth = 0.056;

SET fatTblThreshold_Start = 0;
SET fatTblSpacing = 0.064;
@ 1 "adrc/adrc_fatMetal.ev" 1
/*check fat metal table*/
if (fatTblThreshold > 0) {
    if ((fatTblThreshold / 2.0) > 0.0001 ) {
       SIZE fat_candidate  { UNDER_OVER = fatTblThreshold / 2.0 - 0.0001  } TEMP = fat_candidate
       if (fatTblNextThreshold > 0) {
          SIZE fat_candidate { UNDER_OVER = fatTblNextThreshold / 2.0 - 0.0001  } TEMP = fat_next
          BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
          BOOLEAN fat AND fat_target { } TEMP = fat
          SET fatTblNextThreshold = 0;
       } else {
          BOOLEAN fat_candidate AND fat_target {  } TEMP = fat 
       }
    } else {
      COPY fat_target {  } TEMP = fat 
    }
    COPY fat_target { } TEMP = spc_target
    if (fatTblThreshold_Start > 0  || fatTblThreshold_End > 0) {
       if (fatTblThreshold_Start > 0) {
          SIZE fat_target { UNDER_OVER = fatTblThreshold_Start / 2.0 - 0.0001  } TEMP = spc_target
       }
       if (fatTblThreshold_End > 0 && fatTblThreshold_End > fatTblThreshold_Start) {
          SIZE spc_target { UNDER_OVER = fatTblThreshold_End / 2.0 - 0.0001  } TEMP = fat_end
          BOOLEAN spc_target NOT fat_end { } TEMP = spc_target
       }
       BOOLEAN spc_target AND fat_target {  } TEMP = spc_target
       if (ignoreBlockage == 0 && fatTblThreshold_Start < fatTblThreshold_1) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal5_blockage  {  } TEMP = spc_target
       }
       SET fatTblThreshold_Start = 0;
       SET fatTblThreshold_End = 0;
       SET fatTblThreshold_1 = 0;
    } else {
       if (ignoreBlockage == 0) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal5_blockage  {  } TEMP = spc_target
       }
    }
 
    if (fatTblEnclosedArea > 0) {
       SELECT holes INTERACT fat { } TEMP = fat_holes
       AREA fat_holes { 
          RANGE = [0.0001 * 0.0001 , fatTblEnclosedArea - 0.0001 * 0.0001 ]
       } TEMP = fat_holes
       if (fatTblMinEnclosedAreaMode==0) {
          SIZE fat_holes { OVER_UNDER = fatTblThreshold / 2.0 + 0.0001  } TEMP = ovun_holes
          SELECT ovun_holes INTERACT fat_holes { RANGE = [2, 9999999999 ] } TEMP = merged_holes
          BOOLEAN fat_candidate AND fat_target { } TEMP = fat_metal
          BOOLEAN metal5  NOT fat_metal { } TEMP = thin_metal
          BOOLEAN thin_metal NOT ovun_holes { } TEMP = thin_metal
          SELECT ovun_holes INTERACT thin_metal { } TEMP = thin_holes
          BOOLEAN thin_holes OR merged_holes { } TEMP = thin_holes
          BOOLEAN fat_holes NOT thin_holes { } TEMP = fat_holes
       }
       COPY fat_holes { 
	  COMMENT = "$layer_name EnclsArea : fat metal ( fatTblThreshold um) minimum enclosed area (mode fatTblMinEnclosedAreaMode ) = fatTblEnclosedArea um*um"
       } (19 )
       SET fatTblEnclosedArea = 0;
    }
    if (fatTblSpacing > 0) {
       /*check fat metal*/ 
       if (fatTblParallelLength > 0) {
          if (router_parallelLengthNetMode == 1 || parallelLengthMode == 1) {
             AREA spc_target { RANGE = [fatTblParallelLength * minWidth + 0.0001 , 9999999999 ] } TEMP = spc_target1
             COPY spc_target1 { } TEMP = spc_target2
          } else {
             COPY spc_target { } TEMP = spc_target2
          }
          if (parallelLengthMode == 1) {
             SELECT metal5  INTERACT fat { } TEMP = fat_all 
             BOOLEAN fat_all OR fat { } TEMP = fat2
             SELECT metal5  INTERACT spc_target2 { } TEMP = spc_target_all
             BOOLEAN spc_target_all OR spc_target2 { } TEMP = spc_target2
          } else {
             COPY fat { } TEMP = fat2
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING <= fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
                OUTPUT_EDGES = TRUE
             } TEMP = vio_edge
             SELECT vio_edge INTERACT fat { } TEMP = vio_edge
             SELECT vio_edge INTERACT spc_target1 { } TEMP = vio_edge
             SELECT violation INTERACT vio_edge { } TEMP = violation
          } else {
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
          }
          BOOLEAN violation NOT fat_target { } TEMP = violation
          if (fatTblParallelLength < fatTblSpacing) {
             SELECT_EDGE violation TOUCHING fat2 {
                VSIZE_INSIDE = fatTblParallelLength - 0.0002 
             } TEMP = vio_filter
             SELECT_CONTAINS vio_filter { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = vio_filter
             SELECT violation INTERACT vio_filter { } TEMP = violation
          } else {
             SELECT_CONTAINS violation { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = violation
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING = [fatTblSpacing, fatTblSpacing]
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
             } TEMP = violation3
             BOOLEAN violation3 NOT fat_target { } TEMP = violation3
             BOOLEAN violation NOT violation3 { } TEMP= violation
          }
          SELECT_EDGE fat2 TOUCHING violation { } TEMP=fat_viol
          BOOLEAN fat_viol AND violation { } TEMP=fat_viol
          SELECT_EDGE spc_target2 TOUCHING violation { } TEMP=spc_target2
          BOOLEAN spc_target2 AND violation { } TEMP= spc_target2
	  if (ignoreChildCell == 1) {
             EXTERNAL fat_viol spc_target2 {
		SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		TOUCH = FALSE
		POINT_TOUCH = FALSE
		NON_PARALLEL = TRUE
	     } TEMP = spc_mode0_out
             BOOLEAN spc_mode0_out NOT spc_mode0_child_out { } TEMP = spc_mode0_diff_out
             SELECT spc_mode0_out INTERACT spc_mode0_diff_out { } TEMP = spc_mode0_out
	     SELECT_EDGE fat2 TOUCHING spc_mode0_out { } TEMP=fat_viol
	     BOOLEAN fat_viol AND spc_mode0_out { } TEMP=fat_viol
	     SELECT_EDGE spc_target2 TOUCHING spc_mode0_out { } TEMP=spc_target2
	     BOOLEAN spc_target2 AND spc_mode0_out { } TEMP=spc_target2
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (19 )  		
	  } else {
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing 
	        SET_CORNERS_TO_SPACING = FALSE
	        PARALLEL_POINT_PROJECTION = FALSE
	        TOUCH = FALSE
	        POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (19 )
	  }
	  if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	     if (ignoreChildCell == 1) {
		EXTERNAL fat spc_target {
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} TEMP = spc_mode1_out
	        BOOLEAN spc_mode1_out NOT spc_mode1_child_out { } TEMP = spc_mode1_diff_out
	        SELECT spc_mode1_out INTERACT spc_mode1_diff_out { } TEMP = spc_mode1_out
                SELECT_EDGE fat TOUCHING spc_mode1_out { } TEMP=fat_viol
	        BOOLEAN fat_viol AND spc_mode1_out { } TEMP=fat_viol
	        SELECT_EDGE spc_target TOUCHING spc_mode1_out { } TEMP=spc_target2
	        BOOLEAN spc_target2 AND spc_mode1_out { } TEMP=spc_target2
	        EXTERNAL fat_viol spc_target2 {
	           COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um " 	    
		   SPACING < fatTblSpacing_dg
                   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} (19 )
	     } else {
	        EXTERNAL fat spc_target {
		   COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um "
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
	    	   PARALLEL_POINT_PROJECTION = FALSE
	           TOUCH = FALSE
	     	   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } (19 ) 
	     }
          }
       } else {
	  if (ignoreChildCell == 1) {
              EXTERNAL fat spc_target {
                 SPACING < fatTblSpacing
                 BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
              } TEMP = spc_out
	      BOOLEAN spc_out NOT spc_child_out { } TEMP = spc_diff_out
	      SELECT spc_out INTERACT spc_diff_out { } TEMP = spc_out
	      SELECT_EDGE fat TOUCHING spc_out { } TEMP=fat_viol
	      BOOLEAN fat_viol AND spc_out { } TEMP=fat_viol
              SELECT_EDGE spc_target TOUCHING spc_out { } TEMP=spc_target2
	      BOOLEAN spc_target2 AND spc_out { } TEMP=spc_target2
	      EXTERNAL fat_viol spc_target2 {
		 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
		 BOX_CORNER = FALSE 
		 NON_PARALLEL = TRUE
		 POINT_TOUCH = FALSE
	      } (19 ) 
	  } else {
	      EXTERNAL fat spc_target {
                 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
	         BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
	      } (19 ) 
	  }
       }
       /*check metal in the extension range*/ 
       if (fatTblExtensionRange > 0) {
	  if (fatWireExtensionMode == 0) {
	     SIZE fat { OVERSIZE = fatTblExtensionRange } TEMP = fat_tmp
             BOOLEAN fat_tmp AND metal5  { } TEMP = fat_tmp
  	     BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
             SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_ext
             BOOLEAN fat_ext OR fat { } TEMP = fat_ext
	     if (fatTblParallelLength > 0) {
                if (fatTblParallelLength > fatTblExtensionRange) {
                   SIZE fat { OVERSIZE = fatTblParallelLength } TEMP = fat_tmp
                   BOOLEAN fat_tmp AND metal5  { } TEMP = fat_tmp
  	           BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
                   SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_parallel
                   BOOLEAN fat_parallel OR fat { } TEMP = fat_parallel
                } else {
                   COPY fat_ext { } TEMP = fat_parallel
                }
		EXTERNAL fat_parallel spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
	           NON_PARALLEL = TRUE
	        } TEMP = vio_filter_set
		EXTERNAL fat_ext spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } TEMP = vio_set
                if (fatTblParallelLength < fatTblSpacing) {
                   SELECT_EDGE vio_filter_set TOUCHING fat_parallel {
                      VSIZE_INSIDE = fatTblParallelLength - 0.0002 
                   } TEMP = vio_filter_set_filter
                   SELECT_CONTAINS vio_filter_set_filter { 
                      WIDTH =  0.0002 
                      HEIGHT = fatTblParallelLength + 0.0001 
                   } TEMP = vio_filter_set_filter
                   SELECT vio_filter_set INTERACT vio_filter_set_filter { } TEMP = vio_filter
                } else {
	           SELECT_CONTAINS vio_filter_set { 
	              WIDTH =  0.0002 
	              HEIGHT = fatTblParallelLength + 0.0001 
	           } TEMP = vio_filter
                }
                SELECT vio_set INSIDE vio_filter { } TEMP = mode0_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out1 NOT mode0_child_out1 { } TEMP = mode0_diff_out1
                   SELECT mode0_out1 INTERACT mode0_diff_out1 { } TEMP = mode0_out1
                }
                COPY mode0_out1 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing  = fatTblSpacing um"
                } (19 )
		if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	           EXTERNAL fat_ext spc_target {
		      SPACING < fatTblSpacing_dg
	              SET_CORNERS_TO_SPACING = FALSE
		      PARALLEL_POINT_PROJECTION = FALSE
		      TOUCH = TRUE
		      POINT_TOUCH = FALSE
		      NON_PARALLEL = TRUE
	           } TEMP = mode0_out2
                   if (ignoreChildCell == 1) {
                      BOOLEAN mode0_out2 NOT mode0_child_out2 { } TEMP = mode0_diff_out2
                      SELECT mode0_out2 INTERACT mode0_diff_out2 { } TEMP = mode0_out2
                   }
                   COPY mode0_out2 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing (mode 1/2) = fatTblSpacing um/ fatTblSpacing_dg um "
                   } (19 )
	        } 
	     } else {
	        EXTERNAL fat_ext spc_target {
		   SPACING < fatTblSpacing
		   NON_PARALLEL = TRUE
		   SET_CORNERS_TO_SPACING = FALSE
		   POINT_TOUCH = FALSE
		} TEMP = mode0_out3
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out3 NOT mode0_child_out3 { } TEMP = mode0_diff_out3
                   SELECT mode0_out3 INTERACT mode0_diff_out3 { } TEMP = mode0_out3
                }
                COPY mode0_out3 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range ( fatTblExtensionRange um) minimum spacing = fatTblSpacing um"
                } (19 )
	     }
	  } else if (fatWireExtensionMode == 1) {
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal5  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             if (fatTblParallelLength > 0) {
                EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
		   BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   CHECK_SAME_POLYGON = TRUE 
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
	        SELECT fat_ext INTERACT spacing {  } TEMP = fat_ext
		BOOLEAN fat_ext OR spacing {  } TEMP = combined_fat_ext
                EXTERNAL combined_fat_ext fat {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
                } TEMP = fat_spacing
		BOOLEAN fat_spacing AND fat_ran {  } TEMP = fat_spacing
		BOOLEAN combined_fat_ext OR fat_spacing {  } TEMP = combined_fat_ext
                SELECT_CONTAINS combined_fat_ext { 
                   WIDTH =  0.0002 
                   HEIGHT = fatTblParallelLength + 0.0001 
                } TEMP = combined_fat_ext
		SELECT spacing INTERACT combined_fat_ext { 
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out1 NOT mode1_child_out1 { } TEMP = mode1_diff_out1
                   SELECT mode1_out1 INTERACT mode1_diff_out1 { } TEMP = mode1_out1 
                }
                COPY mode1_out1 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (19 ) 
	     } else {
               	EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
	           BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
	           CHECK_SAME_POLYGON = TRUE 
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
                SELECT spacing INTERACT fat_ext {
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out2
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out2 NOT mode1_child_out2 { } TEMP = mode1_diff_out2
                   SELECT mode1_out2 INTERACT mode1_diff_out2 { } TEMP = mode1_out2
                }
                COPY mode1_out2 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (19 )
	     }
	  } else if (fatWireExtensionMode == 2) {
	     SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
             BOOLEAN fat_ran AND metal5  {  } TEMP = fat_ext
             BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	      	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
             } TEMP = spacing
 	     SELECT spacing INSIDE fat_ran {  } TEMP = spacing
	     SELECT spacing OUTSIDE fat {  } TEMP = spacing
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode2_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode2_out NOT mode2_child_out { } TEMP = mode2_diff_out
                SELECT mode2_out INTERACT mode2_diff_out { } TEMP = mode2_out 
             }
             COPY mode2_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 2, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (19 )
	  } else if (fatWireExtensionMode == 3) {
             SIZE fat {
	        GROW_LEFT = fatTblExtensionRange
	        GROW_RIGHT = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal5  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	       	PARALLEL = TRUE

	       	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		HORIZONTAL_ONLY = TRUE
             } TEMP = spacing_hor
	     SELECT spacing_hor INSIDE fat_ran {  } TEMP = spacing_hor
	     SELECT spacing_hor OUTSIDE fat {  } TEMP = spacing_hor
             SIZE fat {
	        GROW_TOP = fatTblExtensionRange
	        GROW_BOTTOM = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal5  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	        POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		VERTICAL_ONLY = TRUE
             } TEMP = spacing_ver
	     SELECT spacing_ver INSIDE fat_ran {  } TEMP = spacing_ver
	     SELECT spacing_ver OUTSIDE fat {  } TEMP = spacing_ver
  	     BOOLEAN spacing_hor OR spacing_ver {  } TEMP = spacing
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal5  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
  	     /* check overlapped projection length */
 	     if (fatTblParallelLength > 0) {
                POLYGON_FEATURES fat_ext {
                   EQUATIONS {
                      vnum = EV_VNUM_IN;
                      if ( vnum > 0) {
                         bdLeft = EV_VXCOORD_IN[0];
                         bdRight = EV_VXCOORD_IN[0];
                         bdBottom = EV_VYCOORD_IN[0];
                         bdTop = EV_VYCOORD_IN[0];
                         FOR (i = 1; i < vnum; i++) {
                            if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
                            else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
                            if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
                            else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
                         } /* FOR i */
                         if ( (bdRight - bdLeft) >= fatTblParallelLength ||
                  	      (bdTop - bdBottom) >= fatTblParallelLength) {
                            FOR (i = 0; i < vnum; i++) {
                               EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
                               EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
                            }
                            EV_VNUM_OUT = vnum;
                 	    EV_SAVE_POLYGON();
                         }
                      }
                   }
                } TEMP = fat_ext /* POLYGON_FEATURE */
             }
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode3_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode3_out NOT mode3_child_out { } TEMP = mode3_diff_out
                SELECT mode3_out INTERACT mode3_diff_out { } TEMP = mode3_out
             }
             COPY mode3_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 3, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (19 )
          }
       }
       SET fatTblSpacing = 0;
    }
}
@ 640 "adrc/adrc.ev" 2


SET fatTblThreshold = 0.305;
SET fatTblParallelLength = 0.305;
SET minWidth = 0.056;

SET fatTblThreshold_Start = 0;
SET fatTblSpacing = 0.12;
@ 1 "adrc/adrc_fatMetal.ev" 1
/*check fat metal table*/
if (fatTblThreshold > 0) {
    if ((fatTblThreshold / 2.0) > 0.0001 ) {
       SIZE fat_candidate  { UNDER_OVER = fatTblThreshold / 2.0 - 0.0001  } TEMP = fat_candidate
       if (fatTblNextThreshold > 0) {
          SIZE fat_candidate { UNDER_OVER = fatTblNextThreshold / 2.0 - 0.0001  } TEMP = fat_next
          BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
          BOOLEAN fat AND fat_target { } TEMP = fat
          SET fatTblNextThreshold = 0;
       } else {
          BOOLEAN fat_candidate AND fat_target {  } TEMP = fat 
       }
    } else {
      COPY fat_target {  } TEMP = fat 
    }
    COPY fat_target { } TEMP = spc_target
    if (fatTblThreshold_Start > 0  || fatTblThreshold_End > 0) {
       if (fatTblThreshold_Start > 0) {
          SIZE fat_target { UNDER_OVER = fatTblThreshold_Start / 2.0 - 0.0001  } TEMP = spc_target
       }
       if (fatTblThreshold_End > 0 && fatTblThreshold_End > fatTblThreshold_Start) {
          SIZE spc_target { UNDER_OVER = fatTblThreshold_End / 2.0 - 0.0001  } TEMP = fat_end
          BOOLEAN spc_target NOT fat_end { } TEMP = spc_target
       }
       BOOLEAN spc_target AND fat_target {  } TEMP = spc_target
       if (ignoreBlockage == 0 && fatTblThreshold_Start < fatTblThreshold_1) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal5_blockage  {  } TEMP = spc_target
       }
       SET fatTblThreshold_Start = 0;
       SET fatTblThreshold_End = 0;
       SET fatTblThreshold_1 = 0;
    } else {
       if (ignoreBlockage == 0) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal5_blockage  {  } TEMP = spc_target
       }
    }
 
    if (fatTblEnclosedArea > 0) {
       SELECT holes INTERACT fat { } TEMP = fat_holes
       AREA fat_holes { 
          RANGE = [0.0001 * 0.0001 , fatTblEnclosedArea - 0.0001 * 0.0001 ]
       } TEMP = fat_holes
       if (fatTblMinEnclosedAreaMode==0) {
          SIZE fat_holes { OVER_UNDER = fatTblThreshold / 2.0 + 0.0001  } TEMP = ovun_holes
          SELECT ovun_holes INTERACT fat_holes { RANGE = [2, 9999999999 ] } TEMP = merged_holes
          BOOLEAN fat_candidate AND fat_target { } TEMP = fat_metal
          BOOLEAN metal5  NOT fat_metal { } TEMP = thin_metal
          BOOLEAN thin_metal NOT ovun_holes { } TEMP = thin_metal
          SELECT ovun_holes INTERACT thin_metal { } TEMP = thin_holes
          BOOLEAN thin_holes OR merged_holes { } TEMP = thin_holes
          BOOLEAN fat_holes NOT thin_holes { } TEMP = fat_holes
       }
       COPY fat_holes { 
	  COMMENT = "$layer_name EnclsArea : fat metal ( fatTblThreshold um) minimum enclosed area (mode fatTblMinEnclosedAreaMode ) = fatTblEnclosedArea um*um"
       } (19 )
       SET fatTblEnclosedArea = 0;
    }
    if (fatTblSpacing > 0) {
       /*check fat metal*/ 
       if (fatTblParallelLength > 0) {
          if (router_parallelLengthNetMode == 1 || parallelLengthMode == 1) {
             AREA spc_target { RANGE = [fatTblParallelLength * minWidth + 0.0001 , 9999999999 ] } TEMP = spc_target1
             COPY spc_target1 { } TEMP = spc_target2
          } else {
             COPY spc_target { } TEMP = spc_target2
          }
          if (parallelLengthMode == 1) {
             SELECT metal5  INTERACT fat { } TEMP = fat_all 
             BOOLEAN fat_all OR fat { } TEMP = fat2
             SELECT metal5  INTERACT spc_target2 { } TEMP = spc_target_all
             BOOLEAN spc_target_all OR spc_target2 { } TEMP = spc_target2
          } else {
             COPY fat { } TEMP = fat2
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING <= fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
                OUTPUT_EDGES = TRUE
             } TEMP = vio_edge
             SELECT vio_edge INTERACT fat { } TEMP = vio_edge
             SELECT vio_edge INTERACT spc_target1 { } TEMP = vio_edge
             SELECT violation INTERACT vio_edge { } TEMP = violation
          } else {
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
          }
          BOOLEAN violation NOT fat_target { } TEMP = violation
          if (fatTblParallelLength < fatTblSpacing) {
             SELECT_EDGE violation TOUCHING fat2 {
                VSIZE_INSIDE = fatTblParallelLength - 0.0002 
             } TEMP = vio_filter
             SELECT_CONTAINS vio_filter { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = vio_filter
             SELECT violation INTERACT vio_filter { } TEMP = violation
          } else {
             SELECT_CONTAINS violation { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = violation
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING = [fatTblSpacing, fatTblSpacing]
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
             } TEMP = violation3
             BOOLEAN violation3 NOT fat_target { } TEMP = violation3
             BOOLEAN violation NOT violation3 { } TEMP= violation
          }
          SELECT_EDGE fat2 TOUCHING violation { } TEMP=fat_viol
          BOOLEAN fat_viol AND violation { } TEMP=fat_viol
          SELECT_EDGE spc_target2 TOUCHING violation { } TEMP=spc_target2
          BOOLEAN spc_target2 AND violation { } TEMP= spc_target2
	  if (ignoreChildCell == 1) {
             EXTERNAL fat_viol spc_target2 {
		SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		TOUCH = FALSE
		POINT_TOUCH = FALSE
		NON_PARALLEL = TRUE
	     } TEMP = spc_mode0_out
             BOOLEAN spc_mode0_out NOT spc_mode0_child_out { } TEMP = spc_mode0_diff_out
             SELECT spc_mode0_out INTERACT spc_mode0_diff_out { } TEMP = spc_mode0_out
	     SELECT_EDGE fat2 TOUCHING spc_mode0_out { } TEMP=fat_viol
	     BOOLEAN fat_viol AND spc_mode0_out { } TEMP=fat_viol
	     SELECT_EDGE spc_target2 TOUCHING spc_mode0_out { } TEMP=spc_target2
	     BOOLEAN spc_target2 AND spc_mode0_out { } TEMP=spc_target2
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (19 )  		
	  } else {
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing 
	        SET_CORNERS_TO_SPACING = FALSE
	        PARALLEL_POINT_PROJECTION = FALSE
	        TOUCH = FALSE
	        POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (19 )
	  }
	  if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	     if (ignoreChildCell == 1) {
		EXTERNAL fat spc_target {
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} TEMP = spc_mode1_out
	        BOOLEAN spc_mode1_out NOT spc_mode1_child_out { } TEMP = spc_mode1_diff_out
	        SELECT spc_mode1_out INTERACT spc_mode1_diff_out { } TEMP = spc_mode1_out
                SELECT_EDGE fat TOUCHING spc_mode1_out { } TEMP=fat_viol
	        BOOLEAN fat_viol AND spc_mode1_out { } TEMP=fat_viol
	        SELECT_EDGE spc_target TOUCHING spc_mode1_out { } TEMP=spc_target2
	        BOOLEAN spc_target2 AND spc_mode1_out { } TEMP=spc_target2
	        EXTERNAL fat_viol spc_target2 {
	           COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um " 	    
		   SPACING < fatTblSpacing_dg
                   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} (19 )
	     } else {
	        EXTERNAL fat spc_target {
		   COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um "
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
	    	   PARALLEL_POINT_PROJECTION = FALSE
	           TOUCH = FALSE
	     	   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } (19 ) 
	     }
          }
       } else {
	  if (ignoreChildCell == 1) {
              EXTERNAL fat spc_target {
                 SPACING < fatTblSpacing
                 BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
              } TEMP = spc_out
	      BOOLEAN spc_out NOT spc_child_out { } TEMP = spc_diff_out
	      SELECT spc_out INTERACT spc_diff_out { } TEMP = spc_out
	      SELECT_EDGE fat TOUCHING spc_out { } TEMP=fat_viol
	      BOOLEAN fat_viol AND spc_out { } TEMP=fat_viol
              SELECT_EDGE spc_target TOUCHING spc_out { } TEMP=spc_target2
	      BOOLEAN spc_target2 AND spc_out { } TEMP=spc_target2
	      EXTERNAL fat_viol spc_target2 {
		 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
		 BOX_CORNER = FALSE 
		 NON_PARALLEL = TRUE
		 POINT_TOUCH = FALSE
	      } (19 ) 
	  } else {
	      EXTERNAL fat spc_target {
                 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
	         BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
	      } (19 ) 
	  }
       }
       /*check metal in the extension range*/ 
       if (fatTblExtensionRange > 0) {
	  if (fatWireExtensionMode == 0) {
	     SIZE fat { OVERSIZE = fatTblExtensionRange } TEMP = fat_tmp
             BOOLEAN fat_tmp AND metal5  { } TEMP = fat_tmp
  	     BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
             SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_ext
             BOOLEAN fat_ext OR fat { } TEMP = fat_ext
	     if (fatTblParallelLength > 0) {
                if (fatTblParallelLength > fatTblExtensionRange) {
                   SIZE fat { OVERSIZE = fatTblParallelLength } TEMP = fat_tmp
                   BOOLEAN fat_tmp AND metal5  { } TEMP = fat_tmp
  	           BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
                   SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_parallel
                   BOOLEAN fat_parallel OR fat { } TEMP = fat_parallel
                } else {
                   COPY fat_ext { } TEMP = fat_parallel
                }
		EXTERNAL fat_parallel spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
	           NON_PARALLEL = TRUE
	        } TEMP = vio_filter_set
		EXTERNAL fat_ext spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } TEMP = vio_set
                if (fatTblParallelLength < fatTblSpacing) {
                   SELECT_EDGE vio_filter_set TOUCHING fat_parallel {
                      VSIZE_INSIDE = fatTblParallelLength - 0.0002 
                   } TEMP = vio_filter_set_filter
                   SELECT_CONTAINS vio_filter_set_filter { 
                      WIDTH =  0.0002 
                      HEIGHT = fatTblParallelLength + 0.0001 
                   } TEMP = vio_filter_set_filter
                   SELECT vio_filter_set INTERACT vio_filter_set_filter { } TEMP = vio_filter
                } else {
	           SELECT_CONTAINS vio_filter_set { 
	              WIDTH =  0.0002 
	              HEIGHT = fatTblParallelLength + 0.0001 
	           } TEMP = vio_filter
                }
                SELECT vio_set INSIDE vio_filter { } TEMP = mode0_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out1 NOT mode0_child_out1 { } TEMP = mode0_diff_out1
                   SELECT mode0_out1 INTERACT mode0_diff_out1 { } TEMP = mode0_out1
                }
                COPY mode0_out1 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing  = fatTblSpacing um"
                } (19 )
		if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	           EXTERNAL fat_ext spc_target {
		      SPACING < fatTblSpacing_dg
	              SET_CORNERS_TO_SPACING = FALSE
		      PARALLEL_POINT_PROJECTION = FALSE
		      TOUCH = TRUE
		      POINT_TOUCH = FALSE
		      NON_PARALLEL = TRUE
	           } TEMP = mode0_out2
                   if (ignoreChildCell == 1) {
                      BOOLEAN mode0_out2 NOT mode0_child_out2 { } TEMP = mode0_diff_out2
                      SELECT mode0_out2 INTERACT mode0_diff_out2 { } TEMP = mode0_out2
                   }
                   COPY mode0_out2 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing (mode 1/2) = fatTblSpacing um/ fatTblSpacing_dg um "
                   } (19 )
	        } 
	     } else {
	        EXTERNAL fat_ext spc_target {
		   SPACING < fatTblSpacing
		   NON_PARALLEL = TRUE
		   SET_CORNERS_TO_SPACING = FALSE
		   POINT_TOUCH = FALSE
		} TEMP = mode0_out3
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out3 NOT mode0_child_out3 { } TEMP = mode0_diff_out3
                   SELECT mode0_out3 INTERACT mode0_diff_out3 { } TEMP = mode0_out3
                }
                COPY mode0_out3 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range ( fatTblExtensionRange um) minimum spacing = fatTblSpacing um"
                } (19 )
	     }
	  } else if (fatWireExtensionMode == 1) {
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal5  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             if (fatTblParallelLength > 0) {
                EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
		   BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   CHECK_SAME_POLYGON = TRUE 
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
	        SELECT fat_ext INTERACT spacing {  } TEMP = fat_ext
		BOOLEAN fat_ext OR spacing {  } TEMP = combined_fat_ext
                EXTERNAL combined_fat_ext fat {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
                } TEMP = fat_spacing
		BOOLEAN fat_spacing AND fat_ran {  } TEMP = fat_spacing
		BOOLEAN combined_fat_ext OR fat_spacing {  } TEMP = combined_fat_ext
                SELECT_CONTAINS combined_fat_ext { 
                   WIDTH =  0.0002 
                   HEIGHT = fatTblParallelLength + 0.0001 
                } TEMP = combined_fat_ext
		SELECT spacing INTERACT combined_fat_ext { 
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out1 NOT mode1_child_out1 { } TEMP = mode1_diff_out1
                   SELECT mode1_out1 INTERACT mode1_diff_out1 { } TEMP = mode1_out1 
                }
                COPY mode1_out1 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (19 ) 
	     } else {
               	EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
	           BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
	           CHECK_SAME_POLYGON = TRUE 
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
                SELECT spacing INTERACT fat_ext {
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out2
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out2 NOT mode1_child_out2 { } TEMP = mode1_diff_out2
                   SELECT mode1_out2 INTERACT mode1_diff_out2 { } TEMP = mode1_out2
                }
                COPY mode1_out2 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (19 )
	     }
	  } else if (fatWireExtensionMode == 2) {
	     SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
             BOOLEAN fat_ran AND metal5  {  } TEMP = fat_ext
             BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	      	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
             } TEMP = spacing
 	     SELECT spacing INSIDE fat_ran {  } TEMP = spacing
	     SELECT spacing OUTSIDE fat {  } TEMP = spacing
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode2_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode2_out NOT mode2_child_out { } TEMP = mode2_diff_out
                SELECT mode2_out INTERACT mode2_diff_out { } TEMP = mode2_out 
             }
             COPY mode2_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 2, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (19 )
	  } else if (fatWireExtensionMode == 3) {
             SIZE fat {
	        GROW_LEFT = fatTblExtensionRange
	        GROW_RIGHT = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal5  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	       	PARALLEL = TRUE

	       	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		HORIZONTAL_ONLY = TRUE
             } TEMP = spacing_hor
	     SELECT spacing_hor INSIDE fat_ran {  } TEMP = spacing_hor
	     SELECT spacing_hor OUTSIDE fat {  } TEMP = spacing_hor
             SIZE fat {
	        GROW_TOP = fatTblExtensionRange
	        GROW_BOTTOM = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal5  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	        POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		VERTICAL_ONLY = TRUE
             } TEMP = spacing_ver
	     SELECT spacing_ver INSIDE fat_ran {  } TEMP = spacing_ver
	     SELECT spacing_ver OUTSIDE fat {  } TEMP = spacing_ver
  	     BOOLEAN spacing_hor OR spacing_ver {  } TEMP = spacing
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal5  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
  	     /* check overlapped projection length */
 	     if (fatTblParallelLength > 0) {
                POLYGON_FEATURES fat_ext {
                   EQUATIONS {
                      vnum = EV_VNUM_IN;
                      if ( vnum > 0) {
                         bdLeft = EV_VXCOORD_IN[0];
                         bdRight = EV_VXCOORD_IN[0];
                         bdBottom = EV_VYCOORD_IN[0];
                         bdTop = EV_VYCOORD_IN[0];
                         FOR (i = 1; i < vnum; i++) {
                            if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
                            else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
                            if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
                            else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
                         } /* FOR i */
                         if ( (bdRight - bdLeft) >= fatTblParallelLength ||
                  	      (bdTop - bdBottom) >= fatTblParallelLength) {
                            FOR (i = 0; i < vnum; i++) {
                               EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
                               EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
                            }
                            EV_VNUM_OUT = vnum;
                 	    EV_SAVE_POLYGON();
                         }
                      }
                   }
                } TEMP = fat_ext /* POLYGON_FEATURE */
             }
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode3_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode3_out NOT mode3_child_out { } TEMP = mode3_diff_out
                SELECT mode3_out INTERACT mode3_diff_out { } TEMP = mode3_out
             }
             COPY mode3_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 3, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (19 )
          }
       }
       SET fatTblSpacing = 0;
    }
}
@ 648 "adrc/adrc.ev" 2


SET fatTblThreshold = 1.505;
SET fatTblParallelLength = 1.505;
SET minWidth = 0.056;

SET fatTblThreshold_Start = 0;
SET fatTblSpacing = 0.6;
@ 1 "adrc/adrc_fatMetal.ev" 1
/*check fat metal table*/
if (fatTblThreshold > 0) {
    if ((fatTblThreshold / 2.0) > 0.0001 ) {
       SIZE fat_candidate  { UNDER_OVER = fatTblThreshold / 2.0 - 0.0001  } TEMP = fat_candidate
       if (fatTblNextThreshold > 0) {
          SIZE fat_candidate { UNDER_OVER = fatTblNextThreshold / 2.0 - 0.0001  } TEMP = fat_next
          BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
          BOOLEAN fat AND fat_target { } TEMP = fat
          SET fatTblNextThreshold = 0;
       } else {
          BOOLEAN fat_candidate AND fat_target {  } TEMP = fat 
       }
    } else {
      COPY fat_target {  } TEMP = fat 
    }
    COPY fat_target { } TEMP = spc_target
    if (fatTblThreshold_Start > 0  || fatTblThreshold_End > 0) {
       if (fatTblThreshold_Start > 0) {
          SIZE fat_target { UNDER_OVER = fatTblThreshold_Start / 2.0 - 0.0001  } TEMP = spc_target
       }
       if (fatTblThreshold_End > 0 && fatTblThreshold_End > fatTblThreshold_Start) {
          SIZE spc_target { UNDER_OVER = fatTblThreshold_End / 2.0 - 0.0001  } TEMP = fat_end
          BOOLEAN spc_target NOT fat_end { } TEMP = spc_target
       }
       BOOLEAN spc_target AND fat_target {  } TEMP = spc_target
       if (ignoreBlockage == 0 && fatTblThreshold_Start < fatTblThreshold_1) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal5_blockage  {  } TEMP = spc_target
       }
       SET fatTblThreshold_Start = 0;
       SET fatTblThreshold_End = 0;
       SET fatTblThreshold_1 = 0;
    } else {
       if (ignoreBlockage == 0) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal5_blockage  {  } TEMP = spc_target
       }
    }
 
    if (fatTblEnclosedArea > 0) {
       SELECT holes INTERACT fat { } TEMP = fat_holes
       AREA fat_holes { 
          RANGE = [0.0001 * 0.0001 , fatTblEnclosedArea - 0.0001 * 0.0001 ]
       } TEMP = fat_holes
       if (fatTblMinEnclosedAreaMode==0) {
          SIZE fat_holes { OVER_UNDER = fatTblThreshold / 2.0 + 0.0001  } TEMP = ovun_holes
          SELECT ovun_holes INTERACT fat_holes { RANGE = [2, 9999999999 ] } TEMP = merged_holes
          BOOLEAN fat_candidate AND fat_target { } TEMP = fat_metal
          BOOLEAN metal5  NOT fat_metal { } TEMP = thin_metal
          BOOLEAN thin_metal NOT ovun_holes { } TEMP = thin_metal
          SELECT ovun_holes INTERACT thin_metal { } TEMP = thin_holes
          BOOLEAN thin_holes OR merged_holes { } TEMP = thin_holes
          BOOLEAN fat_holes NOT thin_holes { } TEMP = fat_holes
       }
       COPY fat_holes { 
	  COMMENT = "$layer_name EnclsArea : fat metal ( fatTblThreshold um) minimum enclosed area (mode fatTblMinEnclosedAreaMode ) = fatTblEnclosedArea um*um"
       } (19 )
       SET fatTblEnclosedArea = 0;
    }
    if (fatTblSpacing > 0) {
       /*check fat metal*/ 
       if (fatTblParallelLength > 0) {
          if (router_parallelLengthNetMode == 1 || parallelLengthMode == 1) {
             AREA spc_target { RANGE = [fatTblParallelLength * minWidth + 0.0001 , 9999999999 ] } TEMP = spc_target1
             COPY spc_target1 { } TEMP = spc_target2
          } else {
             COPY spc_target { } TEMP = spc_target2
          }
          if (parallelLengthMode == 1) {
             SELECT metal5  INTERACT fat { } TEMP = fat_all 
             BOOLEAN fat_all OR fat { } TEMP = fat2
             SELECT metal5  INTERACT spc_target2 { } TEMP = spc_target_all
             BOOLEAN spc_target_all OR spc_target2 { } TEMP = spc_target2
          } else {
             COPY fat { } TEMP = fat2
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING <= fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
                OUTPUT_EDGES = TRUE
             } TEMP = vio_edge
             SELECT vio_edge INTERACT fat { } TEMP = vio_edge
             SELECT vio_edge INTERACT spc_target1 { } TEMP = vio_edge
             SELECT violation INTERACT vio_edge { } TEMP = violation
          } else {
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
          }
          BOOLEAN violation NOT fat_target { } TEMP = violation
          if (fatTblParallelLength < fatTblSpacing) {
             SELECT_EDGE violation TOUCHING fat2 {
                VSIZE_INSIDE = fatTblParallelLength - 0.0002 
             } TEMP = vio_filter
             SELECT_CONTAINS vio_filter { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = vio_filter
             SELECT violation INTERACT vio_filter { } TEMP = violation
          } else {
             SELECT_CONTAINS violation { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = violation
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING = [fatTblSpacing, fatTblSpacing]
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
             } TEMP = violation3
             BOOLEAN violation3 NOT fat_target { } TEMP = violation3
             BOOLEAN violation NOT violation3 { } TEMP= violation
          }
          SELECT_EDGE fat2 TOUCHING violation { } TEMP=fat_viol
          BOOLEAN fat_viol AND violation { } TEMP=fat_viol
          SELECT_EDGE spc_target2 TOUCHING violation { } TEMP=spc_target2
          BOOLEAN spc_target2 AND violation { } TEMP= spc_target2
	  if (ignoreChildCell == 1) {
             EXTERNAL fat_viol spc_target2 {
		SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		TOUCH = FALSE
		POINT_TOUCH = FALSE
		NON_PARALLEL = TRUE
	     } TEMP = spc_mode0_out
             BOOLEAN spc_mode0_out NOT spc_mode0_child_out { } TEMP = spc_mode0_diff_out
             SELECT spc_mode0_out INTERACT spc_mode0_diff_out { } TEMP = spc_mode0_out
	     SELECT_EDGE fat2 TOUCHING spc_mode0_out { } TEMP=fat_viol
	     BOOLEAN fat_viol AND spc_mode0_out { } TEMP=fat_viol
	     SELECT_EDGE spc_target2 TOUCHING spc_mode0_out { } TEMP=spc_target2
	     BOOLEAN spc_target2 AND spc_mode0_out { } TEMP=spc_target2
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (19 )  		
	  } else {
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing 
	        SET_CORNERS_TO_SPACING = FALSE
	        PARALLEL_POINT_PROJECTION = FALSE
	        TOUCH = FALSE
	        POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (19 )
	  }
	  if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	     if (ignoreChildCell == 1) {
		EXTERNAL fat spc_target {
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} TEMP = spc_mode1_out
	        BOOLEAN spc_mode1_out NOT spc_mode1_child_out { } TEMP = spc_mode1_diff_out
	        SELECT spc_mode1_out INTERACT spc_mode1_diff_out { } TEMP = spc_mode1_out
                SELECT_EDGE fat TOUCHING spc_mode1_out { } TEMP=fat_viol
	        BOOLEAN fat_viol AND spc_mode1_out { } TEMP=fat_viol
	        SELECT_EDGE spc_target TOUCHING spc_mode1_out { } TEMP=spc_target2
	        BOOLEAN spc_target2 AND spc_mode1_out { } TEMP=spc_target2
	        EXTERNAL fat_viol spc_target2 {
	           COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um " 	    
		   SPACING < fatTblSpacing_dg
                   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} (19 )
	     } else {
	        EXTERNAL fat spc_target {
		   COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um "
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
	    	   PARALLEL_POINT_PROJECTION = FALSE
	           TOUCH = FALSE
	     	   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } (19 ) 
	     }
          }
       } else {
	  if (ignoreChildCell == 1) {
              EXTERNAL fat spc_target {
                 SPACING < fatTblSpacing
                 BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
              } TEMP = spc_out
	      BOOLEAN spc_out NOT spc_child_out { } TEMP = spc_diff_out
	      SELECT spc_out INTERACT spc_diff_out { } TEMP = spc_out
	      SELECT_EDGE fat TOUCHING spc_out { } TEMP=fat_viol
	      BOOLEAN fat_viol AND spc_out { } TEMP=fat_viol
              SELECT_EDGE spc_target TOUCHING spc_out { } TEMP=spc_target2
	      BOOLEAN spc_target2 AND spc_out { } TEMP=spc_target2
	      EXTERNAL fat_viol spc_target2 {
		 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
		 BOX_CORNER = FALSE 
		 NON_PARALLEL = TRUE
		 POINT_TOUCH = FALSE
	      } (19 ) 
	  } else {
	      EXTERNAL fat spc_target {
                 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
	         BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
	      } (19 ) 
	  }
       }
       /*check metal in the extension range*/ 
       if (fatTblExtensionRange > 0) {
	  if (fatWireExtensionMode == 0) {
	     SIZE fat { OVERSIZE = fatTblExtensionRange } TEMP = fat_tmp
             BOOLEAN fat_tmp AND metal5  { } TEMP = fat_tmp
  	     BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
             SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_ext
             BOOLEAN fat_ext OR fat { } TEMP = fat_ext
	     if (fatTblParallelLength > 0) {
                if (fatTblParallelLength > fatTblExtensionRange) {
                   SIZE fat { OVERSIZE = fatTblParallelLength } TEMP = fat_tmp
                   BOOLEAN fat_tmp AND metal5  { } TEMP = fat_tmp
  	           BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
                   SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_parallel
                   BOOLEAN fat_parallel OR fat { } TEMP = fat_parallel
                } else {
                   COPY fat_ext { } TEMP = fat_parallel
                }
		EXTERNAL fat_parallel spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
	           NON_PARALLEL = TRUE
	        } TEMP = vio_filter_set
		EXTERNAL fat_ext spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } TEMP = vio_set
                if (fatTblParallelLength < fatTblSpacing) {
                   SELECT_EDGE vio_filter_set TOUCHING fat_parallel {
                      VSIZE_INSIDE = fatTblParallelLength - 0.0002 
                   } TEMP = vio_filter_set_filter
                   SELECT_CONTAINS vio_filter_set_filter { 
                      WIDTH =  0.0002 
                      HEIGHT = fatTblParallelLength + 0.0001 
                   } TEMP = vio_filter_set_filter
                   SELECT vio_filter_set INTERACT vio_filter_set_filter { } TEMP = vio_filter
                } else {
	           SELECT_CONTAINS vio_filter_set { 
	              WIDTH =  0.0002 
	              HEIGHT = fatTblParallelLength + 0.0001 
	           } TEMP = vio_filter
                }
                SELECT vio_set INSIDE vio_filter { } TEMP = mode0_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out1 NOT mode0_child_out1 { } TEMP = mode0_diff_out1
                   SELECT mode0_out1 INTERACT mode0_diff_out1 { } TEMP = mode0_out1
                }
                COPY mode0_out1 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing  = fatTblSpacing um"
                } (19 )
		if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	           EXTERNAL fat_ext spc_target {
		      SPACING < fatTblSpacing_dg
	              SET_CORNERS_TO_SPACING = FALSE
		      PARALLEL_POINT_PROJECTION = FALSE
		      TOUCH = TRUE
		      POINT_TOUCH = FALSE
		      NON_PARALLEL = TRUE
	           } TEMP = mode0_out2
                   if (ignoreChildCell == 1) {
                      BOOLEAN mode0_out2 NOT mode0_child_out2 { } TEMP = mode0_diff_out2
                      SELECT mode0_out2 INTERACT mode0_diff_out2 { } TEMP = mode0_out2
                   }
                   COPY mode0_out2 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing (mode 1/2) = fatTblSpacing um/ fatTblSpacing_dg um "
                   } (19 )
	        } 
	     } else {
	        EXTERNAL fat_ext spc_target {
		   SPACING < fatTblSpacing
		   NON_PARALLEL = TRUE
		   SET_CORNERS_TO_SPACING = FALSE
		   POINT_TOUCH = FALSE
		} TEMP = mode0_out3
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out3 NOT mode0_child_out3 { } TEMP = mode0_diff_out3
                   SELECT mode0_out3 INTERACT mode0_diff_out3 { } TEMP = mode0_out3
                }
                COPY mode0_out3 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range ( fatTblExtensionRange um) minimum spacing = fatTblSpacing um"
                } (19 )
	     }
	  } else if (fatWireExtensionMode == 1) {
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal5  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             if (fatTblParallelLength > 0) {
                EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
		   BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   CHECK_SAME_POLYGON = TRUE 
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
	        SELECT fat_ext INTERACT spacing {  } TEMP = fat_ext
		BOOLEAN fat_ext OR spacing {  } TEMP = combined_fat_ext
                EXTERNAL combined_fat_ext fat {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
                } TEMP = fat_spacing
		BOOLEAN fat_spacing AND fat_ran {  } TEMP = fat_spacing
		BOOLEAN combined_fat_ext OR fat_spacing {  } TEMP = combined_fat_ext
                SELECT_CONTAINS combined_fat_ext { 
                   WIDTH =  0.0002 
                   HEIGHT = fatTblParallelLength + 0.0001 
                } TEMP = combined_fat_ext
		SELECT spacing INTERACT combined_fat_ext { 
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out1 NOT mode1_child_out1 { } TEMP = mode1_diff_out1
                   SELECT mode1_out1 INTERACT mode1_diff_out1 { } TEMP = mode1_out1 
                }
                COPY mode1_out1 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (19 ) 
	     } else {
               	EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
	           BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
	           CHECK_SAME_POLYGON = TRUE 
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
                SELECT spacing INTERACT fat_ext {
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out2
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out2 NOT mode1_child_out2 { } TEMP = mode1_diff_out2
                   SELECT mode1_out2 INTERACT mode1_diff_out2 { } TEMP = mode1_out2
                }
                COPY mode1_out2 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (19 )
	     }
	  } else if (fatWireExtensionMode == 2) {
	     SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
             BOOLEAN fat_ran AND metal5  {  } TEMP = fat_ext
             BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	      	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
             } TEMP = spacing
 	     SELECT spacing INSIDE fat_ran {  } TEMP = spacing
	     SELECT spacing OUTSIDE fat {  } TEMP = spacing
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode2_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode2_out NOT mode2_child_out { } TEMP = mode2_diff_out
                SELECT mode2_out INTERACT mode2_diff_out { } TEMP = mode2_out 
             }
             COPY mode2_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 2, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (19 )
	  } else if (fatWireExtensionMode == 3) {
             SIZE fat {
	        GROW_LEFT = fatTblExtensionRange
	        GROW_RIGHT = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal5  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	       	PARALLEL = TRUE

	       	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		HORIZONTAL_ONLY = TRUE
             } TEMP = spacing_hor
	     SELECT spacing_hor INSIDE fat_ran {  } TEMP = spacing_hor
	     SELECT spacing_hor OUTSIDE fat {  } TEMP = spacing_hor
             SIZE fat {
	        GROW_TOP = fatTblExtensionRange
	        GROW_BOTTOM = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal5  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	        POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		VERTICAL_ONLY = TRUE
             } TEMP = spacing_ver
	     SELECT spacing_ver INSIDE fat_ran {  } TEMP = spacing_ver
	     SELECT spacing_ver OUTSIDE fat {  } TEMP = spacing_ver
  	     BOOLEAN spacing_hor OR spacing_ver {  } TEMP = spacing
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal5  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
  	     /* check overlapped projection length */
 	     if (fatTblParallelLength > 0) {
                POLYGON_FEATURES fat_ext {
                   EQUATIONS {
                      vnum = EV_VNUM_IN;
                      if ( vnum > 0) {
                         bdLeft = EV_VXCOORD_IN[0];
                         bdRight = EV_VXCOORD_IN[0];
                         bdBottom = EV_VYCOORD_IN[0];
                         bdTop = EV_VYCOORD_IN[0];
                         FOR (i = 1; i < vnum; i++) {
                            if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
                            else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
                            if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
                            else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
                         } /* FOR i */
                         if ( (bdRight - bdLeft) >= fatTblParallelLength ||
                  	      (bdTop - bdBottom) >= fatTblParallelLength) {
                            FOR (i = 0; i < vnum; i++) {
                               EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
                               EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
                            }
                            EV_VNUM_OUT = vnum;
                 	    EV_SAVE_POLYGON();
                         }
                      }
                   }
                } TEMP = fat_ext /* POLYGON_FEATURE */
             }
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode3_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode3_out NOT mode3_child_out { } TEMP = mode3_diff_out
                SELECT mode3_out INTERACT mode3_diff_out { } TEMP = mode3_out
             }
             COPY mode3_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 3, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (19 )
          }
       }
       SET fatTblSpacing = 0;
    }
}
@ 656 "adrc/adrc.ev" 2


SET fatTblThreshold = 3.005;
SET fatTblParallelLength = 3.005;
SET minWidth = 0.056;

SET fatTblThreshold_Start = 0;
SET fatTblSpacing = 0.7;
@ 1 "adrc/adrc_fatMetal.ev" 1
/*check fat metal table*/
if (fatTblThreshold > 0) {
    if ((fatTblThreshold / 2.0) > 0.0001 ) {
       SIZE fat_candidate  { UNDER_OVER = fatTblThreshold / 2.0 - 0.0001  } TEMP = fat_candidate
       if (fatTblNextThreshold > 0) {
          SIZE fat_candidate { UNDER_OVER = fatTblNextThreshold / 2.0 - 0.0001  } TEMP = fat_next
          BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
          BOOLEAN fat AND fat_target { } TEMP = fat
          SET fatTblNextThreshold = 0;
       } else {
          BOOLEAN fat_candidate AND fat_target {  } TEMP = fat 
       }
    } else {
      COPY fat_target {  } TEMP = fat 
    }
    COPY fat_target { } TEMP = spc_target
    if (fatTblThreshold_Start > 0  || fatTblThreshold_End > 0) {
       if (fatTblThreshold_Start > 0) {
          SIZE fat_target { UNDER_OVER = fatTblThreshold_Start / 2.0 - 0.0001  } TEMP = spc_target
       }
       if (fatTblThreshold_End > 0 && fatTblThreshold_End > fatTblThreshold_Start) {
          SIZE spc_target { UNDER_OVER = fatTblThreshold_End / 2.0 - 0.0001  } TEMP = fat_end
          BOOLEAN spc_target NOT fat_end { } TEMP = spc_target
       }
       BOOLEAN spc_target AND fat_target {  } TEMP = spc_target
       if (ignoreBlockage == 0 && fatTblThreshold_Start < fatTblThreshold_1) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal5_blockage  {  } TEMP = spc_target
       }
       SET fatTblThreshold_Start = 0;
       SET fatTblThreshold_End = 0;
       SET fatTblThreshold_1 = 0;
    } else {
       if (ignoreBlockage == 0) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal5_blockage  {  } TEMP = spc_target
       }
    }
 
    if (fatTblEnclosedArea > 0) {
       SELECT holes INTERACT fat { } TEMP = fat_holes
       AREA fat_holes { 
          RANGE = [0.0001 * 0.0001 , fatTblEnclosedArea - 0.0001 * 0.0001 ]
       } TEMP = fat_holes
       if (fatTblMinEnclosedAreaMode==0) {
          SIZE fat_holes { OVER_UNDER = fatTblThreshold / 2.0 + 0.0001  } TEMP = ovun_holes
          SELECT ovun_holes INTERACT fat_holes { RANGE = [2, 9999999999 ] } TEMP = merged_holes
          BOOLEAN fat_candidate AND fat_target { } TEMP = fat_metal
          BOOLEAN metal5  NOT fat_metal { } TEMP = thin_metal
          BOOLEAN thin_metal NOT ovun_holes { } TEMP = thin_metal
          SELECT ovun_holes INTERACT thin_metal { } TEMP = thin_holes
          BOOLEAN thin_holes OR merged_holes { } TEMP = thin_holes
          BOOLEAN fat_holes NOT thin_holes { } TEMP = fat_holes
       }
       COPY fat_holes { 
	  COMMENT = "$layer_name EnclsArea : fat metal ( fatTblThreshold um) minimum enclosed area (mode fatTblMinEnclosedAreaMode ) = fatTblEnclosedArea um*um"
       } (19 )
       SET fatTblEnclosedArea = 0;
    }
    if (fatTblSpacing > 0) {
       /*check fat metal*/ 
       if (fatTblParallelLength > 0) {
          if (router_parallelLengthNetMode == 1 || parallelLengthMode == 1) {
             AREA spc_target { RANGE = [fatTblParallelLength * minWidth + 0.0001 , 9999999999 ] } TEMP = spc_target1
             COPY spc_target1 { } TEMP = spc_target2
          } else {
             COPY spc_target { } TEMP = spc_target2
          }
          if (parallelLengthMode == 1) {
             SELECT metal5  INTERACT fat { } TEMP = fat_all 
             BOOLEAN fat_all OR fat { } TEMP = fat2
             SELECT metal5  INTERACT spc_target2 { } TEMP = spc_target_all
             BOOLEAN spc_target_all OR spc_target2 { } TEMP = spc_target2
          } else {
             COPY fat { } TEMP = fat2
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING <= fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
                OUTPUT_EDGES = TRUE
             } TEMP = vio_edge
             SELECT vio_edge INTERACT fat { } TEMP = vio_edge
             SELECT vio_edge INTERACT spc_target1 { } TEMP = vio_edge
             SELECT violation INTERACT vio_edge { } TEMP = violation
          } else {
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
          }
          BOOLEAN violation NOT fat_target { } TEMP = violation
          if (fatTblParallelLength < fatTblSpacing) {
             SELECT_EDGE violation TOUCHING fat2 {
                VSIZE_INSIDE = fatTblParallelLength - 0.0002 
             } TEMP = vio_filter
             SELECT_CONTAINS vio_filter { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = vio_filter
             SELECT violation INTERACT vio_filter { } TEMP = violation
          } else {
             SELECT_CONTAINS violation { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = violation
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING = [fatTblSpacing, fatTblSpacing]
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
             } TEMP = violation3
             BOOLEAN violation3 NOT fat_target { } TEMP = violation3
             BOOLEAN violation NOT violation3 { } TEMP= violation
          }
          SELECT_EDGE fat2 TOUCHING violation { } TEMP=fat_viol
          BOOLEAN fat_viol AND violation { } TEMP=fat_viol
          SELECT_EDGE spc_target2 TOUCHING violation { } TEMP=spc_target2
          BOOLEAN spc_target2 AND violation { } TEMP= spc_target2
	  if (ignoreChildCell == 1) {
             EXTERNAL fat_viol spc_target2 {
		SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		TOUCH = FALSE
		POINT_TOUCH = FALSE
		NON_PARALLEL = TRUE
	     } TEMP = spc_mode0_out
             BOOLEAN spc_mode0_out NOT spc_mode0_child_out { } TEMP = spc_mode0_diff_out
             SELECT spc_mode0_out INTERACT spc_mode0_diff_out { } TEMP = spc_mode0_out
	     SELECT_EDGE fat2 TOUCHING spc_mode0_out { } TEMP=fat_viol
	     BOOLEAN fat_viol AND spc_mode0_out { } TEMP=fat_viol
	     SELECT_EDGE spc_target2 TOUCHING spc_mode0_out { } TEMP=spc_target2
	     BOOLEAN spc_target2 AND spc_mode0_out { } TEMP=spc_target2
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (19 )  		
	  } else {
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing 
	        SET_CORNERS_TO_SPACING = FALSE
	        PARALLEL_POINT_PROJECTION = FALSE
	        TOUCH = FALSE
	        POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (19 )
	  }
	  if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	     if (ignoreChildCell == 1) {
		EXTERNAL fat spc_target {
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} TEMP = spc_mode1_out
	        BOOLEAN spc_mode1_out NOT spc_mode1_child_out { } TEMP = spc_mode1_diff_out
	        SELECT spc_mode1_out INTERACT spc_mode1_diff_out { } TEMP = spc_mode1_out
                SELECT_EDGE fat TOUCHING spc_mode1_out { } TEMP=fat_viol
	        BOOLEAN fat_viol AND spc_mode1_out { } TEMP=fat_viol
	        SELECT_EDGE spc_target TOUCHING spc_mode1_out { } TEMP=spc_target2
	        BOOLEAN spc_target2 AND spc_mode1_out { } TEMP=spc_target2
	        EXTERNAL fat_viol spc_target2 {
	           COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um " 	    
		   SPACING < fatTblSpacing_dg
                   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} (19 )
	     } else {
	        EXTERNAL fat spc_target {
		   COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um "
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
	    	   PARALLEL_POINT_PROJECTION = FALSE
	           TOUCH = FALSE
	     	   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } (19 ) 
	     }
          }
       } else {
	  if (ignoreChildCell == 1) {
              EXTERNAL fat spc_target {
                 SPACING < fatTblSpacing
                 BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
              } TEMP = spc_out
	      BOOLEAN spc_out NOT spc_child_out { } TEMP = spc_diff_out
	      SELECT spc_out INTERACT spc_diff_out { } TEMP = spc_out
	      SELECT_EDGE fat TOUCHING spc_out { } TEMP=fat_viol
	      BOOLEAN fat_viol AND spc_out { } TEMP=fat_viol
              SELECT_EDGE spc_target TOUCHING spc_out { } TEMP=spc_target2
	      BOOLEAN spc_target2 AND spc_out { } TEMP=spc_target2
	      EXTERNAL fat_viol spc_target2 {
		 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
		 BOX_CORNER = FALSE 
		 NON_PARALLEL = TRUE
		 POINT_TOUCH = FALSE
	      } (19 ) 
	  } else {
	      EXTERNAL fat spc_target {
                 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
	         BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
	      } (19 ) 
	  }
       }
       /*check metal in the extension range*/ 
       if (fatTblExtensionRange > 0) {
	  if (fatWireExtensionMode == 0) {
	     SIZE fat { OVERSIZE = fatTblExtensionRange } TEMP = fat_tmp
             BOOLEAN fat_tmp AND metal5  { } TEMP = fat_tmp
  	     BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
             SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_ext
             BOOLEAN fat_ext OR fat { } TEMP = fat_ext
	     if (fatTblParallelLength > 0) {
                if (fatTblParallelLength > fatTblExtensionRange) {
                   SIZE fat { OVERSIZE = fatTblParallelLength } TEMP = fat_tmp
                   BOOLEAN fat_tmp AND metal5  { } TEMP = fat_tmp
  	           BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
                   SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_parallel
                   BOOLEAN fat_parallel OR fat { } TEMP = fat_parallel
                } else {
                   COPY fat_ext { } TEMP = fat_parallel
                }
		EXTERNAL fat_parallel spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
	           NON_PARALLEL = TRUE
	        } TEMP = vio_filter_set
		EXTERNAL fat_ext spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } TEMP = vio_set
                if (fatTblParallelLength < fatTblSpacing) {
                   SELECT_EDGE vio_filter_set TOUCHING fat_parallel {
                      VSIZE_INSIDE = fatTblParallelLength - 0.0002 
                   } TEMP = vio_filter_set_filter
                   SELECT_CONTAINS vio_filter_set_filter { 
                      WIDTH =  0.0002 
                      HEIGHT = fatTblParallelLength + 0.0001 
                   } TEMP = vio_filter_set_filter
                   SELECT vio_filter_set INTERACT vio_filter_set_filter { } TEMP = vio_filter
                } else {
	           SELECT_CONTAINS vio_filter_set { 
	              WIDTH =  0.0002 
	              HEIGHT = fatTblParallelLength + 0.0001 
	           } TEMP = vio_filter
                }
                SELECT vio_set INSIDE vio_filter { } TEMP = mode0_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out1 NOT mode0_child_out1 { } TEMP = mode0_diff_out1
                   SELECT mode0_out1 INTERACT mode0_diff_out1 { } TEMP = mode0_out1
                }
                COPY mode0_out1 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing  = fatTblSpacing um"
                } (19 )
		if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	           EXTERNAL fat_ext spc_target {
		      SPACING < fatTblSpacing_dg
	              SET_CORNERS_TO_SPACING = FALSE
		      PARALLEL_POINT_PROJECTION = FALSE
		      TOUCH = TRUE
		      POINT_TOUCH = FALSE
		      NON_PARALLEL = TRUE
	           } TEMP = mode0_out2
                   if (ignoreChildCell == 1) {
                      BOOLEAN mode0_out2 NOT mode0_child_out2 { } TEMP = mode0_diff_out2
                      SELECT mode0_out2 INTERACT mode0_diff_out2 { } TEMP = mode0_out2
                   }
                   COPY mode0_out2 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing (mode 1/2) = fatTblSpacing um/ fatTblSpacing_dg um "
                   } (19 )
	        } 
	     } else {
	        EXTERNAL fat_ext spc_target {
		   SPACING < fatTblSpacing
		   NON_PARALLEL = TRUE
		   SET_CORNERS_TO_SPACING = FALSE
		   POINT_TOUCH = FALSE
		} TEMP = mode0_out3
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out3 NOT mode0_child_out3 { } TEMP = mode0_diff_out3
                   SELECT mode0_out3 INTERACT mode0_diff_out3 { } TEMP = mode0_out3
                }
                COPY mode0_out3 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range ( fatTblExtensionRange um) minimum spacing = fatTblSpacing um"
                } (19 )
	     }
	  } else if (fatWireExtensionMode == 1) {
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal5  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             if (fatTblParallelLength > 0) {
                EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
		   BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   CHECK_SAME_POLYGON = TRUE 
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
	        SELECT fat_ext INTERACT spacing {  } TEMP = fat_ext
		BOOLEAN fat_ext OR spacing {  } TEMP = combined_fat_ext
                EXTERNAL combined_fat_ext fat {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
                } TEMP = fat_spacing
		BOOLEAN fat_spacing AND fat_ran {  } TEMP = fat_spacing
		BOOLEAN combined_fat_ext OR fat_spacing {  } TEMP = combined_fat_ext
                SELECT_CONTAINS combined_fat_ext { 
                   WIDTH =  0.0002 
                   HEIGHT = fatTblParallelLength + 0.0001 
                } TEMP = combined_fat_ext
		SELECT spacing INTERACT combined_fat_ext { 
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out1 NOT mode1_child_out1 { } TEMP = mode1_diff_out1
                   SELECT mode1_out1 INTERACT mode1_diff_out1 { } TEMP = mode1_out1 
                }
                COPY mode1_out1 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (19 ) 
	     } else {
               	EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
	           BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
	           CHECK_SAME_POLYGON = TRUE 
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
                SELECT spacing INTERACT fat_ext {
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out2
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out2 NOT mode1_child_out2 { } TEMP = mode1_diff_out2
                   SELECT mode1_out2 INTERACT mode1_diff_out2 { } TEMP = mode1_out2
                }
                COPY mode1_out2 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (19 )
	     }
	  } else if (fatWireExtensionMode == 2) {
	     SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
             BOOLEAN fat_ran AND metal5  {  } TEMP = fat_ext
             BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	      	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
             } TEMP = spacing
 	     SELECT spacing INSIDE fat_ran {  } TEMP = spacing
	     SELECT spacing OUTSIDE fat {  } TEMP = spacing
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode2_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode2_out NOT mode2_child_out { } TEMP = mode2_diff_out
                SELECT mode2_out INTERACT mode2_diff_out { } TEMP = mode2_out 
             }
             COPY mode2_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 2, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (19 )
	  } else if (fatWireExtensionMode == 3) {
             SIZE fat {
	        GROW_LEFT = fatTblExtensionRange
	        GROW_RIGHT = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal5  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	       	PARALLEL = TRUE

	       	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		HORIZONTAL_ONLY = TRUE
             } TEMP = spacing_hor
	     SELECT spacing_hor INSIDE fat_ran {  } TEMP = spacing_hor
	     SELECT spacing_hor OUTSIDE fat {  } TEMP = spacing_hor
             SIZE fat {
	        GROW_TOP = fatTblExtensionRange
	        GROW_BOTTOM = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal5  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	        POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		VERTICAL_ONLY = TRUE
             } TEMP = spacing_ver
	     SELECT spacing_ver INSIDE fat_ran {  } TEMP = spacing_ver
	     SELECT spacing_ver OUTSIDE fat {  } TEMP = spacing_ver
  	     BOOLEAN spacing_hor OR spacing_ver {  } TEMP = spacing
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal5  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
  	     /* check overlapped projection length */
 	     if (fatTblParallelLength > 0) {
                POLYGON_FEATURES fat_ext {
                   EQUATIONS {
                      vnum = EV_VNUM_IN;
                      if ( vnum > 0) {
                         bdLeft = EV_VXCOORD_IN[0];
                         bdRight = EV_VXCOORD_IN[0];
                         bdBottom = EV_VYCOORD_IN[0];
                         bdTop = EV_VYCOORD_IN[0];
                         FOR (i = 1; i < vnum; i++) {
                            if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
                            else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
                            if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
                            else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
                         } /* FOR i */
                         if ( (bdRight - bdLeft) >= fatTblParallelLength ||
                  	      (bdTop - bdBottom) >= fatTblParallelLength) {
                            FOR (i = 0; i < vnum; i++) {
                               EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
                               EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
                            }
                            EV_VNUM_OUT = vnum;
                 	    EV_SAVE_POLYGON();
                         }
                      }
                   }
                } TEMP = fat_ext /* POLYGON_FEATURE */
             }
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode3_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode3_out NOT mode3_child_out { } TEMP = mode3_diff_out
                SELECT mode3_out INTERACT mode3_diff_out { } TEMP = mode3_out
             }
             COPY mode3_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 3, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (19 )
          }
       }
       SET fatTblSpacing = 0;
    }
}
@ 664 "adrc/adrc.ev" 2


SET fatTblThreshold = 0;
SET fatTblEnclosedArea = 0;
SET fatTblExtensionRange = 0;
SET fatTblParallelLength = 0;
SET minWidth = 0;

/* End of Met5 fat table spacing rules */










/*metal 6*/
SET layer_name = "Met6";










SET minWidth = 0.056;
SET maxWidth = 5;
SET minArea = 0.016;
SET minEnclosedArea = 0.2;
SET minSpacing = 0.056;
SET sameNetMinSpacing = 0.056;
SET stub2StubSpacing = 0;

SET fatTblDimension = 5;
@ 1 "adrc/adrc_check_metal.ev" 1
/* Data Preparation */
if (fatTblDimension > 1 || fatWireThreshold > 0 || maxWidth > 0) {
  if (ignoreBlockage) {
      /* Let the real blockage be treated as thin */
      BOOLEAN metal6  NOT metal6_rbkg  {} TEMP=fat_candidate
  } else {
      COPY metal6  {} TEMP=fat_candidate
  }
  COPY fat_candidate {} TEMP=fat_target
}
/*Check width*/
if (minWidth > 0) {
    INTERNAL metal6  { 
        COMMENT = "$layer_name MinWidth  : minimum width = minWidth um" 
        SPACING < minWidth
        POINT_TOUCH = FALSE
    } (21 )
}
 
if (maxWidth > 0) {
    SIZE  fat_candidate {
        COMMENT = "$layer_name MaxWidth  : maximum width = maxWidth um"
 	UNDER_OVER = maxWidth / 2 
    } (21 ) 
}
 
/*Check area*/
if (minArea > 0) {
    AREA metal6  { 
	COMMENT = "$layer_name MinArea   : minimum area = minArea um*um"
	RANGE = [0.0001 * 0.0001 , minArea - 0.0001 * 0.0001 ]
    } (21 )
}
/* check min length of bounding box on polygon */
if (minLength > 0) {
  if (minLengthMode == 1) {
    INTERNAL metal6  {
        SPACING < minLength
        VERTICAL_ONLY = TRUE
        SET_CORNERS_TO_SPACING = FALSE
    } TEMP = ver_short
    BOOLEAN metal6  NOT ver_short { } TEMP = ver_long
    INTERNAL metal6  {
        SPACING < minLength
        HORIZONTAL_ONLY = TRUE
        SET_CORNERS_TO_SPACING = FALSE
    } TEMP = hor_short
    BOOLEAN metal6  NOT hor_short { } TEMP = hor_long
    SELECT CUT_LAYER1 INSIDE ver_long { } TEMP = good_cut
    BOOLEAN CUT_LAYER1 NOT good_cut { } TEMP = fail_cut_1
    SELECT fail_cut_1 INSIDE hor_long { } TEMP = good_cut
    BOOLEAN fail_cut_1 NOT good_cut { } TEMP = fail_cut_1
    SELECT CUT_LAYER2 INSIDE ver_long { } TEMP = good_cut
    BOOLEAN CUT_LAYER2 NOT good_cut { } TEMP = fail_cut_2
    SELECT fail_cut_2 INSIDE hor_long { } TEMP = good_cut
    BOOLEAN fail_cut_2 NOT good_cut { } TEMP = fail_cut_2
    BOOLEAN fail_cut_1 OR fail_cut_2 { } TEMP = fail_cut
    BOOLEAN hor_short NOT ver_long { } TEMP = hor_short
    BOOLEAN ver_short NOT hor_long { } TEMP = ver_short
    SELECT ver_short INTERACT fail_cut { } TEMP = ver_fail
    SELECT hor_short INTERACT fail_cut { } TEMP = hor_fail
    BOOLEAN ver_fail OR hor_fail { } TEMP = all_fail
    INTERNAL all_fail {
        COMMENT = "$layer_name MinLength : minimum length = minLength um"
        SPACING < minLength
        VERTICAL_ONLY = TRUE
        SET_CORNERS_TO_SPACING = FALSE
    } (21 )
  } else {
    POLYGON_FEATURES metal6  {
      COMMENT = "$layer_name MinLength : minimum length = minLength um"
      EQUATIONS {
        vnum = EV_VNUM_IN;
        if ( vnum > 0) {
	  bdLeft = EV_VXCOORD_IN[0];
	  bdRight = EV_VXCOORD_IN[0];
	  bdBottom = EV_VYCOORD_IN[0];
	  bdTop = EV_VYCOORD_IN[0];
          FOR (i = 1; i < vnum; i++) {
	    if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
            else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
	    if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
            else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
          }
	  if ( (bdRight - bdLeft) < minLength &&
	       (bdTop - bdBottom) < minLength) {
	    FOR (i = 0; i < vnum; i++) {
              EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
	      EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
            }
	    EV_VNUM_OUT = vnum;
	    EV_SAVE_POLYGON();
          }
        }
      }
    } (21 ) 
  }
  SET minLength = 0;
}
/* check max length of bounding box on polygon */
if (maxLength > 0) {
  POLYGON_FEATURES metal6  {
    COMMENT = "$layer_name MaxLength : maximum length = maxLength um"
    EQUATIONS {
      vnum = EV_VNUM_IN;
      if ( vnum > 0) {
	bdLeft = EV_VXCOORD_IN[0];
	bdRight = EV_VXCOORD_IN[0];
	bdBottom = EV_VYCOORD_IN[0];
	bdTop = EV_VYCOORD_IN[0];
        FOR (i = 1; i < vnum; i++) {
	  if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
          else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
	  if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
          else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
        }
	if ( (bdRight - bdLeft + bdTop - bdBottom) > maxLength ) {
          EV_VXCOORD_OUT[0] = bdLeft;
	  EV_VYCOORD_OUT[0] = bdBottom;
          EV_VXCOORD_OUT[1] = bdLeft;
	  EV_VYCOORD_OUT[1] = bdTop;
          EV_VXCOORD_OUT[2] = bdRight;
	  EV_VYCOORD_OUT[2] = bdTop;
          EV_VXCOORD_OUT[3] = bdRight;
	  EV_VYCOORD_OUT[3] = bdBottom;
          EV_VXCOORD_OUT[4] = bdLeft;
	  EV_VYCOORD_OUT[4] = bdBottom;
	  EV_VNUM_OUT = 5;
	  EV_SAVE_POLYGON();
        }
      }
    }
  } (21 ) 
  SET maxLength = 0;
}
 
/*Check enclosed area*/
if (minEnclosedArea > 0) {
    SELECT metal6  INSIDE_HOLE {
        INNER_HOLE_ONLY
    } TEMP = holes
    BOOLEAN holes NOT metal6  { } TEMP = holes
 
    AREA holes {
        COMMENT = "$layer_name EnclsArea : minimum enclosed area = minEnclosedArea um*um"
        RANGE = [0.0001 * 0.0001 , minEnclosedArea - 0.0001 * 0.0001 ]
    } (21 )
    /* check min length of bounding box on polygon */
    if (minEnclosedWidth > 0) {
      POLYGON_FEATURES holes {
        COMMENT = "$layer_name EnclsWidth: minimum enclosed Width = minEnclosedWidth um"
        EQUATIONS {
          vnum = EV_VNUM_IN;
          if ( vnum > 0) {
            bdLeft = EV_VXCOORD_IN[0];
            bdRight = EV_VXCOORD_IN[0];
            bdBottom = EV_VYCOORD_IN[0];
            bdTop = EV_VYCOORD_IN[0];
            FOR (i = 1; i < vnum; i++) {
              if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
              else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
              if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
              else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
            }
            if ( (bdRight - bdLeft) < minEnclosedWidth &&
                 (bdTop - bdBottom) < minEnclosedWidth) {
              FOR (i = 0; i < vnum; i++) {
                EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
                EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
              }
              EV_VNUM_OUT = vnum;
              EV_SAVE_POLYGON();
            }
          }
        }
      } (21 ) 
    }
}
 
/*check special notch rule*/
if ((minEdgeLength2 > 0.0001  && minEdgeLength3 > 0.0001 ) || minEdgeMode==2) {
  if (minEdgeMode==2) {
    SET minEdgeLength3 = minEdgeLength ;
  }
  NOTCH metal6  {
     SPACING < minEdgeLength3
     SET_CORNERS_TO_SPACING=FALSE
     PARALLEL = TRUE
     OUTPUT_EDGES = TRUE
  } TEMP = notch_vectors
  SELECT_VECTOR notch_vectors {
     LENGTH_RANGE = [0.0001 , minEdgeLength2 - 0.0001 ]
  } TEMP = short_edges
  EXTERNAL short_edges metal6  {
     SPACING < minEdgeLength3
     SET_CORNERS_TO_SPACING=FALSE
     PARALLEL = TRUE
  } TEMP = notch_err
  /* Choose the real U-shaped notch */
  SIZE notch_err { OVERSIZE = 0.0002 *10 } TEMP = neighbors 
  BOOLEAN neighbors AND metal6  { } TEMP = neighbors
  VERTEX neighbors { 
     CONCAVE = TRUE
     CONVEX = TRUE
     SIZE = 0.0002 
  } TEMP = corners
  SELECT_EDGE neighbors INTERACT notch_err { } TEMP = target_edges
  BOOLEAN target_edges NOT corners { } TEMP = target_edges
  VERTEX neighbors { 
     CONCAVE = TRUE
     SIZE = 2* 0.0002 
  } TEMP = corners
  SELECT target_edges INTERACT corners { RANGE = [2, 2] } TEMP=target_edges
  SELECT notch_err INTERACT target_edges {
     COMMENT = "$layer_name SpeclNotch: sameNetSp = minEdgeLength3 um (sideLen minEdgeLength2 um)" 
  } (21 )
}
/*check consecutive short edges*/
if (minEdgeLength > 0.0001  && minEdgeMode != 2) { 
  INTERNAL metal6_top  {
     SEGMENT < minEdgeLength
     FLAG_ACUTE_ANGLE = FALSE
     FLAG_ACUTE_EDGE = FALSE
     OUTPUT_EDGES = TRUE
  } TEMP = short_edges
  if ((minEdgeMode == 0 && maxTotalMinEdgeLength>0) || maxNumMinEdge > 0) {
    SET temporary_1 = 0.0002 *2;
    SET temporary_2 = 2*temporary_1+ 0.0001 ;
    SELECT metal6_top  INTERACT short_edges { } TEMP = target_top
    CLASSIFY_EDGES target_top {
       LENGTH = temporary_1
       DMIN   = temporary_2
       INSIDE_CORNER  TEMP = inside_corner_edges
       OUTSIDE_CORNER TEMP = outside_corner_edges
       REMAINDER      TEMP = remainder_edges
    }
    if (minEdgeMode == 0 && (maxNumMinEdge>0 || maxTotalMinEdgeLength > 0)) {
       SELECT short_edges ENCLOSING inside_corner_edges { } TEMP = short_edges
    }
  }
  if (maxTotalMinEdgeLength > 0) {
    LENGTH short_edges {
       RANGE = [maxTotalMinEdgeLength + 0.0001 , 9999999999 ]
    } TEMP = max_length_err
    /* Work around: translate polygons into dimensional check output */
    SIZE max_length_err { OVERSIZE = 2* 0.0002  } TEMP = max_length_err
    INTERNAL max_length_err {
       SPACING < 3* 0.0002 
       SET_CORNERS_TO_SPACING=FALSE
       COMMENT = "$layer_name MinEdgeLen: maximum total length ( minEdgeLength um)= maxTotalMinEdgeLength um"
    } (21 )
  }
  if (maxTotalMinEdgeLength == 0 || maxNumMinEdge > 0) {
    if (maxNumMinEdge==0)  {
       COPY short_edges {} TEMP=max_edge_err
    } else {
       SIZE short_edges {
         VSIZE_HEAD = - 0.0002 
        VSIZE_TAIL = - 0.0002 
       } TEMP = short_edges
       SIZE short_edges {
          OVERSIZE = 5* 0.0002 
          SIZE_ENDPOINTS = FALSE
       } TEMP = short_contours
       SELECT short_contours ENCLOSING remainder_edges {
          RANGE = [maxNumMinEdge + 1, 9999999999 ]
       } TEMP = short_contours
       SELECT short_edges INSIDE short_contours { } TEMP=max_edge_err
    }
    /* Work around: translate polygons into dimensional check output */
    SIZE max_edge_err { OVERSIZE = 2* 0.0002  } TEMP = max_edge_error
    INTERNAL max_edge_error {
       SPACING < 3* 0.0002 
       SET_CORNERS_TO_SPACING=FALSE
       COMMENT = "$layer_name MinEdgeLen: maximum number of consecutive short edges ( minEdgeLength um)= maxNumMinEdge"
    } (21 ) 
  }
}
 
/*check basic spacing*/
if (sameNetMinSpacing > 0 && sameNetMinSpacing != minSpacing) {
  if (sameNetMinSpacing > minSpacing) {
    /* Special condition for U-shaped Metal spacing rule */
    NOTCH metal6_pin  {
        SPACING < sameNetMinSpacing
        BOX_CORNER = FALSE 
        SET_CORNERS_TO_SPACING=FALSE
        NON_PARALLEL = TRUE
        OUTPUT_EDGES = TRUE
    } TEMP = errs_to_be_waived
    NOTCH metal6_top  {
	SPACING < sameNetMinSpacing
	BOX_CORNER = FALSE 
        SET_CORNERS_TO_SPACING=FALSE
	NON_PARALLEL = TRUE
        OUTPUT_EDGES = TRUE
    } TEMP = all_errs
    BOOLEAN all_errs NOT errs_to_be_waived { } TEMP=err_edge
    EXTERNAL err_edge metal6_top  {
	SPACING < sameNetMinSpacing
	BOX_CORNER = FALSE 
        SET_CORNERS_TO_SPACING=FALSE
	NON_PARALLEL = TRUE
    } TEMP = notch_err
    SIZE notch_err { OVERSIZE = 0.0002 *10 } TEMP = neighbors
    BOOLEAN neighbors AND metal6_top  { } TEMP = neighbors
    VERTEX neighbors { 
       CONCAVE = TRUE
       CONVEX = TRUE
       SIZE = 0.0002 
    } TEMP = corners
    SELECT_EDGE neighbors INTERACT notch_err { } TEMP = target_edges
    BOOLEAN target_edges AND notch_err { } TEMP = target_edges
    BOOLEAN target_edges NOT corners { } TEMP = target_edges
    VERTEX neighbors {
       CONCAVE = TRUE
       SIZE = 2* 0.0002 
    } TEMP = corners
    SELECT target_edges INTERACT corners { RANGE = [2, 2] } TEMP = target_edges
    SELECT notch_err TOUCHING target_edges {
      COMMENT = "$layer_name U-ShpNotch: U-shape notch minimum spacing = sameNetMinSpacing um" 
    } (21 )
  } else {
    NOTCH metal6  {
        COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = sameNetMinSpacing um" 
	SPACING < sameNetMinSpacing
	BOX_CORNER = FALSE 
	NON_PARALLEL = TRUE
    } (21 )
  }
  if (minSpacing > 0) {
    if (stubMode == 0 && stubSpacing > 0 && stubSpacing < minSpacing) {
	EXTERNAL metal6  {
	    COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um"
            LONGEDGE > stubThreshold + 0.0001 
	    LONGEDGE_TO_EDGE < minSpacing
	    SPACING <= 0
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            CHECK_SAME_POLYGON = TRUE 
	} (21 )
    } else {
        EXTERNAL metal6  {
	    COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um" 
	    SPACING < minSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
	    CHECK_SAME_POLYGON = FALSE
        } (21 )
    }
  }
} else {
  if (minSpacing > 0) {
    if (stubMode == 0 && stubSpacing > 0 && stubSpacing < minSpacing) {
        EXTERNAL metal6  {
            COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um"
            LONGEDGE > stubThreshold + 0.0001  
            LONGEDGE_TO_EDGE < minSpacing
            SPACING <= 0 
            BOX_CORNER = FALSE 
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            CHECK_SAME_POLYGON = TRUE 
        } (21 )
    } else {
        EXTERNAL metal6  {
	    COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um" 
            SPACING < minSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
	    CHECK_SAME_POLYGON = TRUE 
        } (21 )
    }
  }
}
 
/*check dogbone */
if (sameNetMinSpacing > 0 && sameNetWidthThreshold) {
  NOTCH metal6  {
    SPACING < sameNetMinSpacing
    BOX_CORNER = FALSE 
    NON_PARALLEL = TRUE
  } TEMP = dog_bone
 
  if (!layer_empty(dog_bone)) {
    SIZE dog_bone {EDGESIZE = sameNetWidthThreshold} TEMP = dog_ext
    BOOLEAN dog_ext NOT dog_bone {} TEMP = dog_ext
    BOOLEAN dog_ext AND metal6  {} TEMP = dog_ext
    if (!layer_empty(dog_ext)) {
      SELECT dog_ext EDGE_TOUCH dog_bone { OUTSIDE RANGE = [1, 9999999999 ] } TEMP = dog_ext
      NOTCH metal6  {
        SPACING < sameNetMinSpacing
        BOX_CORNER = FALSE 
        NON_PARALLEL = TRUE
	OUTPUT_EDGES = TRUE
      } TEMP = dog_bone
      SELECT dog_ext OUTSIDE dog_bone {} TEMP = dog_ext
      INTERNAL dog_ext {
	COMMENT = "$layer_name dogBone   : notch spacing = sameNetMinSpacing um width sameNetWidthThreshold um" 
	SPACING < sameNetWidthThreshold
      } (21 )
    }
  }
}
/*check basic fat spacing*/
if (fatWireThreshold > 0 && fatTblDimension == 0) {
    SIZE fat_candidate { UNDER_OVER = fatWireThreshold / 2.0 - 0.0001  } TEMP = m_fat
    BOOLEAN m_fat AND metal6  {  } TEMP = m_fat
    BOOLEAN metal6  NOT m_fat {  } TEMP = m_thin
    if (ignoreBlockage == 0) {
        /* the blockages on the metal_blockage layer are treated as thin blockages */
        BOOLEAN m_thin OR metal6_blockage  {  } TEMP = m_thin
    }
 
    if (fatFatMinSpacing > 0) {
	EXTERNAL m_fat {
	    COMMENT = "$layer_name FatWireSpc: fat & fat ( fatWireThreshold um) minimum spacing = fatFatMinSpacing um"
	    SPACING < fatFatMinSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = FALSE
	    CHECK_SAME_POLYGON = TRUE 
       } (21 )
    }
 
    if (fatThinMinSpacing > 0) {
	EXTERNAL m_fat m_thin {
	    COMMENT = "$layer_name FatWireSpc: fat & thin ( fatWireThreshold um) minimum spacing fatThinMinSpacing um"
	    SPACING < fatThinMinSpacing
 	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = FALSE
        } (21 )
    }
}
 
/*check thin blockage spacing*/
if (minSpacing > 0 && ignoreBlockage == 0) {
    if (!layer_empty (metal6_blockage )) {
	EXTERNAL metal6_blockage  metal6  {
	    COMMENT = "$layer_name Spacing   : metal & thin blockage minimum spacing = minSpacing um"
	    SPACING < minSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
            TOUCH = TRUE
        } (21 )
    }
}
/*check blockage overlap*/
/*check shorts between top_level routing and fram_blockages*/
if (minSpacing>0 || checkCrossHierShort>0) {
   if (ignoreBlockage == 0) {
      BOOLEAN metal6_blockage  or metal6_rbkg  {} TEMP=all_blockage
   } else {
      COPY metal6_rbkg  {} TEMP=all_blockage
   }
   BOOLEAN all_blockage AND metal6_top  {} TEMP = overlap_shape1
   EXTERNAL all_blockage metal6_top  {
      SPACING <= 0
      TOUCH = TRUE
   } TEMP = overlap_shape2
   if (checkCrossHierShort>0) {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
         COMMENT = "$layer_name Short Cross Hierarchy"
      } (21 )
   } else {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
         COMMENT = "$layer_name Overlap   : metal & blockage overlap"
      } (21 )
   }
}
 
if (fatPolyContactRule > 0) {
  /* Fat Poly Contact Rule: not new fat wire formed */
  if (readCellView > 0) {
     SIZE metal1 { UNDER_OVER = fatPolyContactRule / 2.0 - 0.0001  } TEMP = fat
     BOOLEAN fat AND metal1 {  } TEMP = fat 
  } else {
     SIZE metal1_top { UNDER_OVER = fatPolyContactRule / 2.0 - 0.0001  } TEMP = fat
     BOOLEAN fat AND metal1_top {  } TEMP = fat 
  }
  SIZE metal1_pin { UNDER_OVER = fatPolyContactRule / 2.0 - 0.0001  } TEMP = fat_pin
  BOOLEAN fat_pin AND metal1_pin {  } TEMP = fat_pin
  BOOLEAN fat NOT fat_pin {
    COMMENT = "$layer_name FatPolyContactRule: fatPolyContactRule um" 
  } (21 )
}
/* Special End-of-Line Spacing Rule */
if (stubMode == 0 && stubSpacing > 0 && stubSpacing < minSpacing) {
  EXTERNAL metal6  {
     COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 0)"
     LONGEDGE > stubThreshold + 0.0001 
     LONGEDGE_TO_EDGE <= 0 
     SPACING < stubSpacing 
     SET_CORNERS_TO_SPACING = FALSE
     PARALLEL_POINT_PROJECTION = FALSE
  } (21 )
} else if (stubMode > 0 && stubSpacing > minSpacing) {
  if (stubMode == 4) {
     INTERNAL metal6  {
        SEGMENT[90,90] < stubThreshold
        OUTPUT_EDGES = TRUE
     } TEMP = end_of_line
  } else {
     INTERNAL metal6  {
        SEGMENT[90,90] <= stubThreshold
        OUTPUT_EDGES = TRUE
     } TEMP = end_of_line
  }
  /* Quick filter to reduce the size of possible end of line */
  if (sideStubExt > 0) {
    SIZE end_of_line {
       VSIZE_HEAD = sideStubExt
       VSIZE_TAIL = sideStubExt
       OUTPUT_EDGES = TRUE
    } TEMP = eol_ext
  } else {
    COPY end_of_line { } TEMP=eol_ext
  }
  if (stub2StubSpacing > stubSpacing) {
     SET temporary_1 = stub2StubSpacing;
  } else {
     SET temporary_1 = stubSpacing; 
  }
  EXTERNAL eol_ext metal6  {
     SPACING < temporary_1
     TOUCH = TRUE
     OVERLAP = TRUE 
     SET_CORNERS_TO_SPACING = FALSE
     PARALLEL_POINT_PROJECTION = FALSE
     OUTPUT_EDGES = TRUE
  } TEMP=err_edge
  SELECT eol_ext INTERACT err_edge { } TEMP=eol_ext
  SELECT end_of_line INTERACT eol_ext { } TEMP=end_of_line 
  /* Reduce the size of METAL_LAYER */
  if (stubMode==3) {
     SIZE end_of_line {
        VSIZE_HEAD = stubSpacing 
        VSIZE_TAIL = stubSpacing 
        VSIZE_INSIDE = sideStubThreshold
        VSIZE_OUTSIDE = stubSpacing
     } TEMP = eol_filter 
  } else {
     if (stubMode == 1 && stubRange > 0) {
        SIZE end_of_line {
           VSIZE_HEAD = stubSpacing- 0.0001 
           VSIZE_TAIL = stubSpacing- 0.0001 
           VSIZE_OUTSIDE = stubSpacing- 0.0001 
        } TEMP = eol_filter
     } else {
        SIZE end_of_line {
           VSIZE_HEAD = stubSpacing- 0.0001 
           VSIZE_TAIL = stubSpacing- 0.0001 
           VSIZE_INSIDE = sideStubThreshold- 0.0001 
           VSIZE_OUTSIDE = stubSpacing- 0.0001 
        } TEMP = eol_filter
     }
  }
  SELECT metal6  INTERACT eol_filter { } TEMP=target_top
  /* Get the side edges and the whole eol of line set */
  SELECT_EDGE target_top INTERACT end_of_line { 
    POINT_TOUCH = TRUE
  } TEMP = eol_set
  VERTEX target_top { 
     CONCAVE = TRUE 
     CONVEX = TRUE
     SIZE = 0.0002 
  } TEMP = corners
  SELECT corners OUTSIDE end_of_line {} TEMP =corners 
  BOOLEAN eol_set NOT corners { } TEMP=eol_set
  BOOLEAN eol_set NOT end_of_line { } TEMP=side_edge
  /* find out the real end of line */
  if (stubRange > 0) {
     if (stubMode == 1) {
         COPY side_edge { } TEMP = all_side_edge
         LENGTH side_edge { SPACING <= stubRange- 0.0001  } TEMP=side_edge
     } else {
         LENGTH side_edge { SPACING < stubRange- 0.0002  } TEMP=eol_filter
         BOOLEAN side_edge NOT eol_filter { } TEMP=side_edge
     }
     SELECT end_of_line INTERACT side_edge { RANGE = [1,2] } TEMP = end_of_line
  } 
  if (stubMode == 1) {
    if (stub2StubSpacing > 0) {
       if (sideStubExt < 0) {
          SIZE end_of_line {
            VSIZE_HEAD = sideStubExt / 2
            VSIZE_TAIL = sideStubExt / 2
            OUTPUT_EDGES = TRUE
          } TEMP = eol_ext_tip
	 
          EXTERNAL eol_ext_tip {
            COMMENT = "$layer_name specEoLSpc: stub2Stubspacing= stub2StubSpacing um (mode = 1)"
            SPACING < stub2StubSpacing
            SET_CORNERS_TO_SPACING = FALSE
            PARALLEL_POINT_PROJECTION = TRUE
          } (21 )
       } else {
          EXTERNAL end_of_line {
            COMMENT = "$layer_name specEoLSpc: stub2Stubspacing= stub2StubSpacing um (mode = 1)"
            SPACING < stub2StubSpacing
            SET_CORNERS_TO_SPACING = FALSE
            PARALLEL_POINT_PROJECTION = FALSE
          } (21 )
       }
    }
    if (stubRange > 0) {
       SIZE end_of_line {
         VSIZE_INSIDE = 0.0002 
       } TEMP = eol_poly
       SELECT_EDGE eol_poly TOUCHING target_top { } TEMP=eol_edge
       EXTERNAL eol_edge target_top {
         COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
         CONVEX_TO_CONVEX < stubSpacing
         CONVEX_TO_CONVEX [POINT_PROJECTION] < stubSpacing
         CONVEX_TO_EDGE < stubSpacing
         CONCAVE_TO_CONVEX < stubSpacing
         LONGEDGE > 0.0002 
         LONGEDGE_TO_EDGE < stubSpacing
         SPACING <= 0
         SET_CORNERS_TO_SPACING = TRUE
         PARALLEL_POINT_PROJECTION = TRUE
       } (21 )
       SELECT all_side_edge INTERACT end_of_line { } TEMP = side_edge
       SIZE side_edge {
         VSIZE_HEAD = 0.0002 
         VSIZE_TAIL = 0.0002 
       } TEMP = side_edge_ext
       BOOLEAN side_edge_ext NOT side_edge { } TEMP = side_edge_ext
       SELECT side_edge_ext INTERACT end_of_line { } TEMP = side_edge_ext
       EXTERNAL side_edge_ext target_top {
         COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
         SPACING < stubSpacing
         SET_CORNERS_TO_SPACING = FALSE
         PARALLEL_POINT_PROJECTION = FALSE
       } (21 )
    } else {
       if (stub2StubSpacing > 0) {
         VECTORIZE target_top {
            DIRECTED=TRUE
         } TEMP=target_edges
         BOOLEAN target_edges NOT end_of_line { } TEMP = target_edges
         EXTERNAL end_of_line target_edges {
            COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
            SPACING < stubSpacing
            TOUCH=TRUE
            OVERLAP=TRUE
            SET_CORNERS_TO_SPACING=FALSE
            PARALLEL_POINT_PROJECTION=FALSE
         } (21 )
       } else {
         if (sideStubExt > 0) {
            SIZE end_of_line {
               VSIZE_HEAD = sideStubExt
               VSIZE_TAIL = sideStubExt
               OUTPUT_EDGES = TRUE
            } TEMP = end_of_line
            EXTERNAL end_of_line target_top {
               COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing ,crnKeepOut= sideStubExt um (mode = 1)"
               SPACING < stubSpacing
               TOUCH=TRUE
               OVERLAP=TRUE
               SET_CORNERS_TO_SPACING=FALSE
               PARALLEL_POINT_PROJECTION=FALSE
            } (21 )
         } else {
            EXTERNAL end_of_line target_top {
               COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
               SPACING < stubSpacing
               TOUCH=TRUE
               OVERLAP=TRUE
               SET_CORNERS_TO_SPACING=FALSE
               PARALLEL_POINT_PROJECTION=FALSE
            } (21 )
         }
       }
    }
  } else { /* stubMode == 2,3,4 */
    /* stubMode 2 eol classify and reduction */
    if (stubMode !=3 && sideStubExt > 0) {
      if (stubMode == 4) {
        SIZE end_of_line {
           VSIZE_HEAD = sideStubExt
           VSIZE_TAIL = sideStubExt
           OUTPUT_EDGES = TRUE
        } TEMP = eol_ext
        EXTERNAL eol_ext target_top {
           SPACING < stubSpacing
           SET_CORNERS_TO_SPACING=FALSE
           PARALLEL_POINT_PROJECTION=FALSE
           OUTPUT_EDGES = TRUE
        } TEMP=err_edge
        SELECT eol_ext INTERACT err_edge { } TEMP=eol_ext
      } else {
        EXTERNAL end_of_line target_top {
           SPACING < stubSpacing
           SET_CORNERS_TO_SPACING=FALSE
           PARALLEL_POINT_PROJECTION=FALSE
           OUTPUT_EDGES = TRUE
        } TEMP=err_edge
        SELECT end_of_line INTERACT err_edge { } TEMP=eol_body
        SIZE end_of_line {
           VSIZE_HEAD = sideStubExt
           VSIZE_TAIL = sideStubExt
           OUTPUT_EDGES = TRUE
        } TEMP = eol_ext
        BOOLEAN eol_ext NOT end_of_line {} TEMP=eol_ext
        EXTERNAL eol_ext target_top {
           SPACING < stubSpacing
           SET_CORNERS_TO_SPACING=FALSE
           PARALLEL_POINT_PROJECTION=FALSE
           OUTPUT_EDGES = TRUE
        } TEMP=err_edge
        SELECT eol_ext INTERACT err_edge { } TEMP=eol_ext
        BOOLEAN eol_body OR eol_ext { } TEMP=eol_ext
      } 
    } else {
      COPY end_of_line { } TEMP=eol_ext
    }
    SELECT side_edge INTERACT eol_ext { } TEMP=side_edge
    SIZE eol_ext {
       VSIZE_INSIDE = sideStubThreshold 
       VSIZE_OUTSIDE = sideStubExt
    } TEMP = eol_range
    if (sideStubExt > 0) {
       SIZE side_edge {
          VSIZE_HEAD = sideStubExt
          VSIZE_TAIL = sideStubExt
          OUTPUT_EDGES = TRUE
       } TEMP = check_edge
    } else {
       COPY side_edge { } TEMP = check_edge
    }
    BOOLEAN check_edge AND eol_range { } TEMP=check_edge
    EXTERNAL check_edge target_top {
       SPACING < temporary_1
       SET_CORNERS_TO_SPACING = FALSE
       SHADOW_OTHER_LAYER = TRUE
       PARALLEL_POINT_PROJECTION = FALSE
       OUTPUT_EDGES = TRUE
    } TEMP=err_edge
    if (0 && stubMode!=4) { /* Temporarily do not check mode 2,3 side edge length */
       LENGTH side_edge { SPACING < stubSpacing- 0.0001 *2 } TEMP=err_edge_1
       BOOLEAN err_edge OR err_edge_1 { } TEMP=err_edge
    }
    SELECT check_edge INTERACT err_edge { } TEMP=side_edge
    if (stubMode!=3) {
       SELECT eol_ext INTERACT side_edge {} TEMP=err_eol
       EXTERNAL err_eol target_top {
          COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing ,crnKeepOut= sideStubExt um (mode = stubMode )"
          SPACING < temporary_1
          PARALLEL_POINT_PROJECTION=FALSE
          SET_CORNERS_TO_SPACING=FALSE
       } (21 )
    } else { /* stubMode == 3 */
       SELECT eol_ext INTERACT side_edge { RANGE = [2, 2] } TEMP=err_eol
       EXTERNAL err_eol target_top {
          COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 3)"
          SPACING < temporary_1
          PARALLEL_POINT_PROJECTION=FALSE
          SET_CORNERS_TO_SPACING=FALSE
       } (21 )
    }
  }
} /* stubMode > 0, not aligned */
/* Avoid empty optimization result parsing error */
if (addEmptyMetalCheck) {
   BOOLEAN empty OR empty {
      COMMENT = "$layer_name Empty: Dummy Output"
   } (21 )
   SET addEmptyMetalCheck=0;
}
/* reset variables */


 
SET minWidth = 0;
SET maxWidth = 0;
SET minArea = 0;
SET minEnclosedArea = 0;
SET minSpacing = 0;
SET sameNetMinSpacing = 0;
SET maxNumMinEdge = 0;
SET maxTotalMinEdgeLength = 0;
SET minEdgeLength = 0;
SET minEdgeLength2 = 0;
SET minEdgeLength3 = 0;
SET stubRange = 0;
SET stubSpacing = 0;
SET stub2StubSpacing = 0;
SET sideStubExt = 0;
SET sideStubThreshold = 0;
SET stubThreshold = 0;
SET fatPolyContactRule = 0;
SET fatWireThreshold = 0;
SET fatThinMinSpacing = 0;
SET fatFatMinSpacing = 0;
SET fatTblDimension = 0;
@ 704 "adrc/adrc.ev" 2

SET minSpacing = 0.056;
SET fatTblThresh_protru = 0.15;
SET fatTblLength_protru = 0.1;
SET fatTblWidth_protru = 0.06;
@ 1 "adrc/adrc_protru.ev" 1
/*protrusion length rule*/
SIZE metal6     { UNDER_OVER = fatTblThresh_protru / 2.0 - 0.0001  } TEMP = fat
BOOLEAN fat AND metal6  {  } TEMP = fat 
BOOLEAN metal6  NOT fat {  } TEMP = fat_nbr
SIZE fat { OVERSIZE = fatTblLength_protru + 0.0001  } TEMP = fat_ext
BOOLEAN fat_nbr AND fat_ext {} TEMP = fat_nbr
SELECT fat_nbr INTERACT fat TEMP = fat_nbr
/* Get the correct fat extension */
SELECT_EDGE fat_nbr TOUCHING fat { } TEMP = ext_filter
SIZE ext_filter { VSIZE_INSIDE = 0.0001  } TEMP = ext_filter
SIZE ext_filter INSIDE fat_nbr {
   OVERSIZE = fatTblLength_protru- 0.0001 
   INCREMENT = minSpacing
} TEMP=dummy TEMP = fat_nbr
  
VERTEX fat_nbr {
   CONCAVE = TRUE
   SIZE = 0.0002 
} TEMP = corners
SELECT fat_nbr OUTSIDE corners { } TEMP = fat_nbr1
BOOLEAN fat_nbr NOT fat_nbr1 { } TEMP = fat_nbr2
SELECT_CONTAINS fat_nbr1 {
   WIDTH =  0.0002 
   HEIGHT = fatTblLength_protru
} TEMP = good_fat_nbr1
BOOLEAN fat_nbr1 NOT good_fat_nbr1 { } TEMP = fat_nbr1
/* check with L or T shape of fat extension */
SELECT_EDGE fat_nbr2 INTERACT corners { } TEMP = side_edge
LENGTH side_edge { SPACING < fatTblLength_protru } TEMP = vio_edge
SELECT fat_nbr2 INTERACT vio_edge { } TEMP = fat_nbr2
BOOLEAN fat_nbr1 OR fat_nbr2 { } TEMP = fat_nbr
INTERAL fat_nbr {
   SPACING < fatTblWidth_protru
} TEMP = possible_err
if (!layer_empty(possible_err)) {
   SELECT fat_nbr INTERACT possible_err { } TEMP=fat_nbr
   SELECT fat INTERACT fat_nbr {} TEMP=fat
   BOOLEAN fat OR fat_nbr {} TEMP=fat
   INTERNAL fat {
      COMMENT = "$layer_name ProtrusionLength : threshold fatTblThresh_protru um, length  fatTblLength_protru um, width fatTblWidth_protru um"
      SPACING < fatTblWidth_protru
   } (21 )
}
/* protrusion leng rule check */
SET fatTblThresh_protru = 0;
SET fatTblLength_protru = 0;
SET fatTblWidth_protru = 0;
SET minSpacing = 0;
@ 709 "adrc/adrc.ev" 2


SET minSpacing = 0.056;
SET fatTblThresh_protru = 0.3;
SET fatTblLength_protru = 0.15;
SET fatTblWidth_protru = 0.07;
@ 1 "adrc/adrc_protru.ev" 1
/*protrusion length rule*/
SIZE metal6     { UNDER_OVER = fatTblThresh_protru / 2.0 - 0.0001  } TEMP = fat
BOOLEAN fat AND metal6  {  } TEMP = fat 
BOOLEAN metal6  NOT fat {  } TEMP = fat_nbr
SIZE fat { OVERSIZE = fatTblLength_protru + 0.0001  } TEMP = fat_ext
BOOLEAN fat_nbr AND fat_ext {} TEMP = fat_nbr
SELECT fat_nbr INTERACT fat TEMP = fat_nbr
/* Get the correct fat extension */
SELECT_EDGE fat_nbr TOUCHING fat { } TEMP = ext_filter
SIZE ext_filter { VSIZE_INSIDE = 0.0001  } TEMP = ext_filter
SIZE ext_filter INSIDE fat_nbr {
   OVERSIZE = fatTblLength_protru- 0.0001 
   INCREMENT = minSpacing
} TEMP=dummy TEMP = fat_nbr
  
VERTEX fat_nbr {
   CONCAVE = TRUE
   SIZE = 0.0002 
} TEMP = corners
SELECT fat_nbr OUTSIDE corners { } TEMP = fat_nbr1
BOOLEAN fat_nbr NOT fat_nbr1 { } TEMP = fat_nbr2
SELECT_CONTAINS fat_nbr1 {
   WIDTH =  0.0002 
   HEIGHT = fatTblLength_protru
} TEMP = good_fat_nbr1
BOOLEAN fat_nbr1 NOT good_fat_nbr1 { } TEMP = fat_nbr1
/* check with L or T shape of fat extension */
SELECT_EDGE fat_nbr2 INTERACT corners { } TEMP = side_edge
LENGTH side_edge { SPACING < fatTblLength_protru } TEMP = vio_edge
SELECT fat_nbr2 INTERACT vio_edge { } TEMP = fat_nbr2
BOOLEAN fat_nbr1 OR fat_nbr2 { } TEMP = fat_nbr
INTERAL fat_nbr {
   SPACING < fatTblWidth_protru
} TEMP = possible_err
if (!layer_empty(possible_err)) {
   SELECT fat_nbr INTERACT possible_err { } TEMP=fat_nbr
   SELECT fat INTERACT fat_nbr {} TEMP=fat
   BOOLEAN fat OR fat_nbr {} TEMP=fat
   INTERNAL fat {
      COMMENT = "$layer_name ProtrusionLength : threshold fatTblThresh_protru um, length  fatTblLength_protru um, width fatTblWidth_protru um"
      SPACING < fatTblWidth_protru
   } (21 )
}
/* protrusion leng rule check */
SET fatTblThresh_protru = 0;
SET fatTblLength_protru = 0;
SET fatTblWidth_protru = 0;
SET minSpacing = 0;
@ 715 "adrc/adrc.ev" 2


SET minSpacing = 0.056;
SET fatTblThresh_protru = 1.5;
SET fatTblLength_protru = 0.7;
SET fatTblWidth_protru = 0.15;
@ 1 "adrc/adrc_protru.ev" 1
/*protrusion length rule*/
SIZE metal6     { UNDER_OVER = fatTblThresh_protru / 2.0 - 0.0001  } TEMP = fat
BOOLEAN fat AND metal6  {  } TEMP = fat 
BOOLEAN metal6  NOT fat {  } TEMP = fat_nbr
SIZE fat { OVERSIZE = fatTblLength_protru + 0.0001  } TEMP = fat_ext
BOOLEAN fat_nbr AND fat_ext {} TEMP = fat_nbr
SELECT fat_nbr INTERACT fat TEMP = fat_nbr
/* Get the correct fat extension */
SELECT_EDGE fat_nbr TOUCHING fat { } TEMP = ext_filter
SIZE ext_filter { VSIZE_INSIDE = 0.0001  } TEMP = ext_filter
SIZE ext_filter INSIDE fat_nbr {
   OVERSIZE = fatTblLength_protru- 0.0001 
   INCREMENT = minSpacing
} TEMP=dummy TEMP = fat_nbr
  
VERTEX fat_nbr {
   CONCAVE = TRUE
   SIZE = 0.0002 
} TEMP = corners
SELECT fat_nbr OUTSIDE corners { } TEMP = fat_nbr1
BOOLEAN fat_nbr NOT fat_nbr1 { } TEMP = fat_nbr2
SELECT_CONTAINS fat_nbr1 {
   WIDTH =  0.0002 
   HEIGHT = fatTblLength_protru
} TEMP = good_fat_nbr1
BOOLEAN fat_nbr1 NOT good_fat_nbr1 { } TEMP = fat_nbr1
/* check with L or T shape of fat extension */
SELECT_EDGE fat_nbr2 INTERACT corners { } TEMP = side_edge
LENGTH side_edge { SPACING < fatTblLength_protru } TEMP = vio_edge
SELECT fat_nbr2 INTERACT vio_edge { } TEMP = fat_nbr2
BOOLEAN fat_nbr1 OR fat_nbr2 { } TEMP = fat_nbr
INTERAL fat_nbr {
   SPACING < fatTblWidth_protru
} TEMP = possible_err
if (!layer_empty(possible_err)) {
   SELECT fat_nbr INTERACT possible_err { } TEMP=fat_nbr
   SELECT fat INTERACT fat_nbr {} TEMP=fat
   BOOLEAN fat OR fat_nbr {} TEMP=fat
   INTERNAL fat {
      COMMENT = "$layer_name ProtrusionLength : threshold fatTblThresh_protru um, length  fatTblLength_protru um, width fatTblWidth_protru um"
      SPACING < fatTblWidth_protru
   } (21 )
}
/* protrusion leng rule check */
SET fatTblThresh_protru = 0;
SET fatTblLength_protru = 0;
SET fatTblWidth_protru = 0;
SET minSpacing = 0;
@ 721 "adrc/adrc.ev" 2


SET minSpacing = 0.056;
SET fatTblThresh_protru = 3;
SET fatTblLength_protru = 1.5;
SET fatTblWidth_protru = 0.3;
@ 1 "adrc/adrc_protru.ev" 1
/*protrusion length rule*/
SIZE metal6     { UNDER_OVER = fatTblThresh_protru / 2.0 - 0.0001  } TEMP = fat
BOOLEAN fat AND metal6  {  } TEMP = fat 
BOOLEAN metal6  NOT fat {  } TEMP = fat_nbr
SIZE fat { OVERSIZE = fatTblLength_protru + 0.0001  } TEMP = fat_ext
BOOLEAN fat_nbr AND fat_ext {} TEMP = fat_nbr
SELECT fat_nbr INTERACT fat TEMP = fat_nbr
/* Get the correct fat extension */
SELECT_EDGE fat_nbr TOUCHING fat { } TEMP = ext_filter
SIZE ext_filter { VSIZE_INSIDE = 0.0001  } TEMP = ext_filter
SIZE ext_filter INSIDE fat_nbr {
   OVERSIZE = fatTblLength_protru- 0.0001 
   INCREMENT = minSpacing
} TEMP=dummy TEMP = fat_nbr
  
VERTEX fat_nbr {
   CONCAVE = TRUE
   SIZE = 0.0002 
} TEMP = corners
SELECT fat_nbr OUTSIDE corners { } TEMP = fat_nbr1
BOOLEAN fat_nbr NOT fat_nbr1 { } TEMP = fat_nbr2
SELECT_CONTAINS fat_nbr1 {
   WIDTH =  0.0002 
   HEIGHT = fatTblLength_protru
} TEMP = good_fat_nbr1
BOOLEAN fat_nbr1 NOT good_fat_nbr1 { } TEMP = fat_nbr1
/* check with L or T shape of fat extension */
SELECT_EDGE fat_nbr2 INTERACT corners { } TEMP = side_edge
LENGTH side_edge { SPACING < fatTblLength_protru } TEMP = vio_edge
SELECT fat_nbr2 INTERACT vio_edge { } TEMP = fat_nbr2
BOOLEAN fat_nbr1 OR fat_nbr2 { } TEMP = fat_nbr
INTERAL fat_nbr {
   SPACING < fatTblWidth_protru
} TEMP = possible_err
if (!layer_empty(possible_err)) {
   SELECT fat_nbr INTERACT possible_err { } TEMP=fat_nbr
   SELECT fat INTERACT fat_nbr {} TEMP=fat
   BOOLEAN fat OR fat_nbr {} TEMP=fat
   INTERNAL fat {
      COMMENT = "$layer_name ProtrusionLength : threshold fatTblThresh_protru um, length  fatTblLength_protru um, width fatTblWidth_protru um"
      SPACING < fatTblWidth_protru
   } (21 )
}
/* protrusion leng rule check */
SET fatTblThresh_protru = 0;
SET fatTblLength_protru = 0;
SET fatTblWidth_protru = 0;
SET minSpacing = 0;
@ 727 "adrc/adrc.ev" 2





/* Start of Met6 fat table spacing rules */
SET fatTblSpacingMode = 0;
SET parallelLengthMode = 0;
SET router_parallelLengthNetMode = 0;

SET fatTblThreshold = 0.155;
SET fatTblParallelLength = 0.155;
SET minWidth = 0.056;

SET fatTblThreshold_Start = 0;
SET fatTblSpacing = 0.064;
@ 1 "adrc/adrc_fatMetal.ev" 1
/*check fat metal table*/
if (fatTblThreshold > 0) {
    if ((fatTblThreshold / 2.0) > 0.0001 ) {
       SIZE fat_candidate  { UNDER_OVER = fatTblThreshold / 2.0 - 0.0001  } TEMP = fat_candidate
       if (fatTblNextThreshold > 0) {
          SIZE fat_candidate { UNDER_OVER = fatTblNextThreshold / 2.0 - 0.0001  } TEMP = fat_next
          BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
          BOOLEAN fat AND fat_target { } TEMP = fat
          SET fatTblNextThreshold = 0;
       } else {
          BOOLEAN fat_candidate AND fat_target {  } TEMP = fat 
       }
    } else {
      COPY fat_target {  } TEMP = fat 
    }
    COPY fat_target { } TEMP = spc_target
    if (fatTblThreshold_Start > 0  || fatTblThreshold_End > 0) {
       if (fatTblThreshold_Start > 0) {
          SIZE fat_target { UNDER_OVER = fatTblThreshold_Start / 2.0 - 0.0001  } TEMP = spc_target
       }
       if (fatTblThreshold_End > 0 && fatTblThreshold_End > fatTblThreshold_Start) {
          SIZE spc_target { UNDER_OVER = fatTblThreshold_End / 2.0 - 0.0001  } TEMP = fat_end
          BOOLEAN spc_target NOT fat_end { } TEMP = spc_target
       }
       BOOLEAN spc_target AND fat_target {  } TEMP = spc_target
       if (ignoreBlockage == 0 && fatTblThreshold_Start < fatTblThreshold_1) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal6_blockage  {  } TEMP = spc_target
       }
       SET fatTblThreshold_Start = 0;
       SET fatTblThreshold_End = 0;
       SET fatTblThreshold_1 = 0;
    } else {
       if (ignoreBlockage == 0) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal6_blockage  {  } TEMP = spc_target
       }
    }
 
    if (fatTblEnclosedArea > 0) {
       SELECT holes INTERACT fat { } TEMP = fat_holes
       AREA fat_holes { 
          RANGE = [0.0001 * 0.0001 , fatTblEnclosedArea - 0.0001 * 0.0001 ]
       } TEMP = fat_holes
       if (fatTblMinEnclosedAreaMode==0) {
          SIZE fat_holes { OVER_UNDER = fatTblThreshold / 2.0 + 0.0001  } TEMP = ovun_holes
          SELECT ovun_holes INTERACT fat_holes { RANGE = [2, 9999999999 ] } TEMP = merged_holes
          BOOLEAN fat_candidate AND fat_target { } TEMP = fat_metal
          BOOLEAN metal6  NOT fat_metal { } TEMP = thin_metal
          BOOLEAN thin_metal NOT ovun_holes { } TEMP = thin_metal
          SELECT ovun_holes INTERACT thin_metal { } TEMP = thin_holes
          BOOLEAN thin_holes OR merged_holes { } TEMP = thin_holes
          BOOLEAN fat_holes NOT thin_holes { } TEMP = fat_holes
       }
       COPY fat_holes { 
	  COMMENT = "$layer_name EnclsArea : fat metal ( fatTblThreshold um) minimum enclosed area (mode fatTblMinEnclosedAreaMode ) = fatTblEnclosedArea um*um"
       } (21 )
       SET fatTblEnclosedArea = 0;
    }
    if (fatTblSpacing > 0) {
       /*check fat metal*/ 
       if (fatTblParallelLength > 0) {
          if (router_parallelLengthNetMode == 1 || parallelLengthMode == 1) {
             AREA spc_target { RANGE = [fatTblParallelLength * minWidth + 0.0001 , 9999999999 ] } TEMP = spc_target1
             COPY spc_target1 { } TEMP = spc_target2
          } else {
             COPY spc_target { } TEMP = spc_target2
          }
          if (parallelLengthMode == 1) {
             SELECT metal6  INTERACT fat { } TEMP = fat_all 
             BOOLEAN fat_all OR fat { } TEMP = fat2
             SELECT metal6  INTERACT spc_target2 { } TEMP = spc_target_all
             BOOLEAN spc_target_all OR spc_target2 { } TEMP = spc_target2
          } else {
             COPY fat { } TEMP = fat2
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING <= fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
                OUTPUT_EDGES = TRUE
             } TEMP = vio_edge
             SELECT vio_edge INTERACT fat { } TEMP = vio_edge
             SELECT vio_edge INTERACT spc_target1 { } TEMP = vio_edge
             SELECT violation INTERACT vio_edge { } TEMP = violation
          } else {
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
          }
          BOOLEAN violation NOT fat_target { } TEMP = violation
          if (fatTblParallelLength < fatTblSpacing) {
             SELECT_EDGE violation TOUCHING fat2 {
                VSIZE_INSIDE = fatTblParallelLength - 0.0002 
             } TEMP = vio_filter
             SELECT_CONTAINS vio_filter { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = vio_filter
             SELECT violation INTERACT vio_filter { } TEMP = violation
          } else {
             SELECT_CONTAINS violation { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = violation
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING = [fatTblSpacing, fatTblSpacing]
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
             } TEMP = violation3
             BOOLEAN violation3 NOT fat_target { } TEMP = violation3
             BOOLEAN violation NOT violation3 { } TEMP= violation
          }
          SELECT_EDGE fat2 TOUCHING violation { } TEMP=fat_viol
          BOOLEAN fat_viol AND violation { } TEMP=fat_viol
          SELECT_EDGE spc_target2 TOUCHING violation { } TEMP=spc_target2
          BOOLEAN spc_target2 AND violation { } TEMP= spc_target2
	  if (ignoreChildCell == 1) {
             EXTERNAL fat_viol spc_target2 {
		SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		TOUCH = FALSE
		POINT_TOUCH = FALSE
		NON_PARALLEL = TRUE
	     } TEMP = spc_mode0_out
             BOOLEAN spc_mode0_out NOT spc_mode0_child_out { } TEMP = spc_mode0_diff_out
             SELECT spc_mode0_out INTERACT spc_mode0_diff_out { } TEMP = spc_mode0_out
	     SELECT_EDGE fat2 TOUCHING spc_mode0_out { } TEMP=fat_viol
	     BOOLEAN fat_viol AND spc_mode0_out { } TEMP=fat_viol
	     SELECT_EDGE spc_target2 TOUCHING spc_mode0_out { } TEMP=spc_target2
	     BOOLEAN spc_target2 AND spc_mode0_out { } TEMP=spc_target2
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (21 )  		
	  } else {
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing 
	        SET_CORNERS_TO_SPACING = FALSE
	        PARALLEL_POINT_PROJECTION = FALSE
	        TOUCH = FALSE
	        POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (21 )
	  }
	  if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	     if (ignoreChildCell == 1) {
		EXTERNAL fat spc_target {
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} TEMP = spc_mode1_out
	        BOOLEAN spc_mode1_out NOT spc_mode1_child_out { } TEMP = spc_mode1_diff_out
	        SELECT spc_mode1_out INTERACT spc_mode1_diff_out { } TEMP = spc_mode1_out
                SELECT_EDGE fat TOUCHING spc_mode1_out { } TEMP=fat_viol
	        BOOLEAN fat_viol AND spc_mode1_out { } TEMP=fat_viol
	        SELECT_EDGE spc_target TOUCHING spc_mode1_out { } TEMP=spc_target2
	        BOOLEAN spc_target2 AND spc_mode1_out { } TEMP=spc_target2
	        EXTERNAL fat_viol spc_target2 {
	           COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um " 	    
		   SPACING < fatTblSpacing_dg
                   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} (21 )
	     } else {
	        EXTERNAL fat spc_target {
		   COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um "
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
	    	   PARALLEL_POINT_PROJECTION = FALSE
	           TOUCH = FALSE
	     	   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } (21 ) 
	     }
          }
       } else {
	  if (ignoreChildCell == 1) {
              EXTERNAL fat spc_target {
                 SPACING < fatTblSpacing
                 BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
              } TEMP = spc_out
	      BOOLEAN spc_out NOT spc_child_out { } TEMP = spc_diff_out
	      SELECT spc_out INTERACT spc_diff_out { } TEMP = spc_out
	      SELECT_EDGE fat TOUCHING spc_out { } TEMP=fat_viol
	      BOOLEAN fat_viol AND spc_out { } TEMP=fat_viol
              SELECT_EDGE spc_target TOUCHING spc_out { } TEMP=spc_target2
	      BOOLEAN spc_target2 AND spc_out { } TEMP=spc_target2
	      EXTERNAL fat_viol spc_target2 {
		 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
		 BOX_CORNER = FALSE 
		 NON_PARALLEL = TRUE
		 POINT_TOUCH = FALSE
	      } (21 ) 
	  } else {
	      EXTERNAL fat spc_target {
                 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
	         BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
	      } (21 ) 
	  }
       }
       /*check metal in the extension range*/ 
       if (fatTblExtensionRange > 0) {
	  if (fatWireExtensionMode == 0) {
	     SIZE fat { OVERSIZE = fatTblExtensionRange } TEMP = fat_tmp
             BOOLEAN fat_tmp AND metal6  { } TEMP = fat_tmp
  	     BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
             SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_ext
             BOOLEAN fat_ext OR fat { } TEMP = fat_ext
	     if (fatTblParallelLength > 0) {
                if (fatTblParallelLength > fatTblExtensionRange) {
                   SIZE fat { OVERSIZE = fatTblParallelLength } TEMP = fat_tmp
                   BOOLEAN fat_tmp AND metal6  { } TEMP = fat_tmp
  	           BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
                   SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_parallel
                   BOOLEAN fat_parallel OR fat { } TEMP = fat_parallel
                } else {
                   COPY fat_ext { } TEMP = fat_parallel
                }
		EXTERNAL fat_parallel spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
	           NON_PARALLEL = TRUE
	        } TEMP = vio_filter_set
		EXTERNAL fat_ext spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } TEMP = vio_set
                if (fatTblParallelLength < fatTblSpacing) {
                   SELECT_EDGE vio_filter_set TOUCHING fat_parallel {
                      VSIZE_INSIDE = fatTblParallelLength - 0.0002 
                   } TEMP = vio_filter_set_filter
                   SELECT_CONTAINS vio_filter_set_filter { 
                      WIDTH =  0.0002 
                      HEIGHT = fatTblParallelLength + 0.0001 
                   } TEMP = vio_filter_set_filter
                   SELECT vio_filter_set INTERACT vio_filter_set_filter { } TEMP = vio_filter
                } else {
	           SELECT_CONTAINS vio_filter_set { 
	              WIDTH =  0.0002 
	              HEIGHT = fatTblParallelLength + 0.0001 
	           } TEMP = vio_filter
                }
                SELECT vio_set INSIDE vio_filter { } TEMP = mode0_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out1 NOT mode0_child_out1 { } TEMP = mode0_diff_out1
                   SELECT mode0_out1 INTERACT mode0_diff_out1 { } TEMP = mode0_out1
                }
                COPY mode0_out1 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing  = fatTblSpacing um"
                } (21 )
		if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	           EXTERNAL fat_ext spc_target {
		      SPACING < fatTblSpacing_dg
	              SET_CORNERS_TO_SPACING = FALSE
		      PARALLEL_POINT_PROJECTION = FALSE
		      TOUCH = TRUE
		      POINT_TOUCH = FALSE
		      NON_PARALLEL = TRUE
	           } TEMP = mode0_out2
                   if (ignoreChildCell == 1) {
                      BOOLEAN mode0_out2 NOT mode0_child_out2 { } TEMP = mode0_diff_out2
                      SELECT mode0_out2 INTERACT mode0_diff_out2 { } TEMP = mode0_out2
                   }
                   COPY mode0_out2 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing (mode 1/2) = fatTblSpacing um/ fatTblSpacing_dg um "
                   } (21 )
	        } 
	     } else {
	        EXTERNAL fat_ext spc_target {
		   SPACING < fatTblSpacing
		   NON_PARALLEL = TRUE
		   SET_CORNERS_TO_SPACING = FALSE
		   POINT_TOUCH = FALSE
		} TEMP = mode0_out3
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out3 NOT mode0_child_out3 { } TEMP = mode0_diff_out3
                   SELECT mode0_out3 INTERACT mode0_diff_out3 { } TEMP = mode0_out3
                }
                COPY mode0_out3 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range ( fatTblExtensionRange um) minimum spacing = fatTblSpacing um"
                } (21 )
	     }
	  } else if (fatWireExtensionMode == 1) {
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal6  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             if (fatTblParallelLength > 0) {
                EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
		   BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   CHECK_SAME_POLYGON = TRUE 
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
	        SELECT fat_ext INTERACT spacing {  } TEMP = fat_ext
		BOOLEAN fat_ext OR spacing {  } TEMP = combined_fat_ext
                EXTERNAL combined_fat_ext fat {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
                } TEMP = fat_spacing
		BOOLEAN fat_spacing AND fat_ran {  } TEMP = fat_spacing
		BOOLEAN combined_fat_ext OR fat_spacing {  } TEMP = combined_fat_ext
                SELECT_CONTAINS combined_fat_ext { 
                   WIDTH =  0.0002 
                   HEIGHT = fatTblParallelLength + 0.0001 
                } TEMP = combined_fat_ext
		SELECT spacing INTERACT combined_fat_ext { 
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out1 NOT mode1_child_out1 { } TEMP = mode1_diff_out1
                   SELECT mode1_out1 INTERACT mode1_diff_out1 { } TEMP = mode1_out1 
                }
                COPY mode1_out1 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (21 ) 
	     } else {
               	EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
	           BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
	           CHECK_SAME_POLYGON = TRUE 
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
                SELECT spacing INTERACT fat_ext {
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out2
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out2 NOT mode1_child_out2 { } TEMP = mode1_diff_out2
                   SELECT mode1_out2 INTERACT mode1_diff_out2 { } TEMP = mode1_out2
                }
                COPY mode1_out2 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (21 )
	     }
	  } else if (fatWireExtensionMode == 2) {
	     SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
             BOOLEAN fat_ran AND metal6  {  } TEMP = fat_ext
             BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	      	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
             } TEMP = spacing
 	     SELECT spacing INSIDE fat_ran {  } TEMP = spacing
	     SELECT spacing OUTSIDE fat {  } TEMP = spacing
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode2_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode2_out NOT mode2_child_out { } TEMP = mode2_diff_out
                SELECT mode2_out INTERACT mode2_diff_out { } TEMP = mode2_out 
             }
             COPY mode2_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 2, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (21 )
	  } else if (fatWireExtensionMode == 3) {
             SIZE fat {
	        GROW_LEFT = fatTblExtensionRange
	        GROW_RIGHT = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal6  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	       	PARALLEL = TRUE

	       	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		HORIZONTAL_ONLY = TRUE
             } TEMP = spacing_hor
	     SELECT spacing_hor INSIDE fat_ran {  } TEMP = spacing_hor
	     SELECT spacing_hor OUTSIDE fat {  } TEMP = spacing_hor
             SIZE fat {
	        GROW_TOP = fatTblExtensionRange
	        GROW_BOTTOM = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal6  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	        POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		VERTICAL_ONLY = TRUE
             } TEMP = spacing_ver
	     SELECT spacing_ver INSIDE fat_ran {  } TEMP = spacing_ver
	     SELECT spacing_ver OUTSIDE fat {  } TEMP = spacing_ver
  	     BOOLEAN spacing_hor OR spacing_ver {  } TEMP = spacing
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal6  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
  	     /* check overlapped projection length */
 	     if (fatTblParallelLength > 0) {
                POLYGON_FEATURES fat_ext {
                   EQUATIONS {
                      vnum = EV_VNUM_IN;
                      if ( vnum > 0) {
                         bdLeft = EV_VXCOORD_IN[0];
                         bdRight = EV_VXCOORD_IN[0];
                         bdBottom = EV_VYCOORD_IN[0];
                         bdTop = EV_VYCOORD_IN[0];
                         FOR (i = 1; i < vnum; i++) {
                            if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
                            else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
                            if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
                            else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
                         } /* FOR i */
                         if ( (bdRight - bdLeft) >= fatTblParallelLength ||
                  	      (bdTop - bdBottom) >= fatTblParallelLength) {
                            FOR (i = 0; i < vnum; i++) {
                               EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
                               EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
                            }
                            EV_VNUM_OUT = vnum;
                 	    EV_SAVE_POLYGON();
                         }
                      }
                   }
                } TEMP = fat_ext /* POLYGON_FEATURE */
             }
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode3_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode3_out NOT mode3_child_out { } TEMP = mode3_diff_out
                SELECT mode3_out INTERACT mode3_diff_out { } TEMP = mode3_out
             }
             COPY mode3_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 3, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (21 )
          }
       }
       SET fatTblSpacing = 0;
    }
}
@ 743 "adrc/adrc.ev" 2


SET fatTblThreshold = 0.305;
SET fatTblParallelLength = 0.305;
SET minWidth = 0.056;

SET fatTblThreshold_Start = 0;
SET fatTblSpacing = 0.12;
@ 1 "adrc/adrc_fatMetal.ev" 1
/*check fat metal table*/
if (fatTblThreshold > 0) {
    if ((fatTblThreshold / 2.0) > 0.0001 ) {
       SIZE fat_candidate  { UNDER_OVER = fatTblThreshold / 2.0 - 0.0001  } TEMP = fat_candidate
       if (fatTblNextThreshold > 0) {
          SIZE fat_candidate { UNDER_OVER = fatTblNextThreshold / 2.0 - 0.0001  } TEMP = fat_next
          BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
          BOOLEAN fat AND fat_target { } TEMP = fat
          SET fatTblNextThreshold = 0;
       } else {
          BOOLEAN fat_candidate AND fat_target {  } TEMP = fat 
       }
    } else {
      COPY fat_target {  } TEMP = fat 
    }
    COPY fat_target { } TEMP = spc_target
    if (fatTblThreshold_Start > 0  || fatTblThreshold_End > 0) {
       if (fatTblThreshold_Start > 0) {
          SIZE fat_target { UNDER_OVER = fatTblThreshold_Start / 2.0 - 0.0001  } TEMP = spc_target
       }
       if (fatTblThreshold_End > 0 && fatTblThreshold_End > fatTblThreshold_Start) {
          SIZE spc_target { UNDER_OVER = fatTblThreshold_End / 2.0 - 0.0001  } TEMP = fat_end
          BOOLEAN spc_target NOT fat_end { } TEMP = spc_target
       }
       BOOLEAN spc_target AND fat_target {  } TEMP = spc_target
       if (ignoreBlockage == 0 && fatTblThreshold_Start < fatTblThreshold_1) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal6_blockage  {  } TEMP = spc_target
       }
       SET fatTblThreshold_Start = 0;
       SET fatTblThreshold_End = 0;
       SET fatTblThreshold_1 = 0;
    } else {
       if (ignoreBlockage == 0) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal6_blockage  {  } TEMP = spc_target
       }
    }
 
    if (fatTblEnclosedArea > 0) {
       SELECT holes INTERACT fat { } TEMP = fat_holes
       AREA fat_holes { 
          RANGE = [0.0001 * 0.0001 , fatTblEnclosedArea - 0.0001 * 0.0001 ]
       } TEMP = fat_holes
       if (fatTblMinEnclosedAreaMode==0) {
          SIZE fat_holes { OVER_UNDER = fatTblThreshold / 2.0 + 0.0001  } TEMP = ovun_holes
          SELECT ovun_holes INTERACT fat_holes { RANGE = [2, 9999999999 ] } TEMP = merged_holes
          BOOLEAN fat_candidate AND fat_target { } TEMP = fat_metal
          BOOLEAN metal6  NOT fat_metal { } TEMP = thin_metal
          BOOLEAN thin_metal NOT ovun_holes { } TEMP = thin_metal
          SELECT ovun_holes INTERACT thin_metal { } TEMP = thin_holes
          BOOLEAN thin_holes OR merged_holes { } TEMP = thin_holes
          BOOLEAN fat_holes NOT thin_holes { } TEMP = fat_holes
       }
       COPY fat_holes { 
	  COMMENT = "$layer_name EnclsArea : fat metal ( fatTblThreshold um) minimum enclosed area (mode fatTblMinEnclosedAreaMode ) = fatTblEnclosedArea um*um"
       } (21 )
       SET fatTblEnclosedArea = 0;
    }
    if (fatTblSpacing > 0) {
       /*check fat metal*/ 
       if (fatTblParallelLength > 0) {
          if (router_parallelLengthNetMode == 1 || parallelLengthMode == 1) {
             AREA spc_target { RANGE = [fatTblParallelLength * minWidth + 0.0001 , 9999999999 ] } TEMP = spc_target1
             COPY spc_target1 { } TEMP = spc_target2
          } else {
             COPY spc_target { } TEMP = spc_target2
          }
          if (parallelLengthMode == 1) {
             SELECT metal6  INTERACT fat { } TEMP = fat_all 
             BOOLEAN fat_all OR fat { } TEMP = fat2
             SELECT metal6  INTERACT spc_target2 { } TEMP = spc_target_all
             BOOLEAN spc_target_all OR spc_target2 { } TEMP = spc_target2
          } else {
             COPY fat { } TEMP = fat2
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING <= fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
                OUTPUT_EDGES = TRUE
             } TEMP = vio_edge
             SELECT vio_edge INTERACT fat { } TEMP = vio_edge
             SELECT vio_edge INTERACT spc_target1 { } TEMP = vio_edge
             SELECT violation INTERACT vio_edge { } TEMP = violation
          } else {
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
          }
          BOOLEAN violation NOT fat_target { } TEMP = violation
          if (fatTblParallelLength < fatTblSpacing) {
             SELECT_EDGE violation TOUCHING fat2 {
                VSIZE_INSIDE = fatTblParallelLength - 0.0002 
             } TEMP = vio_filter
             SELECT_CONTAINS vio_filter { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = vio_filter
             SELECT violation INTERACT vio_filter { } TEMP = violation
          } else {
             SELECT_CONTAINS violation { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = violation
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING = [fatTblSpacing, fatTblSpacing]
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
             } TEMP = violation3
             BOOLEAN violation3 NOT fat_target { } TEMP = violation3
             BOOLEAN violation NOT violation3 { } TEMP= violation
          }
          SELECT_EDGE fat2 TOUCHING violation { } TEMP=fat_viol
          BOOLEAN fat_viol AND violation { } TEMP=fat_viol
          SELECT_EDGE spc_target2 TOUCHING violation { } TEMP=spc_target2
          BOOLEAN spc_target2 AND violation { } TEMP= spc_target2
	  if (ignoreChildCell == 1) {
             EXTERNAL fat_viol spc_target2 {
		SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		TOUCH = FALSE
		POINT_TOUCH = FALSE
		NON_PARALLEL = TRUE
	     } TEMP = spc_mode0_out
             BOOLEAN spc_mode0_out NOT spc_mode0_child_out { } TEMP = spc_mode0_diff_out
             SELECT spc_mode0_out INTERACT spc_mode0_diff_out { } TEMP = spc_mode0_out
	     SELECT_EDGE fat2 TOUCHING spc_mode0_out { } TEMP=fat_viol
	     BOOLEAN fat_viol AND spc_mode0_out { } TEMP=fat_viol
	     SELECT_EDGE spc_target2 TOUCHING spc_mode0_out { } TEMP=spc_target2
	     BOOLEAN spc_target2 AND spc_mode0_out { } TEMP=spc_target2
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (21 )  		
	  } else {
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing 
	        SET_CORNERS_TO_SPACING = FALSE
	        PARALLEL_POINT_PROJECTION = FALSE
	        TOUCH = FALSE
	        POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (21 )
	  }
	  if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	     if (ignoreChildCell == 1) {
		EXTERNAL fat spc_target {
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} TEMP = spc_mode1_out
	        BOOLEAN spc_mode1_out NOT spc_mode1_child_out { } TEMP = spc_mode1_diff_out
	        SELECT spc_mode1_out INTERACT spc_mode1_diff_out { } TEMP = spc_mode1_out
                SELECT_EDGE fat TOUCHING spc_mode1_out { } TEMP=fat_viol
	        BOOLEAN fat_viol AND spc_mode1_out { } TEMP=fat_viol
	        SELECT_EDGE spc_target TOUCHING spc_mode1_out { } TEMP=spc_target2
	        BOOLEAN spc_target2 AND spc_mode1_out { } TEMP=spc_target2
	        EXTERNAL fat_viol spc_target2 {
	           COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um " 	    
		   SPACING < fatTblSpacing_dg
                   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} (21 )
	     } else {
	        EXTERNAL fat spc_target {
		   COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um "
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
	    	   PARALLEL_POINT_PROJECTION = FALSE
	           TOUCH = FALSE
	     	   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } (21 ) 
	     }
          }
       } else {
	  if (ignoreChildCell == 1) {
              EXTERNAL fat spc_target {
                 SPACING < fatTblSpacing
                 BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
              } TEMP = spc_out
	      BOOLEAN spc_out NOT spc_child_out { } TEMP = spc_diff_out
	      SELECT spc_out INTERACT spc_diff_out { } TEMP = spc_out
	      SELECT_EDGE fat TOUCHING spc_out { } TEMP=fat_viol
	      BOOLEAN fat_viol AND spc_out { } TEMP=fat_viol
              SELECT_EDGE spc_target TOUCHING spc_out { } TEMP=spc_target2
	      BOOLEAN spc_target2 AND spc_out { } TEMP=spc_target2
	      EXTERNAL fat_viol spc_target2 {
		 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
		 BOX_CORNER = FALSE 
		 NON_PARALLEL = TRUE
		 POINT_TOUCH = FALSE
	      } (21 ) 
	  } else {
	      EXTERNAL fat spc_target {
                 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
	         BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
	      } (21 ) 
	  }
       }
       /*check metal in the extension range*/ 
       if (fatTblExtensionRange > 0) {
	  if (fatWireExtensionMode == 0) {
	     SIZE fat { OVERSIZE = fatTblExtensionRange } TEMP = fat_tmp
             BOOLEAN fat_tmp AND metal6  { } TEMP = fat_tmp
  	     BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
             SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_ext
             BOOLEAN fat_ext OR fat { } TEMP = fat_ext
	     if (fatTblParallelLength > 0) {
                if (fatTblParallelLength > fatTblExtensionRange) {
                   SIZE fat { OVERSIZE = fatTblParallelLength } TEMP = fat_tmp
                   BOOLEAN fat_tmp AND metal6  { } TEMP = fat_tmp
  	           BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
                   SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_parallel
                   BOOLEAN fat_parallel OR fat { } TEMP = fat_parallel
                } else {
                   COPY fat_ext { } TEMP = fat_parallel
                }
		EXTERNAL fat_parallel spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
	           NON_PARALLEL = TRUE
	        } TEMP = vio_filter_set
		EXTERNAL fat_ext spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } TEMP = vio_set
                if (fatTblParallelLength < fatTblSpacing) {
                   SELECT_EDGE vio_filter_set TOUCHING fat_parallel {
                      VSIZE_INSIDE = fatTblParallelLength - 0.0002 
                   } TEMP = vio_filter_set_filter
                   SELECT_CONTAINS vio_filter_set_filter { 
                      WIDTH =  0.0002 
                      HEIGHT = fatTblParallelLength + 0.0001 
                   } TEMP = vio_filter_set_filter
                   SELECT vio_filter_set INTERACT vio_filter_set_filter { } TEMP = vio_filter
                } else {
	           SELECT_CONTAINS vio_filter_set { 
	              WIDTH =  0.0002 
	              HEIGHT = fatTblParallelLength + 0.0001 
	           } TEMP = vio_filter
                }
                SELECT vio_set INSIDE vio_filter { } TEMP = mode0_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out1 NOT mode0_child_out1 { } TEMP = mode0_diff_out1
                   SELECT mode0_out1 INTERACT mode0_diff_out1 { } TEMP = mode0_out1
                }
                COPY mode0_out1 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing  = fatTblSpacing um"
                } (21 )
		if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	           EXTERNAL fat_ext spc_target {
		      SPACING < fatTblSpacing_dg
	              SET_CORNERS_TO_SPACING = FALSE
		      PARALLEL_POINT_PROJECTION = FALSE
		      TOUCH = TRUE
		      POINT_TOUCH = FALSE
		      NON_PARALLEL = TRUE
	           } TEMP = mode0_out2
                   if (ignoreChildCell == 1) {
                      BOOLEAN mode0_out2 NOT mode0_child_out2 { } TEMP = mode0_diff_out2
                      SELECT mode0_out2 INTERACT mode0_diff_out2 { } TEMP = mode0_out2
                   }
                   COPY mode0_out2 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing (mode 1/2) = fatTblSpacing um/ fatTblSpacing_dg um "
                   } (21 )
	        } 
	     } else {
	        EXTERNAL fat_ext spc_target {
		   SPACING < fatTblSpacing
		   NON_PARALLEL = TRUE
		   SET_CORNERS_TO_SPACING = FALSE
		   POINT_TOUCH = FALSE
		} TEMP = mode0_out3
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out3 NOT mode0_child_out3 { } TEMP = mode0_diff_out3
                   SELECT mode0_out3 INTERACT mode0_diff_out3 { } TEMP = mode0_out3
                }
                COPY mode0_out3 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range ( fatTblExtensionRange um) minimum spacing = fatTblSpacing um"
                } (21 )
	     }
	  } else if (fatWireExtensionMode == 1) {
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal6  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             if (fatTblParallelLength > 0) {
                EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
		   BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   CHECK_SAME_POLYGON = TRUE 
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
	        SELECT fat_ext INTERACT spacing {  } TEMP = fat_ext
		BOOLEAN fat_ext OR spacing {  } TEMP = combined_fat_ext
                EXTERNAL combined_fat_ext fat {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
                } TEMP = fat_spacing
		BOOLEAN fat_spacing AND fat_ran {  } TEMP = fat_spacing
		BOOLEAN combined_fat_ext OR fat_spacing {  } TEMP = combined_fat_ext
                SELECT_CONTAINS combined_fat_ext { 
                   WIDTH =  0.0002 
                   HEIGHT = fatTblParallelLength + 0.0001 
                } TEMP = combined_fat_ext
		SELECT spacing INTERACT combined_fat_ext { 
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out1 NOT mode1_child_out1 { } TEMP = mode1_diff_out1
                   SELECT mode1_out1 INTERACT mode1_diff_out1 { } TEMP = mode1_out1 
                }
                COPY mode1_out1 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (21 ) 
	     } else {
               	EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
	           BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
	           CHECK_SAME_POLYGON = TRUE 
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
                SELECT spacing INTERACT fat_ext {
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out2
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out2 NOT mode1_child_out2 { } TEMP = mode1_diff_out2
                   SELECT mode1_out2 INTERACT mode1_diff_out2 { } TEMP = mode1_out2
                }
                COPY mode1_out2 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (21 )
	     }
	  } else if (fatWireExtensionMode == 2) {
	     SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
             BOOLEAN fat_ran AND metal6  {  } TEMP = fat_ext
             BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	      	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
             } TEMP = spacing
 	     SELECT spacing INSIDE fat_ran {  } TEMP = spacing
	     SELECT spacing OUTSIDE fat {  } TEMP = spacing
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode2_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode2_out NOT mode2_child_out { } TEMP = mode2_diff_out
                SELECT mode2_out INTERACT mode2_diff_out { } TEMP = mode2_out 
             }
             COPY mode2_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 2, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (21 )
	  } else if (fatWireExtensionMode == 3) {
             SIZE fat {
	        GROW_LEFT = fatTblExtensionRange
	        GROW_RIGHT = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal6  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	       	PARALLEL = TRUE

	       	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		HORIZONTAL_ONLY = TRUE
             } TEMP = spacing_hor
	     SELECT spacing_hor INSIDE fat_ran {  } TEMP = spacing_hor
	     SELECT spacing_hor OUTSIDE fat {  } TEMP = spacing_hor
             SIZE fat {
	        GROW_TOP = fatTblExtensionRange
	        GROW_BOTTOM = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal6  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	        POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		VERTICAL_ONLY = TRUE
             } TEMP = spacing_ver
	     SELECT spacing_ver INSIDE fat_ran {  } TEMP = spacing_ver
	     SELECT spacing_ver OUTSIDE fat {  } TEMP = spacing_ver
  	     BOOLEAN spacing_hor OR spacing_ver {  } TEMP = spacing
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal6  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
  	     /* check overlapped projection length */
 	     if (fatTblParallelLength > 0) {
                POLYGON_FEATURES fat_ext {
                   EQUATIONS {
                      vnum = EV_VNUM_IN;
                      if ( vnum > 0) {
                         bdLeft = EV_VXCOORD_IN[0];
                         bdRight = EV_VXCOORD_IN[0];
                         bdBottom = EV_VYCOORD_IN[0];
                         bdTop = EV_VYCOORD_IN[0];
                         FOR (i = 1; i < vnum; i++) {
                            if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
                            else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
                            if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
                            else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
                         } /* FOR i */
                         if ( (bdRight - bdLeft) >= fatTblParallelLength ||
                  	      (bdTop - bdBottom) >= fatTblParallelLength) {
                            FOR (i = 0; i < vnum; i++) {
                               EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
                               EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
                            }
                            EV_VNUM_OUT = vnum;
                 	    EV_SAVE_POLYGON();
                         }
                      }
                   }
                } TEMP = fat_ext /* POLYGON_FEATURE */
             }
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode3_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode3_out NOT mode3_child_out { } TEMP = mode3_diff_out
                SELECT mode3_out INTERACT mode3_diff_out { } TEMP = mode3_out
             }
             COPY mode3_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 3, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (21 )
          }
       }
       SET fatTblSpacing = 0;
    }
}
@ 751 "adrc/adrc.ev" 2


SET fatTblThreshold = 1.505;
SET fatTblParallelLength = 1.505;
SET minWidth = 0.056;

SET fatTblThreshold_Start = 0;
SET fatTblSpacing = 0.6;
@ 1 "adrc/adrc_fatMetal.ev" 1
/*check fat metal table*/
if (fatTblThreshold > 0) {
    if ((fatTblThreshold / 2.0) > 0.0001 ) {
       SIZE fat_candidate  { UNDER_OVER = fatTblThreshold / 2.0 - 0.0001  } TEMP = fat_candidate
       if (fatTblNextThreshold > 0) {
          SIZE fat_candidate { UNDER_OVER = fatTblNextThreshold / 2.0 - 0.0001  } TEMP = fat_next
          BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
          BOOLEAN fat AND fat_target { } TEMP = fat
          SET fatTblNextThreshold = 0;
       } else {
          BOOLEAN fat_candidate AND fat_target {  } TEMP = fat 
       }
    } else {
      COPY fat_target {  } TEMP = fat 
    }
    COPY fat_target { } TEMP = spc_target
    if (fatTblThreshold_Start > 0  || fatTblThreshold_End > 0) {
       if (fatTblThreshold_Start > 0) {
          SIZE fat_target { UNDER_OVER = fatTblThreshold_Start / 2.0 - 0.0001  } TEMP = spc_target
       }
       if (fatTblThreshold_End > 0 && fatTblThreshold_End > fatTblThreshold_Start) {
          SIZE spc_target { UNDER_OVER = fatTblThreshold_End / 2.0 - 0.0001  } TEMP = fat_end
          BOOLEAN spc_target NOT fat_end { } TEMP = spc_target
       }
       BOOLEAN spc_target AND fat_target {  } TEMP = spc_target
       if (ignoreBlockage == 0 && fatTblThreshold_Start < fatTblThreshold_1) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal6_blockage  {  } TEMP = spc_target
       }
       SET fatTblThreshold_Start = 0;
       SET fatTblThreshold_End = 0;
       SET fatTblThreshold_1 = 0;
    } else {
       if (ignoreBlockage == 0) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal6_blockage  {  } TEMP = spc_target
       }
    }
 
    if (fatTblEnclosedArea > 0) {
       SELECT holes INTERACT fat { } TEMP = fat_holes
       AREA fat_holes { 
          RANGE = [0.0001 * 0.0001 , fatTblEnclosedArea - 0.0001 * 0.0001 ]
       } TEMP = fat_holes
       if (fatTblMinEnclosedAreaMode==0) {
          SIZE fat_holes { OVER_UNDER = fatTblThreshold / 2.0 + 0.0001  } TEMP = ovun_holes
          SELECT ovun_holes INTERACT fat_holes { RANGE = [2, 9999999999 ] } TEMP = merged_holes
          BOOLEAN fat_candidate AND fat_target { } TEMP = fat_metal
          BOOLEAN metal6  NOT fat_metal { } TEMP = thin_metal
          BOOLEAN thin_metal NOT ovun_holes { } TEMP = thin_metal
          SELECT ovun_holes INTERACT thin_metal { } TEMP = thin_holes
          BOOLEAN thin_holes OR merged_holes { } TEMP = thin_holes
          BOOLEAN fat_holes NOT thin_holes { } TEMP = fat_holes
       }
       COPY fat_holes { 
	  COMMENT = "$layer_name EnclsArea : fat metal ( fatTblThreshold um) minimum enclosed area (mode fatTblMinEnclosedAreaMode ) = fatTblEnclosedArea um*um"
       } (21 )
       SET fatTblEnclosedArea = 0;
    }
    if (fatTblSpacing > 0) {
       /*check fat metal*/ 
       if (fatTblParallelLength > 0) {
          if (router_parallelLengthNetMode == 1 || parallelLengthMode == 1) {
             AREA spc_target { RANGE = [fatTblParallelLength * minWidth + 0.0001 , 9999999999 ] } TEMP = spc_target1
             COPY spc_target1 { } TEMP = spc_target2
          } else {
             COPY spc_target { } TEMP = spc_target2
          }
          if (parallelLengthMode == 1) {
             SELECT metal6  INTERACT fat { } TEMP = fat_all 
             BOOLEAN fat_all OR fat { } TEMP = fat2
             SELECT metal6  INTERACT spc_target2 { } TEMP = spc_target_all
             BOOLEAN spc_target_all OR spc_target2 { } TEMP = spc_target2
          } else {
             COPY fat { } TEMP = fat2
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING <= fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
                OUTPUT_EDGES = TRUE
             } TEMP = vio_edge
             SELECT vio_edge INTERACT fat { } TEMP = vio_edge
             SELECT vio_edge INTERACT spc_target1 { } TEMP = vio_edge
             SELECT violation INTERACT vio_edge { } TEMP = violation
          } else {
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
          }
          BOOLEAN violation NOT fat_target { } TEMP = violation
          if (fatTblParallelLength < fatTblSpacing) {
             SELECT_EDGE violation TOUCHING fat2 {
                VSIZE_INSIDE = fatTblParallelLength - 0.0002 
             } TEMP = vio_filter
             SELECT_CONTAINS vio_filter { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = vio_filter
             SELECT violation INTERACT vio_filter { } TEMP = violation
          } else {
             SELECT_CONTAINS violation { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = violation
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING = [fatTblSpacing, fatTblSpacing]
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
             } TEMP = violation3
             BOOLEAN violation3 NOT fat_target { } TEMP = violation3
             BOOLEAN violation NOT violation3 { } TEMP= violation
          }
          SELECT_EDGE fat2 TOUCHING violation { } TEMP=fat_viol
          BOOLEAN fat_viol AND violation { } TEMP=fat_viol
          SELECT_EDGE spc_target2 TOUCHING violation { } TEMP=spc_target2
          BOOLEAN spc_target2 AND violation { } TEMP= spc_target2
	  if (ignoreChildCell == 1) {
             EXTERNAL fat_viol spc_target2 {
		SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		TOUCH = FALSE
		POINT_TOUCH = FALSE
		NON_PARALLEL = TRUE
	     } TEMP = spc_mode0_out
             BOOLEAN spc_mode0_out NOT spc_mode0_child_out { } TEMP = spc_mode0_diff_out
             SELECT spc_mode0_out INTERACT spc_mode0_diff_out { } TEMP = spc_mode0_out
	     SELECT_EDGE fat2 TOUCHING spc_mode0_out { } TEMP=fat_viol
	     BOOLEAN fat_viol AND spc_mode0_out { } TEMP=fat_viol
	     SELECT_EDGE spc_target2 TOUCHING spc_mode0_out { } TEMP=spc_target2
	     BOOLEAN spc_target2 AND spc_mode0_out { } TEMP=spc_target2
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (21 )  		
	  } else {
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing 
	        SET_CORNERS_TO_SPACING = FALSE
	        PARALLEL_POINT_PROJECTION = FALSE
	        TOUCH = FALSE
	        POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (21 )
	  }
	  if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	     if (ignoreChildCell == 1) {
		EXTERNAL fat spc_target {
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} TEMP = spc_mode1_out
	        BOOLEAN spc_mode1_out NOT spc_mode1_child_out { } TEMP = spc_mode1_diff_out
	        SELECT spc_mode1_out INTERACT spc_mode1_diff_out { } TEMP = spc_mode1_out
                SELECT_EDGE fat TOUCHING spc_mode1_out { } TEMP=fat_viol
	        BOOLEAN fat_viol AND spc_mode1_out { } TEMP=fat_viol
	        SELECT_EDGE spc_target TOUCHING spc_mode1_out { } TEMP=spc_target2
	        BOOLEAN spc_target2 AND spc_mode1_out { } TEMP=spc_target2
	        EXTERNAL fat_viol spc_target2 {
	           COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um " 	    
		   SPACING < fatTblSpacing_dg
                   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} (21 )
	     } else {
	        EXTERNAL fat spc_target {
		   COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um "
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
	    	   PARALLEL_POINT_PROJECTION = FALSE
	           TOUCH = FALSE
	     	   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } (21 ) 
	     }
          }
       } else {
	  if (ignoreChildCell == 1) {
              EXTERNAL fat spc_target {
                 SPACING < fatTblSpacing
                 BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
              } TEMP = spc_out
	      BOOLEAN spc_out NOT spc_child_out { } TEMP = spc_diff_out
	      SELECT spc_out INTERACT spc_diff_out { } TEMP = spc_out
	      SELECT_EDGE fat TOUCHING spc_out { } TEMP=fat_viol
	      BOOLEAN fat_viol AND spc_out { } TEMP=fat_viol
              SELECT_EDGE spc_target TOUCHING spc_out { } TEMP=spc_target2
	      BOOLEAN spc_target2 AND spc_out { } TEMP=spc_target2
	      EXTERNAL fat_viol spc_target2 {
		 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
		 BOX_CORNER = FALSE 
		 NON_PARALLEL = TRUE
		 POINT_TOUCH = FALSE
	      } (21 ) 
	  } else {
	      EXTERNAL fat spc_target {
                 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
	         BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
	      } (21 ) 
	  }
       }
       /*check metal in the extension range*/ 
       if (fatTblExtensionRange > 0) {
	  if (fatWireExtensionMode == 0) {
	     SIZE fat { OVERSIZE = fatTblExtensionRange } TEMP = fat_tmp
             BOOLEAN fat_tmp AND metal6  { } TEMP = fat_tmp
  	     BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
             SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_ext
             BOOLEAN fat_ext OR fat { } TEMP = fat_ext
	     if (fatTblParallelLength > 0) {
                if (fatTblParallelLength > fatTblExtensionRange) {
                   SIZE fat { OVERSIZE = fatTblParallelLength } TEMP = fat_tmp
                   BOOLEAN fat_tmp AND metal6  { } TEMP = fat_tmp
  	           BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
                   SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_parallel
                   BOOLEAN fat_parallel OR fat { } TEMP = fat_parallel
                } else {
                   COPY fat_ext { } TEMP = fat_parallel
                }
		EXTERNAL fat_parallel spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
	           NON_PARALLEL = TRUE
	        } TEMP = vio_filter_set
		EXTERNAL fat_ext spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } TEMP = vio_set
                if (fatTblParallelLength < fatTblSpacing) {
                   SELECT_EDGE vio_filter_set TOUCHING fat_parallel {
                      VSIZE_INSIDE = fatTblParallelLength - 0.0002 
                   } TEMP = vio_filter_set_filter
                   SELECT_CONTAINS vio_filter_set_filter { 
                      WIDTH =  0.0002 
                      HEIGHT = fatTblParallelLength + 0.0001 
                   } TEMP = vio_filter_set_filter
                   SELECT vio_filter_set INTERACT vio_filter_set_filter { } TEMP = vio_filter
                } else {
	           SELECT_CONTAINS vio_filter_set { 
	              WIDTH =  0.0002 
	              HEIGHT = fatTblParallelLength + 0.0001 
	           } TEMP = vio_filter
                }
                SELECT vio_set INSIDE vio_filter { } TEMP = mode0_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out1 NOT mode0_child_out1 { } TEMP = mode0_diff_out1
                   SELECT mode0_out1 INTERACT mode0_diff_out1 { } TEMP = mode0_out1
                }
                COPY mode0_out1 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing  = fatTblSpacing um"
                } (21 )
		if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	           EXTERNAL fat_ext spc_target {
		      SPACING < fatTblSpacing_dg
	              SET_CORNERS_TO_SPACING = FALSE
		      PARALLEL_POINT_PROJECTION = FALSE
		      TOUCH = TRUE
		      POINT_TOUCH = FALSE
		      NON_PARALLEL = TRUE
	           } TEMP = mode0_out2
                   if (ignoreChildCell == 1) {
                      BOOLEAN mode0_out2 NOT mode0_child_out2 { } TEMP = mode0_diff_out2
                      SELECT mode0_out2 INTERACT mode0_diff_out2 { } TEMP = mode0_out2
                   }
                   COPY mode0_out2 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing (mode 1/2) = fatTblSpacing um/ fatTblSpacing_dg um "
                   } (21 )
	        } 
	     } else {
	        EXTERNAL fat_ext spc_target {
		   SPACING < fatTblSpacing
		   NON_PARALLEL = TRUE
		   SET_CORNERS_TO_SPACING = FALSE
		   POINT_TOUCH = FALSE
		} TEMP = mode0_out3
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out3 NOT mode0_child_out3 { } TEMP = mode0_diff_out3
                   SELECT mode0_out3 INTERACT mode0_diff_out3 { } TEMP = mode0_out3
                }
                COPY mode0_out3 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range ( fatTblExtensionRange um) minimum spacing = fatTblSpacing um"
                } (21 )
	     }
	  } else if (fatWireExtensionMode == 1) {
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal6  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             if (fatTblParallelLength > 0) {
                EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
		   BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   CHECK_SAME_POLYGON = TRUE 
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
	        SELECT fat_ext INTERACT spacing {  } TEMP = fat_ext
		BOOLEAN fat_ext OR spacing {  } TEMP = combined_fat_ext
                EXTERNAL combined_fat_ext fat {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
                } TEMP = fat_spacing
		BOOLEAN fat_spacing AND fat_ran {  } TEMP = fat_spacing
		BOOLEAN combined_fat_ext OR fat_spacing {  } TEMP = combined_fat_ext
                SELECT_CONTAINS combined_fat_ext { 
                   WIDTH =  0.0002 
                   HEIGHT = fatTblParallelLength + 0.0001 
                } TEMP = combined_fat_ext
		SELECT spacing INTERACT combined_fat_ext { 
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out1 NOT mode1_child_out1 { } TEMP = mode1_diff_out1
                   SELECT mode1_out1 INTERACT mode1_diff_out1 { } TEMP = mode1_out1 
                }
                COPY mode1_out1 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (21 ) 
	     } else {
               	EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
	           BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
	           CHECK_SAME_POLYGON = TRUE 
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
                SELECT spacing INTERACT fat_ext {
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out2
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out2 NOT mode1_child_out2 { } TEMP = mode1_diff_out2
                   SELECT mode1_out2 INTERACT mode1_diff_out2 { } TEMP = mode1_out2
                }
                COPY mode1_out2 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (21 )
	     }
	  } else if (fatWireExtensionMode == 2) {
	     SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
             BOOLEAN fat_ran AND metal6  {  } TEMP = fat_ext
             BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	      	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
             } TEMP = spacing
 	     SELECT spacing INSIDE fat_ran {  } TEMP = spacing
	     SELECT spacing OUTSIDE fat {  } TEMP = spacing
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode2_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode2_out NOT mode2_child_out { } TEMP = mode2_diff_out
                SELECT mode2_out INTERACT mode2_diff_out { } TEMP = mode2_out 
             }
             COPY mode2_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 2, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (21 )
	  } else if (fatWireExtensionMode == 3) {
             SIZE fat {
	        GROW_LEFT = fatTblExtensionRange
	        GROW_RIGHT = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal6  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	       	PARALLEL = TRUE

	       	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		HORIZONTAL_ONLY = TRUE
             } TEMP = spacing_hor
	     SELECT spacing_hor INSIDE fat_ran {  } TEMP = spacing_hor
	     SELECT spacing_hor OUTSIDE fat {  } TEMP = spacing_hor
             SIZE fat {
	        GROW_TOP = fatTblExtensionRange
	        GROW_BOTTOM = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal6  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	        POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		VERTICAL_ONLY = TRUE
             } TEMP = spacing_ver
	     SELECT spacing_ver INSIDE fat_ran {  } TEMP = spacing_ver
	     SELECT spacing_ver OUTSIDE fat {  } TEMP = spacing_ver
  	     BOOLEAN spacing_hor OR spacing_ver {  } TEMP = spacing
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal6  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
  	     /* check overlapped projection length */
 	     if (fatTblParallelLength > 0) {
                POLYGON_FEATURES fat_ext {
                   EQUATIONS {
                      vnum = EV_VNUM_IN;
                      if ( vnum > 0) {
                         bdLeft = EV_VXCOORD_IN[0];
                         bdRight = EV_VXCOORD_IN[0];
                         bdBottom = EV_VYCOORD_IN[0];
                         bdTop = EV_VYCOORD_IN[0];
                         FOR (i = 1; i < vnum; i++) {
                            if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
                            else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
                            if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
                            else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
                         } /* FOR i */
                         if ( (bdRight - bdLeft) >= fatTblParallelLength ||
                  	      (bdTop - bdBottom) >= fatTblParallelLength) {
                            FOR (i = 0; i < vnum; i++) {
                               EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
                               EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
                            }
                            EV_VNUM_OUT = vnum;
                 	    EV_SAVE_POLYGON();
                         }
                      }
                   }
                } TEMP = fat_ext /* POLYGON_FEATURE */
             }
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode3_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode3_out NOT mode3_child_out { } TEMP = mode3_diff_out
                SELECT mode3_out INTERACT mode3_diff_out { } TEMP = mode3_out
             }
             COPY mode3_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 3, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (21 )
          }
       }
       SET fatTblSpacing = 0;
    }
}
@ 759 "adrc/adrc.ev" 2


SET fatTblThreshold = 3.005;
SET fatTblParallelLength = 3.005;
SET minWidth = 0.056;

SET fatTblThreshold_Start = 0;
SET fatTblSpacing = 0.7;
@ 1 "adrc/adrc_fatMetal.ev" 1
/*check fat metal table*/
if (fatTblThreshold > 0) {
    if ((fatTblThreshold / 2.0) > 0.0001 ) {
       SIZE fat_candidate  { UNDER_OVER = fatTblThreshold / 2.0 - 0.0001  } TEMP = fat_candidate
       if (fatTblNextThreshold > 0) {
          SIZE fat_candidate { UNDER_OVER = fatTblNextThreshold / 2.0 - 0.0001  } TEMP = fat_next
          BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
          BOOLEAN fat AND fat_target { } TEMP = fat
          SET fatTblNextThreshold = 0;
       } else {
          BOOLEAN fat_candidate AND fat_target {  } TEMP = fat 
       }
    } else {
      COPY fat_target {  } TEMP = fat 
    }
    COPY fat_target { } TEMP = spc_target
    if (fatTblThreshold_Start > 0  || fatTblThreshold_End > 0) {
       if (fatTblThreshold_Start > 0) {
          SIZE fat_target { UNDER_OVER = fatTblThreshold_Start / 2.0 - 0.0001  } TEMP = spc_target
       }
       if (fatTblThreshold_End > 0 && fatTblThreshold_End > fatTblThreshold_Start) {
          SIZE spc_target { UNDER_OVER = fatTblThreshold_End / 2.0 - 0.0001  } TEMP = fat_end
          BOOLEAN spc_target NOT fat_end { } TEMP = spc_target
       }
       BOOLEAN spc_target AND fat_target {  } TEMP = spc_target
       if (ignoreBlockage == 0 && fatTblThreshold_Start < fatTblThreshold_1) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal6_blockage  {  } TEMP = spc_target
       }
       SET fatTblThreshold_Start = 0;
       SET fatTblThreshold_End = 0;
       SET fatTblThreshold_1 = 0;
    } else {
       if (ignoreBlockage == 0) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal6_blockage  {  } TEMP = spc_target
       }
    }
 
    if (fatTblEnclosedArea > 0) {
       SELECT holes INTERACT fat { } TEMP = fat_holes
       AREA fat_holes { 
          RANGE = [0.0001 * 0.0001 , fatTblEnclosedArea - 0.0001 * 0.0001 ]
       } TEMP = fat_holes
       if (fatTblMinEnclosedAreaMode==0) {
          SIZE fat_holes { OVER_UNDER = fatTblThreshold / 2.0 + 0.0001  } TEMP = ovun_holes
          SELECT ovun_holes INTERACT fat_holes { RANGE = [2, 9999999999 ] } TEMP = merged_holes
          BOOLEAN fat_candidate AND fat_target { } TEMP = fat_metal
          BOOLEAN metal6  NOT fat_metal { } TEMP = thin_metal
          BOOLEAN thin_metal NOT ovun_holes { } TEMP = thin_metal
          SELECT ovun_holes INTERACT thin_metal { } TEMP = thin_holes
          BOOLEAN thin_holes OR merged_holes { } TEMP = thin_holes
          BOOLEAN fat_holes NOT thin_holes { } TEMP = fat_holes
       }
       COPY fat_holes { 
	  COMMENT = "$layer_name EnclsArea : fat metal ( fatTblThreshold um) minimum enclosed area (mode fatTblMinEnclosedAreaMode ) = fatTblEnclosedArea um*um"
       } (21 )
       SET fatTblEnclosedArea = 0;
    }
    if (fatTblSpacing > 0) {
       /*check fat metal*/ 
       if (fatTblParallelLength > 0) {
          if (router_parallelLengthNetMode == 1 || parallelLengthMode == 1) {
             AREA spc_target { RANGE = [fatTblParallelLength * minWidth + 0.0001 , 9999999999 ] } TEMP = spc_target1
             COPY spc_target1 { } TEMP = spc_target2
          } else {
             COPY spc_target { } TEMP = spc_target2
          }
          if (parallelLengthMode == 1) {
             SELECT metal6  INTERACT fat { } TEMP = fat_all 
             BOOLEAN fat_all OR fat { } TEMP = fat2
             SELECT metal6  INTERACT spc_target2 { } TEMP = spc_target_all
             BOOLEAN spc_target_all OR spc_target2 { } TEMP = spc_target2
          } else {
             COPY fat { } TEMP = fat2
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING <= fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
                OUTPUT_EDGES = TRUE
             } TEMP = vio_edge
             SELECT vio_edge INTERACT fat { } TEMP = vio_edge
             SELECT vio_edge INTERACT spc_target1 { } TEMP = vio_edge
             SELECT violation INTERACT vio_edge { } TEMP = violation
          } else {
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
          }
          BOOLEAN violation NOT fat_target { } TEMP = violation
          if (fatTblParallelLength < fatTblSpacing) {
             SELECT_EDGE violation TOUCHING fat2 {
                VSIZE_INSIDE = fatTblParallelLength - 0.0002 
             } TEMP = vio_filter
             SELECT_CONTAINS vio_filter { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = vio_filter
             SELECT violation INTERACT vio_filter { } TEMP = violation
          } else {
             SELECT_CONTAINS violation { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = violation
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING = [fatTblSpacing, fatTblSpacing]
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
             } TEMP = violation3
             BOOLEAN violation3 NOT fat_target { } TEMP = violation3
             BOOLEAN violation NOT violation3 { } TEMP= violation
          }
          SELECT_EDGE fat2 TOUCHING violation { } TEMP=fat_viol
          BOOLEAN fat_viol AND violation { } TEMP=fat_viol
          SELECT_EDGE spc_target2 TOUCHING violation { } TEMP=spc_target2
          BOOLEAN spc_target2 AND violation { } TEMP= spc_target2
	  if (ignoreChildCell == 1) {
             EXTERNAL fat_viol spc_target2 {
		SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		TOUCH = FALSE
		POINT_TOUCH = FALSE
		NON_PARALLEL = TRUE
	     } TEMP = spc_mode0_out
             BOOLEAN spc_mode0_out NOT spc_mode0_child_out { } TEMP = spc_mode0_diff_out
             SELECT spc_mode0_out INTERACT spc_mode0_diff_out { } TEMP = spc_mode0_out
	     SELECT_EDGE fat2 TOUCHING spc_mode0_out { } TEMP=fat_viol
	     BOOLEAN fat_viol AND spc_mode0_out { } TEMP=fat_viol
	     SELECT_EDGE spc_target2 TOUCHING spc_mode0_out { } TEMP=spc_target2
	     BOOLEAN spc_target2 AND spc_mode0_out { } TEMP=spc_target2
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (21 )  		
	  } else {
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing 
	        SET_CORNERS_TO_SPACING = FALSE
	        PARALLEL_POINT_PROJECTION = FALSE
	        TOUCH = FALSE
	        POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (21 )
	  }
	  if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	     if (ignoreChildCell == 1) {
		EXTERNAL fat spc_target {
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} TEMP = spc_mode1_out
	        BOOLEAN spc_mode1_out NOT spc_mode1_child_out { } TEMP = spc_mode1_diff_out
	        SELECT spc_mode1_out INTERACT spc_mode1_diff_out { } TEMP = spc_mode1_out
                SELECT_EDGE fat TOUCHING spc_mode1_out { } TEMP=fat_viol
	        BOOLEAN fat_viol AND spc_mode1_out { } TEMP=fat_viol
	        SELECT_EDGE spc_target TOUCHING spc_mode1_out { } TEMP=spc_target2
	        BOOLEAN spc_target2 AND spc_mode1_out { } TEMP=spc_target2
	        EXTERNAL fat_viol spc_target2 {
	           COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um " 	    
		   SPACING < fatTblSpacing_dg
                   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} (21 )
	     } else {
	        EXTERNAL fat spc_target {
		   COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um "
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
	    	   PARALLEL_POINT_PROJECTION = FALSE
	           TOUCH = FALSE
	     	   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } (21 ) 
	     }
          }
       } else {
	  if (ignoreChildCell == 1) {
              EXTERNAL fat spc_target {
                 SPACING < fatTblSpacing
                 BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
              } TEMP = spc_out
	      BOOLEAN spc_out NOT spc_child_out { } TEMP = spc_diff_out
	      SELECT spc_out INTERACT spc_diff_out { } TEMP = spc_out
	      SELECT_EDGE fat TOUCHING spc_out { } TEMP=fat_viol
	      BOOLEAN fat_viol AND spc_out { } TEMP=fat_viol
              SELECT_EDGE spc_target TOUCHING spc_out { } TEMP=spc_target2
	      BOOLEAN spc_target2 AND spc_out { } TEMP=spc_target2
	      EXTERNAL fat_viol spc_target2 {
		 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
		 BOX_CORNER = FALSE 
		 NON_PARALLEL = TRUE
		 POINT_TOUCH = FALSE
	      } (21 ) 
	  } else {
	      EXTERNAL fat spc_target {
                 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
	         BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
	      } (21 ) 
	  }
       }
       /*check metal in the extension range*/ 
       if (fatTblExtensionRange > 0) {
	  if (fatWireExtensionMode == 0) {
	     SIZE fat { OVERSIZE = fatTblExtensionRange } TEMP = fat_tmp
             BOOLEAN fat_tmp AND metal6  { } TEMP = fat_tmp
  	     BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
             SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_ext
             BOOLEAN fat_ext OR fat { } TEMP = fat_ext
	     if (fatTblParallelLength > 0) {
                if (fatTblParallelLength > fatTblExtensionRange) {
                   SIZE fat { OVERSIZE = fatTblParallelLength } TEMP = fat_tmp
                   BOOLEAN fat_tmp AND metal6  { } TEMP = fat_tmp
  	           BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
                   SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_parallel
                   BOOLEAN fat_parallel OR fat { } TEMP = fat_parallel
                } else {
                   COPY fat_ext { } TEMP = fat_parallel
                }
		EXTERNAL fat_parallel spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
	           NON_PARALLEL = TRUE
	        } TEMP = vio_filter_set
		EXTERNAL fat_ext spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } TEMP = vio_set
                if (fatTblParallelLength < fatTblSpacing) {
                   SELECT_EDGE vio_filter_set TOUCHING fat_parallel {
                      VSIZE_INSIDE = fatTblParallelLength - 0.0002 
                   } TEMP = vio_filter_set_filter
                   SELECT_CONTAINS vio_filter_set_filter { 
                      WIDTH =  0.0002 
                      HEIGHT = fatTblParallelLength + 0.0001 
                   } TEMP = vio_filter_set_filter
                   SELECT vio_filter_set INTERACT vio_filter_set_filter { } TEMP = vio_filter
                } else {
	           SELECT_CONTAINS vio_filter_set { 
	              WIDTH =  0.0002 
	              HEIGHT = fatTblParallelLength + 0.0001 
	           } TEMP = vio_filter
                }
                SELECT vio_set INSIDE vio_filter { } TEMP = mode0_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out1 NOT mode0_child_out1 { } TEMP = mode0_diff_out1
                   SELECT mode0_out1 INTERACT mode0_diff_out1 { } TEMP = mode0_out1
                }
                COPY mode0_out1 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing  = fatTblSpacing um"
                } (21 )
		if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	           EXTERNAL fat_ext spc_target {
		      SPACING < fatTblSpacing_dg
	              SET_CORNERS_TO_SPACING = FALSE
		      PARALLEL_POINT_PROJECTION = FALSE
		      TOUCH = TRUE
		      POINT_TOUCH = FALSE
		      NON_PARALLEL = TRUE
	           } TEMP = mode0_out2
                   if (ignoreChildCell == 1) {
                      BOOLEAN mode0_out2 NOT mode0_child_out2 { } TEMP = mode0_diff_out2
                      SELECT mode0_out2 INTERACT mode0_diff_out2 { } TEMP = mode0_out2
                   }
                   COPY mode0_out2 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing (mode 1/2) = fatTblSpacing um/ fatTblSpacing_dg um "
                   } (21 )
	        } 
	     } else {
	        EXTERNAL fat_ext spc_target {
		   SPACING < fatTblSpacing
		   NON_PARALLEL = TRUE
		   SET_CORNERS_TO_SPACING = FALSE
		   POINT_TOUCH = FALSE
		} TEMP = mode0_out3
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out3 NOT mode0_child_out3 { } TEMP = mode0_diff_out3
                   SELECT mode0_out3 INTERACT mode0_diff_out3 { } TEMP = mode0_out3
                }
                COPY mode0_out3 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range ( fatTblExtensionRange um) minimum spacing = fatTblSpacing um"
                } (21 )
	     }
	  } else if (fatWireExtensionMode == 1) {
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal6  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             if (fatTblParallelLength > 0) {
                EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
		   BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   CHECK_SAME_POLYGON = TRUE 
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
	        SELECT fat_ext INTERACT spacing {  } TEMP = fat_ext
		BOOLEAN fat_ext OR spacing {  } TEMP = combined_fat_ext
                EXTERNAL combined_fat_ext fat {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
                } TEMP = fat_spacing
		BOOLEAN fat_spacing AND fat_ran {  } TEMP = fat_spacing
		BOOLEAN combined_fat_ext OR fat_spacing {  } TEMP = combined_fat_ext
                SELECT_CONTAINS combined_fat_ext { 
                   WIDTH =  0.0002 
                   HEIGHT = fatTblParallelLength + 0.0001 
                } TEMP = combined_fat_ext
		SELECT spacing INTERACT combined_fat_ext { 
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out1 NOT mode1_child_out1 { } TEMP = mode1_diff_out1
                   SELECT mode1_out1 INTERACT mode1_diff_out1 { } TEMP = mode1_out1 
                }
                COPY mode1_out1 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (21 ) 
	     } else {
               	EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
	           BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
	           CHECK_SAME_POLYGON = TRUE 
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
                SELECT spacing INTERACT fat_ext {
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out2
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out2 NOT mode1_child_out2 { } TEMP = mode1_diff_out2
                   SELECT mode1_out2 INTERACT mode1_diff_out2 { } TEMP = mode1_out2
                }
                COPY mode1_out2 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (21 )
	     }
	  } else if (fatWireExtensionMode == 2) {
	     SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
             BOOLEAN fat_ran AND metal6  {  } TEMP = fat_ext
             BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	      	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
             } TEMP = spacing
 	     SELECT spacing INSIDE fat_ran {  } TEMP = spacing
	     SELECT spacing OUTSIDE fat {  } TEMP = spacing
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode2_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode2_out NOT mode2_child_out { } TEMP = mode2_diff_out
                SELECT mode2_out INTERACT mode2_diff_out { } TEMP = mode2_out 
             }
             COPY mode2_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 2, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (21 )
	  } else if (fatWireExtensionMode == 3) {
             SIZE fat {
	        GROW_LEFT = fatTblExtensionRange
	        GROW_RIGHT = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal6  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	       	PARALLEL = TRUE

	       	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		HORIZONTAL_ONLY = TRUE
             } TEMP = spacing_hor
	     SELECT spacing_hor INSIDE fat_ran {  } TEMP = spacing_hor
	     SELECT spacing_hor OUTSIDE fat {  } TEMP = spacing_hor
             SIZE fat {
	        GROW_TOP = fatTblExtensionRange
	        GROW_BOTTOM = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal6  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	        POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		VERTICAL_ONLY = TRUE
             } TEMP = spacing_ver
	     SELECT spacing_ver INSIDE fat_ran {  } TEMP = spacing_ver
	     SELECT spacing_ver OUTSIDE fat {  } TEMP = spacing_ver
  	     BOOLEAN spacing_hor OR spacing_ver {  } TEMP = spacing
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal6  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
  	     /* check overlapped projection length */
 	     if (fatTblParallelLength > 0) {
                POLYGON_FEATURES fat_ext {
                   EQUATIONS {
                      vnum = EV_VNUM_IN;
                      if ( vnum > 0) {
                         bdLeft = EV_VXCOORD_IN[0];
                         bdRight = EV_VXCOORD_IN[0];
                         bdBottom = EV_VYCOORD_IN[0];
                         bdTop = EV_VYCOORD_IN[0];
                         FOR (i = 1; i < vnum; i++) {
                            if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
                            else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
                            if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
                            else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
                         } /* FOR i */
                         if ( (bdRight - bdLeft) >= fatTblParallelLength ||
                  	      (bdTop - bdBottom) >= fatTblParallelLength) {
                            FOR (i = 0; i < vnum; i++) {
                               EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
                               EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
                            }
                            EV_VNUM_OUT = vnum;
                 	    EV_SAVE_POLYGON();
                         }
                      }
                   }
                } TEMP = fat_ext /* POLYGON_FEATURE */
             }
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode3_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode3_out NOT mode3_child_out { } TEMP = mode3_diff_out
                SELECT mode3_out INTERACT mode3_diff_out { } TEMP = mode3_out
             }
             COPY mode3_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 3, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (21 )
          }
       }
       SET fatTblSpacing = 0;
    }
}
@ 767 "adrc/adrc.ev" 2


SET fatTblThreshold = 0;
SET fatTblEnclosedArea = 0;
SET fatTblExtensionRange = 0;
SET fatTblParallelLength = 0;
SET minWidth = 0;

/* End of Met6 fat table spacing rules */










/*metal 7*/
SET layer_name = "Met7";










SET minWidth = 0.056;
SET maxWidth = 5;
SET minArea = 0.016;
SET minEnclosedArea = 0.2;
SET minSpacing = 0.056;
SET sameNetMinSpacing = 0.056;
SET stub2StubSpacing = 0;

SET fatTblDimension = 5;
@ 1 "adrc/adrc_check_metal.ev" 1
/* Data Preparation */
if (fatTblDimension > 1 || fatWireThreshold > 0 || maxWidth > 0) {
  if (ignoreBlockage) {
      /* Let the real blockage be treated as thin */
      BOOLEAN metal7  NOT metal7_rbkg  {} TEMP=fat_candidate
  } else {
      COPY metal7  {} TEMP=fat_candidate
  }
  COPY fat_candidate {} TEMP=fat_target
}
/*Check width*/
if (minWidth > 0) {
    INTERNAL metal7  { 
        COMMENT = "$layer_name MinWidth  : minimum width = minWidth um" 
        SPACING < minWidth
        POINT_TOUCH = FALSE
    } (23 )
}
 
if (maxWidth > 0) {
    SIZE  fat_candidate {
        COMMENT = "$layer_name MaxWidth  : maximum width = maxWidth um"
 	UNDER_OVER = maxWidth / 2 
    } (23 ) 
}
 
/*Check area*/
if (minArea > 0) {
    AREA metal7  { 
	COMMENT = "$layer_name MinArea   : minimum area = minArea um*um"
	RANGE = [0.0001 * 0.0001 , minArea - 0.0001 * 0.0001 ]
    } (23 )
}
/* check min length of bounding box on polygon */
if (minLength > 0) {
  if (minLengthMode == 1) {
    INTERNAL metal7  {
        SPACING < minLength
        VERTICAL_ONLY = TRUE
        SET_CORNERS_TO_SPACING = FALSE
    } TEMP = ver_short
    BOOLEAN metal7  NOT ver_short { } TEMP = ver_long
    INTERNAL metal7  {
        SPACING < minLength
        HORIZONTAL_ONLY = TRUE
        SET_CORNERS_TO_SPACING = FALSE
    } TEMP = hor_short
    BOOLEAN metal7  NOT hor_short { } TEMP = hor_long
    SELECT CUT_LAYER1 INSIDE ver_long { } TEMP = good_cut
    BOOLEAN CUT_LAYER1 NOT good_cut { } TEMP = fail_cut_1
    SELECT fail_cut_1 INSIDE hor_long { } TEMP = good_cut
    BOOLEAN fail_cut_1 NOT good_cut { } TEMP = fail_cut_1
    SELECT CUT_LAYER2 INSIDE ver_long { } TEMP = good_cut
    BOOLEAN CUT_LAYER2 NOT good_cut { } TEMP = fail_cut_2
    SELECT fail_cut_2 INSIDE hor_long { } TEMP = good_cut
    BOOLEAN fail_cut_2 NOT good_cut { } TEMP = fail_cut_2
    BOOLEAN fail_cut_1 OR fail_cut_2 { } TEMP = fail_cut
    BOOLEAN hor_short NOT ver_long { } TEMP = hor_short
    BOOLEAN ver_short NOT hor_long { } TEMP = ver_short
    SELECT ver_short INTERACT fail_cut { } TEMP = ver_fail
    SELECT hor_short INTERACT fail_cut { } TEMP = hor_fail
    BOOLEAN ver_fail OR hor_fail { } TEMP = all_fail
    INTERNAL all_fail {
        COMMENT = "$layer_name MinLength : minimum length = minLength um"
        SPACING < minLength
        VERTICAL_ONLY = TRUE
        SET_CORNERS_TO_SPACING = FALSE
    } (23 )
  } else {
    POLYGON_FEATURES metal7  {
      COMMENT = "$layer_name MinLength : minimum length = minLength um"
      EQUATIONS {
        vnum = EV_VNUM_IN;
        if ( vnum > 0) {
	  bdLeft = EV_VXCOORD_IN[0];
	  bdRight = EV_VXCOORD_IN[0];
	  bdBottom = EV_VYCOORD_IN[0];
	  bdTop = EV_VYCOORD_IN[0];
          FOR (i = 1; i < vnum; i++) {
	    if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
            else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
	    if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
            else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
          }
	  if ( (bdRight - bdLeft) < minLength &&
	       (bdTop - bdBottom) < minLength) {
	    FOR (i = 0; i < vnum; i++) {
              EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
	      EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
            }
	    EV_VNUM_OUT = vnum;
	    EV_SAVE_POLYGON();
          }
        }
      }
    } (23 ) 
  }
  SET minLength = 0;
}
/* check max length of bounding box on polygon */
if (maxLength > 0) {
  POLYGON_FEATURES metal7  {
    COMMENT = "$layer_name MaxLength : maximum length = maxLength um"
    EQUATIONS {
      vnum = EV_VNUM_IN;
      if ( vnum > 0) {
	bdLeft = EV_VXCOORD_IN[0];
	bdRight = EV_VXCOORD_IN[0];
	bdBottom = EV_VYCOORD_IN[0];
	bdTop = EV_VYCOORD_IN[0];
        FOR (i = 1; i < vnum; i++) {
	  if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
          else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
	  if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
          else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
        }
	if ( (bdRight - bdLeft + bdTop - bdBottom) > maxLength ) {
          EV_VXCOORD_OUT[0] = bdLeft;
	  EV_VYCOORD_OUT[0] = bdBottom;
          EV_VXCOORD_OUT[1] = bdLeft;
	  EV_VYCOORD_OUT[1] = bdTop;
          EV_VXCOORD_OUT[2] = bdRight;
	  EV_VYCOORD_OUT[2] = bdTop;
          EV_VXCOORD_OUT[3] = bdRight;
	  EV_VYCOORD_OUT[3] = bdBottom;
          EV_VXCOORD_OUT[4] = bdLeft;
	  EV_VYCOORD_OUT[4] = bdBottom;
	  EV_VNUM_OUT = 5;
	  EV_SAVE_POLYGON();
        }
      }
    }
  } (23 ) 
  SET maxLength = 0;
}
 
/*Check enclosed area*/
if (minEnclosedArea > 0) {
    SELECT metal7  INSIDE_HOLE {
        INNER_HOLE_ONLY
    } TEMP = holes
    BOOLEAN holes NOT metal7  { } TEMP = holes
 
    AREA holes {
        COMMENT = "$layer_name EnclsArea : minimum enclosed area = minEnclosedArea um*um"
        RANGE = [0.0001 * 0.0001 , minEnclosedArea - 0.0001 * 0.0001 ]
    } (23 )
    /* check min length of bounding box on polygon */
    if (minEnclosedWidth > 0) {
      POLYGON_FEATURES holes {
        COMMENT = "$layer_name EnclsWidth: minimum enclosed Width = minEnclosedWidth um"
        EQUATIONS {
          vnum = EV_VNUM_IN;
          if ( vnum > 0) {
            bdLeft = EV_VXCOORD_IN[0];
            bdRight = EV_VXCOORD_IN[0];
            bdBottom = EV_VYCOORD_IN[0];
            bdTop = EV_VYCOORD_IN[0];
            FOR (i = 1; i < vnum; i++) {
              if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
              else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
              if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
              else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
            }
            if ( (bdRight - bdLeft) < minEnclosedWidth &&
                 (bdTop - bdBottom) < minEnclosedWidth) {
              FOR (i = 0; i < vnum; i++) {
                EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
                EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
              }
              EV_VNUM_OUT = vnum;
              EV_SAVE_POLYGON();
            }
          }
        }
      } (23 ) 
    }
}
 
/*check special notch rule*/
if ((minEdgeLength2 > 0.0001  && minEdgeLength3 > 0.0001 ) || minEdgeMode==2) {
  if (minEdgeMode==2) {
    SET minEdgeLength3 = minEdgeLength ;
  }
  NOTCH metal7  {
     SPACING < minEdgeLength3
     SET_CORNERS_TO_SPACING=FALSE
     PARALLEL = TRUE
     OUTPUT_EDGES = TRUE
  } TEMP = notch_vectors
  SELECT_VECTOR notch_vectors {
     LENGTH_RANGE = [0.0001 , minEdgeLength2 - 0.0001 ]
  } TEMP = short_edges
  EXTERNAL short_edges metal7  {
     SPACING < minEdgeLength3
     SET_CORNERS_TO_SPACING=FALSE
     PARALLEL = TRUE
  } TEMP = notch_err
  /* Choose the real U-shaped notch */
  SIZE notch_err { OVERSIZE = 0.0002 *10 } TEMP = neighbors 
  BOOLEAN neighbors AND metal7  { } TEMP = neighbors
  VERTEX neighbors { 
     CONCAVE = TRUE
     CONVEX = TRUE
     SIZE = 0.0002 
  } TEMP = corners
  SELECT_EDGE neighbors INTERACT notch_err { } TEMP = target_edges
  BOOLEAN target_edges NOT corners { } TEMP = target_edges
  VERTEX neighbors { 
     CONCAVE = TRUE
     SIZE = 2* 0.0002 
  } TEMP = corners
  SELECT target_edges INTERACT corners { RANGE = [2, 2] } TEMP=target_edges
  SELECT notch_err INTERACT target_edges {
     COMMENT = "$layer_name SpeclNotch: sameNetSp = minEdgeLength3 um (sideLen minEdgeLength2 um)" 
  } (23 )
}
/*check consecutive short edges*/
if (minEdgeLength > 0.0001  && minEdgeMode != 2) { 
  INTERNAL metal7_top  {
     SEGMENT < minEdgeLength
     FLAG_ACUTE_ANGLE = FALSE
     FLAG_ACUTE_EDGE = FALSE
     OUTPUT_EDGES = TRUE
  } TEMP = short_edges
  if ((minEdgeMode == 0 && maxTotalMinEdgeLength>0) || maxNumMinEdge > 0) {
    SET temporary_1 = 0.0002 *2;
    SET temporary_2 = 2*temporary_1+ 0.0001 ;
    SELECT metal7_top  INTERACT short_edges { } TEMP = target_top
    CLASSIFY_EDGES target_top {
       LENGTH = temporary_1
       DMIN   = temporary_2
       INSIDE_CORNER  TEMP = inside_corner_edges
       OUTSIDE_CORNER TEMP = outside_corner_edges
       REMAINDER      TEMP = remainder_edges
    }
    if (minEdgeMode == 0 && (maxNumMinEdge>0 || maxTotalMinEdgeLength > 0)) {
       SELECT short_edges ENCLOSING inside_corner_edges { } TEMP = short_edges
    }
  }
  if (maxTotalMinEdgeLength > 0) {
    LENGTH short_edges {
       RANGE = [maxTotalMinEdgeLength + 0.0001 , 9999999999 ]
    } TEMP = max_length_err
    /* Work around: translate polygons into dimensional check output */
    SIZE max_length_err { OVERSIZE = 2* 0.0002  } TEMP = max_length_err
    INTERNAL max_length_err {
       SPACING < 3* 0.0002 
       SET_CORNERS_TO_SPACING=FALSE
       COMMENT = "$layer_name MinEdgeLen: maximum total length ( minEdgeLength um)= maxTotalMinEdgeLength um"
    } (23 )
  }
  if (maxTotalMinEdgeLength == 0 || maxNumMinEdge > 0) {
    if (maxNumMinEdge==0)  {
       COPY short_edges {} TEMP=max_edge_err
    } else {
       SIZE short_edges {
         VSIZE_HEAD = - 0.0002 
        VSIZE_TAIL = - 0.0002 
       } TEMP = short_edges
       SIZE short_edges {
          OVERSIZE = 5* 0.0002 
          SIZE_ENDPOINTS = FALSE
       } TEMP = short_contours
       SELECT short_contours ENCLOSING remainder_edges {
          RANGE = [maxNumMinEdge + 1, 9999999999 ]
       } TEMP = short_contours
       SELECT short_edges INSIDE short_contours { } TEMP=max_edge_err
    }
    /* Work around: translate polygons into dimensional check output */
    SIZE max_edge_err { OVERSIZE = 2* 0.0002  } TEMP = max_edge_error
    INTERNAL max_edge_error {
       SPACING < 3* 0.0002 
       SET_CORNERS_TO_SPACING=FALSE
       COMMENT = "$layer_name MinEdgeLen: maximum number of consecutive short edges ( minEdgeLength um)= maxNumMinEdge"
    } (23 ) 
  }
}
 
/*check basic spacing*/
if (sameNetMinSpacing > 0 && sameNetMinSpacing != minSpacing) {
  if (sameNetMinSpacing > minSpacing) {
    /* Special condition for U-shaped Metal spacing rule */
    NOTCH metal7_pin  {
        SPACING < sameNetMinSpacing
        BOX_CORNER = FALSE 
        SET_CORNERS_TO_SPACING=FALSE
        NON_PARALLEL = TRUE
        OUTPUT_EDGES = TRUE
    } TEMP = errs_to_be_waived
    NOTCH metal7_top  {
	SPACING < sameNetMinSpacing
	BOX_CORNER = FALSE 
        SET_CORNERS_TO_SPACING=FALSE
	NON_PARALLEL = TRUE
        OUTPUT_EDGES = TRUE
    } TEMP = all_errs
    BOOLEAN all_errs NOT errs_to_be_waived { } TEMP=err_edge
    EXTERNAL err_edge metal7_top  {
	SPACING < sameNetMinSpacing
	BOX_CORNER = FALSE 
        SET_CORNERS_TO_SPACING=FALSE
	NON_PARALLEL = TRUE
    } TEMP = notch_err
    SIZE notch_err { OVERSIZE = 0.0002 *10 } TEMP = neighbors
    BOOLEAN neighbors AND metal7_top  { } TEMP = neighbors
    VERTEX neighbors { 
       CONCAVE = TRUE
       CONVEX = TRUE
       SIZE = 0.0002 
    } TEMP = corners
    SELECT_EDGE neighbors INTERACT notch_err { } TEMP = target_edges
    BOOLEAN target_edges AND notch_err { } TEMP = target_edges
    BOOLEAN target_edges NOT corners { } TEMP = target_edges
    VERTEX neighbors {
       CONCAVE = TRUE
       SIZE = 2* 0.0002 
    } TEMP = corners
    SELECT target_edges INTERACT corners { RANGE = [2, 2] } TEMP = target_edges
    SELECT notch_err TOUCHING target_edges {
      COMMENT = "$layer_name U-ShpNotch: U-shape notch minimum spacing = sameNetMinSpacing um" 
    } (23 )
  } else {
    NOTCH metal7  {
        COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = sameNetMinSpacing um" 
	SPACING < sameNetMinSpacing
	BOX_CORNER = FALSE 
	NON_PARALLEL = TRUE
    } (23 )
  }
  if (minSpacing > 0) {
    if (stubMode == 0 && stubSpacing > 0 && stubSpacing < minSpacing) {
	EXTERNAL metal7  {
	    COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um"
            LONGEDGE > stubThreshold + 0.0001 
	    LONGEDGE_TO_EDGE < minSpacing
	    SPACING <= 0
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            CHECK_SAME_POLYGON = TRUE 
	} (23 )
    } else {
        EXTERNAL metal7  {
	    COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um" 
	    SPACING < minSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
	    CHECK_SAME_POLYGON = FALSE
        } (23 )
    }
  }
} else {
  if (minSpacing > 0) {
    if (stubMode == 0 && stubSpacing > 0 && stubSpacing < minSpacing) {
        EXTERNAL metal7  {
            COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um"
            LONGEDGE > stubThreshold + 0.0001  
            LONGEDGE_TO_EDGE < minSpacing
            SPACING <= 0 
            BOX_CORNER = FALSE 
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            CHECK_SAME_POLYGON = TRUE 
        } (23 )
    } else {
        EXTERNAL metal7  {
	    COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um" 
            SPACING < minSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
	    CHECK_SAME_POLYGON = TRUE 
        } (23 )
    }
  }
}
 
/*check dogbone */
if (sameNetMinSpacing > 0 && sameNetWidthThreshold) {
  NOTCH metal7  {
    SPACING < sameNetMinSpacing
    BOX_CORNER = FALSE 
    NON_PARALLEL = TRUE
  } TEMP = dog_bone
 
  if (!layer_empty(dog_bone)) {
    SIZE dog_bone {EDGESIZE = sameNetWidthThreshold} TEMP = dog_ext
    BOOLEAN dog_ext NOT dog_bone {} TEMP = dog_ext
    BOOLEAN dog_ext AND metal7  {} TEMP = dog_ext
    if (!layer_empty(dog_ext)) {
      SELECT dog_ext EDGE_TOUCH dog_bone { OUTSIDE RANGE = [1, 9999999999 ] } TEMP = dog_ext
      NOTCH metal7  {
        SPACING < sameNetMinSpacing
        BOX_CORNER = FALSE 
        NON_PARALLEL = TRUE
	OUTPUT_EDGES = TRUE
      } TEMP = dog_bone
      SELECT dog_ext OUTSIDE dog_bone {} TEMP = dog_ext
      INTERNAL dog_ext {
	COMMENT = "$layer_name dogBone   : notch spacing = sameNetMinSpacing um width sameNetWidthThreshold um" 
	SPACING < sameNetWidthThreshold
      } (23 )
    }
  }
}
/*check basic fat spacing*/
if (fatWireThreshold > 0 && fatTblDimension == 0) {
    SIZE fat_candidate { UNDER_OVER = fatWireThreshold / 2.0 - 0.0001  } TEMP = m_fat
    BOOLEAN m_fat AND metal7  {  } TEMP = m_fat
    BOOLEAN metal7  NOT m_fat {  } TEMP = m_thin
    if (ignoreBlockage == 0) {
        /* the blockages on the metal_blockage layer are treated as thin blockages */
        BOOLEAN m_thin OR metal7_blockage  {  } TEMP = m_thin
    }
 
    if (fatFatMinSpacing > 0) {
	EXTERNAL m_fat {
	    COMMENT = "$layer_name FatWireSpc: fat & fat ( fatWireThreshold um) minimum spacing = fatFatMinSpacing um"
	    SPACING < fatFatMinSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = FALSE
	    CHECK_SAME_POLYGON = TRUE 
       } (23 )
    }
 
    if (fatThinMinSpacing > 0) {
	EXTERNAL m_fat m_thin {
	    COMMENT = "$layer_name FatWireSpc: fat & thin ( fatWireThreshold um) minimum spacing fatThinMinSpacing um"
	    SPACING < fatThinMinSpacing
 	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = FALSE
        } (23 )
    }
}
 
/*check thin blockage spacing*/
if (minSpacing > 0 && ignoreBlockage == 0) {
    if (!layer_empty (metal7_blockage )) {
	EXTERNAL metal7_blockage  metal7  {
	    COMMENT = "$layer_name Spacing   : metal & thin blockage minimum spacing = minSpacing um"
	    SPACING < minSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
            TOUCH = TRUE
        } (23 )
    }
}
/*check blockage overlap*/
/*check shorts between top_level routing and fram_blockages*/
if (minSpacing>0 || checkCrossHierShort>0) {
   if (ignoreBlockage == 0) {
      BOOLEAN metal7_blockage  or metal7_rbkg  {} TEMP=all_blockage
   } else {
      COPY metal7_rbkg  {} TEMP=all_blockage
   }
   BOOLEAN all_blockage AND metal7_top  {} TEMP = overlap_shape1
   EXTERNAL all_blockage metal7_top  {
      SPACING <= 0
      TOUCH = TRUE
   } TEMP = overlap_shape2
   if (checkCrossHierShort>0) {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
         COMMENT = "$layer_name Short Cross Hierarchy"
      } (23 )
   } else {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
         COMMENT = "$layer_name Overlap   : metal & blockage overlap"
      } (23 )
   }
}
 
if (fatPolyContactRule > 0) {
  /* Fat Poly Contact Rule: not new fat wire formed */
  if (readCellView > 0) {
     SIZE metal1 { UNDER_OVER = fatPolyContactRule / 2.0 - 0.0001  } TEMP = fat
     BOOLEAN fat AND metal1 {  } TEMP = fat 
  } else {
     SIZE metal1_top { UNDER_OVER = fatPolyContactRule / 2.0 - 0.0001  } TEMP = fat
     BOOLEAN fat AND metal1_top {  } TEMP = fat 
  }
  SIZE metal1_pin { UNDER_OVER = fatPolyContactRule / 2.0 - 0.0001  } TEMP = fat_pin
  BOOLEAN fat_pin AND metal1_pin {  } TEMP = fat_pin
  BOOLEAN fat NOT fat_pin {
    COMMENT = "$layer_name FatPolyContactRule: fatPolyContactRule um" 
  } (23 )
}
/* Special End-of-Line Spacing Rule */
if (stubMode == 0 && stubSpacing > 0 && stubSpacing < minSpacing) {
  EXTERNAL metal7  {
     COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 0)"
     LONGEDGE > stubThreshold + 0.0001 
     LONGEDGE_TO_EDGE <= 0 
     SPACING < stubSpacing 
     SET_CORNERS_TO_SPACING = FALSE
     PARALLEL_POINT_PROJECTION = FALSE
  } (23 )
} else if (stubMode > 0 && stubSpacing > minSpacing) {
  if (stubMode == 4) {
     INTERNAL metal7  {
        SEGMENT[90,90] < stubThreshold
        OUTPUT_EDGES = TRUE
     } TEMP = end_of_line
  } else {
     INTERNAL metal7  {
        SEGMENT[90,90] <= stubThreshold
        OUTPUT_EDGES = TRUE
     } TEMP = end_of_line
  }
  /* Quick filter to reduce the size of possible end of line */
  if (sideStubExt > 0) {
    SIZE end_of_line {
       VSIZE_HEAD = sideStubExt
       VSIZE_TAIL = sideStubExt
       OUTPUT_EDGES = TRUE
    } TEMP = eol_ext
  } else {
    COPY end_of_line { } TEMP=eol_ext
  }
  if (stub2StubSpacing > stubSpacing) {
     SET temporary_1 = stub2StubSpacing;
  } else {
     SET temporary_1 = stubSpacing; 
  }
  EXTERNAL eol_ext metal7  {
     SPACING < temporary_1
     TOUCH = TRUE
     OVERLAP = TRUE 
     SET_CORNERS_TO_SPACING = FALSE
     PARALLEL_POINT_PROJECTION = FALSE
     OUTPUT_EDGES = TRUE
  } TEMP=err_edge
  SELECT eol_ext INTERACT err_edge { } TEMP=eol_ext
  SELECT end_of_line INTERACT eol_ext { } TEMP=end_of_line 
  /* Reduce the size of METAL_LAYER */
  if (stubMode==3) {
     SIZE end_of_line {
        VSIZE_HEAD = stubSpacing 
        VSIZE_TAIL = stubSpacing 
        VSIZE_INSIDE = sideStubThreshold
        VSIZE_OUTSIDE = stubSpacing
     } TEMP = eol_filter 
  } else {
     if (stubMode == 1 && stubRange > 0) {
        SIZE end_of_line {
           VSIZE_HEAD = stubSpacing- 0.0001 
           VSIZE_TAIL = stubSpacing- 0.0001 
           VSIZE_OUTSIDE = stubSpacing- 0.0001 
        } TEMP = eol_filter
     } else {
        SIZE end_of_line {
           VSIZE_HEAD = stubSpacing- 0.0001 
           VSIZE_TAIL = stubSpacing- 0.0001 
           VSIZE_INSIDE = sideStubThreshold- 0.0001 
           VSIZE_OUTSIDE = stubSpacing- 0.0001 
        } TEMP = eol_filter
     }
  }
  SELECT metal7  INTERACT eol_filter { } TEMP=target_top
  /* Get the side edges and the whole eol of line set */
  SELECT_EDGE target_top INTERACT end_of_line { 
    POINT_TOUCH = TRUE
  } TEMP = eol_set
  VERTEX target_top { 
     CONCAVE = TRUE 
     CONVEX = TRUE
     SIZE = 0.0002 
  } TEMP = corners
  SELECT corners OUTSIDE end_of_line {} TEMP =corners 
  BOOLEAN eol_set NOT corners { } TEMP=eol_set
  BOOLEAN eol_set NOT end_of_line { } TEMP=side_edge
  /* find out the real end of line */
  if (stubRange > 0) {
     if (stubMode == 1) {
         COPY side_edge { } TEMP = all_side_edge
         LENGTH side_edge { SPACING <= stubRange- 0.0001  } TEMP=side_edge
     } else {
         LENGTH side_edge { SPACING < stubRange- 0.0002  } TEMP=eol_filter
         BOOLEAN side_edge NOT eol_filter { } TEMP=side_edge
     }
     SELECT end_of_line INTERACT side_edge { RANGE = [1,2] } TEMP = end_of_line
  } 
  if (stubMode == 1) {
    if (stub2StubSpacing > 0) {
       if (sideStubExt < 0) {
          SIZE end_of_line {
            VSIZE_HEAD = sideStubExt / 2
            VSIZE_TAIL = sideStubExt / 2
            OUTPUT_EDGES = TRUE
          } TEMP = eol_ext_tip
	 
          EXTERNAL eol_ext_tip {
            COMMENT = "$layer_name specEoLSpc: stub2Stubspacing= stub2StubSpacing um (mode = 1)"
            SPACING < stub2StubSpacing
            SET_CORNERS_TO_SPACING = FALSE
            PARALLEL_POINT_PROJECTION = TRUE
          } (23 )
       } else {
          EXTERNAL end_of_line {
            COMMENT = "$layer_name specEoLSpc: stub2Stubspacing= stub2StubSpacing um (mode = 1)"
            SPACING < stub2StubSpacing
            SET_CORNERS_TO_SPACING = FALSE
            PARALLEL_POINT_PROJECTION = FALSE
          } (23 )
       }
    }
    if (stubRange > 0) {
       SIZE end_of_line {
         VSIZE_INSIDE = 0.0002 
       } TEMP = eol_poly
       SELECT_EDGE eol_poly TOUCHING target_top { } TEMP=eol_edge
       EXTERNAL eol_edge target_top {
         COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
         CONVEX_TO_CONVEX < stubSpacing
         CONVEX_TO_CONVEX [POINT_PROJECTION] < stubSpacing
         CONVEX_TO_EDGE < stubSpacing
         CONCAVE_TO_CONVEX < stubSpacing
         LONGEDGE > 0.0002 
         LONGEDGE_TO_EDGE < stubSpacing
         SPACING <= 0
         SET_CORNERS_TO_SPACING = TRUE
         PARALLEL_POINT_PROJECTION = TRUE
       } (23 )
       SELECT all_side_edge INTERACT end_of_line { } TEMP = side_edge
       SIZE side_edge {
         VSIZE_HEAD = 0.0002 
         VSIZE_TAIL = 0.0002 
       } TEMP = side_edge_ext
       BOOLEAN side_edge_ext NOT side_edge { } TEMP = side_edge_ext
       SELECT side_edge_ext INTERACT end_of_line { } TEMP = side_edge_ext
       EXTERNAL side_edge_ext target_top {
         COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
         SPACING < stubSpacing
         SET_CORNERS_TO_SPACING = FALSE
         PARALLEL_POINT_PROJECTION = FALSE
       } (23 )
    } else {
       if (stub2StubSpacing > 0) {
         VECTORIZE target_top {
            DIRECTED=TRUE
         } TEMP=target_edges
         BOOLEAN target_edges NOT end_of_line { } TEMP = target_edges
         EXTERNAL end_of_line target_edges {
            COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
            SPACING < stubSpacing
            TOUCH=TRUE
            OVERLAP=TRUE
            SET_CORNERS_TO_SPACING=FALSE
            PARALLEL_POINT_PROJECTION=FALSE
         } (23 )
       } else {
         if (sideStubExt > 0) {
            SIZE end_of_line {
               VSIZE_HEAD = sideStubExt
               VSIZE_TAIL = sideStubExt
               OUTPUT_EDGES = TRUE
            } TEMP = end_of_line
            EXTERNAL end_of_line target_top {
               COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing ,crnKeepOut= sideStubExt um (mode = 1)"
               SPACING < stubSpacing
               TOUCH=TRUE
               OVERLAP=TRUE
               SET_CORNERS_TO_SPACING=FALSE
               PARALLEL_POINT_PROJECTION=FALSE
            } (23 )
         } else {
            EXTERNAL end_of_line target_top {
               COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
               SPACING < stubSpacing
               TOUCH=TRUE
               OVERLAP=TRUE
               SET_CORNERS_TO_SPACING=FALSE
               PARALLEL_POINT_PROJECTION=FALSE
            } (23 )
         }
       }
    }
  } else { /* stubMode == 2,3,4 */
    /* stubMode 2 eol classify and reduction */
    if (stubMode !=3 && sideStubExt > 0) {
      if (stubMode == 4) {
        SIZE end_of_line {
           VSIZE_HEAD = sideStubExt
           VSIZE_TAIL = sideStubExt
           OUTPUT_EDGES = TRUE
        } TEMP = eol_ext
        EXTERNAL eol_ext target_top {
           SPACING < stubSpacing
           SET_CORNERS_TO_SPACING=FALSE
           PARALLEL_POINT_PROJECTION=FALSE
           OUTPUT_EDGES = TRUE
        } TEMP=err_edge
        SELECT eol_ext INTERACT err_edge { } TEMP=eol_ext
      } else {
        EXTERNAL end_of_line target_top {
           SPACING < stubSpacing
           SET_CORNERS_TO_SPACING=FALSE
           PARALLEL_POINT_PROJECTION=FALSE
           OUTPUT_EDGES = TRUE
        } TEMP=err_edge
        SELECT end_of_line INTERACT err_edge { } TEMP=eol_body
        SIZE end_of_line {
           VSIZE_HEAD = sideStubExt
           VSIZE_TAIL = sideStubExt
           OUTPUT_EDGES = TRUE
        } TEMP = eol_ext
        BOOLEAN eol_ext NOT end_of_line {} TEMP=eol_ext
        EXTERNAL eol_ext target_top {
           SPACING < stubSpacing
           SET_CORNERS_TO_SPACING=FALSE
           PARALLEL_POINT_PROJECTION=FALSE
           OUTPUT_EDGES = TRUE
        } TEMP=err_edge
        SELECT eol_ext INTERACT err_edge { } TEMP=eol_ext
        BOOLEAN eol_body OR eol_ext { } TEMP=eol_ext
      } 
    } else {
      COPY end_of_line { } TEMP=eol_ext
    }
    SELECT side_edge INTERACT eol_ext { } TEMP=side_edge
    SIZE eol_ext {
       VSIZE_INSIDE = sideStubThreshold 
       VSIZE_OUTSIDE = sideStubExt
    } TEMP = eol_range
    if (sideStubExt > 0) {
       SIZE side_edge {
          VSIZE_HEAD = sideStubExt
          VSIZE_TAIL = sideStubExt
          OUTPUT_EDGES = TRUE
       } TEMP = check_edge
    } else {
       COPY side_edge { } TEMP = check_edge
    }
    BOOLEAN check_edge AND eol_range { } TEMP=check_edge
    EXTERNAL check_edge target_top {
       SPACING < temporary_1
       SET_CORNERS_TO_SPACING = FALSE
       SHADOW_OTHER_LAYER = TRUE
       PARALLEL_POINT_PROJECTION = FALSE
       OUTPUT_EDGES = TRUE
    } TEMP=err_edge
    if (0 && stubMode!=4) { /* Temporarily do not check mode 2,3 side edge length */
       LENGTH side_edge { SPACING < stubSpacing- 0.0001 *2 } TEMP=err_edge_1
       BOOLEAN err_edge OR err_edge_1 { } TEMP=err_edge
    }
    SELECT check_edge INTERACT err_edge { } TEMP=side_edge
    if (stubMode!=3) {
       SELECT eol_ext INTERACT side_edge {} TEMP=err_eol
       EXTERNAL err_eol target_top {
          COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing ,crnKeepOut= sideStubExt um (mode = stubMode )"
          SPACING < temporary_1
          PARALLEL_POINT_PROJECTION=FALSE
          SET_CORNERS_TO_SPACING=FALSE
       } (23 )
    } else { /* stubMode == 3 */
       SELECT eol_ext INTERACT side_edge { RANGE = [2, 2] } TEMP=err_eol
       EXTERNAL err_eol target_top {
          COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 3)"
          SPACING < temporary_1
          PARALLEL_POINT_PROJECTION=FALSE
          SET_CORNERS_TO_SPACING=FALSE
       } (23 )
    }
  }
} /* stubMode > 0, not aligned */
/* Avoid empty optimization result parsing error */
if (addEmptyMetalCheck) {
   BOOLEAN empty OR empty {
      COMMENT = "$layer_name Empty: Dummy Output"
   } (23 )
   SET addEmptyMetalCheck=0;
}
/* reset variables */


 
SET minWidth = 0;
SET maxWidth = 0;
SET minArea = 0;
SET minEnclosedArea = 0;
SET minSpacing = 0;
SET sameNetMinSpacing = 0;
SET maxNumMinEdge = 0;
SET maxTotalMinEdgeLength = 0;
SET minEdgeLength = 0;
SET minEdgeLength2 = 0;
SET minEdgeLength3 = 0;
SET stubRange = 0;
SET stubSpacing = 0;
SET stub2StubSpacing = 0;
SET sideStubExt = 0;
SET sideStubThreshold = 0;
SET stubThreshold = 0;
SET fatPolyContactRule = 0;
SET fatWireThreshold = 0;
SET fatThinMinSpacing = 0;
SET fatFatMinSpacing = 0;
SET fatTblDimension = 0;
@ 807 "adrc/adrc.ev" 2

SET minSpacing = 0.056;
SET fatTblThresh_protru = 0.15;
SET fatTblLength_protru = 0.1;
SET fatTblWidth_protru = 0.06;
@ 1 "adrc/adrc_protru.ev" 1
/*protrusion length rule*/
SIZE metal7     { UNDER_OVER = fatTblThresh_protru / 2.0 - 0.0001  } TEMP = fat
BOOLEAN fat AND metal7  {  } TEMP = fat 
BOOLEAN metal7  NOT fat {  } TEMP = fat_nbr
SIZE fat { OVERSIZE = fatTblLength_protru + 0.0001  } TEMP = fat_ext
BOOLEAN fat_nbr AND fat_ext {} TEMP = fat_nbr
SELECT fat_nbr INTERACT fat TEMP = fat_nbr
/* Get the correct fat extension */
SELECT_EDGE fat_nbr TOUCHING fat { } TEMP = ext_filter
SIZE ext_filter { VSIZE_INSIDE = 0.0001  } TEMP = ext_filter
SIZE ext_filter INSIDE fat_nbr {
   OVERSIZE = fatTblLength_protru- 0.0001 
   INCREMENT = minSpacing
} TEMP=dummy TEMP = fat_nbr
  
VERTEX fat_nbr {
   CONCAVE = TRUE
   SIZE = 0.0002 
} TEMP = corners
SELECT fat_nbr OUTSIDE corners { } TEMP = fat_nbr1
BOOLEAN fat_nbr NOT fat_nbr1 { } TEMP = fat_nbr2
SELECT_CONTAINS fat_nbr1 {
   WIDTH =  0.0002 
   HEIGHT = fatTblLength_protru
} TEMP = good_fat_nbr1
BOOLEAN fat_nbr1 NOT good_fat_nbr1 { } TEMP = fat_nbr1
/* check with L or T shape of fat extension */
SELECT_EDGE fat_nbr2 INTERACT corners { } TEMP = side_edge
LENGTH side_edge { SPACING < fatTblLength_protru } TEMP = vio_edge
SELECT fat_nbr2 INTERACT vio_edge { } TEMP = fat_nbr2
BOOLEAN fat_nbr1 OR fat_nbr2 { } TEMP = fat_nbr
INTERAL fat_nbr {
   SPACING < fatTblWidth_protru
} TEMP = possible_err
if (!layer_empty(possible_err)) {
   SELECT fat_nbr INTERACT possible_err { } TEMP=fat_nbr
   SELECT fat INTERACT fat_nbr {} TEMP=fat
   BOOLEAN fat OR fat_nbr {} TEMP=fat
   INTERNAL fat {
      COMMENT = "$layer_name ProtrusionLength : threshold fatTblThresh_protru um, length  fatTblLength_protru um, width fatTblWidth_protru um"
      SPACING < fatTblWidth_protru
   } (23 )
}
/* protrusion leng rule check */
SET fatTblThresh_protru = 0;
SET fatTblLength_protru = 0;
SET fatTblWidth_protru = 0;
SET minSpacing = 0;
@ 812 "adrc/adrc.ev" 2


SET minSpacing = 0.056;
SET fatTblThresh_protru = 0.3;
SET fatTblLength_protru = 0.15;
SET fatTblWidth_protru = 0.07;
@ 1 "adrc/adrc_protru.ev" 1
/*protrusion length rule*/
SIZE metal7     { UNDER_OVER = fatTblThresh_protru / 2.0 - 0.0001  } TEMP = fat
BOOLEAN fat AND metal7  {  } TEMP = fat 
BOOLEAN metal7  NOT fat {  } TEMP = fat_nbr
SIZE fat { OVERSIZE = fatTblLength_protru + 0.0001  } TEMP = fat_ext
BOOLEAN fat_nbr AND fat_ext {} TEMP = fat_nbr
SELECT fat_nbr INTERACT fat TEMP = fat_nbr
/* Get the correct fat extension */
SELECT_EDGE fat_nbr TOUCHING fat { } TEMP = ext_filter
SIZE ext_filter { VSIZE_INSIDE = 0.0001  } TEMP = ext_filter
SIZE ext_filter INSIDE fat_nbr {
   OVERSIZE = fatTblLength_protru- 0.0001 
   INCREMENT = minSpacing
} TEMP=dummy TEMP = fat_nbr
  
VERTEX fat_nbr {
   CONCAVE = TRUE
   SIZE = 0.0002 
} TEMP = corners
SELECT fat_nbr OUTSIDE corners { } TEMP = fat_nbr1
BOOLEAN fat_nbr NOT fat_nbr1 { } TEMP = fat_nbr2
SELECT_CONTAINS fat_nbr1 {
   WIDTH =  0.0002 
   HEIGHT = fatTblLength_protru
} TEMP = good_fat_nbr1
BOOLEAN fat_nbr1 NOT good_fat_nbr1 { } TEMP = fat_nbr1
/* check with L or T shape of fat extension */
SELECT_EDGE fat_nbr2 INTERACT corners { } TEMP = side_edge
LENGTH side_edge { SPACING < fatTblLength_protru } TEMP = vio_edge
SELECT fat_nbr2 INTERACT vio_edge { } TEMP = fat_nbr2
BOOLEAN fat_nbr1 OR fat_nbr2 { } TEMP = fat_nbr
INTERAL fat_nbr {
   SPACING < fatTblWidth_protru
} TEMP = possible_err
if (!layer_empty(possible_err)) {
   SELECT fat_nbr INTERACT possible_err { } TEMP=fat_nbr
   SELECT fat INTERACT fat_nbr {} TEMP=fat
   BOOLEAN fat OR fat_nbr {} TEMP=fat
   INTERNAL fat {
      COMMENT = "$layer_name ProtrusionLength : threshold fatTblThresh_protru um, length  fatTblLength_protru um, width fatTblWidth_protru um"
      SPACING < fatTblWidth_protru
   } (23 )
}
/* protrusion leng rule check */
SET fatTblThresh_protru = 0;
SET fatTblLength_protru = 0;
SET fatTblWidth_protru = 0;
SET minSpacing = 0;
@ 818 "adrc/adrc.ev" 2


SET minSpacing = 0.056;
SET fatTblThresh_protru = 1.5;
SET fatTblLength_protru = 0.7;
SET fatTblWidth_protru = 0.15;
@ 1 "adrc/adrc_protru.ev" 1
/*protrusion length rule*/
SIZE metal7     { UNDER_OVER = fatTblThresh_protru / 2.0 - 0.0001  } TEMP = fat
BOOLEAN fat AND metal7  {  } TEMP = fat 
BOOLEAN metal7  NOT fat {  } TEMP = fat_nbr
SIZE fat { OVERSIZE = fatTblLength_protru + 0.0001  } TEMP = fat_ext
BOOLEAN fat_nbr AND fat_ext {} TEMP = fat_nbr
SELECT fat_nbr INTERACT fat TEMP = fat_nbr
/* Get the correct fat extension */
SELECT_EDGE fat_nbr TOUCHING fat { } TEMP = ext_filter
SIZE ext_filter { VSIZE_INSIDE = 0.0001  } TEMP = ext_filter
SIZE ext_filter INSIDE fat_nbr {
   OVERSIZE = fatTblLength_protru- 0.0001 
   INCREMENT = minSpacing
} TEMP=dummy TEMP = fat_nbr
  
VERTEX fat_nbr {
   CONCAVE = TRUE
   SIZE = 0.0002 
} TEMP = corners
SELECT fat_nbr OUTSIDE corners { } TEMP = fat_nbr1
BOOLEAN fat_nbr NOT fat_nbr1 { } TEMP = fat_nbr2
SELECT_CONTAINS fat_nbr1 {
   WIDTH =  0.0002 
   HEIGHT = fatTblLength_protru
} TEMP = good_fat_nbr1
BOOLEAN fat_nbr1 NOT good_fat_nbr1 { } TEMP = fat_nbr1
/* check with L or T shape of fat extension */
SELECT_EDGE fat_nbr2 INTERACT corners { } TEMP = side_edge
LENGTH side_edge { SPACING < fatTblLength_protru } TEMP = vio_edge
SELECT fat_nbr2 INTERACT vio_edge { } TEMP = fat_nbr2
BOOLEAN fat_nbr1 OR fat_nbr2 { } TEMP = fat_nbr
INTERAL fat_nbr {
   SPACING < fatTblWidth_protru
} TEMP = possible_err
if (!layer_empty(possible_err)) {
   SELECT fat_nbr INTERACT possible_err { } TEMP=fat_nbr
   SELECT fat INTERACT fat_nbr {} TEMP=fat
   BOOLEAN fat OR fat_nbr {} TEMP=fat
   INTERNAL fat {
      COMMENT = "$layer_name ProtrusionLength : threshold fatTblThresh_protru um, length  fatTblLength_protru um, width fatTblWidth_protru um"
      SPACING < fatTblWidth_protru
   } (23 )
}
/* protrusion leng rule check */
SET fatTblThresh_protru = 0;
SET fatTblLength_protru = 0;
SET fatTblWidth_protru = 0;
SET minSpacing = 0;
@ 824 "adrc/adrc.ev" 2


SET minSpacing = 0.056;
SET fatTblThresh_protru = 3;
SET fatTblLength_protru = 1.5;
SET fatTblWidth_protru = 0.3;
@ 1 "adrc/adrc_protru.ev" 1
/*protrusion length rule*/
SIZE metal7     { UNDER_OVER = fatTblThresh_protru / 2.0 - 0.0001  } TEMP = fat
BOOLEAN fat AND metal7  {  } TEMP = fat 
BOOLEAN metal7  NOT fat {  } TEMP = fat_nbr
SIZE fat { OVERSIZE = fatTblLength_protru + 0.0001  } TEMP = fat_ext
BOOLEAN fat_nbr AND fat_ext {} TEMP = fat_nbr
SELECT fat_nbr INTERACT fat TEMP = fat_nbr
/* Get the correct fat extension */
SELECT_EDGE fat_nbr TOUCHING fat { } TEMP = ext_filter
SIZE ext_filter { VSIZE_INSIDE = 0.0001  } TEMP = ext_filter
SIZE ext_filter INSIDE fat_nbr {
   OVERSIZE = fatTblLength_protru- 0.0001 
   INCREMENT = minSpacing
} TEMP=dummy TEMP = fat_nbr
  
VERTEX fat_nbr {
   CONCAVE = TRUE
   SIZE = 0.0002 
} TEMP = corners
SELECT fat_nbr OUTSIDE corners { } TEMP = fat_nbr1
BOOLEAN fat_nbr NOT fat_nbr1 { } TEMP = fat_nbr2
SELECT_CONTAINS fat_nbr1 {
   WIDTH =  0.0002 
   HEIGHT = fatTblLength_protru
} TEMP = good_fat_nbr1
BOOLEAN fat_nbr1 NOT good_fat_nbr1 { } TEMP = fat_nbr1
/* check with L or T shape of fat extension */
SELECT_EDGE fat_nbr2 INTERACT corners { } TEMP = side_edge
LENGTH side_edge { SPACING < fatTblLength_protru } TEMP = vio_edge
SELECT fat_nbr2 INTERACT vio_edge { } TEMP = fat_nbr2
BOOLEAN fat_nbr1 OR fat_nbr2 { } TEMP = fat_nbr
INTERAL fat_nbr {
   SPACING < fatTblWidth_protru
} TEMP = possible_err
if (!layer_empty(possible_err)) {
   SELECT fat_nbr INTERACT possible_err { } TEMP=fat_nbr
   SELECT fat INTERACT fat_nbr {} TEMP=fat
   BOOLEAN fat OR fat_nbr {} TEMP=fat
   INTERNAL fat {
      COMMENT = "$layer_name ProtrusionLength : threshold fatTblThresh_protru um, length  fatTblLength_protru um, width fatTblWidth_protru um"
      SPACING < fatTblWidth_protru
   } (23 )
}
/* protrusion leng rule check */
SET fatTblThresh_protru = 0;
SET fatTblLength_protru = 0;
SET fatTblWidth_protru = 0;
SET minSpacing = 0;
@ 830 "adrc/adrc.ev" 2





/* Start of Met7 fat table spacing rules */
SET fatTblSpacingMode = 0;
SET parallelLengthMode = 0;
SET router_parallelLengthNetMode = 0;

SET fatTblThreshold = 0.155;
SET fatTblParallelLength = 0.155;
SET minWidth = 0.056;

SET fatTblThreshold_Start = 0;
SET fatTblSpacing = 0.064;
@ 1 "adrc/adrc_fatMetal.ev" 1
/*check fat metal table*/
if (fatTblThreshold > 0) {
    if ((fatTblThreshold / 2.0) > 0.0001 ) {
       SIZE fat_candidate  { UNDER_OVER = fatTblThreshold / 2.0 - 0.0001  } TEMP = fat_candidate
       if (fatTblNextThreshold > 0) {
          SIZE fat_candidate { UNDER_OVER = fatTblNextThreshold / 2.0 - 0.0001  } TEMP = fat_next
          BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
          BOOLEAN fat AND fat_target { } TEMP = fat
          SET fatTblNextThreshold = 0;
       } else {
          BOOLEAN fat_candidate AND fat_target {  } TEMP = fat 
       }
    } else {
      COPY fat_target {  } TEMP = fat 
    }
    COPY fat_target { } TEMP = spc_target
    if (fatTblThreshold_Start > 0  || fatTblThreshold_End > 0) {
       if (fatTblThreshold_Start > 0) {
          SIZE fat_target { UNDER_OVER = fatTblThreshold_Start / 2.0 - 0.0001  } TEMP = spc_target
       }
       if (fatTblThreshold_End > 0 && fatTblThreshold_End > fatTblThreshold_Start) {
          SIZE spc_target { UNDER_OVER = fatTblThreshold_End / 2.0 - 0.0001  } TEMP = fat_end
          BOOLEAN spc_target NOT fat_end { } TEMP = spc_target
       }
       BOOLEAN spc_target AND fat_target {  } TEMP = spc_target
       if (ignoreBlockage == 0 && fatTblThreshold_Start < fatTblThreshold_1) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal7_blockage  {  } TEMP = spc_target
       }
       SET fatTblThreshold_Start = 0;
       SET fatTblThreshold_End = 0;
       SET fatTblThreshold_1 = 0;
    } else {
       if (ignoreBlockage == 0) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal7_blockage  {  } TEMP = spc_target
       }
    }
 
    if (fatTblEnclosedArea > 0) {
       SELECT holes INTERACT fat { } TEMP = fat_holes
       AREA fat_holes { 
          RANGE = [0.0001 * 0.0001 , fatTblEnclosedArea - 0.0001 * 0.0001 ]
       } TEMP = fat_holes
       if (fatTblMinEnclosedAreaMode==0) {
          SIZE fat_holes { OVER_UNDER = fatTblThreshold / 2.0 + 0.0001  } TEMP = ovun_holes
          SELECT ovun_holes INTERACT fat_holes { RANGE = [2, 9999999999 ] } TEMP = merged_holes
          BOOLEAN fat_candidate AND fat_target { } TEMP = fat_metal
          BOOLEAN metal7  NOT fat_metal { } TEMP = thin_metal
          BOOLEAN thin_metal NOT ovun_holes { } TEMP = thin_metal
          SELECT ovun_holes INTERACT thin_metal { } TEMP = thin_holes
          BOOLEAN thin_holes OR merged_holes { } TEMP = thin_holes
          BOOLEAN fat_holes NOT thin_holes { } TEMP = fat_holes
       }
       COPY fat_holes { 
	  COMMENT = "$layer_name EnclsArea : fat metal ( fatTblThreshold um) minimum enclosed area (mode fatTblMinEnclosedAreaMode ) = fatTblEnclosedArea um*um"
       } (23 )
       SET fatTblEnclosedArea = 0;
    }
    if (fatTblSpacing > 0) {
       /*check fat metal*/ 
       if (fatTblParallelLength > 0) {
          if (router_parallelLengthNetMode == 1 || parallelLengthMode == 1) {
             AREA spc_target { RANGE = [fatTblParallelLength * minWidth + 0.0001 , 9999999999 ] } TEMP = spc_target1
             COPY spc_target1 { } TEMP = spc_target2
          } else {
             COPY spc_target { } TEMP = spc_target2
          }
          if (parallelLengthMode == 1) {
             SELECT metal7  INTERACT fat { } TEMP = fat_all 
             BOOLEAN fat_all OR fat { } TEMP = fat2
             SELECT metal7  INTERACT spc_target2 { } TEMP = spc_target_all
             BOOLEAN spc_target_all OR spc_target2 { } TEMP = spc_target2
          } else {
             COPY fat { } TEMP = fat2
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING <= fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
                OUTPUT_EDGES = TRUE
             } TEMP = vio_edge
             SELECT vio_edge INTERACT fat { } TEMP = vio_edge
             SELECT vio_edge INTERACT spc_target1 { } TEMP = vio_edge
             SELECT violation INTERACT vio_edge { } TEMP = violation
          } else {
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
          }
          BOOLEAN violation NOT fat_target { } TEMP = violation
          if (fatTblParallelLength < fatTblSpacing) {
             SELECT_EDGE violation TOUCHING fat2 {
                VSIZE_INSIDE = fatTblParallelLength - 0.0002 
             } TEMP = vio_filter
             SELECT_CONTAINS vio_filter { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = vio_filter
             SELECT violation INTERACT vio_filter { } TEMP = violation
          } else {
             SELECT_CONTAINS violation { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = violation
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING = [fatTblSpacing, fatTblSpacing]
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
             } TEMP = violation3
             BOOLEAN violation3 NOT fat_target { } TEMP = violation3
             BOOLEAN violation NOT violation3 { } TEMP= violation
          }
          SELECT_EDGE fat2 TOUCHING violation { } TEMP=fat_viol
          BOOLEAN fat_viol AND violation { } TEMP=fat_viol
          SELECT_EDGE spc_target2 TOUCHING violation { } TEMP=spc_target2
          BOOLEAN spc_target2 AND violation { } TEMP= spc_target2
	  if (ignoreChildCell == 1) {
             EXTERNAL fat_viol spc_target2 {
		SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		TOUCH = FALSE
		POINT_TOUCH = FALSE
		NON_PARALLEL = TRUE
	     } TEMP = spc_mode0_out
             BOOLEAN spc_mode0_out NOT spc_mode0_child_out { } TEMP = spc_mode0_diff_out
             SELECT spc_mode0_out INTERACT spc_mode0_diff_out { } TEMP = spc_mode0_out
	     SELECT_EDGE fat2 TOUCHING spc_mode0_out { } TEMP=fat_viol
	     BOOLEAN fat_viol AND spc_mode0_out { } TEMP=fat_viol
	     SELECT_EDGE spc_target2 TOUCHING spc_mode0_out { } TEMP=spc_target2
	     BOOLEAN spc_target2 AND spc_mode0_out { } TEMP=spc_target2
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (23 )  		
	  } else {
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing 
	        SET_CORNERS_TO_SPACING = FALSE
	        PARALLEL_POINT_PROJECTION = FALSE
	        TOUCH = FALSE
	        POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (23 )
	  }
	  if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	     if (ignoreChildCell == 1) {
		EXTERNAL fat spc_target {
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} TEMP = spc_mode1_out
	        BOOLEAN spc_mode1_out NOT spc_mode1_child_out { } TEMP = spc_mode1_diff_out
	        SELECT spc_mode1_out INTERACT spc_mode1_diff_out { } TEMP = spc_mode1_out
                SELECT_EDGE fat TOUCHING spc_mode1_out { } TEMP=fat_viol
	        BOOLEAN fat_viol AND spc_mode1_out { } TEMP=fat_viol
	        SELECT_EDGE spc_target TOUCHING spc_mode1_out { } TEMP=spc_target2
	        BOOLEAN spc_target2 AND spc_mode1_out { } TEMP=spc_target2
	        EXTERNAL fat_viol spc_target2 {
	           COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um " 	    
		   SPACING < fatTblSpacing_dg
                   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} (23 )
	     } else {
	        EXTERNAL fat spc_target {
		   COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um "
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
	    	   PARALLEL_POINT_PROJECTION = FALSE
	           TOUCH = FALSE
	     	   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } (23 ) 
	     }
          }
       } else {
	  if (ignoreChildCell == 1) {
              EXTERNAL fat spc_target {
                 SPACING < fatTblSpacing
                 BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
              } TEMP = spc_out
	      BOOLEAN spc_out NOT spc_child_out { } TEMP = spc_diff_out
	      SELECT spc_out INTERACT spc_diff_out { } TEMP = spc_out
	      SELECT_EDGE fat TOUCHING spc_out { } TEMP=fat_viol
	      BOOLEAN fat_viol AND spc_out { } TEMP=fat_viol
              SELECT_EDGE spc_target TOUCHING spc_out { } TEMP=spc_target2
	      BOOLEAN spc_target2 AND spc_out { } TEMP=spc_target2
	      EXTERNAL fat_viol spc_target2 {
		 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
		 BOX_CORNER = FALSE 
		 NON_PARALLEL = TRUE
		 POINT_TOUCH = FALSE
	      } (23 ) 
	  } else {
	      EXTERNAL fat spc_target {
                 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
	         BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
	      } (23 ) 
	  }
       }
       /*check metal in the extension range*/ 
       if (fatTblExtensionRange > 0) {
	  if (fatWireExtensionMode == 0) {
	     SIZE fat { OVERSIZE = fatTblExtensionRange } TEMP = fat_tmp
             BOOLEAN fat_tmp AND metal7  { } TEMP = fat_tmp
  	     BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
             SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_ext
             BOOLEAN fat_ext OR fat { } TEMP = fat_ext
	     if (fatTblParallelLength > 0) {
                if (fatTblParallelLength > fatTblExtensionRange) {
                   SIZE fat { OVERSIZE = fatTblParallelLength } TEMP = fat_tmp
                   BOOLEAN fat_tmp AND metal7  { } TEMP = fat_tmp
  	           BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
                   SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_parallel
                   BOOLEAN fat_parallel OR fat { } TEMP = fat_parallel
                } else {
                   COPY fat_ext { } TEMP = fat_parallel
                }
		EXTERNAL fat_parallel spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
	           NON_PARALLEL = TRUE
	        } TEMP = vio_filter_set
		EXTERNAL fat_ext spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } TEMP = vio_set
                if (fatTblParallelLength < fatTblSpacing) {
                   SELECT_EDGE vio_filter_set TOUCHING fat_parallel {
                      VSIZE_INSIDE = fatTblParallelLength - 0.0002 
                   } TEMP = vio_filter_set_filter
                   SELECT_CONTAINS vio_filter_set_filter { 
                      WIDTH =  0.0002 
                      HEIGHT = fatTblParallelLength + 0.0001 
                   } TEMP = vio_filter_set_filter
                   SELECT vio_filter_set INTERACT vio_filter_set_filter { } TEMP = vio_filter
                } else {
	           SELECT_CONTAINS vio_filter_set { 
	              WIDTH =  0.0002 
	              HEIGHT = fatTblParallelLength + 0.0001 
	           } TEMP = vio_filter
                }
                SELECT vio_set INSIDE vio_filter { } TEMP = mode0_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out1 NOT mode0_child_out1 { } TEMP = mode0_diff_out1
                   SELECT mode0_out1 INTERACT mode0_diff_out1 { } TEMP = mode0_out1
                }
                COPY mode0_out1 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing  = fatTblSpacing um"
                } (23 )
		if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	           EXTERNAL fat_ext spc_target {
		      SPACING < fatTblSpacing_dg
	              SET_CORNERS_TO_SPACING = FALSE
		      PARALLEL_POINT_PROJECTION = FALSE
		      TOUCH = TRUE
		      POINT_TOUCH = FALSE
		      NON_PARALLEL = TRUE
	           } TEMP = mode0_out2
                   if (ignoreChildCell == 1) {
                      BOOLEAN mode0_out2 NOT mode0_child_out2 { } TEMP = mode0_diff_out2
                      SELECT mode0_out2 INTERACT mode0_diff_out2 { } TEMP = mode0_out2
                   }
                   COPY mode0_out2 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing (mode 1/2) = fatTblSpacing um/ fatTblSpacing_dg um "
                   } (23 )
	        } 
	     } else {
	        EXTERNAL fat_ext spc_target {
		   SPACING < fatTblSpacing
		   NON_PARALLEL = TRUE
		   SET_CORNERS_TO_SPACING = FALSE
		   POINT_TOUCH = FALSE
		} TEMP = mode0_out3
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out3 NOT mode0_child_out3 { } TEMP = mode0_diff_out3
                   SELECT mode0_out3 INTERACT mode0_diff_out3 { } TEMP = mode0_out3
                }
                COPY mode0_out3 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range ( fatTblExtensionRange um) minimum spacing = fatTblSpacing um"
                } (23 )
	     }
	  } else if (fatWireExtensionMode == 1) {
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal7  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             if (fatTblParallelLength > 0) {
                EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
		   BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   CHECK_SAME_POLYGON = TRUE 
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
	        SELECT fat_ext INTERACT spacing {  } TEMP = fat_ext
		BOOLEAN fat_ext OR spacing {  } TEMP = combined_fat_ext
                EXTERNAL combined_fat_ext fat {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
                } TEMP = fat_spacing
		BOOLEAN fat_spacing AND fat_ran {  } TEMP = fat_spacing
		BOOLEAN combined_fat_ext OR fat_spacing {  } TEMP = combined_fat_ext
                SELECT_CONTAINS combined_fat_ext { 
                   WIDTH =  0.0002 
                   HEIGHT = fatTblParallelLength + 0.0001 
                } TEMP = combined_fat_ext
		SELECT spacing INTERACT combined_fat_ext { 
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out1 NOT mode1_child_out1 { } TEMP = mode1_diff_out1
                   SELECT mode1_out1 INTERACT mode1_diff_out1 { } TEMP = mode1_out1 
                }
                COPY mode1_out1 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (23 ) 
	     } else {
               	EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
	           BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
	           CHECK_SAME_POLYGON = TRUE 
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
                SELECT spacing INTERACT fat_ext {
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out2
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out2 NOT mode1_child_out2 { } TEMP = mode1_diff_out2
                   SELECT mode1_out2 INTERACT mode1_diff_out2 { } TEMP = mode1_out2
                }
                COPY mode1_out2 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (23 )
	     }
	  } else if (fatWireExtensionMode == 2) {
	     SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
             BOOLEAN fat_ran AND metal7  {  } TEMP = fat_ext
             BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	      	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
             } TEMP = spacing
 	     SELECT spacing INSIDE fat_ran {  } TEMP = spacing
	     SELECT spacing OUTSIDE fat {  } TEMP = spacing
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode2_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode2_out NOT mode2_child_out { } TEMP = mode2_diff_out
                SELECT mode2_out INTERACT mode2_diff_out { } TEMP = mode2_out 
             }
             COPY mode2_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 2, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (23 )
	  } else if (fatWireExtensionMode == 3) {
             SIZE fat {
	        GROW_LEFT = fatTblExtensionRange
	        GROW_RIGHT = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal7  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	       	PARALLEL = TRUE

	       	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		HORIZONTAL_ONLY = TRUE
             } TEMP = spacing_hor
	     SELECT spacing_hor INSIDE fat_ran {  } TEMP = spacing_hor
	     SELECT spacing_hor OUTSIDE fat {  } TEMP = spacing_hor
             SIZE fat {
	        GROW_TOP = fatTblExtensionRange
	        GROW_BOTTOM = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal7  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	        POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		VERTICAL_ONLY = TRUE
             } TEMP = spacing_ver
	     SELECT spacing_ver INSIDE fat_ran {  } TEMP = spacing_ver
	     SELECT spacing_ver OUTSIDE fat {  } TEMP = spacing_ver
  	     BOOLEAN spacing_hor OR spacing_ver {  } TEMP = spacing
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal7  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
  	     /* check overlapped projection length */
 	     if (fatTblParallelLength > 0) {
                POLYGON_FEATURES fat_ext {
                   EQUATIONS {
                      vnum = EV_VNUM_IN;
                      if ( vnum > 0) {
                         bdLeft = EV_VXCOORD_IN[0];
                         bdRight = EV_VXCOORD_IN[0];
                         bdBottom = EV_VYCOORD_IN[0];
                         bdTop = EV_VYCOORD_IN[0];
                         FOR (i = 1; i < vnum; i++) {
                            if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
                            else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
                            if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
                            else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
                         } /* FOR i */
                         if ( (bdRight - bdLeft) >= fatTblParallelLength ||
                  	      (bdTop - bdBottom) >= fatTblParallelLength) {
                            FOR (i = 0; i < vnum; i++) {
                               EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
                               EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
                            }
                            EV_VNUM_OUT = vnum;
                 	    EV_SAVE_POLYGON();
                         }
                      }
                   }
                } TEMP = fat_ext /* POLYGON_FEATURE */
             }
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode3_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode3_out NOT mode3_child_out { } TEMP = mode3_diff_out
                SELECT mode3_out INTERACT mode3_diff_out { } TEMP = mode3_out
             }
             COPY mode3_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 3, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (23 )
          }
       }
       SET fatTblSpacing = 0;
    }
}
@ 846 "adrc/adrc.ev" 2


SET fatTblThreshold = 0.305;
SET fatTblParallelLength = 0.305;
SET minWidth = 0.056;

SET fatTblThreshold_Start = 0;
SET fatTblSpacing = 0.12;
@ 1 "adrc/adrc_fatMetal.ev" 1
/*check fat metal table*/
if (fatTblThreshold > 0) {
    if ((fatTblThreshold / 2.0) > 0.0001 ) {
       SIZE fat_candidate  { UNDER_OVER = fatTblThreshold / 2.0 - 0.0001  } TEMP = fat_candidate
       if (fatTblNextThreshold > 0) {
          SIZE fat_candidate { UNDER_OVER = fatTblNextThreshold / 2.0 - 0.0001  } TEMP = fat_next
          BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
          BOOLEAN fat AND fat_target { } TEMP = fat
          SET fatTblNextThreshold = 0;
       } else {
          BOOLEAN fat_candidate AND fat_target {  } TEMP = fat 
       }
    } else {
      COPY fat_target {  } TEMP = fat 
    }
    COPY fat_target { } TEMP = spc_target
    if (fatTblThreshold_Start > 0  || fatTblThreshold_End > 0) {
       if (fatTblThreshold_Start > 0) {
          SIZE fat_target { UNDER_OVER = fatTblThreshold_Start / 2.0 - 0.0001  } TEMP = spc_target
       }
       if (fatTblThreshold_End > 0 && fatTblThreshold_End > fatTblThreshold_Start) {
          SIZE spc_target { UNDER_OVER = fatTblThreshold_End / 2.0 - 0.0001  } TEMP = fat_end
          BOOLEAN spc_target NOT fat_end { } TEMP = spc_target
       }
       BOOLEAN spc_target AND fat_target {  } TEMP = spc_target
       if (ignoreBlockage == 0 && fatTblThreshold_Start < fatTblThreshold_1) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal7_blockage  {  } TEMP = spc_target
       }
       SET fatTblThreshold_Start = 0;
       SET fatTblThreshold_End = 0;
       SET fatTblThreshold_1 = 0;
    } else {
       if (ignoreBlockage == 0) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal7_blockage  {  } TEMP = spc_target
       }
    }
 
    if (fatTblEnclosedArea > 0) {
       SELECT holes INTERACT fat { } TEMP = fat_holes
       AREA fat_holes { 
          RANGE = [0.0001 * 0.0001 , fatTblEnclosedArea - 0.0001 * 0.0001 ]
       } TEMP = fat_holes
       if (fatTblMinEnclosedAreaMode==0) {
          SIZE fat_holes { OVER_UNDER = fatTblThreshold / 2.0 + 0.0001  } TEMP = ovun_holes
          SELECT ovun_holes INTERACT fat_holes { RANGE = [2, 9999999999 ] } TEMP = merged_holes
          BOOLEAN fat_candidate AND fat_target { } TEMP = fat_metal
          BOOLEAN metal7  NOT fat_metal { } TEMP = thin_metal
          BOOLEAN thin_metal NOT ovun_holes { } TEMP = thin_metal
          SELECT ovun_holes INTERACT thin_metal { } TEMP = thin_holes
          BOOLEAN thin_holes OR merged_holes { } TEMP = thin_holes
          BOOLEAN fat_holes NOT thin_holes { } TEMP = fat_holes
       }
       COPY fat_holes { 
	  COMMENT = "$layer_name EnclsArea : fat metal ( fatTblThreshold um) minimum enclosed area (mode fatTblMinEnclosedAreaMode ) = fatTblEnclosedArea um*um"
       } (23 )
       SET fatTblEnclosedArea = 0;
    }
    if (fatTblSpacing > 0) {
       /*check fat metal*/ 
       if (fatTblParallelLength > 0) {
          if (router_parallelLengthNetMode == 1 || parallelLengthMode == 1) {
             AREA spc_target { RANGE = [fatTblParallelLength * minWidth + 0.0001 , 9999999999 ] } TEMP = spc_target1
             COPY spc_target1 { } TEMP = spc_target2
          } else {
             COPY spc_target { } TEMP = spc_target2
          }
          if (parallelLengthMode == 1) {
             SELECT metal7  INTERACT fat { } TEMP = fat_all 
             BOOLEAN fat_all OR fat { } TEMP = fat2
             SELECT metal7  INTERACT spc_target2 { } TEMP = spc_target_all
             BOOLEAN spc_target_all OR spc_target2 { } TEMP = spc_target2
          } else {
             COPY fat { } TEMP = fat2
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING <= fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
                OUTPUT_EDGES = TRUE
             } TEMP = vio_edge
             SELECT vio_edge INTERACT fat { } TEMP = vio_edge
             SELECT vio_edge INTERACT spc_target1 { } TEMP = vio_edge
             SELECT violation INTERACT vio_edge { } TEMP = violation
          } else {
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
          }
          BOOLEAN violation NOT fat_target { } TEMP = violation
          if (fatTblParallelLength < fatTblSpacing) {
             SELECT_EDGE violation TOUCHING fat2 {
                VSIZE_INSIDE = fatTblParallelLength - 0.0002 
             } TEMP = vio_filter
             SELECT_CONTAINS vio_filter { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = vio_filter
             SELECT violation INTERACT vio_filter { } TEMP = violation
          } else {
             SELECT_CONTAINS violation { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = violation
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING = [fatTblSpacing, fatTblSpacing]
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
             } TEMP = violation3
             BOOLEAN violation3 NOT fat_target { } TEMP = violation3
             BOOLEAN violation NOT violation3 { } TEMP= violation
          }
          SELECT_EDGE fat2 TOUCHING violation { } TEMP=fat_viol
          BOOLEAN fat_viol AND violation { } TEMP=fat_viol
          SELECT_EDGE spc_target2 TOUCHING violation { } TEMP=spc_target2
          BOOLEAN spc_target2 AND violation { } TEMP= spc_target2
	  if (ignoreChildCell == 1) {
             EXTERNAL fat_viol spc_target2 {
		SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		TOUCH = FALSE
		POINT_TOUCH = FALSE
		NON_PARALLEL = TRUE
	     } TEMP = spc_mode0_out
             BOOLEAN spc_mode0_out NOT spc_mode0_child_out { } TEMP = spc_mode0_diff_out
             SELECT spc_mode0_out INTERACT spc_mode0_diff_out { } TEMP = spc_mode0_out
	     SELECT_EDGE fat2 TOUCHING spc_mode0_out { } TEMP=fat_viol
	     BOOLEAN fat_viol AND spc_mode0_out { } TEMP=fat_viol
	     SELECT_EDGE spc_target2 TOUCHING spc_mode0_out { } TEMP=spc_target2
	     BOOLEAN spc_target2 AND spc_mode0_out { } TEMP=spc_target2
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (23 )  		
	  } else {
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing 
	        SET_CORNERS_TO_SPACING = FALSE
	        PARALLEL_POINT_PROJECTION = FALSE
	        TOUCH = FALSE
	        POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (23 )
	  }
	  if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	     if (ignoreChildCell == 1) {
		EXTERNAL fat spc_target {
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} TEMP = spc_mode1_out
	        BOOLEAN spc_mode1_out NOT spc_mode1_child_out { } TEMP = spc_mode1_diff_out
	        SELECT spc_mode1_out INTERACT spc_mode1_diff_out { } TEMP = spc_mode1_out
                SELECT_EDGE fat TOUCHING spc_mode1_out { } TEMP=fat_viol
	        BOOLEAN fat_viol AND spc_mode1_out { } TEMP=fat_viol
	        SELECT_EDGE spc_target TOUCHING spc_mode1_out { } TEMP=spc_target2
	        BOOLEAN spc_target2 AND spc_mode1_out { } TEMP=spc_target2
	        EXTERNAL fat_viol spc_target2 {
	           COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um " 	    
		   SPACING < fatTblSpacing_dg
                   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} (23 )
	     } else {
	        EXTERNAL fat spc_target {
		   COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um "
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
	    	   PARALLEL_POINT_PROJECTION = FALSE
	           TOUCH = FALSE
	     	   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } (23 ) 
	     }
          }
       } else {
	  if (ignoreChildCell == 1) {
              EXTERNAL fat spc_target {
                 SPACING < fatTblSpacing
                 BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
              } TEMP = spc_out
	      BOOLEAN spc_out NOT spc_child_out { } TEMP = spc_diff_out
	      SELECT spc_out INTERACT spc_diff_out { } TEMP = spc_out
	      SELECT_EDGE fat TOUCHING spc_out { } TEMP=fat_viol
	      BOOLEAN fat_viol AND spc_out { } TEMP=fat_viol
              SELECT_EDGE spc_target TOUCHING spc_out { } TEMP=spc_target2
	      BOOLEAN spc_target2 AND spc_out { } TEMP=spc_target2
	      EXTERNAL fat_viol spc_target2 {
		 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
		 BOX_CORNER = FALSE 
		 NON_PARALLEL = TRUE
		 POINT_TOUCH = FALSE
	      } (23 ) 
	  } else {
	      EXTERNAL fat spc_target {
                 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
	         BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
	      } (23 ) 
	  }
       }
       /*check metal in the extension range*/ 
       if (fatTblExtensionRange > 0) {
	  if (fatWireExtensionMode == 0) {
	     SIZE fat { OVERSIZE = fatTblExtensionRange } TEMP = fat_tmp
             BOOLEAN fat_tmp AND metal7  { } TEMP = fat_tmp
  	     BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
             SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_ext
             BOOLEAN fat_ext OR fat { } TEMP = fat_ext
	     if (fatTblParallelLength > 0) {
                if (fatTblParallelLength > fatTblExtensionRange) {
                   SIZE fat { OVERSIZE = fatTblParallelLength } TEMP = fat_tmp
                   BOOLEAN fat_tmp AND metal7  { } TEMP = fat_tmp
  	           BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
                   SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_parallel
                   BOOLEAN fat_parallel OR fat { } TEMP = fat_parallel
                } else {
                   COPY fat_ext { } TEMP = fat_parallel
                }
		EXTERNAL fat_parallel spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
	           NON_PARALLEL = TRUE
	        } TEMP = vio_filter_set
		EXTERNAL fat_ext spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } TEMP = vio_set
                if (fatTblParallelLength < fatTblSpacing) {
                   SELECT_EDGE vio_filter_set TOUCHING fat_parallel {
                      VSIZE_INSIDE = fatTblParallelLength - 0.0002 
                   } TEMP = vio_filter_set_filter
                   SELECT_CONTAINS vio_filter_set_filter { 
                      WIDTH =  0.0002 
                      HEIGHT = fatTblParallelLength + 0.0001 
                   } TEMP = vio_filter_set_filter
                   SELECT vio_filter_set INTERACT vio_filter_set_filter { } TEMP = vio_filter
                } else {
	           SELECT_CONTAINS vio_filter_set { 
	              WIDTH =  0.0002 
	              HEIGHT = fatTblParallelLength + 0.0001 
	           } TEMP = vio_filter
                }
                SELECT vio_set INSIDE vio_filter { } TEMP = mode0_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out1 NOT mode0_child_out1 { } TEMP = mode0_diff_out1
                   SELECT mode0_out1 INTERACT mode0_diff_out1 { } TEMP = mode0_out1
                }
                COPY mode0_out1 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing  = fatTblSpacing um"
                } (23 )
		if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	           EXTERNAL fat_ext spc_target {
		      SPACING < fatTblSpacing_dg
	              SET_CORNERS_TO_SPACING = FALSE
		      PARALLEL_POINT_PROJECTION = FALSE
		      TOUCH = TRUE
		      POINT_TOUCH = FALSE
		      NON_PARALLEL = TRUE
	           } TEMP = mode0_out2
                   if (ignoreChildCell == 1) {
                      BOOLEAN mode0_out2 NOT mode0_child_out2 { } TEMP = mode0_diff_out2
                      SELECT mode0_out2 INTERACT mode0_diff_out2 { } TEMP = mode0_out2
                   }
                   COPY mode0_out2 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing (mode 1/2) = fatTblSpacing um/ fatTblSpacing_dg um "
                   } (23 )
	        } 
	     } else {
	        EXTERNAL fat_ext spc_target {
		   SPACING < fatTblSpacing
		   NON_PARALLEL = TRUE
		   SET_CORNERS_TO_SPACING = FALSE
		   POINT_TOUCH = FALSE
		} TEMP = mode0_out3
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out3 NOT mode0_child_out3 { } TEMP = mode0_diff_out3
                   SELECT mode0_out3 INTERACT mode0_diff_out3 { } TEMP = mode0_out3
                }
                COPY mode0_out3 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range ( fatTblExtensionRange um) minimum spacing = fatTblSpacing um"
                } (23 )
	     }
	  } else if (fatWireExtensionMode == 1) {
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal7  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             if (fatTblParallelLength > 0) {
                EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
		   BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   CHECK_SAME_POLYGON = TRUE 
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
	        SELECT fat_ext INTERACT spacing {  } TEMP = fat_ext
		BOOLEAN fat_ext OR spacing {  } TEMP = combined_fat_ext
                EXTERNAL combined_fat_ext fat {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
                } TEMP = fat_spacing
		BOOLEAN fat_spacing AND fat_ran {  } TEMP = fat_spacing
		BOOLEAN combined_fat_ext OR fat_spacing {  } TEMP = combined_fat_ext
                SELECT_CONTAINS combined_fat_ext { 
                   WIDTH =  0.0002 
                   HEIGHT = fatTblParallelLength + 0.0001 
                } TEMP = combined_fat_ext
		SELECT spacing INTERACT combined_fat_ext { 
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out1 NOT mode1_child_out1 { } TEMP = mode1_diff_out1
                   SELECT mode1_out1 INTERACT mode1_diff_out1 { } TEMP = mode1_out1 
                }
                COPY mode1_out1 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (23 ) 
	     } else {
               	EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
	           BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
	           CHECK_SAME_POLYGON = TRUE 
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
                SELECT spacing INTERACT fat_ext {
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out2
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out2 NOT mode1_child_out2 { } TEMP = mode1_diff_out2
                   SELECT mode1_out2 INTERACT mode1_diff_out2 { } TEMP = mode1_out2
                }
                COPY mode1_out2 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (23 )
	     }
	  } else if (fatWireExtensionMode == 2) {
	     SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
             BOOLEAN fat_ran AND metal7  {  } TEMP = fat_ext
             BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	      	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
             } TEMP = spacing
 	     SELECT spacing INSIDE fat_ran {  } TEMP = spacing
	     SELECT spacing OUTSIDE fat {  } TEMP = spacing
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode2_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode2_out NOT mode2_child_out { } TEMP = mode2_diff_out
                SELECT mode2_out INTERACT mode2_diff_out { } TEMP = mode2_out 
             }
             COPY mode2_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 2, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (23 )
	  } else if (fatWireExtensionMode == 3) {
             SIZE fat {
	        GROW_LEFT = fatTblExtensionRange
	        GROW_RIGHT = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal7  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	       	PARALLEL = TRUE

	       	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		HORIZONTAL_ONLY = TRUE
             } TEMP = spacing_hor
	     SELECT spacing_hor INSIDE fat_ran {  } TEMP = spacing_hor
	     SELECT spacing_hor OUTSIDE fat {  } TEMP = spacing_hor
             SIZE fat {
	        GROW_TOP = fatTblExtensionRange
	        GROW_BOTTOM = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal7  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	        POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		VERTICAL_ONLY = TRUE
             } TEMP = spacing_ver
	     SELECT spacing_ver INSIDE fat_ran {  } TEMP = spacing_ver
	     SELECT spacing_ver OUTSIDE fat {  } TEMP = spacing_ver
  	     BOOLEAN spacing_hor OR spacing_ver {  } TEMP = spacing
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal7  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
  	     /* check overlapped projection length */
 	     if (fatTblParallelLength > 0) {
                POLYGON_FEATURES fat_ext {
                   EQUATIONS {
                      vnum = EV_VNUM_IN;
                      if ( vnum > 0) {
                         bdLeft = EV_VXCOORD_IN[0];
                         bdRight = EV_VXCOORD_IN[0];
                         bdBottom = EV_VYCOORD_IN[0];
                         bdTop = EV_VYCOORD_IN[0];
                         FOR (i = 1; i < vnum; i++) {
                            if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
                            else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
                            if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
                            else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
                         } /* FOR i */
                         if ( (bdRight - bdLeft) >= fatTblParallelLength ||
                  	      (bdTop - bdBottom) >= fatTblParallelLength) {
                            FOR (i = 0; i < vnum; i++) {
                               EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
                               EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
                            }
                            EV_VNUM_OUT = vnum;
                 	    EV_SAVE_POLYGON();
                         }
                      }
                   }
                } TEMP = fat_ext /* POLYGON_FEATURE */
             }
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode3_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode3_out NOT mode3_child_out { } TEMP = mode3_diff_out
                SELECT mode3_out INTERACT mode3_diff_out { } TEMP = mode3_out
             }
             COPY mode3_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 3, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (23 )
          }
       }
       SET fatTblSpacing = 0;
    }
}
@ 854 "adrc/adrc.ev" 2


SET fatTblThreshold = 1.505;
SET fatTblParallelLength = 1.505;
SET minWidth = 0.056;

SET fatTblThreshold_Start = 0;
SET fatTblSpacing = 0.6;
@ 1 "adrc/adrc_fatMetal.ev" 1
/*check fat metal table*/
if (fatTblThreshold > 0) {
    if ((fatTblThreshold / 2.0) > 0.0001 ) {
       SIZE fat_candidate  { UNDER_OVER = fatTblThreshold / 2.0 - 0.0001  } TEMP = fat_candidate
       if (fatTblNextThreshold > 0) {
          SIZE fat_candidate { UNDER_OVER = fatTblNextThreshold / 2.0 - 0.0001  } TEMP = fat_next
          BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
          BOOLEAN fat AND fat_target { } TEMP = fat
          SET fatTblNextThreshold = 0;
       } else {
          BOOLEAN fat_candidate AND fat_target {  } TEMP = fat 
       }
    } else {
      COPY fat_target {  } TEMP = fat 
    }
    COPY fat_target { } TEMP = spc_target
    if (fatTblThreshold_Start > 0  || fatTblThreshold_End > 0) {
       if (fatTblThreshold_Start > 0) {
          SIZE fat_target { UNDER_OVER = fatTblThreshold_Start / 2.0 - 0.0001  } TEMP = spc_target
       }
       if (fatTblThreshold_End > 0 && fatTblThreshold_End > fatTblThreshold_Start) {
          SIZE spc_target { UNDER_OVER = fatTblThreshold_End / 2.0 - 0.0001  } TEMP = fat_end
          BOOLEAN spc_target NOT fat_end { } TEMP = spc_target
       }
       BOOLEAN spc_target AND fat_target {  } TEMP = spc_target
       if (ignoreBlockage == 0 && fatTblThreshold_Start < fatTblThreshold_1) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal7_blockage  {  } TEMP = spc_target
       }
       SET fatTblThreshold_Start = 0;
       SET fatTblThreshold_End = 0;
       SET fatTblThreshold_1 = 0;
    } else {
       if (ignoreBlockage == 0) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal7_blockage  {  } TEMP = spc_target
       }
    }
 
    if (fatTblEnclosedArea > 0) {
       SELECT holes INTERACT fat { } TEMP = fat_holes
       AREA fat_holes { 
          RANGE = [0.0001 * 0.0001 , fatTblEnclosedArea - 0.0001 * 0.0001 ]
       } TEMP = fat_holes
       if (fatTblMinEnclosedAreaMode==0) {
          SIZE fat_holes { OVER_UNDER = fatTblThreshold / 2.0 + 0.0001  } TEMP = ovun_holes
          SELECT ovun_holes INTERACT fat_holes { RANGE = [2, 9999999999 ] } TEMP = merged_holes
          BOOLEAN fat_candidate AND fat_target { } TEMP = fat_metal
          BOOLEAN metal7  NOT fat_metal { } TEMP = thin_metal
          BOOLEAN thin_metal NOT ovun_holes { } TEMP = thin_metal
          SELECT ovun_holes INTERACT thin_metal { } TEMP = thin_holes
          BOOLEAN thin_holes OR merged_holes { } TEMP = thin_holes
          BOOLEAN fat_holes NOT thin_holes { } TEMP = fat_holes
       }
       COPY fat_holes { 
	  COMMENT = "$layer_name EnclsArea : fat metal ( fatTblThreshold um) minimum enclosed area (mode fatTblMinEnclosedAreaMode ) = fatTblEnclosedArea um*um"
       } (23 )
       SET fatTblEnclosedArea = 0;
    }
    if (fatTblSpacing > 0) {
       /*check fat metal*/ 
       if (fatTblParallelLength > 0) {
          if (router_parallelLengthNetMode == 1 || parallelLengthMode == 1) {
             AREA spc_target { RANGE = [fatTblParallelLength * minWidth + 0.0001 , 9999999999 ] } TEMP = spc_target1
             COPY spc_target1 { } TEMP = spc_target2
          } else {
             COPY spc_target { } TEMP = spc_target2
          }
          if (parallelLengthMode == 1) {
             SELECT metal7  INTERACT fat { } TEMP = fat_all 
             BOOLEAN fat_all OR fat { } TEMP = fat2
             SELECT metal7  INTERACT spc_target2 { } TEMP = spc_target_all
             BOOLEAN spc_target_all OR spc_target2 { } TEMP = spc_target2
          } else {
             COPY fat { } TEMP = fat2
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING <= fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
                OUTPUT_EDGES = TRUE
             } TEMP = vio_edge
             SELECT vio_edge INTERACT fat { } TEMP = vio_edge
             SELECT vio_edge INTERACT spc_target1 { } TEMP = vio_edge
             SELECT violation INTERACT vio_edge { } TEMP = violation
          } else {
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
          }
          BOOLEAN violation NOT fat_target { } TEMP = violation
          if (fatTblParallelLength < fatTblSpacing) {
             SELECT_EDGE violation TOUCHING fat2 {
                VSIZE_INSIDE = fatTblParallelLength - 0.0002 
             } TEMP = vio_filter
             SELECT_CONTAINS vio_filter { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = vio_filter
             SELECT violation INTERACT vio_filter { } TEMP = violation
          } else {
             SELECT_CONTAINS violation { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = violation
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING = [fatTblSpacing, fatTblSpacing]
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
             } TEMP = violation3
             BOOLEAN violation3 NOT fat_target { } TEMP = violation3
             BOOLEAN violation NOT violation3 { } TEMP= violation
          }
          SELECT_EDGE fat2 TOUCHING violation { } TEMP=fat_viol
          BOOLEAN fat_viol AND violation { } TEMP=fat_viol
          SELECT_EDGE spc_target2 TOUCHING violation { } TEMP=spc_target2
          BOOLEAN spc_target2 AND violation { } TEMP= spc_target2
	  if (ignoreChildCell == 1) {
             EXTERNAL fat_viol spc_target2 {
		SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		TOUCH = FALSE
		POINT_TOUCH = FALSE
		NON_PARALLEL = TRUE
	     } TEMP = spc_mode0_out
             BOOLEAN spc_mode0_out NOT spc_mode0_child_out { } TEMP = spc_mode0_diff_out
             SELECT spc_mode0_out INTERACT spc_mode0_diff_out { } TEMP = spc_mode0_out
	     SELECT_EDGE fat2 TOUCHING spc_mode0_out { } TEMP=fat_viol
	     BOOLEAN fat_viol AND spc_mode0_out { } TEMP=fat_viol
	     SELECT_EDGE spc_target2 TOUCHING spc_mode0_out { } TEMP=spc_target2
	     BOOLEAN spc_target2 AND spc_mode0_out { } TEMP=spc_target2
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (23 )  		
	  } else {
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing 
	        SET_CORNERS_TO_SPACING = FALSE
	        PARALLEL_POINT_PROJECTION = FALSE
	        TOUCH = FALSE
	        POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (23 )
	  }
	  if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	     if (ignoreChildCell == 1) {
		EXTERNAL fat spc_target {
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} TEMP = spc_mode1_out
	        BOOLEAN spc_mode1_out NOT spc_mode1_child_out { } TEMP = spc_mode1_diff_out
	        SELECT spc_mode1_out INTERACT spc_mode1_diff_out { } TEMP = spc_mode1_out
                SELECT_EDGE fat TOUCHING spc_mode1_out { } TEMP=fat_viol
	        BOOLEAN fat_viol AND spc_mode1_out { } TEMP=fat_viol
	        SELECT_EDGE spc_target TOUCHING spc_mode1_out { } TEMP=spc_target2
	        BOOLEAN spc_target2 AND spc_mode1_out { } TEMP=spc_target2
	        EXTERNAL fat_viol spc_target2 {
	           COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um " 	    
		   SPACING < fatTblSpacing_dg
                   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} (23 )
	     } else {
	        EXTERNAL fat spc_target {
		   COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um "
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
	    	   PARALLEL_POINT_PROJECTION = FALSE
	           TOUCH = FALSE
	     	   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } (23 ) 
	     }
          }
       } else {
	  if (ignoreChildCell == 1) {
              EXTERNAL fat spc_target {
                 SPACING < fatTblSpacing
                 BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
              } TEMP = spc_out
	      BOOLEAN spc_out NOT spc_child_out { } TEMP = spc_diff_out
	      SELECT spc_out INTERACT spc_diff_out { } TEMP = spc_out
	      SELECT_EDGE fat TOUCHING spc_out { } TEMP=fat_viol
	      BOOLEAN fat_viol AND spc_out { } TEMP=fat_viol
              SELECT_EDGE spc_target TOUCHING spc_out { } TEMP=spc_target2
	      BOOLEAN spc_target2 AND spc_out { } TEMP=spc_target2
	      EXTERNAL fat_viol spc_target2 {
		 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
		 BOX_CORNER = FALSE 
		 NON_PARALLEL = TRUE
		 POINT_TOUCH = FALSE
	      } (23 ) 
	  } else {
	      EXTERNAL fat spc_target {
                 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
	         BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
	      } (23 ) 
	  }
       }
       /*check metal in the extension range*/ 
       if (fatTblExtensionRange > 0) {
	  if (fatWireExtensionMode == 0) {
	     SIZE fat { OVERSIZE = fatTblExtensionRange } TEMP = fat_tmp
             BOOLEAN fat_tmp AND metal7  { } TEMP = fat_tmp
  	     BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
             SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_ext
             BOOLEAN fat_ext OR fat { } TEMP = fat_ext
	     if (fatTblParallelLength > 0) {
                if (fatTblParallelLength > fatTblExtensionRange) {
                   SIZE fat { OVERSIZE = fatTblParallelLength } TEMP = fat_tmp
                   BOOLEAN fat_tmp AND metal7  { } TEMP = fat_tmp
  	           BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
                   SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_parallel
                   BOOLEAN fat_parallel OR fat { } TEMP = fat_parallel
                } else {
                   COPY fat_ext { } TEMP = fat_parallel
                }
		EXTERNAL fat_parallel spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
	           NON_PARALLEL = TRUE
	        } TEMP = vio_filter_set
		EXTERNAL fat_ext spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } TEMP = vio_set
                if (fatTblParallelLength < fatTblSpacing) {
                   SELECT_EDGE vio_filter_set TOUCHING fat_parallel {
                      VSIZE_INSIDE = fatTblParallelLength - 0.0002 
                   } TEMP = vio_filter_set_filter
                   SELECT_CONTAINS vio_filter_set_filter { 
                      WIDTH =  0.0002 
                      HEIGHT = fatTblParallelLength + 0.0001 
                   } TEMP = vio_filter_set_filter
                   SELECT vio_filter_set INTERACT vio_filter_set_filter { } TEMP = vio_filter
                } else {
	           SELECT_CONTAINS vio_filter_set { 
	              WIDTH =  0.0002 
	              HEIGHT = fatTblParallelLength + 0.0001 
	           } TEMP = vio_filter
                }
                SELECT vio_set INSIDE vio_filter { } TEMP = mode0_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out1 NOT mode0_child_out1 { } TEMP = mode0_diff_out1
                   SELECT mode0_out1 INTERACT mode0_diff_out1 { } TEMP = mode0_out1
                }
                COPY mode0_out1 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing  = fatTblSpacing um"
                } (23 )
		if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	           EXTERNAL fat_ext spc_target {
		      SPACING < fatTblSpacing_dg
	              SET_CORNERS_TO_SPACING = FALSE
		      PARALLEL_POINT_PROJECTION = FALSE
		      TOUCH = TRUE
		      POINT_TOUCH = FALSE
		      NON_PARALLEL = TRUE
	           } TEMP = mode0_out2
                   if (ignoreChildCell == 1) {
                      BOOLEAN mode0_out2 NOT mode0_child_out2 { } TEMP = mode0_diff_out2
                      SELECT mode0_out2 INTERACT mode0_diff_out2 { } TEMP = mode0_out2
                   }
                   COPY mode0_out2 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing (mode 1/2) = fatTblSpacing um/ fatTblSpacing_dg um "
                   } (23 )
	        } 
	     } else {
	        EXTERNAL fat_ext spc_target {
		   SPACING < fatTblSpacing
		   NON_PARALLEL = TRUE
		   SET_CORNERS_TO_SPACING = FALSE
		   POINT_TOUCH = FALSE
		} TEMP = mode0_out3
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out3 NOT mode0_child_out3 { } TEMP = mode0_diff_out3
                   SELECT mode0_out3 INTERACT mode0_diff_out3 { } TEMP = mode0_out3
                }
                COPY mode0_out3 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range ( fatTblExtensionRange um) minimum spacing = fatTblSpacing um"
                } (23 )
	     }
	  } else if (fatWireExtensionMode == 1) {
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal7  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             if (fatTblParallelLength > 0) {
                EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
		   BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   CHECK_SAME_POLYGON = TRUE 
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
	        SELECT fat_ext INTERACT spacing {  } TEMP = fat_ext
		BOOLEAN fat_ext OR spacing {  } TEMP = combined_fat_ext
                EXTERNAL combined_fat_ext fat {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
                } TEMP = fat_spacing
		BOOLEAN fat_spacing AND fat_ran {  } TEMP = fat_spacing
		BOOLEAN combined_fat_ext OR fat_spacing {  } TEMP = combined_fat_ext
                SELECT_CONTAINS combined_fat_ext { 
                   WIDTH =  0.0002 
                   HEIGHT = fatTblParallelLength + 0.0001 
                } TEMP = combined_fat_ext
		SELECT spacing INTERACT combined_fat_ext { 
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out1 NOT mode1_child_out1 { } TEMP = mode1_diff_out1
                   SELECT mode1_out1 INTERACT mode1_diff_out1 { } TEMP = mode1_out1 
                }
                COPY mode1_out1 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (23 ) 
	     } else {
               	EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
	           BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
	           CHECK_SAME_POLYGON = TRUE 
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
                SELECT spacing INTERACT fat_ext {
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out2
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out2 NOT mode1_child_out2 { } TEMP = mode1_diff_out2
                   SELECT mode1_out2 INTERACT mode1_diff_out2 { } TEMP = mode1_out2
                }
                COPY mode1_out2 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (23 )
	     }
	  } else if (fatWireExtensionMode == 2) {
	     SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
             BOOLEAN fat_ran AND metal7  {  } TEMP = fat_ext
             BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	      	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
             } TEMP = spacing
 	     SELECT spacing INSIDE fat_ran {  } TEMP = spacing
	     SELECT spacing OUTSIDE fat {  } TEMP = spacing
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode2_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode2_out NOT mode2_child_out { } TEMP = mode2_diff_out
                SELECT mode2_out INTERACT mode2_diff_out { } TEMP = mode2_out 
             }
             COPY mode2_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 2, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (23 )
	  } else if (fatWireExtensionMode == 3) {
             SIZE fat {
	        GROW_LEFT = fatTblExtensionRange
	        GROW_RIGHT = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal7  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	       	PARALLEL = TRUE

	       	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		HORIZONTAL_ONLY = TRUE
             } TEMP = spacing_hor
	     SELECT spacing_hor INSIDE fat_ran {  } TEMP = spacing_hor
	     SELECT spacing_hor OUTSIDE fat {  } TEMP = spacing_hor
             SIZE fat {
	        GROW_TOP = fatTblExtensionRange
	        GROW_BOTTOM = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal7  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	        POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		VERTICAL_ONLY = TRUE
             } TEMP = spacing_ver
	     SELECT spacing_ver INSIDE fat_ran {  } TEMP = spacing_ver
	     SELECT spacing_ver OUTSIDE fat {  } TEMP = spacing_ver
  	     BOOLEAN spacing_hor OR spacing_ver {  } TEMP = spacing
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal7  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
  	     /* check overlapped projection length */
 	     if (fatTblParallelLength > 0) {
                POLYGON_FEATURES fat_ext {
                   EQUATIONS {
                      vnum = EV_VNUM_IN;
                      if ( vnum > 0) {
                         bdLeft = EV_VXCOORD_IN[0];
                         bdRight = EV_VXCOORD_IN[0];
                         bdBottom = EV_VYCOORD_IN[0];
                         bdTop = EV_VYCOORD_IN[0];
                         FOR (i = 1; i < vnum; i++) {
                            if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
                            else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
                            if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
                            else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
                         } /* FOR i */
                         if ( (bdRight - bdLeft) >= fatTblParallelLength ||
                  	      (bdTop - bdBottom) >= fatTblParallelLength) {
                            FOR (i = 0; i < vnum; i++) {
                               EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
                               EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
                            }
                            EV_VNUM_OUT = vnum;
                 	    EV_SAVE_POLYGON();
                         }
                      }
                   }
                } TEMP = fat_ext /* POLYGON_FEATURE */
             }
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode3_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode3_out NOT mode3_child_out { } TEMP = mode3_diff_out
                SELECT mode3_out INTERACT mode3_diff_out { } TEMP = mode3_out
             }
             COPY mode3_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 3, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (23 )
          }
       }
       SET fatTblSpacing = 0;
    }
}
@ 862 "adrc/adrc.ev" 2


SET fatTblThreshold = 3.005;
SET fatTblParallelLength = 3.005;
SET minWidth = 0.056;

SET fatTblThreshold_Start = 0;
SET fatTblSpacing = 0.7;
@ 1 "adrc/adrc_fatMetal.ev" 1
/*check fat metal table*/
if (fatTblThreshold > 0) {
    if ((fatTblThreshold / 2.0) > 0.0001 ) {
       SIZE fat_candidate  { UNDER_OVER = fatTblThreshold / 2.0 - 0.0001  } TEMP = fat_candidate
       if (fatTblNextThreshold > 0) {
          SIZE fat_candidate { UNDER_OVER = fatTblNextThreshold / 2.0 - 0.0001  } TEMP = fat_next
          BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
          BOOLEAN fat AND fat_target { } TEMP = fat
          SET fatTblNextThreshold = 0;
       } else {
          BOOLEAN fat_candidate AND fat_target {  } TEMP = fat 
       }
    } else {
      COPY fat_target {  } TEMP = fat 
    }
    COPY fat_target { } TEMP = spc_target
    if (fatTblThreshold_Start > 0  || fatTblThreshold_End > 0) {
       if (fatTblThreshold_Start > 0) {
          SIZE fat_target { UNDER_OVER = fatTblThreshold_Start / 2.0 - 0.0001  } TEMP = spc_target
       }
       if (fatTblThreshold_End > 0 && fatTblThreshold_End > fatTblThreshold_Start) {
          SIZE spc_target { UNDER_OVER = fatTblThreshold_End / 2.0 - 0.0001  } TEMP = fat_end
          BOOLEAN spc_target NOT fat_end { } TEMP = spc_target
       }
       BOOLEAN spc_target AND fat_target {  } TEMP = spc_target
       if (ignoreBlockage == 0 && fatTblThreshold_Start < fatTblThreshold_1) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal7_blockage  {  } TEMP = spc_target
       }
       SET fatTblThreshold_Start = 0;
       SET fatTblThreshold_End = 0;
       SET fatTblThreshold_1 = 0;
    } else {
       if (ignoreBlockage == 0) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal7_blockage  {  } TEMP = spc_target
       }
    }
 
    if (fatTblEnclosedArea > 0) {
       SELECT holes INTERACT fat { } TEMP = fat_holes
       AREA fat_holes { 
          RANGE = [0.0001 * 0.0001 , fatTblEnclosedArea - 0.0001 * 0.0001 ]
       } TEMP = fat_holes
       if (fatTblMinEnclosedAreaMode==0) {
          SIZE fat_holes { OVER_UNDER = fatTblThreshold / 2.0 + 0.0001  } TEMP = ovun_holes
          SELECT ovun_holes INTERACT fat_holes { RANGE = [2, 9999999999 ] } TEMP = merged_holes
          BOOLEAN fat_candidate AND fat_target { } TEMP = fat_metal
          BOOLEAN metal7  NOT fat_metal { } TEMP = thin_metal
          BOOLEAN thin_metal NOT ovun_holes { } TEMP = thin_metal
          SELECT ovun_holes INTERACT thin_metal { } TEMP = thin_holes
          BOOLEAN thin_holes OR merged_holes { } TEMP = thin_holes
          BOOLEAN fat_holes NOT thin_holes { } TEMP = fat_holes
       }
       COPY fat_holes { 
	  COMMENT = "$layer_name EnclsArea : fat metal ( fatTblThreshold um) minimum enclosed area (mode fatTblMinEnclosedAreaMode ) = fatTblEnclosedArea um*um"
       } (23 )
       SET fatTblEnclosedArea = 0;
    }
    if (fatTblSpacing > 0) {
       /*check fat metal*/ 
       if (fatTblParallelLength > 0) {
          if (router_parallelLengthNetMode == 1 || parallelLengthMode == 1) {
             AREA spc_target { RANGE = [fatTblParallelLength * minWidth + 0.0001 , 9999999999 ] } TEMP = spc_target1
             COPY spc_target1 { } TEMP = spc_target2
          } else {
             COPY spc_target { } TEMP = spc_target2
          }
          if (parallelLengthMode == 1) {
             SELECT metal7  INTERACT fat { } TEMP = fat_all 
             BOOLEAN fat_all OR fat { } TEMP = fat2
             SELECT metal7  INTERACT spc_target2 { } TEMP = spc_target_all
             BOOLEAN spc_target_all OR spc_target2 { } TEMP = spc_target2
          } else {
             COPY fat { } TEMP = fat2
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING <= fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
                OUTPUT_EDGES = TRUE
             } TEMP = vio_edge
             SELECT vio_edge INTERACT fat { } TEMP = vio_edge
             SELECT vio_edge INTERACT spc_target1 { } TEMP = vio_edge
             SELECT violation INTERACT vio_edge { } TEMP = violation
          } else {
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
          }
          BOOLEAN violation NOT fat_target { } TEMP = violation
          if (fatTblParallelLength < fatTblSpacing) {
             SELECT_EDGE violation TOUCHING fat2 {
                VSIZE_INSIDE = fatTblParallelLength - 0.0002 
             } TEMP = vio_filter
             SELECT_CONTAINS vio_filter { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = vio_filter
             SELECT violation INTERACT vio_filter { } TEMP = violation
          } else {
             SELECT_CONTAINS violation { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = violation
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING = [fatTblSpacing, fatTblSpacing]
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
             } TEMP = violation3
             BOOLEAN violation3 NOT fat_target { } TEMP = violation3
             BOOLEAN violation NOT violation3 { } TEMP= violation
          }
          SELECT_EDGE fat2 TOUCHING violation { } TEMP=fat_viol
          BOOLEAN fat_viol AND violation { } TEMP=fat_viol
          SELECT_EDGE spc_target2 TOUCHING violation { } TEMP=spc_target2
          BOOLEAN spc_target2 AND violation { } TEMP= spc_target2
	  if (ignoreChildCell == 1) {
             EXTERNAL fat_viol spc_target2 {
		SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		TOUCH = FALSE
		POINT_TOUCH = FALSE
		NON_PARALLEL = TRUE
	     } TEMP = spc_mode0_out
             BOOLEAN spc_mode0_out NOT spc_mode0_child_out { } TEMP = spc_mode0_diff_out
             SELECT spc_mode0_out INTERACT spc_mode0_diff_out { } TEMP = spc_mode0_out
	     SELECT_EDGE fat2 TOUCHING spc_mode0_out { } TEMP=fat_viol
	     BOOLEAN fat_viol AND spc_mode0_out { } TEMP=fat_viol
	     SELECT_EDGE spc_target2 TOUCHING spc_mode0_out { } TEMP=spc_target2
	     BOOLEAN spc_target2 AND spc_mode0_out { } TEMP=spc_target2
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (23 )  		
	  } else {
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing 
	        SET_CORNERS_TO_SPACING = FALSE
	        PARALLEL_POINT_PROJECTION = FALSE
	        TOUCH = FALSE
	        POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (23 )
	  }
	  if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	     if (ignoreChildCell == 1) {
		EXTERNAL fat spc_target {
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} TEMP = spc_mode1_out
	        BOOLEAN spc_mode1_out NOT spc_mode1_child_out { } TEMP = spc_mode1_diff_out
	        SELECT spc_mode1_out INTERACT spc_mode1_diff_out { } TEMP = spc_mode1_out
                SELECT_EDGE fat TOUCHING spc_mode1_out { } TEMP=fat_viol
	        BOOLEAN fat_viol AND spc_mode1_out { } TEMP=fat_viol
	        SELECT_EDGE spc_target TOUCHING spc_mode1_out { } TEMP=spc_target2
	        BOOLEAN spc_target2 AND spc_mode1_out { } TEMP=spc_target2
	        EXTERNAL fat_viol spc_target2 {
	           COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um " 	    
		   SPACING < fatTblSpacing_dg
                   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} (23 )
	     } else {
	        EXTERNAL fat spc_target {
		   COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um "
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
	    	   PARALLEL_POINT_PROJECTION = FALSE
	           TOUCH = FALSE
	     	   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } (23 ) 
	     }
          }
       } else {
	  if (ignoreChildCell == 1) {
              EXTERNAL fat spc_target {
                 SPACING < fatTblSpacing
                 BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
              } TEMP = spc_out
	      BOOLEAN spc_out NOT spc_child_out { } TEMP = spc_diff_out
	      SELECT spc_out INTERACT spc_diff_out { } TEMP = spc_out
	      SELECT_EDGE fat TOUCHING spc_out { } TEMP=fat_viol
	      BOOLEAN fat_viol AND spc_out { } TEMP=fat_viol
              SELECT_EDGE spc_target TOUCHING spc_out { } TEMP=spc_target2
	      BOOLEAN spc_target2 AND spc_out { } TEMP=spc_target2
	      EXTERNAL fat_viol spc_target2 {
		 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
		 BOX_CORNER = FALSE 
		 NON_PARALLEL = TRUE
		 POINT_TOUCH = FALSE
	      } (23 ) 
	  } else {
	      EXTERNAL fat spc_target {
                 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
	         BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
	      } (23 ) 
	  }
       }
       /*check metal in the extension range*/ 
       if (fatTblExtensionRange > 0) {
	  if (fatWireExtensionMode == 0) {
	     SIZE fat { OVERSIZE = fatTblExtensionRange } TEMP = fat_tmp
             BOOLEAN fat_tmp AND metal7  { } TEMP = fat_tmp
  	     BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
             SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_ext
             BOOLEAN fat_ext OR fat { } TEMP = fat_ext
	     if (fatTblParallelLength > 0) {
                if (fatTblParallelLength > fatTblExtensionRange) {
                   SIZE fat { OVERSIZE = fatTblParallelLength } TEMP = fat_tmp
                   BOOLEAN fat_tmp AND metal7  { } TEMP = fat_tmp
  	           BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
                   SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_parallel
                   BOOLEAN fat_parallel OR fat { } TEMP = fat_parallel
                } else {
                   COPY fat_ext { } TEMP = fat_parallel
                }
		EXTERNAL fat_parallel spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
	           NON_PARALLEL = TRUE
	        } TEMP = vio_filter_set
		EXTERNAL fat_ext spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } TEMP = vio_set
                if (fatTblParallelLength < fatTblSpacing) {
                   SELECT_EDGE vio_filter_set TOUCHING fat_parallel {
                      VSIZE_INSIDE = fatTblParallelLength - 0.0002 
                   } TEMP = vio_filter_set_filter
                   SELECT_CONTAINS vio_filter_set_filter { 
                      WIDTH =  0.0002 
                      HEIGHT = fatTblParallelLength + 0.0001 
                   } TEMP = vio_filter_set_filter
                   SELECT vio_filter_set INTERACT vio_filter_set_filter { } TEMP = vio_filter
                } else {
	           SELECT_CONTAINS vio_filter_set { 
	              WIDTH =  0.0002 
	              HEIGHT = fatTblParallelLength + 0.0001 
	           } TEMP = vio_filter
                }
                SELECT vio_set INSIDE vio_filter { } TEMP = mode0_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out1 NOT mode0_child_out1 { } TEMP = mode0_diff_out1
                   SELECT mode0_out1 INTERACT mode0_diff_out1 { } TEMP = mode0_out1
                }
                COPY mode0_out1 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing  = fatTblSpacing um"
                } (23 )
		if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	           EXTERNAL fat_ext spc_target {
		      SPACING < fatTblSpacing_dg
	              SET_CORNERS_TO_SPACING = FALSE
		      PARALLEL_POINT_PROJECTION = FALSE
		      TOUCH = TRUE
		      POINT_TOUCH = FALSE
		      NON_PARALLEL = TRUE
	           } TEMP = mode0_out2
                   if (ignoreChildCell == 1) {
                      BOOLEAN mode0_out2 NOT mode0_child_out2 { } TEMP = mode0_diff_out2
                      SELECT mode0_out2 INTERACT mode0_diff_out2 { } TEMP = mode0_out2
                   }
                   COPY mode0_out2 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing (mode 1/2) = fatTblSpacing um/ fatTblSpacing_dg um "
                   } (23 )
	        } 
	     } else {
	        EXTERNAL fat_ext spc_target {
		   SPACING < fatTblSpacing
		   NON_PARALLEL = TRUE
		   SET_CORNERS_TO_SPACING = FALSE
		   POINT_TOUCH = FALSE
		} TEMP = mode0_out3
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out3 NOT mode0_child_out3 { } TEMP = mode0_diff_out3
                   SELECT mode0_out3 INTERACT mode0_diff_out3 { } TEMP = mode0_out3
                }
                COPY mode0_out3 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range ( fatTblExtensionRange um) minimum spacing = fatTblSpacing um"
                } (23 )
	     }
	  } else if (fatWireExtensionMode == 1) {
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal7  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             if (fatTblParallelLength > 0) {
                EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
		   BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   CHECK_SAME_POLYGON = TRUE 
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
	        SELECT fat_ext INTERACT spacing {  } TEMP = fat_ext
		BOOLEAN fat_ext OR spacing {  } TEMP = combined_fat_ext
                EXTERNAL combined_fat_ext fat {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
                } TEMP = fat_spacing
		BOOLEAN fat_spacing AND fat_ran {  } TEMP = fat_spacing
		BOOLEAN combined_fat_ext OR fat_spacing {  } TEMP = combined_fat_ext
                SELECT_CONTAINS combined_fat_ext { 
                   WIDTH =  0.0002 
                   HEIGHT = fatTblParallelLength + 0.0001 
                } TEMP = combined_fat_ext
		SELECT spacing INTERACT combined_fat_ext { 
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out1 NOT mode1_child_out1 { } TEMP = mode1_diff_out1
                   SELECT mode1_out1 INTERACT mode1_diff_out1 { } TEMP = mode1_out1 
                }
                COPY mode1_out1 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (23 ) 
	     } else {
               	EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
	           BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
	           CHECK_SAME_POLYGON = TRUE 
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
                SELECT spacing INTERACT fat_ext {
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out2
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out2 NOT mode1_child_out2 { } TEMP = mode1_diff_out2
                   SELECT mode1_out2 INTERACT mode1_diff_out2 { } TEMP = mode1_out2
                }
                COPY mode1_out2 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (23 )
	     }
	  } else if (fatWireExtensionMode == 2) {
	     SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
             BOOLEAN fat_ran AND metal7  {  } TEMP = fat_ext
             BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	      	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
             } TEMP = spacing
 	     SELECT spacing INSIDE fat_ran {  } TEMP = spacing
	     SELECT spacing OUTSIDE fat {  } TEMP = spacing
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode2_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode2_out NOT mode2_child_out { } TEMP = mode2_diff_out
                SELECT mode2_out INTERACT mode2_diff_out { } TEMP = mode2_out 
             }
             COPY mode2_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 2, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (23 )
	  } else if (fatWireExtensionMode == 3) {
             SIZE fat {
	        GROW_LEFT = fatTblExtensionRange
	        GROW_RIGHT = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal7  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	       	PARALLEL = TRUE

	       	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		HORIZONTAL_ONLY = TRUE
             } TEMP = spacing_hor
	     SELECT spacing_hor INSIDE fat_ran {  } TEMP = spacing_hor
	     SELECT spacing_hor OUTSIDE fat {  } TEMP = spacing_hor
             SIZE fat {
	        GROW_TOP = fatTblExtensionRange
	        GROW_BOTTOM = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal7  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	        POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		VERTICAL_ONLY = TRUE
             } TEMP = spacing_ver
	     SELECT spacing_ver INSIDE fat_ran {  } TEMP = spacing_ver
	     SELECT spacing_ver OUTSIDE fat {  } TEMP = spacing_ver
  	     BOOLEAN spacing_hor OR spacing_ver {  } TEMP = spacing
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal7  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
  	     /* check overlapped projection length */
 	     if (fatTblParallelLength > 0) {
                POLYGON_FEATURES fat_ext {
                   EQUATIONS {
                      vnum = EV_VNUM_IN;
                      if ( vnum > 0) {
                         bdLeft = EV_VXCOORD_IN[0];
                         bdRight = EV_VXCOORD_IN[0];
                         bdBottom = EV_VYCOORD_IN[0];
                         bdTop = EV_VYCOORD_IN[0];
                         FOR (i = 1; i < vnum; i++) {
                            if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
                            else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
                            if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
                            else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
                         } /* FOR i */
                         if ( (bdRight - bdLeft) >= fatTblParallelLength ||
                  	      (bdTop - bdBottom) >= fatTblParallelLength) {
                            FOR (i = 0; i < vnum; i++) {
                               EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
                               EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
                            }
                            EV_VNUM_OUT = vnum;
                 	    EV_SAVE_POLYGON();
                         }
                      }
                   }
                } TEMP = fat_ext /* POLYGON_FEATURE */
             }
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode3_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode3_out NOT mode3_child_out { } TEMP = mode3_diff_out
                SELECT mode3_out INTERACT mode3_diff_out { } TEMP = mode3_out
             }
             COPY mode3_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 3, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (23 )
          }
       }
       SET fatTblSpacing = 0;
    }
}
@ 870 "adrc/adrc.ev" 2


SET fatTblThreshold = 0;
SET fatTblEnclosedArea = 0;
SET fatTblExtensionRange = 0;
SET fatTblParallelLength = 0;
SET minWidth = 0;

/* End of Met7 fat table spacing rules */










/*metal 8*/
SET layer_name = "Met8";










SET minWidth = 0.056;
SET maxWidth = 5;
SET minArea = 0.016;
SET minEnclosedArea = 0.2;
SET minSpacing = 0.056;
SET sameNetMinSpacing = 0.056;
SET stub2StubSpacing = 0;

SET fatTblDimension = 5;
@ 1 "adrc/adrc_check_metal.ev" 1
/* Data Preparation */
if (fatTblDimension > 1 || fatWireThreshold > 0 || maxWidth > 0) {
  if (ignoreBlockage) {
      /* Let the real blockage be treated as thin */
      BOOLEAN metal8  NOT metal8_rbkg  {} TEMP=fat_candidate
  } else {
      COPY metal8  {} TEMP=fat_candidate
  }
  COPY fat_candidate {} TEMP=fat_target
}
/*Check width*/
if (minWidth > 0) {
    INTERNAL metal8  { 
        COMMENT = "$layer_name MinWidth  : minimum width = minWidth um" 
        SPACING < minWidth
        POINT_TOUCH = FALSE
    } (25 )
}
 
if (maxWidth > 0) {
    SIZE  fat_candidate {
        COMMENT = "$layer_name MaxWidth  : maximum width = maxWidth um"
 	UNDER_OVER = maxWidth / 2 
    } (25 ) 
}
 
/*Check area*/
if (minArea > 0) {
    AREA metal8  { 
	COMMENT = "$layer_name MinArea   : minimum area = minArea um*um"
	RANGE = [0.0001 * 0.0001 , minArea - 0.0001 * 0.0001 ]
    } (25 )
}
/* check min length of bounding box on polygon */
if (minLength > 0) {
  if (minLengthMode == 1) {
    INTERNAL metal8  {
        SPACING < minLength
        VERTICAL_ONLY = TRUE
        SET_CORNERS_TO_SPACING = FALSE
    } TEMP = ver_short
    BOOLEAN metal8  NOT ver_short { } TEMP = ver_long
    INTERNAL metal8  {
        SPACING < minLength
        HORIZONTAL_ONLY = TRUE
        SET_CORNERS_TO_SPACING = FALSE
    } TEMP = hor_short
    BOOLEAN metal8  NOT hor_short { } TEMP = hor_long
    SELECT CUT_LAYER1 INSIDE ver_long { } TEMP = good_cut
    BOOLEAN CUT_LAYER1 NOT good_cut { } TEMP = fail_cut_1
    SELECT fail_cut_1 INSIDE hor_long { } TEMP = good_cut
    BOOLEAN fail_cut_1 NOT good_cut { } TEMP = fail_cut_1
    SELECT CUT_LAYER2 INSIDE ver_long { } TEMP = good_cut
    BOOLEAN CUT_LAYER2 NOT good_cut { } TEMP = fail_cut_2
    SELECT fail_cut_2 INSIDE hor_long { } TEMP = good_cut
    BOOLEAN fail_cut_2 NOT good_cut { } TEMP = fail_cut_2
    BOOLEAN fail_cut_1 OR fail_cut_2 { } TEMP = fail_cut
    BOOLEAN hor_short NOT ver_long { } TEMP = hor_short
    BOOLEAN ver_short NOT hor_long { } TEMP = ver_short
    SELECT ver_short INTERACT fail_cut { } TEMP = ver_fail
    SELECT hor_short INTERACT fail_cut { } TEMP = hor_fail
    BOOLEAN ver_fail OR hor_fail { } TEMP = all_fail
    INTERNAL all_fail {
        COMMENT = "$layer_name MinLength : minimum length = minLength um"
        SPACING < minLength
        VERTICAL_ONLY = TRUE
        SET_CORNERS_TO_SPACING = FALSE
    } (25 )
  } else {
    POLYGON_FEATURES metal8  {
      COMMENT = "$layer_name MinLength : minimum length = minLength um"
      EQUATIONS {
        vnum = EV_VNUM_IN;
        if ( vnum > 0) {
	  bdLeft = EV_VXCOORD_IN[0];
	  bdRight = EV_VXCOORD_IN[0];
	  bdBottom = EV_VYCOORD_IN[0];
	  bdTop = EV_VYCOORD_IN[0];
          FOR (i = 1; i < vnum; i++) {
	    if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
            else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
	    if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
            else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
          }
	  if ( (bdRight - bdLeft) < minLength &&
	       (bdTop - bdBottom) < minLength) {
	    FOR (i = 0; i < vnum; i++) {
              EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
	      EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
            }
	    EV_VNUM_OUT = vnum;
	    EV_SAVE_POLYGON();
          }
        }
      }
    } (25 ) 
  }
  SET minLength = 0;
}
/* check max length of bounding box on polygon */
if (maxLength > 0) {
  POLYGON_FEATURES metal8  {
    COMMENT = "$layer_name MaxLength : maximum length = maxLength um"
    EQUATIONS {
      vnum = EV_VNUM_IN;
      if ( vnum > 0) {
	bdLeft = EV_VXCOORD_IN[0];
	bdRight = EV_VXCOORD_IN[0];
	bdBottom = EV_VYCOORD_IN[0];
	bdTop = EV_VYCOORD_IN[0];
        FOR (i = 1; i < vnum; i++) {
	  if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
          else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
	  if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
          else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
        }
	if ( (bdRight - bdLeft + bdTop - bdBottom) > maxLength ) {
          EV_VXCOORD_OUT[0] = bdLeft;
	  EV_VYCOORD_OUT[0] = bdBottom;
          EV_VXCOORD_OUT[1] = bdLeft;
	  EV_VYCOORD_OUT[1] = bdTop;
          EV_VXCOORD_OUT[2] = bdRight;
	  EV_VYCOORD_OUT[2] = bdTop;
          EV_VXCOORD_OUT[3] = bdRight;
	  EV_VYCOORD_OUT[3] = bdBottom;
          EV_VXCOORD_OUT[4] = bdLeft;
	  EV_VYCOORD_OUT[4] = bdBottom;
	  EV_VNUM_OUT = 5;
	  EV_SAVE_POLYGON();
        }
      }
    }
  } (25 ) 
  SET maxLength = 0;
}
 
/*Check enclosed area*/
if (minEnclosedArea > 0) {
    SELECT metal8  INSIDE_HOLE {
        INNER_HOLE_ONLY
    } TEMP = holes
    BOOLEAN holes NOT metal8  { } TEMP = holes
 
    AREA holes {
        COMMENT = "$layer_name EnclsArea : minimum enclosed area = minEnclosedArea um*um"
        RANGE = [0.0001 * 0.0001 , minEnclosedArea - 0.0001 * 0.0001 ]
    } (25 )
    /* check min length of bounding box on polygon */
    if (minEnclosedWidth > 0) {
      POLYGON_FEATURES holes {
        COMMENT = "$layer_name EnclsWidth: minimum enclosed Width = minEnclosedWidth um"
        EQUATIONS {
          vnum = EV_VNUM_IN;
          if ( vnum > 0) {
            bdLeft = EV_VXCOORD_IN[0];
            bdRight = EV_VXCOORD_IN[0];
            bdBottom = EV_VYCOORD_IN[0];
            bdTop = EV_VYCOORD_IN[0];
            FOR (i = 1; i < vnum; i++) {
              if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
              else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
              if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
              else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
            }
            if ( (bdRight - bdLeft) < minEnclosedWidth &&
                 (bdTop - bdBottom) < minEnclosedWidth) {
              FOR (i = 0; i < vnum; i++) {
                EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
                EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
              }
              EV_VNUM_OUT = vnum;
              EV_SAVE_POLYGON();
            }
          }
        }
      } (25 ) 
    }
}
 
/*check special notch rule*/
if ((minEdgeLength2 > 0.0001  && minEdgeLength3 > 0.0001 ) || minEdgeMode==2) {
  if (minEdgeMode==2) {
    SET minEdgeLength3 = minEdgeLength ;
  }
  NOTCH metal8  {
     SPACING < minEdgeLength3
     SET_CORNERS_TO_SPACING=FALSE
     PARALLEL = TRUE
     OUTPUT_EDGES = TRUE
  } TEMP = notch_vectors
  SELECT_VECTOR notch_vectors {
     LENGTH_RANGE = [0.0001 , minEdgeLength2 - 0.0001 ]
  } TEMP = short_edges
  EXTERNAL short_edges metal8  {
     SPACING < minEdgeLength3
     SET_CORNERS_TO_SPACING=FALSE
     PARALLEL = TRUE
  } TEMP = notch_err
  /* Choose the real U-shaped notch */
  SIZE notch_err { OVERSIZE = 0.0002 *10 } TEMP = neighbors 
  BOOLEAN neighbors AND metal8  { } TEMP = neighbors
  VERTEX neighbors { 
     CONCAVE = TRUE
     CONVEX = TRUE
     SIZE = 0.0002 
  } TEMP = corners
  SELECT_EDGE neighbors INTERACT notch_err { } TEMP = target_edges
  BOOLEAN target_edges NOT corners { } TEMP = target_edges
  VERTEX neighbors { 
     CONCAVE = TRUE
     SIZE = 2* 0.0002 
  } TEMP = corners
  SELECT target_edges INTERACT corners { RANGE = [2, 2] } TEMP=target_edges
  SELECT notch_err INTERACT target_edges {
     COMMENT = "$layer_name SpeclNotch: sameNetSp = minEdgeLength3 um (sideLen minEdgeLength2 um)" 
  } (25 )
}
/*check consecutive short edges*/
if (minEdgeLength > 0.0001  && minEdgeMode != 2) { 
  INTERNAL metal8_top  {
     SEGMENT < minEdgeLength
     FLAG_ACUTE_ANGLE = FALSE
     FLAG_ACUTE_EDGE = FALSE
     OUTPUT_EDGES = TRUE
  } TEMP = short_edges
  if ((minEdgeMode == 0 && maxTotalMinEdgeLength>0) || maxNumMinEdge > 0) {
    SET temporary_1 = 0.0002 *2;
    SET temporary_2 = 2*temporary_1+ 0.0001 ;
    SELECT metal8_top  INTERACT short_edges { } TEMP = target_top
    CLASSIFY_EDGES target_top {
       LENGTH = temporary_1
       DMIN   = temporary_2
       INSIDE_CORNER  TEMP = inside_corner_edges
       OUTSIDE_CORNER TEMP = outside_corner_edges
       REMAINDER      TEMP = remainder_edges
    }
    if (minEdgeMode == 0 && (maxNumMinEdge>0 || maxTotalMinEdgeLength > 0)) {
       SELECT short_edges ENCLOSING inside_corner_edges { } TEMP = short_edges
    }
  }
  if (maxTotalMinEdgeLength > 0) {
    LENGTH short_edges {
       RANGE = [maxTotalMinEdgeLength + 0.0001 , 9999999999 ]
    } TEMP = max_length_err
    /* Work around: translate polygons into dimensional check output */
    SIZE max_length_err { OVERSIZE = 2* 0.0002  } TEMP = max_length_err
    INTERNAL max_length_err {
       SPACING < 3* 0.0002 
       SET_CORNERS_TO_SPACING=FALSE
       COMMENT = "$layer_name MinEdgeLen: maximum total length ( minEdgeLength um)= maxTotalMinEdgeLength um"
    } (25 )
  }
  if (maxTotalMinEdgeLength == 0 || maxNumMinEdge > 0) {
    if (maxNumMinEdge==0)  {
       COPY short_edges {} TEMP=max_edge_err
    } else {
       SIZE short_edges {
         VSIZE_HEAD = - 0.0002 
        VSIZE_TAIL = - 0.0002 
       } TEMP = short_edges
       SIZE short_edges {
          OVERSIZE = 5* 0.0002 
          SIZE_ENDPOINTS = FALSE
       } TEMP = short_contours
       SELECT short_contours ENCLOSING remainder_edges {
          RANGE = [maxNumMinEdge + 1, 9999999999 ]
       } TEMP = short_contours
       SELECT short_edges INSIDE short_contours { } TEMP=max_edge_err
    }
    /* Work around: translate polygons into dimensional check output */
    SIZE max_edge_err { OVERSIZE = 2* 0.0002  } TEMP = max_edge_error
    INTERNAL max_edge_error {
       SPACING < 3* 0.0002 
       SET_CORNERS_TO_SPACING=FALSE
       COMMENT = "$layer_name MinEdgeLen: maximum number of consecutive short edges ( minEdgeLength um)= maxNumMinEdge"
    } (25 ) 
  }
}
 
/*check basic spacing*/
if (sameNetMinSpacing > 0 && sameNetMinSpacing != minSpacing) {
  if (sameNetMinSpacing > minSpacing) {
    /* Special condition for U-shaped Metal spacing rule */
    NOTCH metal8_pin  {
        SPACING < sameNetMinSpacing
        BOX_CORNER = FALSE 
        SET_CORNERS_TO_SPACING=FALSE
        NON_PARALLEL = TRUE
        OUTPUT_EDGES = TRUE
    } TEMP = errs_to_be_waived
    NOTCH metal8_top  {
	SPACING < sameNetMinSpacing
	BOX_CORNER = FALSE 
        SET_CORNERS_TO_SPACING=FALSE
	NON_PARALLEL = TRUE
        OUTPUT_EDGES = TRUE
    } TEMP = all_errs
    BOOLEAN all_errs NOT errs_to_be_waived { } TEMP=err_edge
    EXTERNAL err_edge metal8_top  {
	SPACING < sameNetMinSpacing
	BOX_CORNER = FALSE 
        SET_CORNERS_TO_SPACING=FALSE
	NON_PARALLEL = TRUE
    } TEMP = notch_err
    SIZE notch_err { OVERSIZE = 0.0002 *10 } TEMP = neighbors
    BOOLEAN neighbors AND metal8_top  { } TEMP = neighbors
    VERTEX neighbors { 
       CONCAVE = TRUE
       CONVEX = TRUE
       SIZE = 0.0002 
    } TEMP = corners
    SELECT_EDGE neighbors INTERACT notch_err { } TEMP = target_edges
    BOOLEAN target_edges AND notch_err { } TEMP = target_edges
    BOOLEAN target_edges NOT corners { } TEMP = target_edges
    VERTEX neighbors {
       CONCAVE = TRUE
       SIZE = 2* 0.0002 
    } TEMP = corners
    SELECT target_edges INTERACT corners { RANGE = [2, 2] } TEMP = target_edges
    SELECT notch_err TOUCHING target_edges {
      COMMENT = "$layer_name U-ShpNotch: U-shape notch minimum spacing = sameNetMinSpacing um" 
    } (25 )
  } else {
    NOTCH metal8  {
        COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = sameNetMinSpacing um" 
	SPACING < sameNetMinSpacing
	BOX_CORNER = FALSE 
	NON_PARALLEL = TRUE
    } (25 )
  }
  if (minSpacing > 0) {
    if (stubMode == 0 && stubSpacing > 0 && stubSpacing < minSpacing) {
	EXTERNAL metal8  {
	    COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um"
            LONGEDGE > stubThreshold + 0.0001 
	    LONGEDGE_TO_EDGE < minSpacing
	    SPACING <= 0
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            CHECK_SAME_POLYGON = TRUE 
	} (25 )
    } else {
        EXTERNAL metal8  {
	    COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um" 
	    SPACING < minSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
	    CHECK_SAME_POLYGON = FALSE
        } (25 )
    }
  }
} else {
  if (minSpacing > 0) {
    if (stubMode == 0 && stubSpacing > 0 && stubSpacing < minSpacing) {
        EXTERNAL metal8  {
            COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um"
            LONGEDGE > stubThreshold + 0.0001  
            LONGEDGE_TO_EDGE < minSpacing
            SPACING <= 0 
            BOX_CORNER = FALSE 
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            CHECK_SAME_POLYGON = TRUE 
        } (25 )
    } else {
        EXTERNAL metal8  {
	    COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um" 
            SPACING < minSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
	    CHECK_SAME_POLYGON = TRUE 
        } (25 )
    }
  }
}
 
/*check dogbone */
if (sameNetMinSpacing > 0 && sameNetWidthThreshold) {
  NOTCH metal8  {
    SPACING < sameNetMinSpacing
    BOX_CORNER = FALSE 
    NON_PARALLEL = TRUE
  } TEMP = dog_bone
 
  if (!layer_empty(dog_bone)) {
    SIZE dog_bone {EDGESIZE = sameNetWidthThreshold} TEMP = dog_ext
    BOOLEAN dog_ext NOT dog_bone {} TEMP = dog_ext
    BOOLEAN dog_ext AND metal8  {} TEMP = dog_ext
    if (!layer_empty(dog_ext)) {
      SELECT dog_ext EDGE_TOUCH dog_bone { OUTSIDE RANGE = [1, 9999999999 ] } TEMP = dog_ext
      NOTCH metal8  {
        SPACING < sameNetMinSpacing
        BOX_CORNER = FALSE 
        NON_PARALLEL = TRUE
	OUTPUT_EDGES = TRUE
      } TEMP = dog_bone
      SELECT dog_ext OUTSIDE dog_bone {} TEMP = dog_ext
      INTERNAL dog_ext {
	COMMENT = "$layer_name dogBone   : notch spacing = sameNetMinSpacing um width sameNetWidthThreshold um" 
	SPACING < sameNetWidthThreshold
      } (25 )
    }
  }
}
/*check basic fat spacing*/
if (fatWireThreshold > 0 && fatTblDimension == 0) {
    SIZE fat_candidate { UNDER_OVER = fatWireThreshold / 2.0 - 0.0001  } TEMP = m_fat
    BOOLEAN m_fat AND metal8  {  } TEMP = m_fat
    BOOLEAN metal8  NOT m_fat {  } TEMP = m_thin
    if (ignoreBlockage == 0) {
        /* the blockages on the metal_blockage layer are treated as thin blockages */
        BOOLEAN m_thin OR metal8_blockage  {  } TEMP = m_thin
    }
 
    if (fatFatMinSpacing > 0) {
	EXTERNAL m_fat {
	    COMMENT = "$layer_name FatWireSpc: fat & fat ( fatWireThreshold um) minimum spacing = fatFatMinSpacing um"
	    SPACING < fatFatMinSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = FALSE
	    CHECK_SAME_POLYGON = TRUE 
       } (25 )
    }
 
    if (fatThinMinSpacing > 0) {
	EXTERNAL m_fat m_thin {
	    COMMENT = "$layer_name FatWireSpc: fat & thin ( fatWireThreshold um) minimum spacing fatThinMinSpacing um"
	    SPACING < fatThinMinSpacing
 	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = FALSE
        } (25 )
    }
}
 
/*check thin blockage spacing*/
if (minSpacing > 0 && ignoreBlockage == 0) {
    if (!layer_empty (metal8_blockage )) {
	EXTERNAL metal8_blockage  metal8  {
	    COMMENT = "$layer_name Spacing   : metal & thin blockage minimum spacing = minSpacing um"
	    SPACING < minSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
            TOUCH = TRUE
        } (25 )
    }
}
/*check blockage overlap*/
/*check shorts between top_level routing and fram_blockages*/
if (minSpacing>0 || checkCrossHierShort>0) {
   if (ignoreBlockage == 0) {
      BOOLEAN metal8_blockage  or metal8_rbkg  {} TEMP=all_blockage
   } else {
      COPY metal8_rbkg  {} TEMP=all_blockage
   }
   BOOLEAN all_blockage AND metal8_top  {} TEMP = overlap_shape1
   EXTERNAL all_blockage metal8_top  {
      SPACING <= 0
      TOUCH = TRUE
   } TEMP = overlap_shape2
   if (checkCrossHierShort>0) {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
         COMMENT = "$layer_name Short Cross Hierarchy"
      } (25 )
   } else {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
         COMMENT = "$layer_name Overlap   : metal & blockage overlap"
      } (25 )
   }
}
 
if (fatPolyContactRule > 0) {
  /* Fat Poly Contact Rule: not new fat wire formed */
  if (readCellView > 0) {
     SIZE metal1 { UNDER_OVER = fatPolyContactRule / 2.0 - 0.0001  } TEMP = fat
     BOOLEAN fat AND metal1 {  } TEMP = fat 
  } else {
     SIZE metal1_top { UNDER_OVER = fatPolyContactRule / 2.0 - 0.0001  } TEMP = fat
     BOOLEAN fat AND metal1_top {  } TEMP = fat 
  }
  SIZE metal1_pin { UNDER_OVER = fatPolyContactRule / 2.0 - 0.0001  } TEMP = fat_pin
  BOOLEAN fat_pin AND metal1_pin {  } TEMP = fat_pin
  BOOLEAN fat NOT fat_pin {
    COMMENT = "$layer_name FatPolyContactRule: fatPolyContactRule um" 
  } (25 )
}
/* Special End-of-Line Spacing Rule */
if (stubMode == 0 && stubSpacing > 0 && stubSpacing < minSpacing) {
  EXTERNAL metal8  {
     COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 0)"
     LONGEDGE > stubThreshold + 0.0001 
     LONGEDGE_TO_EDGE <= 0 
     SPACING < stubSpacing 
     SET_CORNERS_TO_SPACING = FALSE
     PARALLEL_POINT_PROJECTION = FALSE
  } (25 )
} else if (stubMode > 0 && stubSpacing > minSpacing) {
  if (stubMode == 4) {
     INTERNAL metal8  {
        SEGMENT[90,90] < stubThreshold
        OUTPUT_EDGES = TRUE
     } TEMP = end_of_line
  } else {
     INTERNAL metal8  {
        SEGMENT[90,90] <= stubThreshold
        OUTPUT_EDGES = TRUE
     } TEMP = end_of_line
  }
  /* Quick filter to reduce the size of possible end of line */
  if (sideStubExt > 0) {
    SIZE end_of_line {
       VSIZE_HEAD = sideStubExt
       VSIZE_TAIL = sideStubExt
       OUTPUT_EDGES = TRUE
    } TEMP = eol_ext
  } else {
    COPY end_of_line { } TEMP=eol_ext
  }
  if (stub2StubSpacing > stubSpacing) {
     SET temporary_1 = stub2StubSpacing;
  } else {
     SET temporary_1 = stubSpacing; 
  }
  EXTERNAL eol_ext metal8  {
     SPACING < temporary_1
     TOUCH = TRUE
     OVERLAP = TRUE 
     SET_CORNERS_TO_SPACING = FALSE
     PARALLEL_POINT_PROJECTION = FALSE
     OUTPUT_EDGES = TRUE
  } TEMP=err_edge
  SELECT eol_ext INTERACT err_edge { } TEMP=eol_ext
  SELECT end_of_line INTERACT eol_ext { } TEMP=end_of_line 
  /* Reduce the size of METAL_LAYER */
  if (stubMode==3) {
     SIZE end_of_line {
        VSIZE_HEAD = stubSpacing 
        VSIZE_TAIL = stubSpacing 
        VSIZE_INSIDE = sideStubThreshold
        VSIZE_OUTSIDE = stubSpacing
     } TEMP = eol_filter 
  } else {
     if (stubMode == 1 && stubRange > 0) {
        SIZE end_of_line {
           VSIZE_HEAD = stubSpacing- 0.0001 
           VSIZE_TAIL = stubSpacing- 0.0001 
           VSIZE_OUTSIDE = stubSpacing- 0.0001 
        } TEMP = eol_filter
     } else {
        SIZE end_of_line {
           VSIZE_HEAD = stubSpacing- 0.0001 
           VSIZE_TAIL = stubSpacing- 0.0001 
           VSIZE_INSIDE = sideStubThreshold- 0.0001 
           VSIZE_OUTSIDE = stubSpacing- 0.0001 
        } TEMP = eol_filter
     }
  }
  SELECT metal8  INTERACT eol_filter { } TEMP=target_top
  /* Get the side edges and the whole eol of line set */
  SELECT_EDGE target_top INTERACT end_of_line { 
    POINT_TOUCH = TRUE
  } TEMP = eol_set
  VERTEX target_top { 
     CONCAVE = TRUE 
     CONVEX = TRUE
     SIZE = 0.0002 
  } TEMP = corners
  SELECT corners OUTSIDE end_of_line {} TEMP =corners 
  BOOLEAN eol_set NOT corners { } TEMP=eol_set
  BOOLEAN eol_set NOT end_of_line { } TEMP=side_edge
  /* find out the real end of line */
  if (stubRange > 0) {
     if (stubMode == 1) {
         COPY side_edge { } TEMP = all_side_edge
         LENGTH side_edge { SPACING <= stubRange- 0.0001  } TEMP=side_edge
     } else {
         LENGTH side_edge { SPACING < stubRange- 0.0002  } TEMP=eol_filter
         BOOLEAN side_edge NOT eol_filter { } TEMP=side_edge
     }
     SELECT end_of_line INTERACT side_edge { RANGE = [1,2] } TEMP = end_of_line
  } 
  if (stubMode == 1) {
    if (stub2StubSpacing > 0) {
       if (sideStubExt < 0) {
          SIZE end_of_line {
            VSIZE_HEAD = sideStubExt / 2
            VSIZE_TAIL = sideStubExt / 2
            OUTPUT_EDGES = TRUE
          } TEMP = eol_ext_tip
	 
          EXTERNAL eol_ext_tip {
            COMMENT = "$layer_name specEoLSpc: stub2Stubspacing= stub2StubSpacing um (mode = 1)"
            SPACING < stub2StubSpacing
            SET_CORNERS_TO_SPACING = FALSE
            PARALLEL_POINT_PROJECTION = TRUE
          } (25 )
       } else {
          EXTERNAL end_of_line {
            COMMENT = "$layer_name specEoLSpc: stub2Stubspacing= stub2StubSpacing um (mode = 1)"
            SPACING < stub2StubSpacing
            SET_CORNERS_TO_SPACING = FALSE
            PARALLEL_POINT_PROJECTION = FALSE
          } (25 )
       }
    }
    if (stubRange > 0) {
       SIZE end_of_line {
         VSIZE_INSIDE = 0.0002 
       } TEMP = eol_poly
       SELECT_EDGE eol_poly TOUCHING target_top { } TEMP=eol_edge
       EXTERNAL eol_edge target_top {
         COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
         CONVEX_TO_CONVEX < stubSpacing
         CONVEX_TO_CONVEX [POINT_PROJECTION] < stubSpacing
         CONVEX_TO_EDGE < stubSpacing
         CONCAVE_TO_CONVEX < stubSpacing
         LONGEDGE > 0.0002 
         LONGEDGE_TO_EDGE < stubSpacing
         SPACING <= 0
         SET_CORNERS_TO_SPACING = TRUE
         PARALLEL_POINT_PROJECTION = TRUE
       } (25 )
       SELECT all_side_edge INTERACT end_of_line { } TEMP = side_edge
       SIZE side_edge {
         VSIZE_HEAD = 0.0002 
         VSIZE_TAIL = 0.0002 
       } TEMP = side_edge_ext
       BOOLEAN side_edge_ext NOT side_edge { } TEMP = side_edge_ext
       SELECT side_edge_ext INTERACT end_of_line { } TEMP = side_edge_ext
       EXTERNAL side_edge_ext target_top {
         COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
         SPACING < stubSpacing
         SET_CORNERS_TO_SPACING = FALSE
         PARALLEL_POINT_PROJECTION = FALSE
       } (25 )
    } else {
       if (stub2StubSpacing > 0) {
         VECTORIZE target_top {
            DIRECTED=TRUE
         } TEMP=target_edges
         BOOLEAN target_edges NOT end_of_line { } TEMP = target_edges
         EXTERNAL end_of_line target_edges {
            COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
            SPACING < stubSpacing
            TOUCH=TRUE
            OVERLAP=TRUE
            SET_CORNERS_TO_SPACING=FALSE
            PARALLEL_POINT_PROJECTION=FALSE
         } (25 )
       } else {
         if (sideStubExt > 0) {
            SIZE end_of_line {
               VSIZE_HEAD = sideStubExt
               VSIZE_TAIL = sideStubExt
               OUTPUT_EDGES = TRUE
            } TEMP = end_of_line
            EXTERNAL end_of_line target_top {
               COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing ,crnKeepOut= sideStubExt um (mode = 1)"
               SPACING < stubSpacing
               TOUCH=TRUE
               OVERLAP=TRUE
               SET_CORNERS_TO_SPACING=FALSE
               PARALLEL_POINT_PROJECTION=FALSE
            } (25 )
         } else {
            EXTERNAL end_of_line target_top {
               COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
               SPACING < stubSpacing
               TOUCH=TRUE
               OVERLAP=TRUE
               SET_CORNERS_TO_SPACING=FALSE
               PARALLEL_POINT_PROJECTION=FALSE
            } (25 )
         }
       }
    }
  } else { /* stubMode == 2,3,4 */
    /* stubMode 2 eol classify and reduction */
    if (stubMode !=3 && sideStubExt > 0) {
      if (stubMode == 4) {
        SIZE end_of_line {
           VSIZE_HEAD = sideStubExt
           VSIZE_TAIL = sideStubExt
           OUTPUT_EDGES = TRUE
        } TEMP = eol_ext
        EXTERNAL eol_ext target_top {
           SPACING < stubSpacing
           SET_CORNERS_TO_SPACING=FALSE
           PARALLEL_POINT_PROJECTION=FALSE
           OUTPUT_EDGES = TRUE
        } TEMP=err_edge
        SELECT eol_ext INTERACT err_edge { } TEMP=eol_ext
      } else {
        EXTERNAL end_of_line target_top {
           SPACING < stubSpacing
           SET_CORNERS_TO_SPACING=FALSE
           PARALLEL_POINT_PROJECTION=FALSE
           OUTPUT_EDGES = TRUE
        } TEMP=err_edge
        SELECT end_of_line INTERACT err_edge { } TEMP=eol_body
        SIZE end_of_line {
           VSIZE_HEAD = sideStubExt
           VSIZE_TAIL = sideStubExt
           OUTPUT_EDGES = TRUE
        } TEMP = eol_ext
        BOOLEAN eol_ext NOT end_of_line {} TEMP=eol_ext
        EXTERNAL eol_ext target_top {
           SPACING < stubSpacing
           SET_CORNERS_TO_SPACING=FALSE
           PARALLEL_POINT_PROJECTION=FALSE
           OUTPUT_EDGES = TRUE
        } TEMP=err_edge
        SELECT eol_ext INTERACT err_edge { } TEMP=eol_ext
        BOOLEAN eol_body OR eol_ext { } TEMP=eol_ext
      } 
    } else {
      COPY end_of_line { } TEMP=eol_ext
    }
    SELECT side_edge INTERACT eol_ext { } TEMP=side_edge
    SIZE eol_ext {
       VSIZE_INSIDE = sideStubThreshold 
       VSIZE_OUTSIDE = sideStubExt
    } TEMP = eol_range
    if (sideStubExt > 0) {
       SIZE side_edge {
          VSIZE_HEAD = sideStubExt
          VSIZE_TAIL = sideStubExt
          OUTPUT_EDGES = TRUE
       } TEMP = check_edge
    } else {
       COPY side_edge { } TEMP = check_edge
    }
    BOOLEAN check_edge AND eol_range { } TEMP=check_edge
    EXTERNAL check_edge target_top {
       SPACING < temporary_1
       SET_CORNERS_TO_SPACING = FALSE
       SHADOW_OTHER_LAYER = TRUE
       PARALLEL_POINT_PROJECTION = FALSE
       OUTPUT_EDGES = TRUE
    } TEMP=err_edge
    if (0 && stubMode!=4) { /* Temporarily do not check mode 2,3 side edge length */
       LENGTH side_edge { SPACING < stubSpacing- 0.0001 *2 } TEMP=err_edge_1
       BOOLEAN err_edge OR err_edge_1 { } TEMP=err_edge
    }
    SELECT check_edge INTERACT err_edge { } TEMP=side_edge
    if (stubMode!=3) {
       SELECT eol_ext INTERACT side_edge {} TEMP=err_eol
       EXTERNAL err_eol target_top {
          COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing ,crnKeepOut= sideStubExt um (mode = stubMode )"
          SPACING < temporary_1
          PARALLEL_POINT_PROJECTION=FALSE
          SET_CORNERS_TO_SPACING=FALSE
       } (25 )
    } else { /* stubMode == 3 */
       SELECT eol_ext INTERACT side_edge { RANGE = [2, 2] } TEMP=err_eol
       EXTERNAL err_eol target_top {
          COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 3)"
          SPACING < temporary_1
          PARALLEL_POINT_PROJECTION=FALSE
          SET_CORNERS_TO_SPACING=FALSE
       } (25 )
    }
  }
} /* stubMode > 0, not aligned */
/* Avoid empty optimization result parsing error */
if (addEmptyMetalCheck) {
   BOOLEAN empty OR empty {
      COMMENT = "$layer_name Empty: Dummy Output"
   } (25 )
   SET addEmptyMetalCheck=0;
}
/* reset variables */


 
SET minWidth = 0;
SET maxWidth = 0;
SET minArea = 0;
SET minEnclosedArea = 0;
SET minSpacing = 0;
SET sameNetMinSpacing = 0;
SET maxNumMinEdge = 0;
SET maxTotalMinEdgeLength = 0;
SET minEdgeLength = 0;
SET minEdgeLength2 = 0;
SET minEdgeLength3 = 0;
SET stubRange = 0;
SET stubSpacing = 0;
SET stub2StubSpacing = 0;
SET sideStubExt = 0;
SET sideStubThreshold = 0;
SET stubThreshold = 0;
SET fatPolyContactRule = 0;
SET fatWireThreshold = 0;
SET fatThinMinSpacing = 0;
SET fatFatMinSpacing = 0;
SET fatTblDimension = 0;
@ 910 "adrc/adrc.ev" 2

SET minSpacing = 0.056;
SET fatTblThresh_protru = 0.15;
SET fatTblLength_protru = 0.1;
SET fatTblWidth_protru = 0.06;
@ 1 "adrc/adrc_protru.ev" 1
/*protrusion length rule*/
SIZE metal8     { UNDER_OVER = fatTblThresh_protru / 2.0 - 0.0001  } TEMP = fat
BOOLEAN fat AND metal8  {  } TEMP = fat 
BOOLEAN metal8  NOT fat {  } TEMP = fat_nbr
SIZE fat { OVERSIZE = fatTblLength_protru + 0.0001  } TEMP = fat_ext
BOOLEAN fat_nbr AND fat_ext {} TEMP = fat_nbr
SELECT fat_nbr INTERACT fat TEMP = fat_nbr
/* Get the correct fat extension */
SELECT_EDGE fat_nbr TOUCHING fat { } TEMP = ext_filter
SIZE ext_filter { VSIZE_INSIDE = 0.0001  } TEMP = ext_filter
SIZE ext_filter INSIDE fat_nbr {
   OVERSIZE = fatTblLength_protru- 0.0001 
   INCREMENT = minSpacing
} TEMP=dummy TEMP = fat_nbr
  
VERTEX fat_nbr {
   CONCAVE = TRUE
   SIZE = 0.0002 
} TEMP = corners
SELECT fat_nbr OUTSIDE corners { } TEMP = fat_nbr1
BOOLEAN fat_nbr NOT fat_nbr1 { } TEMP = fat_nbr2
SELECT_CONTAINS fat_nbr1 {
   WIDTH =  0.0002 
   HEIGHT = fatTblLength_protru
} TEMP = good_fat_nbr1
BOOLEAN fat_nbr1 NOT good_fat_nbr1 { } TEMP = fat_nbr1
/* check with L or T shape of fat extension */
SELECT_EDGE fat_nbr2 INTERACT corners { } TEMP = side_edge
LENGTH side_edge { SPACING < fatTblLength_protru } TEMP = vio_edge
SELECT fat_nbr2 INTERACT vio_edge { } TEMP = fat_nbr2
BOOLEAN fat_nbr1 OR fat_nbr2 { } TEMP = fat_nbr
INTERAL fat_nbr {
   SPACING < fatTblWidth_protru
} TEMP = possible_err
if (!layer_empty(possible_err)) {
   SELECT fat_nbr INTERACT possible_err { } TEMP=fat_nbr
   SELECT fat INTERACT fat_nbr {} TEMP=fat
   BOOLEAN fat OR fat_nbr {} TEMP=fat
   INTERNAL fat {
      COMMENT = "$layer_name ProtrusionLength : threshold fatTblThresh_protru um, length  fatTblLength_protru um, width fatTblWidth_protru um"
      SPACING < fatTblWidth_protru
   } (25 )
}
/* protrusion leng rule check */
SET fatTblThresh_protru = 0;
SET fatTblLength_protru = 0;
SET fatTblWidth_protru = 0;
SET minSpacing = 0;
@ 915 "adrc/adrc.ev" 2


SET minSpacing = 0.056;
SET fatTblThresh_protru = 0.3;
SET fatTblLength_protru = 0.15;
SET fatTblWidth_protru = 0.07;
@ 1 "adrc/adrc_protru.ev" 1
/*protrusion length rule*/
SIZE metal8     { UNDER_OVER = fatTblThresh_protru / 2.0 - 0.0001  } TEMP = fat
BOOLEAN fat AND metal8  {  } TEMP = fat 
BOOLEAN metal8  NOT fat {  } TEMP = fat_nbr
SIZE fat { OVERSIZE = fatTblLength_protru + 0.0001  } TEMP = fat_ext
BOOLEAN fat_nbr AND fat_ext {} TEMP = fat_nbr
SELECT fat_nbr INTERACT fat TEMP = fat_nbr
/* Get the correct fat extension */
SELECT_EDGE fat_nbr TOUCHING fat { } TEMP = ext_filter
SIZE ext_filter { VSIZE_INSIDE = 0.0001  } TEMP = ext_filter
SIZE ext_filter INSIDE fat_nbr {
   OVERSIZE = fatTblLength_protru- 0.0001 
   INCREMENT = minSpacing
} TEMP=dummy TEMP = fat_nbr
  
VERTEX fat_nbr {
   CONCAVE = TRUE
   SIZE = 0.0002 
} TEMP = corners
SELECT fat_nbr OUTSIDE corners { } TEMP = fat_nbr1
BOOLEAN fat_nbr NOT fat_nbr1 { } TEMP = fat_nbr2
SELECT_CONTAINS fat_nbr1 {
   WIDTH =  0.0002 
   HEIGHT = fatTblLength_protru
} TEMP = good_fat_nbr1
BOOLEAN fat_nbr1 NOT good_fat_nbr1 { } TEMP = fat_nbr1
/* check with L or T shape of fat extension */
SELECT_EDGE fat_nbr2 INTERACT corners { } TEMP = side_edge
LENGTH side_edge { SPACING < fatTblLength_protru } TEMP = vio_edge
SELECT fat_nbr2 INTERACT vio_edge { } TEMP = fat_nbr2
BOOLEAN fat_nbr1 OR fat_nbr2 { } TEMP = fat_nbr
INTERAL fat_nbr {
   SPACING < fatTblWidth_protru
} TEMP = possible_err
if (!layer_empty(possible_err)) {
   SELECT fat_nbr INTERACT possible_err { } TEMP=fat_nbr
   SELECT fat INTERACT fat_nbr {} TEMP=fat
   BOOLEAN fat OR fat_nbr {} TEMP=fat
   INTERNAL fat {
      COMMENT = "$layer_name ProtrusionLength : threshold fatTblThresh_protru um, length  fatTblLength_protru um, width fatTblWidth_protru um"
      SPACING < fatTblWidth_protru
   } (25 )
}
/* protrusion leng rule check */
SET fatTblThresh_protru = 0;
SET fatTblLength_protru = 0;
SET fatTblWidth_protru = 0;
SET minSpacing = 0;
@ 921 "adrc/adrc.ev" 2


SET minSpacing = 0.056;
SET fatTblThresh_protru = 1.5;
SET fatTblLength_protru = 0.7;
SET fatTblWidth_protru = 0.15;
@ 1 "adrc/adrc_protru.ev" 1
/*protrusion length rule*/
SIZE metal8     { UNDER_OVER = fatTblThresh_protru / 2.0 - 0.0001  } TEMP = fat
BOOLEAN fat AND metal8  {  } TEMP = fat 
BOOLEAN metal8  NOT fat {  } TEMP = fat_nbr
SIZE fat { OVERSIZE = fatTblLength_protru + 0.0001  } TEMP = fat_ext
BOOLEAN fat_nbr AND fat_ext {} TEMP = fat_nbr
SELECT fat_nbr INTERACT fat TEMP = fat_nbr
/* Get the correct fat extension */
SELECT_EDGE fat_nbr TOUCHING fat { } TEMP = ext_filter
SIZE ext_filter { VSIZE_INSIDE = 0.0001  } TEMP = ext_filter
SIZE ext_filter INSIDE fat_nbr {
   OVERSIZE = fatTblLength_protru- 0.0001 
   INCREMENT = minSpacing
} TEMP=dummy TEMP = fat_nbr
  
VERTEX fat_nbr {
   CONCAVE = TRUE
   SIZE = 0.0002 
} TEMP = corners
SELECT fat_nbr OUTSIDE corners { } TEMP = fat_nbr1
BOOLEAN fat_nbr NOT fat_nbr1 { } TEMP = fat_nbr2
SELECT_CONTAINS fat_nbr1 {
   WIDTH =  0.0002 
   HEIGHT = fatTblLength_protru
} TEMP = good_fat_nbr1
BOOLEAN fat_nbr1 NOT good_fat_nbr1 { } TEMP = fat_nbr1
/* check with L or T shape of fat extension */
SELECT_EDGE fat_nbr2 INTERACT corners { } TEMP = side_edge
LENGTH side_edge { SPACING < fatTblLength_protru } TEMP = vio_edge
SELECT fat_nbr2 INTERACT vio_edge { } TEMP = fat_nbr2
BOOLEAN fat_nbr1 OR fat_nbr2 { } TEMP = fat_nbr
INTERAL fat_nbr {
   SPACING < fatTblWidth_protru
} TEMP = possible_err
if (!layer_empty(possible_err)) {
   SELECT fat_nbr INTERACT possible_err { } TEMP=fat_nbr
   SELECT fat INTERACT fat_nbr {} TEMP=fat
   BOOLEAN fat OR fat_nbr {} TEMP=fat
   INTERNAL fat {
      COMMENT = "$layer_name ProtrusionLength : threshold fatTblThresh_protru um, length  fatTblLength_protru um, width fatTblWidth_protru um"
      SPACING < fatTblWidth_protru
   } (25 )
}
/* protrusion leng rule check */
SET fatTblThresh_protru = 0;
SET fatTblLength_protru = 0;
SET fatTblWidth_protru = 0;
SET minSpacing = 0;
@ 927 "adrc/adrc.ev" 2


SET minSpacing = 0.056;
SET fatTblThresh_protru = 3;
SET fatTblLength_protru = 1.5;
SET fatTblWidth_protru = 0.3;
@ 1 "adrc/adrc_protru.ev" 1
/*protrusion length rule*/
SIZE metal8     { UNDER_OVER = fatTblThresh_protru / 2.0 - 0.0001  } TEMP = fat
BOOLEAN fat AND metal8  {  } TEMP = fat 
BOOLEAN metal8  NOT fat {  } TEMP = fat_nbr
SIZE fat { OVERSIZE = fatTblLength_protru + 0.0001  } TEMP = fat_ext
BOOLEAN fat_nbr AND fat_ext {} TEMP = fat_nbr
SELECT fat_nbr INTERACT fat TEMP = fat_nbr
/* Get the correct fat extension */
SELECT_EDGE fat_nbr TOUCHING fat { } TEMP = ext_filter
SIZE ext_filter { VSIZE_INSIDE = 0.0001  } TEMP = ext_filter
SIZE ext_filter INSIDE fat_nbr {
   OVERSIZE = fatTblLength_protru- 0.0001 
   INCREMENT = minSpacing
} TEMP=dummy TEMP = fat_nbr
  
VERTEX fat_nbr {
   CONCAVE = TRUE
   SIZE = 0.0002 
} TEMP = corners
SELECT fat_nbr OUTSIDE corners { } TEMP = fat_nbr1
BOOLEAN fat_nbr NOT fat_nbr1 { } TEMP = fat_nbr2
SELECT_CONTAINS fat_nbr1 {
   WIDTH =  0.0002 
   HEIGHT = fatTblLength_protru
} TEMP = good_fat_nbr1
BOOLEAN fat_nbr1 NOT good_fat_nbr1 { } TEMP = fat_nbr1
/* check with L or T shape of fat extension */
SELECT_EDGE fat_nbr2 INTERACT corners { } TEMP = side_edge
LENGTH side_edge { SPACING < fatTblLength_protru } TEMP = vio_edge
SELECT fat_nbr2 INTERACT vio_edge { } TEMP = fat_nbr2
BOOLEAN fat_nbr1 OR fat_nbr2 { } TEMP = fat_nbr
INTERAL fat_nbr {
   SPACING < fatTblWidth_protru
} TEMP = possible_err
if (!layer_empty(possible_err)) {
   SELECT fat_nbr INTERACT possible_err { } TEMP=fat_nbr
   SELECT fat INTERACT fat_nbr {} TEMP=fat
   BOOLEAN fat OR fat_nbr {} TEMP=fat
   INTERNAL fat {
      COMMENT = "$layer_name ProtrusionLength : threshold fatTblThresh_protru um, length  fatTblLength_protru um, width fatTblWidth_protru um"
      SPACING < fatTblWidth_protru
   } (25 )
}
/* protrusion leng rule check */
SET fatTblThresh_protru = 0;
SET fatTblLength_protru = 0;
SET fatTblWidth_protru = 0;
SET minSpacing = 0;
@ 933 "adrc/adrc.ev" 2





/* Start of Met8 fat table spacing rules */
SET fatTblSpacingMode = 0;
SET parallelLengthMode = 0;
SET router_parallelLengthNetMode = 0;

SET fatTblThreshold = 0.155;
SET fatTblParallelLength = 0.155;
SET minWidth = 0.056;

SET fatTblThreshold_Start = 0;
SET fatTblSpacing = 0.064;
@ 1 "adrc/adrc_fatMetal.ev" 1
/*check fat metal table*/
if (fatTblThreshold > 0) {
    if ((fatTblThreshold / 2.0) > 0.0001 ) {
       SIZE fat_candidate  { UNDER_OVER = fatTblThreshold / 2.0 - 0.0001  } TEMP = fat_candidate
       if (fatTblNextThreshold > 0) {
          SIZE fat_candidate { UNDER_OVER = fatTblNextThreshold / 2.0 - 0.0001  } TEMP = fat_next
          BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
          BOOLEAN fat AND fat_target { } TEMP = fat
          SET fatTblNextThreshold = 0;
       } else {
          BOOLEAN fat_candidate AND fat_target {  } TEMP = fat 
       }
    } else {
      COPY fat_target {  } TEMP = fat 
    }
    COPY fat_target { } TEMP = spc_target
    if (fatTblThreshold_Start > 0  || fatTblThreshold_End > 0) {
       if (fatTblThreshold_Start > 0) {
          SIZE fat_target { UNDER_OVER = fatTblThreshold_Start / 2.0 - 0.0001  } TEMP = spc_target
       }
       if (fatTblThreshold_End > 0 && fatTblThreshold_End > fatTblThreshold_Start) {
          SIZE spc_target { UNDER_OVER = fatTblThreshold_End / 2.0 - 0.0001  } TEMP = fat_end
          BOOLEAN spc_target NOT fat_end { } TEMP = spc_target
       }
       BOOLEAN spc_target AND fat_target {  } TEMP = spc_target
       if (ignoreBlockage == 0 && fatTblThreshold_Start < fatTblThreshold_1) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal8_blockage  {  } TEMP = spc_target
       }
       SET fatTblThreshold_Start = 0;
       SET fatTblThreshold_End = 0;
       SET fatTblThreshold_1 = 0;
    } else {
       if (ignoreBlockage == 0) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal8_blockage  {  } TEMP = spc_target
       }
    }
 
    if (fatTblEnclosedArea > 0) {
       SELECT holes INTERACT fat { } TEMP = fat_holes
       AREA fat_holes { 
          RANGE = [0.0001 * 0.0001 , fatTblEnclosedArea - 0.0001 * 0.0001 ]
       } TEMP = fat_holes
       if (fatTblMinEnclosedAreaMode==0) {
          SIZE fat_holes { OVER_UNDER = fatTblThreshold / 2.0 + 0.0001  } TEMP = ovun_holes
          SELECT ovun_holes INTERACT fat_holes { RANGE = [2, 9999999999 ] } TEMP = merged_holes
          BOOLEAN fat_candidate AND fat_target { } TEMP = fat_metal
          BOOLEAN metal8  NOT fat_metal { } TEMP = thin_metal
          BOOLEAN thin_metal NOT ovun_holes { } TEMP = thin_metal
          SELECT ovun_holes INTERACT thin_metal { } TEMP = thin_holes
          BOOLEAN thin_holes OR merged_holes { } TEMP = thin_holes
          BOOLEAN fat_holes NOT thin_holes { } TEMP = fat_holes
       }
       COPY fat_holes { 
	  COMMENT = "$layer_name EnclsArea : fat metal ( fatTblThreshold um) minimum enclosed area (mode fatTblMinEnclosedAreaMode ) = fatTblEnclosedArea um*um"
       } (25 )
       SET fatTblEnclosedArea = 0;
    }
    if (fatTblSpacing > 0) {
       /*check fat metal*/ 
       if (fatTblParallelLength > 0) {
          if (router_parallelLengthNetMode == 1 || parallelLengthMode == 1) {
             AREA spc_target { RANGE = [fatTblParallelLength * minWidth + 0.0001 , 9999999999 ] } TEMP = spc_target1
             COPY spc_target1 { } TEMP = spc_target2
          } else {
             COPY spc_target { } TEMP = spc_target2
          }
          if (parallelLengthMode == 1) {
             SELECT metal8  INTERACT fat { } TEMP = fat_all 
             BOOLEAN fat_all OR fat { } TEMP = fat2
             SELECT metal8  INTERACT spc_target2 { } TEMP = spc_target_all
             BOOLEAN spc_target_all OR spc_target2 { } TEMP = spc_target2
          } else {
             COPY fat { } TEMP = fat2
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING <= fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
                OUTPUT_EDGES = TRUE
             } TEMP = vio_edge
             SELECT vio_edge INTERACT fat { } TEMP = vio_edge
             SELECT vio_edge INTERACT spc_target1 { } TEMP = vio_edge
             SELECT violation INTERACT vio_edge { } TEMP = violation
          } else {
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
          }
          BOOLEAN violation NOT fat_target { } TEMP = violation
          if (fatTblParallelLength < fatTblSpacing) {
             SELECT_EDGE violation TOUCHING fat2 {
                VSIZE_INSIDE = fatTblParallelLength - 0.0002 
             } TEMP = vio_filter
             SELECT_CONTAINS vio_filter { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = vio_filter
             SELECT violation INTERACT vio_filter { } TEMP = violation
          } else {
             SELECT_CONTAINS violation { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = violation
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING = [fatTblSpacing, fatTblSpacing]
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
             } TEMP = violation3
             BOOLEAN violation3 NOT fat_target { } TEMP = violation3
             BOOLEAN violation NOT violation3 { } TEMP= violation
          }
          SELECT_EDGE fat2 TOUCHING violation { } TEMP=fat_viol
          BOOLEAN fat_viol AND violation { } TEMP=fat_viol
          SELECT_EDGE spc_target2 TOUCHING violation { } TEMP=spc_target2
          BOOLEAN spc_target2 AND violation { } TEMP= spc_target2
	  if (ignoreChildCell == 1) {
             EXTERNAL fat_viol spc_target2 {
		SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		TOUCH = FALSE
		POINT_TOUCH = FALSE
		NON_PARALLEL = TRUE
	     } TEMP = spc_mode0_out
             BOOLEAN spc_mode0_out NOT spc_mode0_child_out { } TEMP = spc_mode0_diff_out
             SELECT spc_mode0_out INTERACT spc_mode0_diff_out { } TEMP = spc_mode0_out
	     SELECT_EDGE fat2 TOUCHING spc_mode0_out { } TEMP=fat_viol
	     BOOLEAN fat_viol AND spc_mode0_out { } TEMP=fat_viol
	     SELECT_EDGE spc_target2 TOUCHING spc_mode0_out { } TEMP=spc_target2
	     BOOLEAN spc_target2 AND spc_mode0_out { } TEMP=spc_target2
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (25 )  		
	  } else {
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing 
	        SET_CORNERS_TO_SPACING = FALSE
	        PARALLEL_POINT_PROJECTION = FALSE
	        TOUCH = FALSE
	        POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (25 )
	  }
	  if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	     if (ignoreChildCell == 1) {
		EXTERNAL fat spc_target {
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} TEMP = spc_mode1_out
	        BOOLEAN spc_mode1_out NOT spc_mode1_child_out { } TEMP = spc_mode1_diff_out
	        SELECT spc_mode1_out INTERACT spc_mode1_diff_out { } TEMP = spc_mode1_out
                SELECT_EDGE fat TOUCHING spc_mode1_out { } TEMP=fat_viol
	        BOOLEAN fat_viol AND spc_mode1_out { } TEMP=fat_viol
	        SELECT_EDGE spc_target TOUCHING spc_mode1_out { } TEMP=spc_target2
	        BOOLEAN spc_target2 AND spc_mode1_out { } TEMP=spc_target2
	        EXTERNAL fat_viol spc_target2 {
	           COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um " 	    
		   SPACING < fatTblSpacing_dg
                   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} (25 )
	     } else {
	        EXTERNAL fat spc_target {
		   COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um "
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
	    	   PARALLEL_POINT_PROJECTION = FALSE
	           TOUCH = FALSE
	     	   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } (25 ) 
	     }
          }
       } else {
	  if (ignoreChildCell == 1) {
              EXTERNAL fat spc_target {
                 SPACING < fatTblSpacing
                 BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
              } TEMP = spc_out
	      BOOLEAN spc_out NOT spc_child_out { } TEMP = spc_diff_out
	      SELECT spc_out INTERACT spc_diff_out { } TEMP = spc_out
	      SELECT_EDGE fat TOUCHING spc_out { } TEMP=fat_viol
	      BOOLEAN fat_viol AND spc_out { } TEMP=fat_viol
              SELECT_EDGE spc_target TOUCHING spc_out { } TEMP=spc_target2
	      BOOLEAN spc_target2 AND spc_out { } TEMP=spc_target2
	      EXTERNAL fat_viol spc_target2 {
		 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
		 BOX_CORNER = FALSE 
		 NON_PARALLEL = TRUE
		 POINT_TOUCH = FALSE
	      } (25 ) 
	  } else {
	      EXTERNAL fat spc_target {
                 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
	         BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
	      } (25 ) 
	  }
       }
       /*check metal in the extension range*/ 
       if (fatTblExtensionRange > 0) {
	  if (fatWireExtensionMode == 0) {
	     SIZE fat { OVERSIZE = fatTblExtensionRange } TEMP = fat_tmp
             BOOLEAN fat_tmp AND metal8  { } TEMP = fat_tmp
  	     BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
             SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_ext
             BOOLEAN fat_ext OR fat { } TEMP = fat_ext
	     if (fatTblParallelLength > 0) {
                if (fatTblParallelLength > fatTblExtensionRange) {
                   SIZE fat { OVERSIZE = fatTblParallelLength } TEMP = fat_tmp
                   BOOLEAN fat_tmp AND metal8  { } TEMP = fat_tmp
  	           BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
                   SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_parallel
                   BOOLEAN fat_parallel OR fat { } TEMP = fat_parallel
                } else {
                   COPY fat_ext { } TEMP = fat_parallel
                }
		EXTERNAL fat_parallel spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
	           NON_PARALLEL = TRUE
	        } TEMP = vio_filter_set
		EXTERNAL fat_ext spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } TEMP = vio_set
                if (fatTblParallelLength < fatTblSpacing) {
                   SELECT_EDGE vio_filter_set TOUCHING fat_parallel {
                      VSIZE_INSIDE = fatTblParallelLength - 0.0002 
                   } TEMP = vio_filter_set_filter
                   SELECT_CONTAINS vio_filter_set_filter { 
                      WIDTH =  0.0002 
                      HEIGHT = fatTblParallelLength + 0.0001 
                   } TEMP = vio_filter_set_filter
                   SELECT vio_filter_set INTERACT vio_filter_set_filter { } TEMP = vio_filter
                } else {
	           SELECT_CONTAINS vio_filter_set { 
	              WIDTH =  0.0002 
	              HEIGHT = fatTblParallelLength + 0.0001 
	           } TEMP = vio_filter
                }
                SELECT vio_set INSIDE vio_filter { } TEMP = mode0_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out1 NOT mode0_child_out1 { } TEMP = mode0_diff_out1
                   SELECT mode0_out1 INTERACT mode0_diff_out1 { } TEMP = mode0_out1
                }
                COPY mode0_out1 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing  = fatTblSpacing um"
                } (25 )
		if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	           EXTERNAL fat_ext spc_target {
		      SPACING < fatTblSpacing_dg
	              SET_CORNERS_TO_SPACING = FALSE
		      PARALLEL_POINT_PROJECTION = FALSE
		      TOUCH = TRUE
		      POINT_TOUCH = FALSE
		      NON_PARALLEL = TRUE
	           } TEMP = mode0_out2
                   if (ignoreChildCell == 1) {
                      BOOLEAN mode0_out2 NOT mode0_child_out2 { } TEMP = mode0_diff_out2
                      SELECT mode0_out2 INTERACT mode0_diff_out2 { } TEMP = mode0_out2
                   }
                   COPY mode0_out2 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing (mode 1/2) = fatTblSpacing um/ fatTblSpacing_dg um "
                   } (25 )
	        } 
	     } else {
	        EXTERNAL fat_ext spc_target {
		   SPACING < fatTblSpacing
		   NON_PARALLEL = TRUE
		   SET_CORNERS_TO_SPACING = FALSE
		   POINT_TOUCH = FALSE
		} TEMP = mode0_out3
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out3 NOT mode0_child_out3 { } TEMP = mode0_diff_out3
                   SELECT mode0_out3 INTERACT mode0_diff_out3 { } TEMP = mode0_out3
                }
                COPY mode0_out3 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range ( fatTblExtensionRange um) minimum spacing = fatTblSpacing um"
                } (25 )
	     }
	  } else if (fatWireExtensionMode == 1) {
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal8  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             if (fatTblParallelLength > 0) {
                EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
		   BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   CHECK_SAME_POLYGON = TRUE 
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
	        SELECT fat_ext INTERACT spacing {  } TEMP = fat_ext
		BOOLEAN fat_ext OR spacing {  } TEMP = combined_fat_ext
                EXTERNAL combined_fat_ext fat {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
                } TEMP = fat_spacing
		BOOLEAN fat_spacing AND fat_ran {  } TEMP = fat_spacing
		BOOLEAN combined_fat_ext OR fat_spacing {  } TEMP = combined_fat_ext
                SELECT_CONTAINS combined_fat_ext { 
                   WIDTH =  0.0002 
                   HEIGHT = fatTblParallelLength + 0.0001 
                } TEMP = combined_fat_ext
		SELECT spacing INTERACT combined_fat_ext { 
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out1 NOT mode1_child_out1 { } TEMP = mode1_diff_out1
                   SELECT mode1_out1 INTERACT mode1_diff_out1 { } TEMP = mode1_out1 
                }
                COPY mode1_out1 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (25 ) 
	     } else {
               	EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
	           BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
	           CHECK_SAME_POLYGON = TRUE 
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
                SELECT spacing INTERACT fat_ext {
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out2
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out2 NOT mode1_child_out2 { } TEMP = mode1_diff_out2
                   SELECT mode1_out2 INTERACT mode1_diff_out2 { } TEMP = mode1_out2
                }
                COPY mode1_out2 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (25 )
	     }
	  } else if (fatWireExtensionMode == 2) {
	     SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
             BOOLEAN fat_ran AND metal8  {  } TEMP = fat_ext
             BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	      	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
             } TEMP = spacing
 	     SELECT spacing INSIDE fat_ran {  } TEMP = spacing
	     SELECT spacing OUTSIDE fat {  } TEMP = spacing
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode2_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode2_out NOT mode2_child_out { } TEMP = mode2_diff_out
                SELECT mode2_out INTERACT mode2_diff_out { } TEMP = mode2_out 
             }
             COPY mode2_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 2, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (25 )
	  } else if (fatWireExtensionMode == 3) {
             SIZE fat {
	        GROW_LEFT = fatTblExtensionRange
	        GROW_RIGHT = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal8  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	       	PARALLEL = TRUE

	       	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		HORIZONTAL_ONLY = TRUE
             } TEMP = spacing_hor
	     SELECT spacing_hor INSIDE fat_ran {  } TEMP = spacing_hor
	     SELECT spacing_hor OUTSIDE fat {  } TEMP = spacing_hor
             SIZE fat {
	        GROW_TOP = fatTblExtensionRange
	        GROW_BOTTOM = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal8  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	        POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		VERTICAL_ONLY = TRUE
             } TEMP = spacing_ver
	     SELECT spacing_ver INSIDE fat_ran {  } TEMP = spacing_ver
	     SELECT spacing_ver OUTSIDE fat {  } TEMP = spacing_ver
  	     BOOLEAN spacing_hor OR spacing_ver {  } TEMP = spacing
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal8  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
  	     /* check overlapped projection length */
 	     if (fatTblParallelLength > 0) {
                POLYGON_FEATURES fat_ext {
                   EQUATIONS {
                      vnum = EV_VNUM_IN;
                      if ( vnum > 0) {
                         bdLeft = EV_VXCOORD_IN[0];
                         bdRight = EV_VXCOORD_IN[0];
                         bdBottom = EV_VYCOORD_IN[0];
                         bdTop = EV_VYCOORD_IN[0];
                         FOR (i = 1; i < vnum; i++) {
                            if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
                            else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
                            if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
                            else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
                         } /* FOR i */
                         if ( (bdRight - bdLeft) >= fatTblParallelLength ||
                  	      (bdTop - bdBottom) >= fatTblParallelLength) {
                            FOR (i = 0; i < vnum; i++) {
                               EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
                               EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
                            }
                            EV_VNUM_OUT = vnum;
                 	    EV_SAVE_POLYGON();
                         }
                      }
                   }
                } TEMP = fat_ext /* POLYGON_FEATURE */
             }
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode3_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode3_out NOT mode3_child_out { } TEMP = mode3_diff_out
                SELECT mode3_out INTERACT mode3_diff_out { } TEMP = mode3_out
             }
             COPY mode3_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 3, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (25 )
          }
       }
       SET fatTblSpacing = 0;
    }
}
@ 949 "adrc/adrc.ev" 2


SET fatTblThreshold = 0.305;
SET fatTblParallelLength = 0.305;
SET minWidth = 0.056;

SET fatTblThreshold_Start = 0;
SET fatTblSpacing = 0.12;
@ 1 "adrc/adrc_fatMetal.ev" 1
/*check fat metal table*/
if (fatTblThreshold > 0) {
    if ((fatTblThreshold / 2.0) > 0.0001 ) {
       SIZE fat_candidate  { UNDER_OVER = fatTblThreshold / 2.0 - 0.0001  } TEMP = fat_candidate
       if (fatTblNextThreshold > 0) {
          SIZE fat_candidate { UNDER_OVER = fatTblNextThreshold / 2.0 - 0.0001  } TEMP = fat_next
          BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
          BOOLEAN fat AND fat_target { } TEMP = fat
          SET fatTblNextThreshold = 0;
       } else {
          BOOLEAN fat_candidate AND fat_target {  } TEMP = fat 
       }
    } else {
      COPY fat_target {  } TEMP = fat 
    }
    COPY fat_target { } TEMP = spc_target
    if (fatTblThreshold_Start > 0  || fatTblThreshold_End > 0) {
       if (fatTblThreshold_Start > 0) {
          SIZE fat_target { UNDER_OVER = fatTblThreshold_Start / 2.0 - 0.0001  } TEMP = spc_target
       }
       if (fatTblThreshold_End > 0 && fatTblThreshold_End > fatTblThreshold_Start) {
          SIZE spc_target { UNDER_OVER = fatTblThreshold_End / 2.0 - 0.0001  } TEMP = fat_end
          BOOLEAN spc_target NOT fat_end { } TEMP = spc_target
       }
       BOOLEAN spc_target AND fat_target {  } TEMP = spc_target
       if (ignoreBlockage == 0 && fatTblThreshold_Start < fatTblThreshold_1) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal8_blockage  {  } TEMP = spc_target
       }
       SET fatTblThreshold_Start = 0;
       SET fatTblThreshold_End = 0;
       SET fatTblThreshold_1 = 0;
    } else {
       if (ignoreBlockage == 0) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal8_blockage  {  } TEMP = spc_target
       }
    }
 
    if (fatTblEnclosedArea > 0) {
       SELECT holes INTERACT fat { } TEMP = fat_holes
       AREA fat_holes { 
          RANGE = [0.0001 * 0.0001 , fatTblEnclosedArea - 0.0001 * 0.0001 ]
       } TEMP = fat_holes
       if (fatTblMinEnclosedAreaMode==0) {
          SIZE fat_holes { OVER_UNDER = fatTblThreshold / 2.0 + 0.0001  } TEMP = ovun_holes
          SELECT ovun_holes INTERACT fat_holes { RANGE = [2, 9999999999 ] } TEMP = merged_holes
          BOOLEAN fat_candidate AND fat_target { } TEMP = fat_metal
          BOOLEAN metal8  NOT fat_metal { } TEMP = thin_metal
          BOOLEAN thin_metal NOT ovun_holes { } TEMP = thin_metal
          SELECT ovun_holes INTERACT thin_metal { } TEMP = thin_holes
          BOOLEAN thin_holes OR merged_holes { } TEMP = thin_holes
          BOOLEAN fat_holes NOT thin_holes { } TEMP = fat_holes
       }
       COPY fat_holes { 
	  COMMENT = "$layer_name EnclsArea : fat metal ( fatTblThreshold um) minimum enclosed area (mode fatTblMinEnclosedAreaMode ) = fatTblEnclosedArea um*um"
       } (25 )
       SET fatTblEnclosedArea = 0;
    }
    if (fatTblSpacing > 0) {
       /*check fat metal*/ 
       if (fatTblParallelLength > 0) {
          if (router_parallelLengthNetMode == 1 || parallelLengthMode == 1) {
             AREA spc_target { RANGE = [fatTblParallelLength * minWidth + 0.0001 , 9999999999 ] } TEMP = spc_target1
             COPY spc_target1 { } TEMP = spc_target2
          } else {
             COPY spc_target { } TEMP = spc_target2
          }
          if (parallelLengthMode == 1) {
             SELECT metal8  INTERACT fat { } TEMP = fat_all 
             BOOLEAN fat_all OR fat { } TEMP = fat2
             SELECT metal8  INTERACT spc_target2 { } TEMP = spc_target_all
             BOOLEAN spc_target_all OR spc_target2 { } TEMP = spc_target2
          } else {
             COPY fat { } TEMP = fat2
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING <= fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
                OUTPUT_EDGES = TRUE
             } TEMP = vio_edge
             SELECT vio_edge INTERACT fat { } TEMP = vio_edge
             SELECT vio_edge INTERACT spc_target1 { } TEMP = vio_edge
             SELECT violation INTERACT vio_edge { } TEMP = violation
          } else {
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
          }
          BOOLEAN violation NOT fat_target { } TEMP = violation
          if (fatTblParallelLength < fatTblSpacing) {
             SELECT_EDGE violation TOUCHING fat2 {
                VSIZE_INSIDE = fatTblParallelLength - 0.0002 
             } TEMP = vio_filter
             SELECT_CONTAINS vio_filter { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = vio_filter
             SELECT violation INTERACT vio_filter { } TEMP = violation
          } else {
             SELECT_CONTAINS violation { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = violation
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING = [fatTblSpacing, fatTblSpacing]
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
             } TEMP = violation3
             BOOLEAN violation3 NOT fat_target { } TEMP = violation3
             BOOLEAN violation NOT violation3 { } TEMP= violation
          }
          SELECT_EDGE fat2 TOUCHING violation { } TEMP=fat_viol
          BOOLEAN fat_viol AND violation { } TEMP=fat_viol
          SELECT_EDGE spc_target2 TOUCHING violation { } TEMP=spc_target2
          BOOLEAN spc_target2 AND violation { } TEMP= spc_target2
	  if (ignoreChildCell == 1) {
             EXTERNAL fat_viol spc_target2 {
		SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		TOUCH = FALSE
		POINT_TOUCH = FALSE
		NON_PARALLEL = TRUE
	     } TEMP = spc_mode0_out
             BOOLEAN spc_mode0_out NOT spc_mode0_child_out { } TEMP = spc_mode0_diff_out
             SELECT spc_mode0_out INTERACT spc_mode0_diff_out { } TEMP = spc_mode0_out
	     SELECT_EDGE fat2 TOUCHING spc_mode0_out { } TEMP=fat_viol
	     BOOLEAN fat_viol AND spc_mode0_out { } TEMP=fat_viol
	     SELECT_EDGE spc_target2 TOUCHING spc_mode0_out { } TEMP=spc_target2
	     BOOLEAN spc_target2 AND spc_mode0_out { } TEMP=spc_target2
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (25 )  		
	  } else {
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing 
	        SET_CORNERS_TO_SPACING = FALSE
	        PARALLEL_POINT_PROJECTION = FALSE
	        TOUCH = FALSE
	        POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (25 )
	  }
	  if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	     if (ignoreChildCell == 1) {
		EXTERNAL fat spc_target {
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} TEMP = spc_mode1_out
	        BOOLEAN spc_mode1_out NOT spc_mode1_child_out { } TEMP = spc_mode1_diff_out
	        SELECT spc_mode1_out INTERACT spc_mode1_diff_out { } TEMP = spc_mode1_out
                SELECT_EDGE fat TOUCHING spc_mode1_out { } TEMP=fat_viol
	        BOOLEAN fat_viol AND spc_mode1_out { } TEMP=fat_viol
	        SELECT_EDGE spc_target TOUCHING spc_mode1_out { } TEMP=spc_target2
	        BOOLEAN spc_target2 AND spc_mode1_out { } TEMP=spc_target2
	        EXTERNAL fat_viol spc_target2 {
	           COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um " 	    
		   SPACING < fatTblSpacing_dg
                   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} (25 )
	     } else {
	        EXTERNAL fat spc_target {
		   COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um "
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
	    	   PARALLEL_POINT_PROJECTION = FALSE
	           TOUCH = FALSE
	     	   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } (25 ) 
	     }
          }
       } else {
	  if (ignoreChildCell == 1) {
              EXTERNAL fat spc_target {
                 SPACING < fatTblSpacing
                 BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
              } TEMP = spc_out
	      BOOLEAN spc_out NOT spc_child_out { } TEMP = spc_diff_out
	      SELECT spc_out INTERACT spc_diff_out { } TEMP = spc_out
	      SELECT_EDGE fat TOUCHING spc_out { } TEMP=fat_viol
	      BOOLEAN fat_viol AND spc_out { } TEMP=fat_viol
              SELECT_EDGE spc_target TOUCHING spc_out { } TEMP=spc_target2
	      BOOLEAN spc_target2 AND spc_out { } TEMP=spc_target2
	      EXTERNAL fat_viol spc_target2 {
		 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
		 BOX_CORNER = FALSE 
		 NON_PARALLEL = TRUE
		 POINT_TOUCH = FALSE
	      } (25 ) 
	  } else {
	      EXTERNAL fat spc_target {
                 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
	         BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
	      } (25 ) 
	  }
       }
       /*check metal in the extension range*/ 
       if (fatTblExtensionRange > 0) {
	  if (fatWireExtensionMode == 0) {
	     SIZE fat { OVERSIZE = fatTblExtensionRange } TEMP = fat_tmp
             BOOLEAN fat_tmp AND metal8  { } TEMP = fat_tmp
  	     BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
             SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_ext
             BOOLEAN fat_ext OR fat { } TEMP = fat_ext
	     if (fatTblParallelLength > 0) {
                if (fatTblParallelLength > fatTblExtensionRange) {
                   SIZE fat { OVERSIZE = fatTblParallelLength } TEMP = fat_tmp
                   BOOLEAN fat_tmp AND metal8  { } TEMP = fat_tmp
  	           BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
                   SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_parallel
                   BOOLEAN fat_parallel OR fat { } TEMP = fat_parallel
                } else {
                   COPY fat_ext { } TEMP = fat_parallel
                }
		EXTERNAL fat_parallel spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
	           NON_PARALLEL = TRUE
	        } TEMP = vio_filter_set
		EXTERNAL fat_ext spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } TEMP = vio_set
                if (fatTblParallelLength < fatTblSpacing) {
                   SELECT_EDGE vio_filter_set TOUCHING fat_parallel {
                      VSIZE_INSIDE = fatTblParallelLength - 0.0002 
                   } TEMP = vio_filter_set_filter
                   SELECT_CONTAINS vio_filter_set_filter { 
                      WIDTH =  0.0002 
                      HEIGHT = fatTblParallelLength + 0.0001 
                   } TEMP = vio_filter_set_filter
                   SELECT vio_filter_set INTERACT vio_filter_set_filter { } TEMP = vio_filter
                } else {
	           SELECT_CONTAINS vio_filter_set { 
	              WIDTH =  0.0002 
	              HEIGHT = fatTblParallelLength + 0.0001 
	           } TEMP = vio_filter
                }
                SELECT vio_set INSIDE vio_filter { } TEMP = mode0_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out1 NOT mode0_child_out1 { } TEMP = mode0_diff_out1
                   SELECT mode0_out1 INTERACT mode0_diff_out1 { } TEMP = mode0_out1
                }
                COPY mode0_out1 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing  = fatTblSpacing um"
                } (25 )
		if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	           EXTERNAL fat_ext spc_target {
		      SPACING < fatTblSpacing_dg
	              SET_CORNERS_TO_SPACING = FALSE
		      PARALLEL_POINT_PROJECTION = FALSE
		      TOUCH = TRUE
		      POINT_TOUCH = FALSE
		      NON_PARALLEL = TRUE
	           } TEMP = mode0_out2
                   if (ignoreChildCell == 1) {
                      BOOLEAN mode0_out2 NOT mode0_child_out2 { } TEMP = mode0_diff_out2
                      SELECT mode0_out2 INTERACT mode0_diff_out2 { } TEMP = mode0_out2
                   }
                   COPY mode0_out2 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing (mode 1/2) = fatTblSpacing um/ fatTblSpacing_dg um "
                   } (25 )
	        } 
	     } else {
	        EXTERNAL fat_ext spc_target {
		   SPACING < fatTblSpacing
		   NON_PARALLEL = TRUE
		   SET_CORNERS_TO_SPACING = FALSE
		   POINT_TOUCH = FALSE
		} TEMP = mode0_out3
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out3 NOT mode0_child_out3 { } TEMP = mode0_diff_out3
                   SELECT mode0_out3 INTERACT mode0_diff_out3 { } TEMP = mode0_out3
                }
                COPY mode0_out3 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range ( fatTblExtensionRange um) minimum spacing = fatTblSpacing um"
                } (25 )
	     }
	  } else if (fatWireExtensionMode == 1) {
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal8  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             if (fatTblParallelLength > 0) {
                EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
		   BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   CHECK_SAME_POLYGON = TRUE 
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
	        SELECT fat_ext INTERACT spacing {  } TEMP = fat_ext
		BOOLEAN fat_ext OR spacing {  } TEMP = combined_fat_ext
                EXTERNAL combined_fat_ext fat {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
                } TEMP = fat_spacing
		BOOLEAN fat_spacing AND fat_ran {  } TEMP = fat_spacing
		BOOLEAN combined_fat_ext OR fat_spacing {  } TEMP = combined_fat_ext
                SELECT_CONTAINS combined_fat_ext { 
                   WIDTH =  0.0002 
                   HEIGHT = fatTblParallelLength + 0.0001 
                } TEMP = combined_fat_ext
		SELECT spacing INTERACT combined_fat_ext { 
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out1 NOT mode1_child_out1 { } TEMP = mode1_diff_out1
                   SELECT mode1_out1 INTERACT mode1_diff_out1 { } TEMP = mode1_out1 
                }
                COPY mode1_out1 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (25 ) 
	     } else {
               	EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
	           BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
	           CHECK_SAME_POLYGON = TRUE 
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
                SELECT spacing INTERACT fat_ext {
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out2
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out2 NOT mode1_child_out2 { } TEMP = mode1_diff_out2
                   SELECT mode1_out2 INTERACT mode1_diff_out2 { } TEMP = mode1_out2
                }
                COPY mode1_out2 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (25 )
	     }
	  } else if (fatWireExtensionMode == 2) {
	     SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
             BOOLEAN fat_ran AND metal8  {  } TEMP = fat_ext
             BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	      	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
             } TEMP = spacing
 	     SELECT spacing INSIDE fat_ran {  } TEMP = spacing
	     SELECT spacing OUTSIDE fat {  } TEMP = spacing
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode2_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode2_out NOT mode2_child_out { } TEMP = mode2_diff_out
                SELECT mode2_out INTERACT mode2_diff_out { } TEMP = mode2_out 
             }
             COPY mode2_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 2, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (25 )
	  } else if (fatWireExtensionMode == 3) {
             SIZE fat {
	        GROW_LEFT = fatTblExtensionRange
	        GROW_RIGHT = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal8  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	       	PARALLEL = TRUE

	       	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		HORIZONTAL_ONLY = TRUE
             } TEMP = spacing_hor
	     SELECT spacing_hor INSIDE fat_ran {  } TEMP = spacing_hor
	     SELECT spacing_hor OUTSIDE fat {  } TEMP = spacing_hor
             SIZE fat {
	        GROW_TOP = fatTblExtensionRange
	        GROW_BOTTOM = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal8  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	        POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		VERTICAL_ONLY = TRUE
             } TEMP = spacing_ver
	     SELECT spacing_ver INSIDE fat_ran {  } TEMP = spacing_ver
	     SELECT spacing_ver OUTSIDE fat {  } TEMP = spacing_ver
  	     BOOLEAN spacing_hor OR spacing_ver {  } TEMP = spacing
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal8  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
  	     /* check overlapped projection length */
 	     if (fatTblParallelLength > 0) {
                POLYGON_FEATURES fat_ext {
                   EQUATIONS {
                      vnum = EV_VNUM_IN;
                      if ( vnum > 0) {
                         bdLeft = EV_VXCOORD_IN[0];
                         bdRight = EV_VXCOORD_IN[0];
                         bdBottom = EV_VYCOORD_IN[0];
                         bdTop = EV_VYCOORD_IN[0];
                         FOR (i = 1; i < vnum; i++) {
                            if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
                            else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
                            if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
                            else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
                         } /* FOR i */
                         if ( (bdRight - bdLeft) >= fatTblParallelLength ||
                  	      (bdTop - bdBottom) >= fatTblParallelLength) {
                            FOR (i = 0; i < vnum; i++) {
                               EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
                               EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
                            }
                            EV_VNUM_OUT = vnum;
                 	    EV_SAVE_POLYGON();
                         }
                      }
                   }
                } TEMP = fat_ext /* POLYGON_FEATURE */
             }
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode3_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode3_out NOT mode3_child_out { } TEMP = mode3_diff_out
                SELECT mode3_out INTERACT mode3_diff_out { } TEMP = mode3_out
             }
             COPY mode3_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 3, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (25 )
          }
       }
       SET fatTblSpacing = 0;
    }
}
@ 957 "adrc/adrc.ev" 2


SET fatTblThreshold = 1.505;
SET fatTblParallelLength = 1.505;
SET minWidth = 0.056;

SET fatTblThreshold_Start = 0;
SET fatTblSpacing = 0.6;
@ 1 "adrc/adrc_fatMetal.ev" 1
/*check fat metal table*/
if (fatTblThreshold > 0) {
    if ((fatTblThreshold / 2.0) > 0.0001 ) {
       SIZE fat_candidate  { UNDER_OVER = fatTblThreshold / 2.0 - 0.0001  } TEMP = fat_candidate
       if (fatTblNextThreshold > 0) {
          SIZE fat_candidate { UNDER_OVER = fatTblNextThreshold / 2.0 - 0.0001  } TEMP = fat_next
          BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
          BOOLEAN fat AND fat_target { } TEMP = fat
          SET fatTblNextThreshold = 0;
       } else {
          BOOLEAN fat_candidate AND fat_target {  } TEMP = fat 
       }
    } else {
      COPY fat_target {  } TEMP = fat 
    }
    COPY fat_target { } TEMP = spc_target
    if (fatTblThreshold_Start > 0  || fatTblThreshold_End > 0) {
       if (fatTblThreshold_Start > 0) {
          SIZE fat_target { UNDER_OVER = fatTblThreshold_Start / 2.0 - 0.0001  } TEMP = spc_target
       }
       if (fatTblThreshold_End > 0 && fatTblThreshold_End > fatTblThreshold_Start) {
          SIZE spc_target { UNDER_OVER = fatTblThreshold_End / 2.0 - 0.0001  } TEMP = fat_end
          BOOLEAN spc_target NOT fat_end { } TEMP = spc_target
       }
       BOOLEAN spc_target AND fat_target {  } TEMP = spc_target
       if (ignoreBlockage == 0 && fatTblThreshold_Start < fatTblThreshold_1) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal8_blockage  {  } TEMP = spc_target
       }
       SET fatTblThreshold_Start = 0;
       SET fatTblThreshold_End = 0;
       SET fatTblThreshold_1 = 0;
    } else {
       if (ignoreBlockage == 0) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal8_blockage  {  } TEMP = spc_target
       }
    }
 
    if (fatTblEnclosedArea > 0) {
       SELECT holes INTERACT fat { } TEMP = fat_holes
       AREA fat_holes { 
          RANGE = [0.0001 * 0.0001 , fatTblEnclosedArea - 0.0001 * 0.0001 ]
       } TEMP = fat_holes
       if (fatTblMinEnclosedAreaMode==0) {
          SIZE fat_holes { OVER_UNDER = fatTblThreshold / 2.0 + 0.0001  } TEMP = ovun_holes
          SELECT ovun_holes INTERACT fat_holes { RANGE = [2, 9999999999 ] } TEMP = merged_holes
          BOOLEAN fat_candidate AND fat_target { } TEMP = fat_metal
          BOOLEAN metal8  NOT fat_metal { } TEMP = thin_metal
          BOOLEAN thin_metal NOT ovun_holes { } TEMP = thin_metal
          SELECT ovun_holes INTERACT thin_metal { } TEMP = thin_holes
          BOOLEAN thin_holes OR merged_holes { } TEMP = thin_holes
          BOOLEAN fat_holes NOT thin_holes { } TEMP = fat_holes
       }
       COPY fat_holes { 
	  COMMENT = "$layer_name EnclsArea : fat metal ( fatTblThreshold um) minimum enclosed area (mode fatTblMinEnclosedAreaMode ) = fatTblEnclosedArea um*um"
       } (25 )
       SET fatTblEnclosedArea = 0;
    }
    if (fatTblSpacing > 0) {
       /*check fat metal*/ 
       if (fatTblParallelLength > 0) {
          if (router_parallelLengthNetMode == 1 || parallelLengthMode == 1) {
             AREA spc_target { RANGE = [fatTblParallelLength * minWidth + 0.0001 , 9999999999 ] } TEMP = spc_target1
             COPY spc_target1 { } TEMP = spc_target2
          } else {
             COPY spc_target { } TEMP = spc_target2
          }
          if (parallelLengthMode == 1) {
             SELECT metal8  INTERACT fat { } TEMP = fat_all 
             BOOLEAN fat_all OR fat { } TEMP = fat2
             SELECT metal8  INTERACT spc_target2 { } TEMP = spc_target_all
             BOOLEAN spc_target_all OR spc_target2 { } TEMP = spc_target2
          } else {
             COPY fat { } TEMP = fat2
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING <= fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
                OUTPUT_EDGES = TRUE
             } TEMP = vio_edge
             SELECT vio_edge INTERACT fat { } TEMP = vio_edge
             SELECT vio_edge INTERACT spc_target1 { } TEMP = vio_edge
             SELECT violation INTERACT vio_edge { } TEMP = violation
          } else {
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
          }
          BOOLEAN violation NOT fat_target { } TEMP = violation
          if (fatTblParallelLength < fatTblSpacing) {
             SELECT_EDGE violation TOUCHING fat2 {
                VSIZE_INSIDE = fatTblParallelLength - 0.0002 
             } TEMP = vio_filter
             SELECT_CONTAINS vio_filter { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = vio_filter
             SELECT violation INTERACT vio_filter { } TEMP = violation
          } else {
             SELECT_CONTAINS violation { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = violation
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING = [fatTblSpacing, fatTblSpacing]
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
             } TEMP = violation3
             BOOLEAN violation3 NOT fat_target { } TEMP = violation3
             BOOLEAN violation NOT violation3 { } TEMP= violation
          }
          SELECT_EDGE fat2 TOUCHING violation { } TEMP=fat_viol
          BOOLEAN fat_viol AND violation { } TEMP=fat_viol
          SELECT_EDGE spc_target2 TOUCHING violation { } TEMP=spc_target2
          BOOLEAN spc_target2 AND violation { } TEMP= spc_target2
	  if (ignoreChildCell == 1) {
             EXTERNAL fat_viol spc_target2 {
		SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		TOUCH = FALSE
		POINT_TOUCH = FALSE
		NON_PARALLEL = TRUE
	     } TEMP = spc_mode0_out
             BOOLEAN spc_mode0_out NOT spc_mode0_child_out { } TEMP = spc_mode0_diff_out
             SELECT spc_mode0_out INTERACT spc_mode0_diff_out { } TEMP = spc_mode0_out
	     SELECT_EDGE fat2 TOUCHING spc_mode0_out { } TEMP=fat_viol
	     BOOLEAN fat_viol AND spc_mode0_out { } TEMP=fat_viol
	     SELECT_EDGE spc_target2 TOUCHING spc_mode0_out { } TEMP=spc_target2
	     BOOLEAN spc_target2 AND spc_mode0_out { } TEMP=spc_target2
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (25 )  		
	  } else {
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing 
	        SET_CORNERS_TO_SPACING = FALSE
	        PARALLEL_POINT_PROJECTION = FALSE
	        TOUCH = FALSE
	        POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (25 )
	  }
	  if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	     if (ignoreChildCell == 1) {
		EXTERNAL fat spc_target {
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} TEMP = spc_mode1_out
	        BOOLEAN spc_mode1_out NOT spc_mode1_child_out { } TEMP = spc_mode1_diff_out
	        SELECT spc_mode1_out INTERACT spc_mode1_diff_out { } TEMP = spc_mode1_out
                SELECT_EDGE fat TOUCHING spc_mode1_out { } TEMP=fat_viol
	        BOOLEAN fat_viol AND spc_mode1_out { } TEMP=fat_viol
	        SELECT_EDGE spc_target TOUCHING spc_mode1_out { } TEMP=spc_target2
	        BOOLEAN spc_target2 AND spc_mode1_out { } TEMP=spc_target2
	        EXTERNAL fat_viol spc_target2 {
	           COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um " 	    
		   SPACING < fatTblSpacing_dg
                   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} (25 )
	     } else {
	        EXTERNAL fat spc_target {
		   COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um "
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
	    	   PARALLEL_POINT_PROJECTION = FALSE
	           TOUCH = FALSE
	     	   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } (25 ) 
	     }
          }
       } else {
	  if (ignoreChildCell == 1) {
              EXTERNAL fat spc_target {
                 SPACING < fatTblSpacing
                 BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
              } TEMP = spc_out
	      BOOLEAN spc_out NOT spc_child_out { } TEMP = spc_diff_out
	      SELECT spc_out INTERACT spc_diff_out { } TEMP = spc_out
	      SELECT_EDGE fat TOUCHING spc_out { } TEMP=fat_viol
	      BOOLEAN fat_viol AND spc_out { } TEMP=fat_viol
              SELECT_EDGE spc_target TOUCHING spc_out { } TEMP=spc_target2
	      BOOLEAN spc_target2 AND spc_out { } TEMP=spc_target2
	      EXTERNAL fat_viol spc_target2 {
		 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
		 BOX_CORNER = FALSE 
		 NON_PARALLEL = TRUE
		 POINT_TOUCH = FALSE
	      } (25 ) 
	  } else {
	      EXTERNAL fat spc_target {
                 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
	         BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
	      } (25 ) 
	  }
       }
       /*check metal in the extension range*/ 
       if (fatTblExtensionRange > 0) {
	  if (fatWireExtensionMode == 0) {
	     SIZE fat { OVERSIZE = fatTblExtensionRange } TEMP = fat_tmp
             BOOLEAN fat_tmp AND metal8  { } TEMP = fat_tmp
  	     BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
             SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_ext
             BOOLEAN fat_ext OR fat { } TEMP = fat_ext
	     if (fatTblParallelLength > 0) {
                if (fatTblParallelLength > fatTblExtensionRange) {
                   SIZE fat { OVERSIZE = fatTblParallelLength } TEMP = fat_tmp
                   BOOLEAN fat_tmp AND metal8  { } TEMP = fat_tmp
  	           BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
                   SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_parallel
                   BOOLEAN fat_parallel OR fat { } TEMP = fat_parallel
                } else {
                   COPY fat_ext { } TEMP = fat_parallel
                }
		EXTERNAL fat_parallel spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
	           NON_PARALLEL = TRUE
	        } TEMP = vio_filter_set
		EXTERNAL fat_ext spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } TEMP = vio_set
                if (fatTblParallelLength < fatTblSpacing) {
                   SELECT_EDGE vio_filter_set TOUCHING fat_parallel {
                      VSIZE_INSIDE = fatTblParallelLength - 0.0002 
                   } TEMP = vio_filter_set_filter
                   SELECT_CONTAINS vio_filter_set_filter { 
                      WIDTH =  0.0002 
                      HEIGHT = fatTblParallelLength + 0.0001 
                   } TEMP = vio_filter_set_filter
                   SELECT vio_filter_set INTERACT vio_filter_set_filter { } TEMP = vio_filter
                } else {
	           SELECT_CONTAINS vio_filter_set { 
	              WIDTH =  0.0002 
	              HEIGHT = fatTblParallelLength + 0.0001 
	           } TEMP = vio_filter
                }
                SELECT vio_set INSIDE vio_filter { } TEMP = mode0_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out1 NOT mode0_child_out1 { } TEMP = mode0_diff_out1
                   SELECT mode0_out1 INTERACT mode0_diff_out1 { } TEMP = mode0_out1
                }
                COPY mode0_out1 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing  = fatTblSpacing um"
                } (25 )
		if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	           EXTERNAL fat_ext spc_target {
		      SPACING < fatTblSpacing_dg
	              SET_CORNERS_TO_SPACING = FALSE
		      PARALLEL_POINT_PROJECTION = FALSE
		      TOUCH = TRUE
		      POINT_TOUCH = FALSE
		      NON_PARALLEL = TRUE
	           } TEMP = mode0_out2
                   if (ignoreChildCell == 1) {
                      BOOLEAN mode0_out2 NOT mode0_child_out2 { } TEMP = mode0_diff_out2
                      SELECT mode0_out2 INTERACT mode0_diff_out2 { } TEMP = mode0_out2
                   }
                   COPY mode0_out2 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing (mode 1/2) = fatTblSpacing um/ fatTblSpacing_dg um "
                   } (25 )
	        } 
	     } else {
	        EXTERNAL fat_ext spc_target {
		   SPACING < fatTblSpacing
		   NON_PARALLEL = TRUE
		   SET_CORNERS_TO_SPACING = FALSE
		   POINT_TOUCH = FALSE
		} TEMP = mode0_out3
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out3 NOT mode0_child_out3 { } TEMP = mode0_diff_out3
                   SELECT mode0_out3 INTERACT mode0_diff_out3 { } TEMP = mode0_out3
                }
                COPY mode0_out3 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range ( fatTblExtensionRange um) minimum spacing = fatTblSpacing um"
                } (25 )
	     }
	  } else if (fatWireExtensionMode == 1) {
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal8  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             if (fatTblParallelLength > 0) {
                EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
		   BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   CHECK_SAME_POLYGON = TRUE 
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
	        SELECT fat_ext INTERACT spacing {  } TEMP = fat_ext
		BOOLEAN fat_ext OR spacing {  } TEMP = combined_fat_ext
                EXTERNAL combined_fat_ext fat {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
                } TEMP = fat_spacing
		BOOLEAN fat_spacing AND fat_ran {  } TEMP = fat_spacing
		BOOLEAN combined_fat_ext OR fat_spacing {  } TEMP = combined_fat_ext
                SELECT_CONTAINS combined_fat_ext { 
                   WIDTH =  0.0002 
                   HEIGHT = fatTblParallelLength + 0.0001 
                } TEMP = combined_fat_ext
		SELECT spacing INTERACT combined_fat_ext { 
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out1 NOT mode1_child_out1 { } TEMP = mode1_diff_out1
                   SELECT mode1_out1 INTERACT mode1_diff_out1 { } TEMP = mode1_out1 
                }
                COPY mode1_out1 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (25 ) 
	     } else {
               	EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
	           BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
	           CHECK_SAME_POLYGON = TRUE 
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
                SELECT spacing INTERACT fat_ext {
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out2
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out2 NOT mode1_child_out2 { } TEMP = mode1_diff_out2
                   SELECT mode1_out2 INTERACT mode1_diff_out2 { } TEMP = mode1_out2
                }
                COPY mode1_out2 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (25 )
	     }
	  } else if (fatWireExtensionMode == 2) {
	     SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
             BOOLEAN fat_ran AND metal8  {  } TEMP = fat_ext
             BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	      	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
             } TEMP = spacing
 	     SELECT spacing INSIDE fat_ran {  } TEMP = spacing
	     SELECT spacing OUTSIDE fat {  } TEMP = spacing
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode2_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode2_out NOT mode2_child_out { } TEMP = mode2_diff_out
                SELECT mode2_out INTERACT mode2_diff_out { } TEMP = mode2_out 
             }
             COPY mode2_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 2, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (25 )
	  } else if (fatWireExtensionMode == 3) {
             SIZE fat {
	        GROW_LEFT = fatTblExtensionRange
	        GROW_RIGHT = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal8  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	       	PARALLEL = TRUE

	       	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		HORIZONTAL_ONLY = TRUE
             } TEMP = spacing_hor
	     SELECT spacing_hor INSIDE fat_ran {  } TEMP = spacing_hor
	     SELECT spacing_hor OUTSIDE fat {  } TEMP = spacing_hor
             SIZE fat {
	        GROW_TOP = fatTblExtensionRange
	        GROW_BOTTOM = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal8  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	        POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		VERTICAL_ONLY = TRUE
             } TEMP = spacing_ver
	     SELECT spacing_ver INSIDE fat_ran {  } TEMP = spacing_ver
	     SELECT spacing_ver OUTSIDE fat {  } TEMP = spacing_ver
  	     BOOLEAN spacing_hor OR spacing_ver {  } TEMP = spacing
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal8  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
  	     /* check overlapped projection length */
 	     if (fatTblParallelLength > 0) {
                POLYGON_FEATURES fat_ext {
                   EQUATIONS {
                      vnum = EV_VNUM_IN;
                      if ( vnum > 0) {
                         bdLeft = EV_VXCOORD_IN[0];
                         bdRight = EV_VXCOORD_IN[0];
                         bdBottom = EV_VYCOORD_IN[0];
                         bdTop = EV_VYCOORD_IN[0];
                         FOR (i = 1; i < vnum; i++) {
                            if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
                            else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
                            if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
                            else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
                         } /* FOR i */
                         if ( (bdRight - bdLeft) >= fatTblParallelLength ||
                  	      (bdTop - bdBottom) >= fatTblParallelLength) {
                            FOR (i = 0; i < vnum; i++) {
                               EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
                               EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
                            }
                            EV_VNUM_OUT = vnum;
                 	    EV_SAVE_POLYGON();
                         }
                      }
                   }
                } TEMP = fat_ext /* POLYGON_FEATURE */
             }
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode3_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode3_out NOT mode3_child_out { } TEMP = mode3_diff_out
                SELECT mode3_out INTERACT mode3_diff_out { } TEMP = mode3_out
             }
             COPY mode3_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 3, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (25 )
          }
       }
       SET fatTblSpacing = 0;
    }
}
@ 965 "adrc/adrc.ev" 2


SET fatTblThreshold = 3.005;
SET fatTblParallelLength = 3.005;
SET minWidth = 0.056;

SET fatTblThreshold_Start = 0;
SET fatTblSpacing = 0.7;
@ 1 "adrc/adrc_fatMetal.ev" 1
/*check fat metal table*/
if (fatTblThreshold > 0) {
    if ((fatTblThreshold / 2.0) > 0.0001 ) {
       SIZE fat_candidate  { UNDER_OVER = fatTblThreshold / 2.0 - 0.0001  } TEMP = fat_candidate
       if (fatTblNextThreshold > 0) {
          SIZE fat_candidate { UNDER_OVER = fatTblNextThreshold / 2.0 - 0.0001  } TEMP = fat_next
          BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
          BOOLEAN fat AND fat_target { } TEMP = fat
          SET fatTblNextThreshold = 0;
       } else {
          BOOLEAN fat_candidate AND fat_target {  } TEMP = fat 
       }
    } else {
      COPY fat_target {  } TEMP = fat 
    }
    COPY fat_target { } TEMP = spc_target
    if (fatTblThreshold_Start > 0  || fatTblThreshold_End > 0) {
       if (fatTblThreshold_Start > 0) {
          SIZE fat_target { UNDER_OVER = fatTblThreshold_Start / 2.0 - 0.0001  } TEMP = spc_target
       }
       if (fatTblThreshold_End > 0 && fatTblThreshold_End > fatTblThreshold_Start) {
          SIZE spc_target { UNDER_OVER = fatTblThreshold_End / 2.0 - 0.0001  } TEMP = fat_end
          BOOLEAN spc_target NOT fat_end { } TEMP = spc_target
       }
       BOOLEAN spc_target AND fat_target {  } TEMP = spc_target
       if (ignoreBlockage == 0 && fatTblThreshold_Start < fatTblThreshold_1) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal8_blockage  {  } TEMP = spc_target
       }
       SET fatTblThreshold_Start = 0;
       SET fatTblThreshold_End = 0;
       SET fatTblThreshold_1 = 0;
    } else {
       if (ignoreBlockage == 0) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal8_blockage  {  } TEMP = spc_target
       }
    }
 
    if (fatTblEnclosedArea > 0) {
       SELECT holes INTERACT fat { } TEMP = fat_holes
       AREA fat_holes { 
          RANGE = [0.0001 * 0.0001 , fatTblEnclosedArea - 0.0001 * 0.0001 ]
       } TEMP = fat_holes
       if (fatTblMinEnclosedAreaMode==0) {
          SIZE fat_holes { OVER_UNDER = fatTblThreshold / 2.0 + 0.0001  } TEMP = ovun_holes
          SELECT ovun_holes INTERACT fat_holes { RANGE = [2, 9999999999 ] } TEMP = merged_holes
          BOOLEAN fat_candidate AND fat_target { } TEMP = fat_metal
          BOOLEAN metal8  NOT fat_metal { } TEMP = thin_metal
          BOOLEAN thin_metal NOT ovun_holes { } TEMP = thin_metal
          SELECT ovun_holes INTERACT thin_metal { } TEMP = thin_holes
          BOOLEAN thin_holes OR merged_holes { } TEMP = thin_holes
          BOOLEAN fat_holes NOT thin_holes { } TEMP = fat_holes
       }
       COPY fat_holes { 
	  COMMENT = "$layer_name EnclsArea : fat metal ( fatTblThreshold um) minimum enclosed area (mode fatTblMinEnclosedAreaMode ) = fatTblEnclosedArea um*um"
       } (25 )
       SET fatTblEnclosedArea = 0;
    }
    if (fatTblSpacing > 0) {
       /*check fat metal*/ 
       if (fatTblParallelLength > 0) {
          if (router_parallelLengthNetMode == 1 || parallelLengthMode == 1) {
             AREA spc_target { RANGE = [fatTblParallelLength * minWidth + 0.0001 , 9999999999 ] } TEMP = spc_target1
             COPY spc_target1 { } TEMP = spc_target2
          } else {
             COPY spc_target { } TEMP = spc_target2
          }
          if (parallelLengthMode == 1) {
             SELECT metal8  INTERACT fat { } TEMP = fat_all 
             BOOLEAN fat_all OR fat { } TEMP = fat2
             SELECT metal8  INTERACT spc_target2 { } TEMP = spc_target_all
             BOOLEAN spc_target_all OR spc_target2 { } TEMP = spc_target2
          } else {
             COPY fat { } TEMP = fat2
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING <= fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
                OUTPUT_EDGES = TRUE
             } TEMP = vio_edge
             SELECT vio_edge INTERACT fat { } TEMP = vio_edge
             SELECT vio_edge INTERACT spc_target1 { } TEMP = vio_edge
             SELECT violation INTERACT vio_edge { } TEMP = violation
          } else {
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
          }
          BOOLEAN violation NOT fat_target { } TEMP = violation
          if (fatTblParallelLength < fatTblSpacing) {
             SELECT_EDGE violation TOUCHING fat2 {
                VSIZE_INSIDE = fatTblParallelLength - 0.0002 
             } TEMP = vio_filter
             SELECT_CONTAINS vio_filter { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = vio_filter
             SELECT violation INTERACT vio_filter { } TEMP = violation
          } else {
             SELECT_CONTAINS violation { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = violation
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING = [fatTblSpacing, fatTblSpacing]
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
             } TEMP = violation3
             BOOLEAN violation3 NOT fat_target { } TEMP = violation3
             BOOLEAN violation NOT violation3 { } TEMP= violation
          }
          SELECT_EDGE fat2 TOUCHING violation { } TEMP=fat_viol
          BOOLEAN fat_viol AND violation { } TEMP=fat_viol
          SELECT_EDGE spc_target2 TOUCHING violation { } TEMP=spc_target2
          BOOLEAN spc_target2 AND violation { } TEMP= spc_target2
	  if (ignoreChildCell == 1) {
             EXTERNAL fat_viol spc_target2 {
		SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		TOUCH = FALSE
		POINT_TOUCH = FALSE
		NON_PARALLEL = TRUE
	     } TEMP = spc_mode0_out
             BOOLEAN spc_mode0_out NOT spc_mode0_child_out { } TEMP = spc_mode0_diff_out
             SELECT spc_mode0_out INTERACT spc_mode0_diff_out { } TEMP = spc_mode0_out
	     SELECT_EDGE fat2 TOUCHING spc_mode0_out { } TEMP=fat_viol
	     BOOLEAN fat_viol AND spc_mode0_out { } TEMP=fat_viol
	     SELECT_EDGE spc_target2 TOUCHING spc_mode0_out { } TEMP=spc_target2
	     BOOLEAN spc_target2 AND spc_mode0_out { } TEMP=spc_target2
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (25 )  		
	  } else {
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing 
	        SET_CORNERS_TO_SPACING = FALSE
	        PARALLEL_POINT_PROJECTION = FALSE
	        TOUCH = FALSE
	        POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (25 )
	  }
	  if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	     if (ignoreChildCell == 1) {
		EXTERNAL fat spc_target {
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} TEMP = spc_mode1_out
	        BOOLEAN spc_mode1_out NOT spc_mode1_child_out { } TEMP = spc_mode1_diff_out
	        SELECT spc_mode1_out INTERACT spc_mode1_diff_out { } TEMP = spc_mode1_out
                SELECT_EDGE fat TOUCHING spc_mode1_out { } TEMP=fat_viol
	        BOOLEAN fat_viol AND spc_mode1_out { } TEMP=fat_viol
	        SELECT_EDGE spc_target TOUCHING spc_mode1_out { } TEMP=spc_target2
	        BOOLEAN spc_target2 AND spc_mode1_out { } TEMP=spc_target2
	        EXTERNAL fat_viol spc_target2 {
	           COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um " 	    
		   SPACING < fatTblSpacing_dg
                   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} (25 )
	     } else {
	        EXTERNAL fat spc_target {
		   COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um "
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
	    	   PARALLEL_POINT_PROJECTION = FALSE
	           TOUCH = FALSE
	     	   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } (25 ) 
	     }
          }
       } else {
	  if (ignoreChildCell == 1) {
              EXTERNAL fat spc_target {
                 SPACING < fatTblSpacing
                 BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
              } TEMP = spc_out
	      BOOLEAN spc_out NOT spc_child_out { } TEMP = spc_diff_out
	      SELECT spc_out INTERACT spc_diff_out { } TEMP = spc_out
	      SELECT_EDGE fat TOUCHING spc_out { } TEMP=fat_viol
	      BOOLEAN fat_viol AND spc_out { } TEMP=fat_viol
              SELECT_EDGE spc_target TOUCHING spc_out { } TEMP=spc_target2
	      BOOLEAN spc_target2 AND spc_out { } TEMP=spc_target2
	      EXTERNAL fat_viol spc_target2 {
		 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
		 BOX_CORNER = FALSE 
		 NON_PARALLEL = TRUE
		 POINT_TOUCH = FALSE
	      } (25 ) 
	  } else {
	      EXTERNAL fat spc_target {
                 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
	         BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
	      } (25 ) 
	  }
       }
       /*check metal in the extension range*/ 
       if (fatTblExtensionRange > 0) {
	  if (fatWireExtensionMode == 0) {
	     SIZE fat { OVERSIZE = fatTblExtensionRange } TEMP = fat_tmp
             BOOLEAN fat_tmp AND metal8  { } TEMP = fat_tmp
  	     BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
             SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_ext
             BOOLEAN fat_ext OR fat { } TEMP = fat_ext
	     if (fatTblParallelLength > 0) {
                if (fatTblParallelLength > fatTblExtensionRange) {
                   SIZE fat { OVERSIZE = fatTblParallelLength } TEMP = fat_tmp
                   BOOLEAN fat_tmp AND metal8  { } TEMP = fat_tmp
  	           BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
                   SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_parallel
                   BOOLEAN fat_parallel OR fat { } TEMP = fat_parallel
                } else {
                   COPY fat_ext { } TEMP = fat_parallel
                }
		EXTERNAL fat_parallel spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
	           NON_PARALLEL = TRUE
	        } TEMP = vio_filter_set
		EXTERNAL fat_ext spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } TEMP = vio_set
                if (fatTblParallelLength < fatTblSpacing) {
                   SELECT_EDGE vio_filter_set TOUCHING fat_parallel {
                      VSIZE_INSIDE = fatTblParallelLength - 0.0002 
                   } TEMP = vio_filter_set_filter
                   SELECT_CONTAINS vio_filter_set_filter { 
                      WIDTH =  0.0002 
                      HEIGHT = fatTblParallelLength + 0.0001 
                   } TEMP = vio_filter_set_filter
                   SELECT vio_filter_set INTERACT vio_filter_set_filter { } TEMP = vio_filter
                } else {
	           SELECT_CONTAINS vio_filter_set { 
	              WIDTH =  0.0002 
	              HEIGHT = fatTblParallelLength + 0.0001 
	           } TEMP = vio_filter
                }
                SELECT vio_set INSIDE vio_filter { } TEMP = mode0_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out1 NOT mode0_child_out1 { } TEMP = mode0_diff_out1
                   SELECT mode0_out1 INTERACT mode0_diff_out1 { } TEMP = mode0_out1
                }
                COPY mode0_out1 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing  = fatTblSpacing um"
                } (25 )
		if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	           EXTERNAL fat_ext spc_target {
		      SPACING < fatTblSpacing_dg
	              SET_CORNERS_TO_SPACING = FALSE
		      PARALLEL_POINT_PROJECTION = FALSE
		      TOUCH = TRUE
		      POINT_TOUCH = FALSE
		      NON_PARALLEL = TRUE
	           } TEMP = mode0_out2
                   if (ignoreChildCell == 1) {
                      BOOLEAN mode0_out2 NOT mode0_child_out2 { } TEMP = mode0_diff_out2
                      SELECT mode0_out2 INTERACT mode0_diff_out2 { } TEMP = mode0_out2
                   }
                   COPY mode0_out2 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing (mode 1/2) = fatTblSpacing um/ fatTblSpacing_dg um "
                   } (25 )
	        } 
	     } else {
	        EXTERNAL fat_ext spc_target {
		   SPACING < fatTblSpacing
		   NON_PARALLEL = TRUE
		   SET_CORNERS_TO_SPACING = FALSE
		   POINT_TOUCH = FALSE
		} TEMP = mode0_out3
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out3 NOT mode0_child_out3 { } TEMP = mode0_diff_out3
                   SELECT mode0_out3 INTERACT mode0_diff_out3 { } TEMP = mode0_out3
                }
                COPY mode0_out3 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range ( fatTblExtensionRange um) minimum spacing = fatTblSpacing um"
                } (25 )
	     }
	  } else if (fatWireExtensionMode == 1) {
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal8  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             if (fatTblParallelLength > 0) {
                EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
		   BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   CHECK_SAME_POLYGON = TRUE 
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
	        SELECT fat_ext INTERACT spacing {  } TEMP = fat_ext
		BOOLEAN fat_ext OR spacing {  } TEMP = combined_fat_ext
                EXTERNAL combined_fat_ext fat {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
                } TEMP = fat_spacing
		BOOLEAN fat_spacing AND fat_ran {  } TEMP = fat_spacing
		BOOLEAN combined_fat_ext OR fat_spacing {  } TEMP = combined_fat_ext
                SELECT_CONTAINS combined_fat_ext { 
                   WIDTH =  0.0002 
                   HEIGHT = fatTblParallelLength + 0.0001 
                } TEMP = combined_fat_ext
		SELECT spacing INTERACT combined_fat_ext { 
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out1 NOT mode1_child_out1 { } TEMP = mode1_diff_out1
                   SELECT mode1_out1 INTERACT mode1_diff_out1 { } TEMP = mode1_out1 
                }
                COPY mode1_out1 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (25 ) 
	     } else {
               	EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
	           BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
	           CHECK_SAME_POLYGON = TRUE 
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
                SELECT spacing INTERACT fat_ext {
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out2
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out2 NOT mode1_child_out2 { } TEMP = mode1_diff_out2
                   SELECT mode1_out2 INTERACT mode1_diff_out2 { } TEMP = mode1_out2
                }
                COPY mode1_out2 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (25 )
	     }
	  } else if (fatWireExtensionMode == 2) {
	     SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
             BOOLEAN fat_ran AND metal8  {  } TEMP = fat_ext
             BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	      	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
             } TEMP = spacing
 	     SELECT spacing INSIDE fat_ran {  } TEMP = spacing
	     SELECT spacing OUTSIDE fat {  } TEMP = spacing
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode2_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode2_out NOT mode2_child_out { } TEMP = mode2_diff_out
                SELECT mode2_out INTERACT mode2_diff_out { } TEMP = mode2_out 
             }
             COPY mode2_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 2, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (25 )
	  } else if (fatWireExtensionMode == 3) {
             SIZE fat {
	        GROW_LEFT = fatTblExtensionRange
	        GROW_RIGHT = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal8  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	       	PARALLEL = TRUE

	       	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		HORIZONTAL_ONLY = TRUE
             } TEMP = spacing_hor
	     SELECT spacing_hor INSIDE fat_ran {  } TEMP = spacing_hor
	     SELECT spacing_hor OUTSIDE fat {  } TEMP = spacing_hor
             SIZE fat {
	        GROW_TOP = fatTblExtensionRange
	        GROW_BOTTOM = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal8  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	        POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		VERTICAL_ONLY = TRUE
             } TEMP = spacing_ver
	     SELECT spacing_ver INSIDE fat_ran {  } TEMP = spacing_ver
	     SELECT spacing_ver OUTSIDE fat {  } TEMP = spacing_ver
  	     BOOLEAN spacing_hor OR spacing_ver {  } TEMP = spacing
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal8  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
  	     /* check overlapped projection length */
 	     if (fatTblParallelLength > 0) {
                POLYGON_FEATURES fat_ext {
                   EQUATIONS {
                      vnum = EV_VNUM_IN;
                      if ( vnum > 0) {
                         bdLeft = EV_VXCOORD_IN[0];
                         bdRight = EV_VXCOORD_IN[0];
                         bdBottom = EV_VYCOORD_IN[0];
                         bdTop = EV_VYCOORD_IN[0];
                         FOR (i = 1; i < vnum; i++) {
                            if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
                            else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
                            if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
                            else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
                         } /* FOR i */
                         if ( (bdRight - bdLeft) >= fatTblParallelLength ||
                  	      (bdTop - bdBottom) >= fatTblParallelLength) {
                            FOR (i = 0; i < vnum; i++) {
                               EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
                               EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
                            }
                            EV_VNUM_OUT = vnum;
                 	    EV_SAVE_POLYGON();
                         }
                      }
                   }
                } TEMP = fat_ext /* POLYGON_FEATURE */
             }
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode3_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode3_out NOT mode3_child_out { } TEMP = mode3_diff_out
                SELECT mode3_out INTERACT mode3_diff_out { } TEMP = mode3_out
             }
             COPY mode3_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 3, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (25 )
          }
       }
       SET fatTblSpacing = 0;
    }
}
@ 973 "adrc/adrc.ev" 2


SET fatTblThreshold = 0;
SET fatTblEnclosedArea = 0;
SET fatTblExtensionRange = 0;
SET fatTblParallelLength = 0;
SET minWidth = 0;

/* End of Met8 fat table spacing rules */










/*metal 9*/
SET layer_name = "Met9";










SET minWidth = 0.16;
SET maxWidth = 10;
SET minArea = 0.055;
SET minEnclosedArea = 0.2;
SET minSpacing = 0.16;
SET stub2StubSpacing = 0;

SET fatTblDimension = 3;
@ 1 "adrc/adrc_check_metal.ev" 1
/* Data Preparation */
if (fatTblDimension > 1 || fatWireThreshold > 0 || maxWidth > 0) {
  if (ignoreBlockage) {
      /* Let the real blockage be treated as thin */
      BOOLEAN metal9  NOT metal9_rbkg  {} TEMP=fat_candidate
  } else {
      COPY metal9  {} TEMP=fat_candidate
  }
  COPY fat_candidate {} TEMP=fat_target
}
/*Check width*/
if (minWidth > 0) {
    INTERNAL metal9  { 
        COMMENT = "$layer_name MinWidth  : minimum width = minWidth um" 
        SPACING < minWidth
        POINT_TOUCH = FALSE
    } (27 )
}
 
if (maxWidth > 0) {
    SIZE  fat_candidate {
        COMMENT = "$layer_name MaxWidth  : maximum width = maxWidth um"
 	UNDER_OVER = maxWidth / 2 
    } (27 ) 
}
 
/*Check area*/
if (minArea > 0) {
    AREA metal9  { 
	COMMENT = "$layer_name MinArea   : minimum area = minArea um*um"
	RANGE = [0.0001 * 0.0001 , minArea - 0.0001 * 0.0001 ]
    } (27 )
}
/* check min length of bounding box on polygon */
if (minLength > 0) {
  if (minLengthMode == 1) {
    INTERNAL metal9  {
        SPACING < minLength
        VERTICAL_ONLY = TRUE
        SET_CORNERS_TO_SPACING = FALSE
    } TEMP = ver_short
    BOOLEAN metal9  NOT ver_short { } TEMP = ver_long
    INTERNAL metal9  {
        SPACING < minLength
        HORIZONTAL_ONLY = TRUE
        SET_CORNERS_TO_SPACING = FALSE
    } TEMP = hor_short
    BOOLEAN metal9  NOT hor_short { } TEMP = hor_long
    SELECT CUT_LAYER1 INSIDE ver_long { } TEMP = good_cut
    BOOLEAN CUT_LAYER1 NOT good_cut { } TEMP = fail_cut_1
    SELECT fail_cut_1 INSIDE hor_long { } TEMP = good_cut
    BOOLEAN fail_cut_1 NOT good_cut { } TEMP = fail_cut_1
    SELECT CUT_LAYER2 INSIDE ver_long { } TEMP = good_cut
    BOOLEAN CUT_LAYER2 NOT good_cut { } TEMP = fail_cut_2
    SELECT fail_cut_2 INSIDE hor_long { } TEMP = good_cut
    BOOLEAN fail_cut_2 NOT good_cut { } TEMP = fail_cut_2
    BOOLEAN fail_cut_1 OR fail_cut_2 { } TEMP = fail_cut
    BOOLEAN hor_short NOT ver_long { } TEMP = hor_short
    BOOLEAN ver_short NOT hor_long { } TEMP = ver_short
    SELECT ver_short INTERACT fail_cut { } TEMP = ver_fail
    SELECT hor_short INTERACT fail_cut { } TEMP = hor_fail
    BOOLEAN ver_fail OR hor_fail { } TEMP = all_fail
    INTERNAL all_fail {
        COMMENT = "$layer_name MinLength : minimum length = minLength um"
        SPACING < minLength
        VERTICAL_ONLY = TRUE
        SET_CORNERS_TO_SPACING = FALSE
    } (27 )
  } else {
    POLYGON_FEATURES metal9  {
      COMMENT = "$layer_name MinLength : minimum length = minLength um"
      EQUATIONS {
        vnum = EV_VNUM_IN;
        if ( vnum > 0) {
	  bdLeft = EV_VXCOORD_IN[0];
	  bdRight = EV_VXCOORD_IN[0];
	  bdBottom = EV_VYCOORD_IN[0];
	  bdTop = EV_VYCOORD_IN[0];
          FOR (i = 1; i < vnum; i++) {
	    if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
            else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
	    if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
            else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
          }
	  if ( (bdRight - bdLeft) < minLength &&
	       (bdTop - bdBottom) < minLength) {
	    FOR (i = 0; i < vnum; i++) {
              EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
	      EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
            }
	    EV_VNUM_OUT = vnum;
	    EV_SAVE_POLYGON();
          }
        }
      }
    } (27 ) 
  }
  SET minLength = 0;
}
/* check max length of bounding box on polygon */
if (maxLength > 0) {
  POLYGON_FEATURES metal9  {
    COMMENT = "$layer_name MaxLength : maximum length = maxLength um"
    EQUATIONS {
      vnum = EV_VNUM_IN;
      if ( vnum > 0) {
	bdLeft = EV_VXCOORD_IN[0];
	bdRight = EV_VXCOORD_IN[0];
	bdBottom = EV_VYCOORD_IN[0];
	bdTop = EV_VYCOORD_IN[0];
        FOR (i = 1; i < vnum; i++) {
	  if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
          else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
	  if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
          else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
        }
	if ( (bdRight - bdLeft + bdTop - bdBottom) > maxLength ) {
          EV_VXCOORD_OUT[0] = bdLeft;
	  EV_VYCOORD_OUT[0] = bdBottom;
          EV_VXCOORD_OUT[1] = bdLeft;
	  EV_VYCOORD_OUT[1] = bdTop;
          EV_VXCOORD_OUT[2] = bdRight;
	  EV_VYCOORD_OUT[2] = bdTop;
          EV_VXCOORD_OUT[3] = bdRight;
	  EV_VYCOORD_OUT[3] = bdBottom;
          EV_VXCOORD_OUT[4] = bdLeft;
	  EV_VYCOORD_OUT[4] = bdBottom;
	  EV_VNUM_OUT = 5;
	  EV_SAVE_POLYGON();
        }
      }
    }
  } (27 ) 
  SET maxLength = 0;
}
 
/*Check enclosed area*/
if (minEnclosedArea > 0) {
    SELECT metal9  INSIDE_HOLE {
        INNER_HOLE_ONLY
    } TEMP = holes
    BOOLEAN holes NOT metal9  { } TEMP = holes
 
    AREA holes {
        COMMENT = "$layer_name EnclsArea : minimum enclosed area = minEnclosedArea um*um"
        RANGE = [0.0001 * 0.0001 , minEnclosedArea - 0.0001 * 0.0001 ]
    } (27 )
    /* check min length of bounding box on polygon */
    if (minEnclosedWidth > 0) {
      POLYGON_FEATURES holes {
        COMMENT = "$layer_name EnclsWidth: minimum enclosed Width = minEnclosedWidth um"
        EQUATIONS {
          vnum = EV_VNUM_IN;
          if ( vnum > 0) {
            bdLeft = EV_VXCOORD_IN[0];
            bdRight = EV_VXCOORD_IN[0];
            bdBottom = EV_VYCOORD_IN[0];
            bdTop = EV_VYCOORD_IN[0];
            FOR (i = 1; i < vnum; i++) {
              if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
              else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
              if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
              else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
            }
            if ( (bdRight - bdLeft) < minEnclosedWidth &&
                 (bdTop - bdBottom) < minEnclosedWidth) {
              FOR (i = 0; i < vnum; i++) {
                EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
                EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
              }
              EV_VNUM_OUT = vnum;
              EV_SAVE_POLYGON();
            }
          }
        }
      } (27 ) 
    }
}
 
/*check special notch rule*/
if ((minEdgeLength2 > 0.0001  && minEdgeLength3 > 0.0001 ) || minEdgeMode==2) {
  if (minEdgeMode==2) {
    SET minEdgeLength3 = minEdgeLength ;
  }
  NOTCH metal9  {
     SPACING < minEdgeLength3
     SET_CORNERS_TO_SPACING=FALSE
     PARALLEL = TRUE
     OUTPUT_EDGES = TRUE
  } TEMP = notch_vectors
  SELECT_VECTOR notch_vectors {
     LENGTH_RANGE = [0.0001 , minEdgeLength2 - 0.0001 ]
  } TEMP = short_edges
  EXTERNAL short_edges metal9  {
     SPACING < minEdgeLength3
     SET_CORNERS_TO_SPACING=FALSE
     PARALLEL = TRUE
  } TEMP = notch_err
  /* Choose the real U-shaped notch */
  SIZE notch_err { OVERSIZE = 0.0002 *10 } TEMP = neighbors 
  BOOLEAN neighbors AND metal9  { } TEMP = neighbors
  VERTEX neighbors { 
     CONCAVE = TRUE
     CONVEX = TRUE
     SIZE = 0.0002 
  } TEMP = corners
  SELECT_EDGE neighbors INTERACT notch_err { } TEMP = target_edges
  BOOLEAN target_edges NOT corners { } TEMP = target_edges
  VERTEX neighbors { 
     CONCAVE = TRUE
     SIZE = 2* 0.0002 
  } TEMP = corners
  SELECT target_edges INTERACT corners { RANGE = [2, 2] } TEMP=target_edges
  SELECT notch_err INTERACT target_edges {
     COMMENT = "$layer_name SpeclNotch: sameNetSp = minEdgeLength3 um (sideLen minEdgeLength2 um)" 
  } (27 )
}
/*check consecutive short edges*/
if (minEdgeLength > 0.0001  && minEdgeMode != 2) { 
  INTERNAL metal9_top  {
     SEGMENT < minEdgeLength
     FLAG_ACUTE_ANGLE = FALSE
     FLAG_ACUTE_EDGE = FALSE
     OUTPUT_EDGES = TRUE
  } TEMP = short_edges
  if ((minEdgeMode == 0 && maxTotalMinEdgeLength>0) || maxNumMinEdge > 0) {
    SET temporary_1 = 0.0002 *2;
    SET temporary_2 = 2*temporary_1+ 0.0001 ;
    SELECT metal9_top  INTERACT short_edges { } TEMP = target_top
    CLASSIFY_EDGES target_top {
       LENGTH = temporary_1
       DMIN   = temporary_2
       INSIDE_CORNER  TEMP = inside_corner_edges
       OUTSIDE_CORNER TEMP = outside_corner_edges
       REMAINDER      TEMP = remainder_edges
    }
    if (minEdgeMode == 0 && (maxNumMinEdge>0 || maxTotalMinEdgeLength > 0)) {
       SELECT short_edges ENCLOSING inside_corner_edges { } TEMP = short_edges
    }
  }
  if (maxTotalMinEdgeLength > 0) {
    LENGTH short_edges {
       RANGE = [maxTotalMinEdgeLength + 0.0001 , 9999999999 ]
    } TEMP = max_length_err
    /* Work around: translate polygons into dimensional check output */
    SIZE max_length_err { OVERSIZE = 2* 0.0002  } TEMP = max_length_err
    INTERNAL max_length_err {
       SPACING < 3* 0.0002 
       SET_CORNERS_TO_SPACING=FALSE
       COMMENT = "$layer_name MinEdgeLen: maximum total length ( minEdgeLength um)= maxTotalMinEdgeLength um"
    } (27 )
  }
  if (maxTotalMinEdgeLength == 0 || maxNumMinEdge > 0) {
    if (maxNumMinEdge==0)  {
       COPY short_edges {} TEMP=max_edge_err
    } else {
       SIZE short_edges {
         VSIZE_HEAD = - 0.0002 
        VSIZE_TAIL = - 0.0002 
       } TEMP = short_edges
       SIZE short_edges {
          OVERSIZE = 5* 0.0002 
          SIZE_ENDPOINTS = FALSE
       } TEMP = short_contours
       SELECT short_contours ENCLOSING remainder_edges {
          RANGE = [maxNumMinEdge + 1, 9999999999 ]
       } TEMP = short_contours
       SELECT short_edges INSIDE short_contours { } TEMP=max_edge_err
    }
    /* Work around: translate polygons into dimensional check output */
    SIZE max_edge_err { OVERSIZE = 2* 0.0002  } TEMP = max_edge_error
    INTERNAL max_edge_error {
       SPACING < 3* 0.0002 
       SET_CORNERS_TO_SPACING=FALSE
       COMMENT = "$layer_name MinEdgeLen: maximum number of consecutive short edges ( minEdgeLength um)= maxNumMinEdge"
    } (27 ) 
  }
}
 
/*check basic spacing*/
if (sameNetMinSpacing > 0 && sameNetMinSpacing != minSpacing) {
  if (sameNetMinSpacing > minSpacing) {
    /* Special condition for U-shaped Metal spacing rule */
    NOTCH metal9_pin  {
        SPACING < sameNetMinSpacing
        BOX_CORNER = FALSE 
        SET_CORNERS_TO_SPACING=FALSE
        NON_PARALLEL = TRUE
        OUTPUT_EDGES = TRUE
    } TEMP = errs_to_be_waived
    NOTCH metal9_top  {
	SPACING < sameNetMinSpacing
	BOX_CORNER = FALSE 
        SET_CORNERS_TO_SPACING=FALSE
	NON_PARALLEL = TRUE
        OUTPUT_EDGES = TRUE
    } TEMP = all_errs
    BOOLEAN all_errs NOT errs_to_be_waived { } TEMP=err_edge
    EXTERNAL err_edge metal9_top  {
	SPACING < sameNetMinSpacing
	BOX_CORNER = FALSE 
        SET_CORNERS_TO_SPACING=FALSE
	NON_PARALLEL = TRUE
    } TEMP = notch_err
    SIZE notch_err { OVERSIZE = 0.0002 *10 } TEMP = neighbors
    BOOLEAN neighbors AND metal9_top  { } TEMP = neighbors
    VERTEX neighbors { 
       CONCAVE = TRUE
       CONVEX = TRUE
       SIZE = 0.0002 
    } TEMP = corners
    SELECT_EDGE neighbors INTERACT notch_err { } TEMP = target_edges
    BOOLEAN target_edges AND notch_err { } TEMP = target_edges
    BOOLEAN target_edges NOT corners { } TEMP = target_edges
    VERTEX neighbors {
       CONCAVE = TRUE
       SIZE = 2* 0.0002 
    } TEMP = corners
    SELECT target_edges INTERACT corners { RANGE = [2, 2] } TEMP = target_edges
    SELECT notch_err TOUCHING target_edges {
      COMMENT = "$layer_name U-ShpNotch: U-shape notch minimum spacing = sameNetMinSpacing um" 
    } (27 )
  } else {
    NOTCH metal9  {
        COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = sameNetMinSpacing um" 
	SPACING < sameNetMinSpacing
	BOX_CORNER = FALSE 
	NON_PARALLEL = TRUE
    } (27 )
  }
  if (minSpacing > 0) {
    if (stubMode == 0 && stubSpacing > 0 && stubSpacing < minSpacing) {
	EXTERNAL metal9  {
	    COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um"
            LONGEDGE > stubThreshold + 0.0001 
	    LONGEDGE_TO_EDGE < minSpacing
	    SPACING <= 0
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            CHECK_SAME_POLYGON = TRUE 
	} (27 )
    } else {
        EXTERNAL metal9  {
	    COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um" 
	    SPACING < minSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
	    CHECK_SAME_POLYGON = FALSE
        } (27 )
    }
  }
} else {
  if (minSpacing > 0) {
    if (stubMode == 0 && stubSpacing > 0 && stubSpacing < minSpacing) {
        EXTERNAL metal9  {
            COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um"
            LONGEDGE > stubThreshold + 0.0001  
            LONGEDGE_TO_EDGE < minSpacing
            SPACING <= 0 
            BOX_CORNER = FALSE 
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            CHECK_SAME_POLYGON = TRUE 
        } (27 )
    } else {
        EXTERNAL metal9  {
	    COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um" 
            SPACING < minSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
	    CHECK_SAME_POLYGON = TRUE 
        } (27 )
    }
  }
}
 
/*check dogbone */
if (sameNetMinSpacing > 0 && sameNetWidthThreshold) {
  NOTCH metal9  {
    SPACING < sameNetMinSpacing
    BOX_CORNER = FALSE 
    NON_PARALLEL = TRUE
  } TEMP = dog_bone
 
  if (!layer_empty(dog_bone)) {
    SIZE dog_bone {EDGESIZE = sameNetWidthThreshold} TEMP = dog_ext
    BOOLEAN dog_ext NOT dog_bone {} TEMP = dog_ext
    BOOLEAN dog_ext AND metal9  {} TEMP = dog_ext
    if (!layer_empty(dog_ext)) {
      SELECT dog_ext EDGE_TOUCH dog_bone { OUTSIDE RANGE = [1, 9999999999 ] } TEMP = dog_ext
      NOTCH metal9  {
        SPACING < sameNetMinSpacing
        BOX_CORNER = FALSE 
        NON_PARALLEL = TRUE
	OUTPUT_EDGES = TRUE
      } TEMP = dog_bone
      SELECT dog_ext OUTSIDE dog_bone {} TEMP = dog_ext
      INTERNAL dog_ext {
	COMMENT = "$layer_name dogBone   : notch spacing = sameNetMinSpacing um width sameNetWidthThreshold um" 
	SPACING < sameNetWidthThreshold
      } (27 )
    }
  }
}
/*check basic fat spacing*/
if (fatWireThreshold > 0 && fatTblDimension == 0) {
    SIZE fat_candidate { UNDER_OVER = fatWireThreshold / 2.0 - 0.0001  } TEMP = m_fat
    BOOLEAN m_fat AND metal9  {  } TEMP = m_fat
    BOOLEAN metal9  NOT m_fat {  } TEMP = m_thin
    if (ignoreBlockage == 0) {
        /* the blockages on the metal_blockage layer are treated as thin blockages */
        BOOLEAN m_thin OR metal9_blockage  {  } TEMP = m_thin
    }
 
    if (fatFatMinSpacing > 0) {
	EXTERNAL m_fat {
	    COMMENT = "$layer_name FatWireSpc: fat & fat ( fatWireThreshold um) minimum spacing = fatFatMinSpacing um"
	    SPACING < fatFatMinSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = FALSE
	    CHECK_SAME_POLYGON = TRUE 
       } (27 )
    }
 
    if (fatThinMinSpacing > 0) {
	EXTERNAL m_fat m_thin {
	    COMMENT = "$layer_name FatWireSpc: fat & thin ( fatWireThreshold um) minimum spacing fatThinMinSpacing um"
	    SPACING < fatThinMinSpacing
 	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = FALSE
        } (27 )
    }
}
 
/*check thin blockage spacing*/
if (minSpacing > 0 && ignoreBlockage == 0) {
    if (!layer_empty (metal9_blockage )) {
	EXTERNAL metal9_blockage  metal9  {
	    COMMENT = "$layer_name Spacing   : metal & thin blockage minimum spacing = minSpacing um"
	    SPACING < minSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
            TOUCH = TRUE
        } (27 )
    }
}
/*check blockage overlap*/
/*check shorts between top_level routing and fram_blockages*/
if (minSpacing>0 || checkCrossHierShort>0) {
   if (ignoreBlockage == 0) {
      BOOLEAN metal9_blockage  or metal9_rbkg  {} TEMP=all_blockage
   } else {
      COPY metal9_rbkg  {} TEMP=all_blockage
   }
   BOOLEAN all_blockage AND metal9_top  {} TEMP = overlap_shape1
   EXTERNAL all_blockage metal9_top  {
      SPACING <= 0
      TOUCH = TRUE
   } TEMP = overlap_shape2
   if (checkCrossHierShort>0) {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
         COMMENT = "$layer_name Short Cross Hierarchy"
      } (27 )
   } else {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
         COMMENT = "$layer_name Overlap   : metal & blockage overlap"
      } (27 )
   }
}
 
if (fatPolyContactRule > 0) {
  /* Fat Poly Contact Rule: not new fat wire formed */
  if (readCellView > 0) {
     SIZE metal1 { UNDER_OVER = fatPolyContactRule / 2.0 - 0.0001  } TEMP = fat
     BOOLEAN fat AND metal1 {  } TEMP = fat 
  } else {
     SIZE metal1_top { UNDER_OVER = fatPolyContactRule / 2.0 - 0.0001  } TEMP = fat
     BOOLEAN fat AND metal1_top {  } TEMP = fat 
  }
  SIZE metal1_pin { UNDER_OVER = fatPolyContactRule / 2.0 - 0.0001  } TEMP = fat_pin
  BOOLEAN fat_pin AND metal1_pin {  } TEMP = fat_pin
  BOOLEAN fat NOT fat_pin {
    COMMENT = "$layer_name FatPolyContactRule: fatPolyContactRule um" 
  } (27 )
}
/* Special End-of-Line Spacing Rule */
if (stubMode == 0 && stubSpacing > 0 && stubSpacing < minSpacing) {
  EXTERNAL metal9  {
     COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 0)"
     LONGEDGE > stubThreshold + 0.0001 
     LONGEDGE_TO_EDGE <= 0 
     SPACING < stubSpacing 
     SET_CORNERS_TO_SPACING = FALSE
     PARALLEL_POINT_PROJECTION = FALSE
  } (27 )
} else if (stubMode > 0 && stubSpacing > minSpacing) {
  if (stubMode == 4) {
     INTERNAL metal9  {
        SEGMENT[90,90] < stubThreshold
        OUTPUT_EDGES = TRUE
     } TEMP = end_of_line
  } else {
     INTERNAL metal9  {
        SEGMENT[90,90] <= stubThreshold
        OUTPUT_EDGES = TRUE
     } TEMP = end_of_line
  }
  /* Quick filter to reduce the size of possible end of line */
  if (sideStubExt > 0) {
    SIZE end_of_line {
       VSIZE_HEAD = sideStubExt
       VSIZE_TAIL = sideStubExt
       OUTPUT_EDGES = TRUE
    } TEMP = eol_ext
  } else {
    COPY end_of_line { } TEMP=eol_ext
  }
  if (stub2StubSpacing > stubSpacing) {
     SET temporary_1 = stub2StubSpacing;
  } else {
     SET temporary_1 = stubSpacing; 
  }
  EXTERNAL eol_ext metal9  {
     SPACING < temporary_1
     TOUCH = TRUE
     OVERLAP = TRUE 
     SET_CORNERS_TO_SPACING = FALSE
     PARALLEL_POINT_PROJECTION = FALSE
     OUTPUT_EDGES = TRUE
  } TEMP=err_edge
  SELECT eol_ext INTERACT err_edge { } TEMP=eol_ext
  SELECT end_of_line INTERACT eol_ext { } TEMP=end_of_line 
  /* Reduce the size of METAL_LAYER */
  if (stubMode==3) {
     SIZE end_of_line {
        VSIZE_HEAD = stubSpacing 
        VSIZE_TAIL = stubSpacing 
        VSIZE_INSIDE = sideStubThreshold
        VSIZE_OUTSIDE = stubSpacing
     } TEMP = eol_filter 
  } else {
     if (stubMode == 1 && stubRange > 0) {
        SIZE end_of_line {
           VSIZE_HEAD = stubSpacing- 0.0001 
           VSIZE_TAIL = stubSpacing- 0.0001 
           VSIZE_OUTSIDE = stubSpacing- 0.0001 
        } TEMP = eol_filter
     } else {
        SIZE end_of_line {
           VSIZE_HEAD = stubSpacing- 0.0001 
           VSIZE_TAIL = stubSpacing- 0.0001 
           VSIZE_INSIDE = sideStubThreshold- 0.0001 
           VSIZE_OUTSIDE = stubSpacing- 0.0001 
        } TEMP = eol_filter
     }
  }
  SELECT metal9  INTERACT eol_filter { } TEMP=target_top
  /* Get the side edges and the whole eol of line set */
  SELECT_EDGE target_top INTERACT end_of_line { 
    POINT_TOUCH = TRUE
  } TEMP = eol_set
  VERTEX target_top { 
     CONCAVE = TRUE 
     CONVEX = TRUE
     SIZE = 0.0002 
  } TEMP = corners
  SELECT corners OUTSIDE end_of_line {} TEMP =corners 
  BOOLEAN eol_set NOT corners { } TEMP=eol_set
  BOOLEAN eol_set NOT end_of_line { } TEMP=side_edge
  /* find out the real end of line */
  if (stubRange > 0) {
     if (stubMode == 1) {
         COPY side_edge { } TEMP = all_side_edge
         LENGTH side_edge { SPACING <= stubRange- 0.0001  } TEMP=side_edge
     } else {
         LENGTH side_edge { SPACING < stubRange- 0.0002  } TEMP=eol_filter
         BOOLEAN side_edge NOT eol_filter { } TEMP=side_edge
     }
     SELECT end_of_line INTERACT side_edge { RANGE = [1,2] } TEMP = end_of_line
  } 
  if (stubMode == 1) {
    if (stub2StubSpacing > 0) {
       if (sideStubExt < 0) {
          SIZE end_of_line {
            VSIZE_HEAD = sideStubExt / 2
            VSIZE_TAIL = sideStubExt / 2
            OUTPUT_EDGES = TRUE
          } TEMP = eol_ext_tip
	 
          EXTERNAL eol_ext_tip {
            COMMENT = "$layer_name specEoLSpc: stub2Stubspacing= stub2StubSpacing um (mode = 1)"
            SPACING < stub2StubSpacing
            SET_CORNERS_TO_SPACING = FALSE
            PARALLEL_POINT_PROJECTION = TRUE
          } (27 )
       } else {
          EXTERNAL end_of_line {
            COMMENT = "$layer_name specEoLSpc: stub2Stubspacing= stub2StubSpacing um (mode = 1)"
            SPACING < stub2StubSpacing
            SET_CORNERS_TO_SPACING = FALSE
            PARALLEL_POINT_PROJECTION = FALSE
          } (27 )
       }
    }
    if (stubRange > 0) {
       SIZE end_of_line {
         VSIZE_INSIDE = 0.0002 
       } TEMP = eol_poly
       SELECT_EDGE eol_poly TOUCHING target_top { } TEMP=eol_edge
       EXTERNAL eol_edge target_top {
         COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
         CONVEX_TO_CONVEX < stubSpacing
         CONVEX_TO_CONVEX [POINT_PROJECTION] < stubSpacing
         CONVEX_TO_EDGE < stubSpacing
         CONCAVE_TO_CONVEX < stubSpacing
         LONGEDGE > 0.0002 
         LONGEDGE_TO_EDGE < stubSpacing
         SPACING <= 0
         SET_CORNERS_TO_SPACING = TRUE
         PARALLEL_POINT_PROJECTION = TRUE
       } (27 )
       SELECT all_side_edge INTERACT end_of_line { } TEMP = side_edge
       SIZE side_edge {
         VSIZE_HEAD = 0.0002 
         VSIZE_TAIL = 0.0002 
       } TEMP = side_edge_ext
       BOOLEAN side_edge_ext NOT side_edge { } TEMP = side_edge_ext
       SELECT side_edge_ext INTERACT end_of_line { } TEMP = side_edge_ext
       EXTERNAL side_edge_ext target_top {
         COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
         SPACING < stubSpacing
         SET_CORNERS_TO_SPACING = FALSE
         PARALLEL_POINT_PROJECTION = FALSE
       } (27 )
    } else {
       if (stub2StubSpacing > 0) {
         VECTORIZE target_top {
            DIRECTED=TRUE
         } TEMP=target_edges
         BOOLEAN target_edges NOT end_of_line { } TEMP = target_edges
         EXTERNAL end_of_line target_edges {
            COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
            SPACING < stubSpacing
            TOUCH=TRUE
            OVERLAP=TRUE
            SET_CORNERS_TO_SPACING=FALSE
            PARALLEL_POINT_PROJECTION=FALSE
         } (27 )
       } else {
         if (sideStubExt > 0) {
            SIZE end_of_line {
               VSIZE_HEAD = sideStubExt
               VSIZE_TAIL = sideStubExt
               OUTPUT_EDGES = TRUE
            } TEMP = end_of_line
            EXTERNAL end_of_line target_top {
               COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing ,crnKeepOut= sideStubExt um (mode = 1)"
               SPACING < stubSpacing
               TOUCH=TRUE
               OVERLAP=TRUE
               SET_CORNERS_TO_SPACING=FALSE
               PARALLEL_POINT_PROJECTION=FALSE
            } (27 )
         } else {
            EXTERNAL end_of_line target_top {
               COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
               SPACING < stubSpacing
               TOUCH=TRUE
               OVERLAP=TRUE
               SET_CORNERS_TO_SPACING=FALSE
               PARALLEL_POINT_PROJECTION=FALSE
            } (27 )
         }
       }
    }
  } else { /* stubMode == 2,3,4 */
    /* stubMode 2 eol classify and reduction */
    if (stubMode !=3 && sideStubExt > 0) {
      if (stubMode == 4) {
        SIZE end_of_line {
           VSIZE_HEAD = sideStubExt
           VSIZE_TAIL = sideStubExt
           OUTPUT_EDGES = TRUE
        } TEMP = eol_ext
        EXTERNAL eol_ext target_top {
           SPACING < stubSpacing
           SET_CORNERS_TO_SPACING=FALSE
           PARALLEL_POINT_PROJECTION=FALSE
           OUTPUT_EDGES = TRUE
        } TEMP=err_edge
        SELECT eol_ext INTERACT err_edge { } TEMP=eol_ext
      } else {
        EXTERNAL end_of_line target_top {
           SPACING < stubSpacing
           SET_CORNERS_TO_SPACING=FALSE
           PARALLEL_POINT_PROJECTION=FALSE
           OUTPUT_EDGES = TRUE
        } TEMP=err_edge
        SELECT end_of_line INTERACT err_edge { } TEMP=eol_body
        SIZE end_of_line {
           VSIZE_HEAD = sideStubExt
           VSIZE_TAIL = sideStubExt
           OUTPUT_EDGES = TRUE
        } TEMP = eol_ext
        BOOLEAN eol_ext NOT end_of_line {} TEMP=eol_ext
        EXTERNAL eol_ext target_top {
           SPACING < stubSpacing
           SET_CORNERS_TO_SPACING=FALSE
           PARALLEL_POINT_PROJECTION=FALSE
           OUTPUT_EDGES = TRUE
        } TEMP=err_edge
        SELECT eol_ext INTERACT err_edge { } TEMP=eol_ext
        BOOLEAN eol_body OR eol_ext { } TEMP=eol_ext
      } 
    } else {
      COPY end_of_line { } TEMP=eol_ext
    }
    SELECT side_edge INTERACT eol_ext { } TEMP=side_edge
    SIZE eol_ext {
       VSIZE_INSIDE = sideStubThreshold 
       VSIZE_OUTSIDE = sideStubExt
    } TEMP = eol_range
    if (sideStubExt > 0) {
       SIZE side_edge {
          VSIZE_HEAD = sideStubExt
          VSIZE_TAIL = sideStubExt
          OUTPUT_EDGES = TRUE
       } TEMP = check_edge
    } else {
       COPY side_edge { } TEMP = check_edge
    }
    BOOLEAN check_edge AND eol_range { } TEMP=check_edge
    EXTERNAL check_edge target_top {
       SPACING < temporary_1
       SET_CORNERS_TO_SPACING = FALSE
       SHADOW_OTHER_LAYER = TRUE
       PARALLEL_POINT_PROJECTION = FALSE
       OUTPUT_EDGES = TRUE
    } TEMP=err_edge
    if (0 && stubMode!=4) { /* Temporarily do not check mode 2,3 side edge length */
       LENGTH side_edge { SPACING < stubSpacing- 0.0001 *2 } TEMP=err_edge_1
       BOOLEAN err_edge OR err_edge_1 { } TEMP=err_edge
    }
    SELECT check_edge INTERACT err_edge { } TEMP=side_edge
    if (stubMode!=3) {
       SELECT eol_ext INTERACT side_edge {} TEMP=err_eol
       EXTERNAL err_eol target_top {
          COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing ,crnKeepOut= sideStubExt um (mode = stubMode )"
          SPACING < temporary_1
          PARALLEL_POINT_PROJECTION=FALSE
          SET_CORNERS_TO_SPACING=FALSE
       } (27 )
    } else { /* stubMode == 3 */
       SELECT eol_ext INTERACT side_edge { RANGE = [2, 2] } TEMP=err_eol
       EXTERNAL err_eol target_top {
          COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 3)"
          SPACING < temporary_1
          PARALLEL_POINT_PROJECTION=FALSE
          SET_CORNERS_TO_SPACING=FALSE
       } (27 )
    }
  }
} /* stubMode > 0, not aligned */
/* Avoid empty optimization result parsing error */
if (addEmptyMetalCheck) {
   BOOLEAN empty OR empty {
      COMMENT = "$layer_name Empty: Dummy Output"
   } (27 )
   SET addEmptyMetalCheck=0;
}
/* reset variables */


 
SET minWidth = 0;
SET maxWidth = 0;
SET minArea = 0;
SET minEnclosedArea = 0;
SET minSpacing = 0;
SET sameNetMinSpacing = 0;
SET maxNumMinEdge = 0;
SET maxTotalMinEdgeLength = 0;
SET minEdgeLength = 0;
SET minEdgeLength2 = 0;
SET minEdgeLength3 = 0;
SET stubRange = 0;
SET stubSpacing = 0;
SET stub2StubSpacing = 0;
SET sideStubExt = 0;
SET sideStubThreshold = 0;
SET stubThreshold = 0;
SET fatPolyContactRule = 0;
SET fatWireThreshold = 0;
SET fatThinMinSpacing = 0;
SET fatFatMinSpacing = 0;
SET fatTblDimension = 0;
@ 1012 "adrc/adrc.ev" 2



/* Start of Met9 fat table spacing rules */
SET fatTblSpacingMode = 0;
SET parallelLengthMode = 0;
SET router_parallelLengthNetMode = 0;

SET fatTblThreshold = 0.501;
SET fatTblParallelLength = 0.501;
SET minWidth = 0.16;

SET fatTblThreshold_Start = 0;
SET fatTblSpacing = 0.18;
@ 1 "adrc/adrc_fatMetal.ev" 1
/*check fat metal table*/
if (fatTblThreshold > 0) {
    if ((fatTblThreshold / 2.0) > 0.0001 ) {
       SIZE fat_candidate  { UNDER_OVER = fatTblThreshold / 2.0 - 0.0001  } TEMP = fat_candidate
       if (fatTblNextThreshold > 0) {
          SIZE fat_candidate { UNDER_OVER = fatTblNextThreshold / 2.0 - 0.0001  } TEMP = fat_next
          BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
          BOOLEAN fat AND fat_target { } TEMP = fat
          SET fatTblNextThreshold = 0;
       } else {
          BOOLEAN fat_candidate AND fat_target {  } TEMP = fat 
       }
    } else {
      COPY fat_target {  } TEMP = fat 
    }
    COPY fat_target { } TEMP = spc_target
    if (fatTblThreshold_Start > 0  || fatTblThreshold_End > 0) {
       if (fatTblThreshold_Start > 0) {
          SIZE fat_target { UNDER_OVER = fatTblThreshold_Start / 2.0 - 0.0001  } TEMP = spc_target
       }
       if (fatTblThreshold_End > 0 && fatTblThreshold_End > fatTblThreshold_Start) {
          SIZE spc_target { UNDER_OVER = fatTblThreshold_End / 2.0 - 0.0001  } TEMP = fat_end
          BOOLEAN spc_target NOT fat_end { } TEMP = spc_target
       }
       BOOLEAN spc_target AND fat_target {  } TEMP = spc_target
       if (ignoreBlockage == 0 && fatTblThreshold_Start < fatTblThreshold_1) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal9_blockage  {  } TEMP = spc_target
       }
       SET fatTblThreshold_Start = 0;
       SET fatTblThreshold_End = 0;
       SET fatTblThreshold_1 = 0;
    } else {
       if (ignoreBlockage == 0) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal9_blockage  {  } TEMP = spc_target
       }
    }
 
    if (fatTblEnclosedArea > 0) {
       SELECT holes INTERACT fat { } TEMP = fat_holes
       AREA fat_holes { 
          RANGE = [0.0001 * 0.0001 , fatTblEnclosedArea - 0.0001 * 0.0001 ]
       } TEMP = fat_holes
       if (fatTblMinEnclosedAreaMode==0) {
          SIZE fat_holes { OVER_UNDER = fatTblThreshold / 2.0 + 0.0001  } TEMP = ovun_holes
          SELECT ovun_holes INTERACT fat_holes { RANGE = [2, 9999999999 ] } TEMP = merged_holes
          BOOLEAN fat_candidate AND fat_target { } TEMP = fat_metal
          BOOLEAN metal9  NOT fat_metal { } TEMP = thin_metal
          BOOLEAN thin_metal NOT ovun_holes { } TEMP = thin_metal
          SELECT ovun_holes INTERACT thin_metal { } TEMP = thin_holes
          BOOLEAN thin_holes OR merged_holes { } TEMP = thin_holes
          BOOLEAN fat_holes NOT thin_holes { } TEMP = fat_holes
       }
       COPY fat_holes { 
	  COMMENT = "$layer_name EnclsArea : fat metal ( fatTblThreshold um) minimum enclosed area (mode fatTblMinEnclosedAreaMode ) = fatTblEnclosedArea um*um"
       } (27 )
       SET fatTblEnclosedArea = 0;
    }
    if (fatTblSpacing > 0) {
       /*check fat metal*/ 
       if (fatTblParallelLength > 0) {
          if (router_parallelLengthNetMode == 1 || parallelLengthMode == 1) {
             AREA spc_target { RANGE = [fatTblParallelLength * minWidth + 0.0001 , 9999999999 ] } TEMP = spc_target1
             COPY spc_target1 { } TEMP = spc_target2
          } else {
             COPY spc_target { } TEMP = spc_target2
          }
          if (parallelLengthMode == 1) {
             SELECT metal9  INTERACT fat { } TEMP = fat_all 
             BOOLEAN fat_all OR fat { } TEMP = fat2
             SELECT metal9  INTERACT spc_target2 { } TEMP = spc_target_all
             BOOLEAN spc_target_all OR spc_target2 { } TEMP = spc_target2
          } else {
             COPY fat { } TEMP = fat2
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING <= fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
                OUTPUT_EDGES = TRUE
             } TEMP = vio_edge
             SELECT vio_edge INTERACT fat { } TEMP = vio_edge
             SELECT vio_edge INTERACT spc_target1 { } TEMP = vio_edge
             SELECT violation INTERACT vio_edge { } TEMP = violation
          } else {
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
          }
          BOOLEAN violation NOT fat_target { } TEMP = violation
          if (fatTblParallelLength < fatTblSpacing) {
             SELECT_EDGE violation TOUCHING fat2 {
                VSIZE_INSIDE = fatTblParallelLength - 0.0002 
             } TEMP = vio_filter
             SELECT_CONTAINS vio_filter { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = vio_filter
             SELECT violation INTERACT vio_filter { } TEMP = violation
          } else {
             SELECT_CONTAINS violation { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = violation
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING = [fatTblSpacing, fatTblSpacing]
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
             } TEMP = violation3
             BOOLEAN violation3 NOT fat_target { } TEMP = violation3
             BOOLEAN violation NOT violation3 { } TEMP= violation
          }
          SELECT_EDGE fat2 TOUCHING violation { } TEMP=fat_viol
          BOOLEAN fat_viol AND violation { } TEMP=fat_viol
          SELECT_EDGE spc_target2 TOUCHING violation { } TEMP=spc_target2
          BOOLEAN spc_target2 AND violation { } TEMP= spc_target2
	  if (ignoreChildCell == 1) {
             EXTERNAL fat_viol spc_target2 {
		SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		TOUCH = FALSE
		POINT_TOUCH = FALSE
		NON_PARALLEL = TRUE
	     } TEMP = spc_mode0_out
             BOOLEAN spc_mode0_out NOT spc_mode0_child_out { } TEMP = spc_mode0_diff_out
             SELECT spc_mode0_out INTERACT spc_mode0_diff_out { } TEMP = spc_mode0_out
	     SELECT_EDGE fat2 TOUCHING spc_mode0_out { } TEMP=fat_viol
	     BOOLEAN fat_viol AND spc_mode0_out { } TEMP=fat_viol
	     SELECT_EDGE spc_target2 TOUCHING spc_mode0_out { } TEMP=spc_target2
	     BOOLEAN spc_target2 AND spc_mode0_out { } TEMP=spc_target2
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (27 )  		
	  } else {
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing 
	        SET_CORNERS_TO_SPACING = FALSE
	        PARALLEL_POINT_PROJECTION = FALSE
	        TOUCH = FALSE
	        POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (27 )
	  }
	  if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	     if (ignoreChildCell == 1) {
		EXTERNAL fat spc_target {
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} TEMP = spc_mode1_out
	        BOOLEAN spc_mode1_out NOT spc_mode1_child_out { } TEMP = spc_mode1_diff_out
	        SELECT spc_mode1_out INTERACT spc_mode1_diff_out { } TEMP = spc_mode1_out
                SELECT_EDGE fat TOUCHING spc_mode1_out { } TEMP=fat_viol
	        BOOLEAN fat_viol AND spc_mode1_out { } TEMP=fat_viol
	        SELECT_EDGE spc_target TOUCHING spc_mode1_out { } TEMP=spc_target2
	        BOOLEAN spc_target2 AND spc_mode1_out { } TEMP=spc_target2
	        EXTERNAL fat_viol spc_target2 {
	           COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um " 	    
		   SPACING < fatTblSpacing_dg
                   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} (27 )
	     } else {
	        EXTERNAL fat spc_target {
		   COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um "
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
	    	   PARALLEL_POINT_PROJECTION = FALSE
	           TOUCH = FALSE
	     	   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } (27 ) 
	     }
          }
       } else {
	  if (ignoreChildCell == 1) {
              EXTERNAL fat spc_target {
                 SPACING < fatTblSpacing
                 BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
              } TEMP = spc_out
	      BOOLEAN spc_out NOT spc_child_out { } TEMP = spc_diff_out
	      SELECT spc_out INTERACT spc_diff_out { } TEMP = spc_out
	      SELECT_EDGE fat TOUCHING spc_out { } TEMP=fat_viol
	      BOOLEAN fat_viol AND spc_out { } TEMP=fat_viol
              SELECT_EDGE spc_target TOUCHING spc_out { } TEMP=spc_target2
	      BOOLEAN spc_target2 AND spc_out { } TEMP=spc_target2
	      EXTERNAL fat_viol spc_target2 {
		 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
		 BOX_CORNER = FALSE 
		 NON_PARALLEL = TRUE
		 POINT_TOUCH = FALSE
	      } (27 ) 
	  } else {
	      EXTERNAL fat spc_target {
                 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
	         BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
	      } (27 ) 
	  }
       }
       /*check metal in the extension range*/ 
       if (fatTblExtensionRange > 0) {
	  if (fatWireExtensionMode == 0) {
	     SIZE fat { OVERSIZE = fatTblExtensionRange } TEMP = fat_tmp
             BOOLEAN fat_tmp AND metal9  { } TEMP = fat_tmp
  	     BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
             SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_ext
             BOOLEAN fat_ext OR fat { } TEMP = fat_ext
	     if (fatTblParallelLength > 0) {
                if (fatTblParallelLength > fatTblExtensionRange) {
                   SIZE fat { OVERSIZE = fatTblParallelLength } TEMP = fat_tmp
                   BOOLEAN fat_tmp AND metal9  { } TEMP = fat_tmp
  	           BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
                   SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_parallel
                   BOOLEAN fat_parallel OR fat { } TEMP = fat_parallel
                } else {
                   COPY fat_ext { } TEMP = fat_parallel
                }
		EXTERNAL fat_parallel spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
	           NON_PARALLEL = TRUE
	        } TEMP = vio_filter_set
		EXTERNAL fat_ext spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } TEMP = vio_set
                if (fatTblParallelLength < fatTblSpacing) {
                   SELECT_EDGE vio_filter_set TOUCHING fat_parallel {
                      VSIZE_INSIDE = fatTblParallelLength - 0.0002 
                   } TEMP = vio_filter_set_filter
                   SELECT_CONTAINS vio_filter_set_filter { 
                      WIDTH =  0.0002 
                      HEIGHT = fatTblParallelLength + 0.0001 
                   } TEMP = vio_filter_set_filter
                   SELECT vio_filter_set INTERACT vio_filter_set_filter { } TEMP = vio_filter
                } else {
	           SELECT_CONTAINS vio_filter_set { 
	              WIDTH =  0.0002 
	              HEIGHT = fatTblParallelLength + 0.0001 
	           } TEMP = vio_filter
                }
                SELECT vio_set INSIDE vio_filter { } TEMP = mode0_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out1 NOT mode0_child_out1 { } TEMP = mode0_diff_out1
                   SELECT mode0_out1 INTERACT mode0_diff_out1 { } TEMP = mode0_out1
                }
                COPY mode0_out1 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing  = fatTblSpacing um"
                } (27 )
		if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	           EXTERNAL fat_ext spc_target {
		      SPACING < fatTblSpacing_dg
	              SET_CORNERS_TO_SPACING = FALSE
		      PARALLEL_POINT_PROJECTION = FALSE
		      TOUCH = TRUE
		      POINT_TOUCH = FALSE
		      NON_PARALLEL = TRUE
	           } TEMP = mode0_out2
                   if (ignoreChildCell == 1) {
                      BOOLEAN mode0_out2 NOT mode0_child_out2 { } TEMP = mode0_diff_out2
                      SELECT mode0_out2 INTERACT mode0_diff_out2 { } TEMP = mode0_out2
                   }
                   COPY mode0_out2 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing (mode 1/2) = fatTblSpacing um/ fatTblSpacing_dg um "
                   } (27 )
	        } 
	     } else {
	        EXTERNAL fat_ext spc_target {
		   SPACING < fatTblSpacing
		   NON_PARALLEL = TRUE
		   SET_CORNERS_TO_SPACING = FALSE
		   POINT_TOUCH = FALSE
		} TEMP = mode0_out3
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out3 NOT mode0_child_out3 { } TEMP = mode0_diff_out3
                   SELECT mode0_out3 INTERACT mode0_diff_out3 { } TEMP = mode0_out3
                }
                COPY mode0_out3 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range ( fatTblExtensionRange um) minimum spacing = fatTblSpacing um"
                } (27 )
	     }
	  } else if (fatWireExtensionMode == 1) {
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal9  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             if (fatTblParallelLength > 0) {
                EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
		   BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   CHECK_SAME_POLYGON = TRUE 
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
	        SELECT fat_ext INTERACT spacing {  } TEMP = fat_ext
		BOOLEAN fat_ext OR spacing {  } TEMP = combined_fat_ext
                EXTERNAL combined_fat_ext fat {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
                } TEMP = fat_spacing
		BOOLEAN fat_spacing AND fat_ran {  } TEMP = fat_spacing
		BOOLEAN combined_fat_ext OR fat_spacing {  } TEMP = combined_fat_ext
                SELECT_CONTAINS combined_fat_ext { 
                   WIDTH =  0.0002 
                   HEIGHT = fatTblParallelLength + 0.0001 
                } TEMP = combined_fat_ext
		SELECT spacing INTERACT combined_fat_ext { 
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out1 NOT mode1_child_out1 { } TEMP = mode1_diff_out1
                   SELECT mode1_out1 INTERACT mode1_diff_out1 { } TEMP = mode1_out1 
                }
                COPY mode1_out1 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (27 ) 
	     } else {
               	EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
	           BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
	           CHECK_SAME_POLYGON = TRUE 
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
                SELECT spacing INTERACT fat_ext {
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out2
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out2 NOT mode1_child_out2 { } TEMP = mode1_diff_out2
                   SELECT mode1_out2 INTERACT mode1_diff_out2 { } TEMP = mode1_out2
                }
                COPY mode1_out2 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (27 )
	     }
	  } else if (fatWireExtensionMode == 2) {
	     SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
             BOOLEAN fat_ran AND metal9  {  } TEMP = fat_ext
             BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	      	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
             } TEMP = spacing
 	     SELECT spacing INSIDE fat_ran {  } TEMP = spacing
	     SELECT spacing OUTSIDE fat {  } TEMP = spacing
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode2_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode2_out NOT mode2_child_out { } TEMP = mode2_diff_out
                SELECT mode2_out INTERACT mode2_diff_out { } TEMP = mode2_out 
             }
             COPY mode2_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 2, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (27 )
	  } else if (fatWireExtensionMode == 3) {
             SIZE fat {
	        GROW_LEFT = fatTblExtensionRange
	        GROW_RIGHT = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal9  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	       	PARALLEL = TRUE

	       	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		HORIZONTAL_ONLY = TRUE
             } TEMP = spacing_hor
	     SELECT spacing_hor INSIDE fat_ran {  } TEMP = spacing_hor
	     SELECT spacing_hor OUTSIDE fat {  } TEMP = spacing_hor
             SIZE fat {
	        GROW_TOP = fatTblExtensionRange
	        GROW_BOTTOM = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal9  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	        POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		VERTICAL_ONLY = TRUE
             } TEMP = spacing_ver
	     SELECT spacing_ver INSIDE fat_ran {  } TEMP = spacing_ver
	     SELECT spacing_ver OUTSIDE fat {  } TEMP = spacing_ver
  	     BOOLEAN spacing_hor OR spacing_ver {  } TEMP = spacing
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal9  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
  	     /* check overlapped projection length */
 	     if (fatTblParallelLength > 0) {
                POLYGON_FEATURES fat_ext {
                   EQUATIONS {
                      vnum = EV_VNUM_IN;
                      if ( vnum > 0) {
                         bdLeft = EV_VXCOORD_IN[0];
                         bdRight = EV_VXCOORD_IN[0];
                         bdBottom = EV_VYCOORD_IN[0];
                         bdTop = EV_VYCOORD_IN[0];
                         FOR (i = 1; i < vnum; i++) {
                            if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
                            else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
                            if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
                            else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
                         } /* FOR i */
                         if ( (bdRight - bdLeft) >= fatTblParallelLength ||
                  	      (bdTop - bdBottom) >= fatTblParallelLength) {
                            FOR (i = 0; i < vnum; i++) {
                               EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
                               EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
                            }
                            EV_VNUM_OUT = vnum;
                 	    EV_SAVE_POLYGON();
                         }
                      }
                   }
                } TEMP = fat_ext /* POLYGON_FEATURE */
             }
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode3_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode3_out NOT mode3_child_out { } TEMP = mode3_diff_out
                SELECT mode3_out INTERACT mode3_diff_out { } TEMP = mode3_out
             }
             COPY mode3_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 3, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (27 )
          }
       }
       SET fatTblSpacing = 0;
    }
}
@ 1026 "adrc/adrc.ev" 2


SET fatTblThreshold = 1.701;
SET fatTblParallelLength = 1.701;
SET minWidth = 0.16;

SET fatTblThreshold_Start = 0;
SET fatTblSpacing = 0.5;
@ 1 "adrc/adrc_fatMetal.ev" 1
/*check fat metal table*/
if (fatTblThreshold > 0) {
    if ((fatTblThreshold / 2.0) > 0.0001 ) {
       SIZE fat_candidate  { UNDER_OVER = fatTblThreshold / 2.0 - 0.0001  } TEMP = fat_candidate
       if (fatTblNextThreshold > 0) {
          SIZE fat_candidate { UNDER_OVER = fatTblNextThreshold / 2.0 - 0.0001  } TEMP = fat_next
          BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
          BOOLEAN fat AND fat_target { } TEMP = fat
          SET fatTblNextThreshold = 0;
       } else {
          BOOLEAN fat_candidate AND fat_target {  } TEMP = fat 
       }
    } else {
      COPY fat_target {  } TEMP = fat 
    }
    COPY fat_target { } TEMP = spc_target
    if (fatTblThreshold_Start > 0  || fatTblThreshold_End > 0) {
       if (fatTblThreshold_Start > 0) {
          SIZE fat_target { UNDER_OVER = fatTblThreshold_Start / 2.0 - 0.0001  } TEMP = spc_target
       }
       if (fatTblThreshold_End > 0 && fatTblThreshold_End > fatTblThreshold_Start) {
          SIZE spc_target { UNDER_OVER = fatTblThreshold_End / 2.0 - 0.0001  } TEMP = fat_end
          BOOLEAN spc_target NOT fat_end { } TEMP = spc_target
       }
       BOOLEAN spc_target AND fat_target {  } TEMP = spc_target
       if (ignoreBlockage == 0 && fatTblThreshold_Start < fatTblThreshold_1) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal9_blockage  {  } TEMP = spc_target
       }
       SET fatTblThreshold_Start = 0;
       SET fatTblThreshold_End = 0;
       SET fatTblThreshold_1 = 0;
    } else {
       if (ignoreBlockage == 0) {
	  /* the blockages on the metal_blockage layer are treated as thin blockages */
	  BOOLEAN spc_target OR metal9_blockage  {  } TEMP = spc_target
       }
    }
 
    if (fatTblEnclosedArea > 0) {
       SELECT holes INTERACT fat { } TEMP = fat_holes
       AREA fat_holes { 
          RANGE = [0.0001 * 0.0001 , fatTblEnclosedArea - 0.0001 * 0.0001 ]
       } TEMP = fat_holes
       if (fatTblMinEnclosedAreaMode==0) {
          SIZE fat_holes { OVER_UNDER = fatTblThreshold / 2.0 + 0.0001  } TEMP = ovun_holes
          SELECT ovun_holes INTERACT fat_holes { RANGE = [2, 9999999999 ] } TEMP = merged_holes
          BOOLEAN fat_candidate AND fat_target { } TEMP = fat_metal
          BOOLEAN metal9  NOT fat_metal { } TEMP = thin_metal
          BOOLEAN thin_metal NOT ovun_holes { } TEMP = thin_metal
          SELECT ovun_holes INTERACT thin_metal { } TEMP = thin_holes
          BOOLEAN thin_holes OR merged_holes { } TEMP = thin_holes
          BOOLEAN fat_holes NOT thin_holes { } TEMP = fat_holes
       }
       COPY fat_holes { 
	  COMMENT = "$layer_name EnclsArea : fat metal ( fatTblThreshold um) minimum enclosed area (mode fatTblMinEnclosedAreaMode ) = fatTblEnclosedArea um*um"
       } (27 )
       SET fatTblEnclosedArea = 0;
    }
    if (fatTblSpacing > 0) {
       /*check fat metal*/ 
       if (fatTblParallelLength > 0) {
          if (router_parallelLengthNetMode == 1 || parallelLengthMode == 1) {
             AREA spc_target { RANGE = [fatTblParallelLength * minWidth + 0.0001 , 9999999999 ] } TEMP = spc_target1
             COPY spc_target1 { } TEMP = spc_target2
          } else {
             COPY spc_target { } TEMP = spc_target2
          }
          if (parallelLengthMode == 1) {
             SELECT metal9  INTERACT fat { } TEMP = fat_all 
             BOOLEAN fat_all OR fat { } TEMP = fat2
             SELECT metal9  INTERACT spc_target2 { } TEMP = spc_target_all
             BOOLEAN spc_target_all OR spc_target2 { } TEMP = spc_target2
          } else {
             COPY fat { } TEMP = fat2
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING <= fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
                OUTPUT_EDGES = TRUE
             } TEMP = vio_edge
             SELECT vio_edge INTERACT fat { } TEMP = vio_edge
             SELECT vio_edge INTERACT spc_target1 { } TEMP = vio_edge
             SELECT violation INTERACT vio_edge { } TEMP = violation
          } else {
             EXTERNAL fat2 spc_target2 {
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } TEMP = violation
          }
          BOOLEAN violation NOT fat_target { } TEMP = violation
          if (fatTblParallelLength < fatTblSpacing) {
             SELECT_EDGE violation TOUCHING fat2 {
                VSIZE_INSIDE = fatTblParallelLength - 0.0002 
             } TEMP = vio_filter
             SELECT_CONTAINS vio_filter { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = vio_filter
             SELECT violation INTERACT vio_filter { } TEMP = violation
          } else {
             SELECT_CONTAINS violation { 
                WIDTH =  0.0002 
                HEIGHT = fatTblParallelLength + 0.0001 
             } TEMP = violation
          }
          if (parallelLengthMode == 1) {
             EXTERNAL fat2 spc_target2 {
                SPACING = [fatTblSpacing, fatTblSpacing]
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
             } TEMP = violation3
             BOOLEAN violation3 NOT fat_target { } TEMP = violation3
             BOOLEAN violation NOT violation3 { } TEMP= violation
          }
          SELECT_EDGE fat2 TOUCHING violation { } TEMP=fat_viol
          BOOLEAN fat_viol AND violation { } TEMP=fat_viol
          SELECT_EDGE spc_target2 TOUCHING violation { } TEMP=spc_target2
          BOOLEAN spc_target2 AND violation { } TEMP= spc_target2
	  if (ignoreChildCell == 1) {
             EXTERNAL fat_viol spc_target2 {
		SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		TOUCH = FALSE
		POINT_TOUCH = FALSE
		NON_PARALLEL = TRUE
	     } TEMP = spc_mode0_out
             BOOLEAN spc_mode0_out NOT spc_mode0_child_out { } TEMP = spc_mode0_diff_out
             SELECT spc_mode0_out INTERACT spc_mode0_diff_out { } TEMP = spc_mode0_out
	     SELECT_EDGE fat2 TOUCHING spc_mode0_out { } TEMP=fat_viol
	     BOOLEAN fat_viol AND spc_mode0_out { } TEMP=fat_viol
	     SELECT_EDGE spc_target2 TOUCHING spc_mode0_out { } TEMP=spc_target2
	     BOOLEAN spc_target2 AND spc_mode0_out { } TEMP=spc_target2
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (27 )  		
	  } else {
	     EXTERNAL fat_viol spc_target2 {
                COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing  = fatTblSpacing um"
                SPACING < fatTblSpacing 
	        SET_CORNERS_TO_SPACING = FALSE
	        PARALLEL_POINT_PROJECTION = FALSE
	        TOUCH = FALSE
	        POINT_TOUCH = FALSE
                NON_PARALLEL = TRUE
             } (27 )
	  }
	  if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	     if (ignoreChildCell == 1) {
		EXTERNAL fat spc_target {
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} TEMP = spc_mode1_out
	        BOOLEAN spc_mode1_out NOT spc_mode1_child_out { } TEMP = spc_mode1_diff_out
	        SELECT spc_mode1_out INTERACT spc_mode1_diff_out { } TEMP = spc_mode1_out
                SELECT_EDGE fat TOUCHING spc_mode1_out { } TEMP=fat_viol
	        BOOLEAN fat_viol AND spc_mode1_out { } TEMP=fat_viol
	        SELECT_EDGE spc_target TOUCHING spc_mode1_out { } TEMP=spc_target2
	        BOOLEAN spc_target2 AND spc_mode1_out { } TEMP=spc_target2
	        EXTERNAL fat_viol spc_target2 {
	           COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um " 	    
		   SPACING < fatTblSpacing_dg
                   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = FALSE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
		} (27 )
	     } else {
	        EXTERNAL fat spc_target {
		   COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um, fatTblParallelLength um) minimum spacing (mode 1) = fatTblSpacing um/ fatTblSpacing_dg um "
		   SPACING < fatTblSpacing_dg
		   SET_CORNERS_TO_SPACING = FALSE
	    	   PARALLEL_POINT_PROJECTION = FALSE
	           TOUCH = FALSE
	     	   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } (27 ) 
	     }
          }
       } else {
	  if (ignoreChildCell == 1) {
              EXTERNAL fat spc_target {
                 SPACING < fatTblSpacing
                 BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
              } TEMP = spc_out
	      BOOLEAN spc_out NOT spc_child_out { } TEMP = spc_diff_out
	      SELECT spc_out INTERACT spc_diff_out { } TEMP = spc_out
	      SELECT_EDGE fat TOUCHING spc_out { } TEMP=fat_viol
	      BOOLEAN fat_viol AND spc_out { } TEMP=fat_viol
              SELECT_EDGE spc_target TOUCHING spc_out { } TEMP=spc_target2
	      BOOLEAN spc_target2 AND spc_out { } TEMP=spc_target2
	      EXTERNAL fat_viol spc_target2 {
		 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
		 BOX_CORNER = FALSE 
		 NON_PARALLEL = TRUE
		 POINT_TOUCH = FALSE
	      } (27 ) 
	  } else {
	      EXTERNAL fat spc_target {
                 COMMENT = "$layer_name FatWireSpc: fat metal ( fatTblThreshold um) minimum spacing = fatTblSpacing um"
                 SPACING < fatTblSpacing
	         BOX_CORNER = FALSE 
                 NON_PARALLEL = TRUE
                 POINT_TOUCH = FALSE
	      } (27 ) 
	  }
       }
       /*check metal in the extension range*/ 
       if (fatTblExtensionRange > 0) {
	  if (fatWireExtensionMode == 0) {
	     SIZE fat { OVERSIZE = fatTblExtensionRange } TEMP = fat_tmp
             BOOLEAN fat_tmp AND metal9  { } TEMP = fat_tmp
  	     BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
             SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_ext
             BOOLEAN fat_ext OR fat { } TEMP = fat_ext
	     if (fatTblParallelLength > 0) {
                if (fatTblParallelLength > fatTblExtensionRange) {
                   SIZE fat { OVERSIZE = fatTblParallelLength } TEMP = fat_tmp
                   BOOLEAN fat_tmp AND metal9  { } TEMP = fat_tmp
  	           BOOLEAN fat_tmp NOT fat {  } TEMP = fat_tmp
                   SELECT  fat_tmp TOUCHING fat {  } TEMP = fat_parallel
                   BOOLEAN fat_parallel OR fat { } TEMP = fat_parallel
                } else {
                   COPY fat_ext { } TEMP = fat_parallel
                }
		EXTERNAL fat_parallel spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
	           NON_PARALLEL = TRUE
	        } TEMP = vio_filter_set
		EXTERNAL fat_ext spc_target {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
		   TOUCH = TRUE
		   POINT_TOUCH = FALSE
		   NON_PARALLEL = TRUE
	        } TEMP = vio_set
                if (fatTblParallelLength < fatTblSpacing) {
                   SELECT_EDGE vio_filter_set TOUCHING fat_parallel {
                      VSIZE_INSIDE = fatTblParallelLength - 0.0002 
                   } TEMP = vio_filter_set_filter
                   SELECT_CONTAINS vio_filter_set_filter { 
                      WIDTH =  0.0002 
                      HEIGHT = fatTblParallelLength + 0.0001 
                   } TEMP = vio_filter_set_filter
                   SELECT vio_filter_set INTERACT vio_filter_set_filter { } TEMP = vio_filter
                } else {
	           SELECT_CONTAINS vio_filter_set { 
	              WIDTH =  0.0002 
	              HEIGHT = fatTblParallelLength + 0.0001 
	           } TEMP = vio_filter
                }
                SELECT vio_set INSIDE vio_filter { } TEMP = mode0_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out1 NOT mode0_child_out1 { } TEMP = mode0_diff_out1
                   SELECT mode0_out1 INTERACT mode0_diff_out1 { } TEMP = mode0_out1
                }
                COPY mode0_out1 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing  = fatTblSpacing um"
                } (27 )
		if (fatTblSpacingMode == 1 && fatTblSpacing_dg > 0 && fatTblSpacing_dg != fatTblSpacing) {
	           EXTERNAL fat_ext spc_target {
		      SPACING < fatTblSpacing_dg
	              SET_CORNERS_TO_SPACING = FALSE
		      PARALLEL_POINT_PROJECTION = FALSE
		      TOUCH = TRUE
		      POINT_TOUCH = FALSE
		      NON_PARALLEL = TRUE
	           } TEMP = mode0_out2
                   if (ignoreChildCell == 1) {
                      BOOLEAN mode0_out2 NOT mode0_child_out2 { } TEMP = mode0_diff_out2
                      SELECT mode0_out2 INTERACT mode0_diff_out2 { } TEMP = mode0_out2
                   }
                   COPY mode0_out2 {
                      COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range ( fatTblExtensionRange um) minimum spacing (mode 1/2) = fatTblSpacing um/ fatTblSpacing_dg um "
                   } (27 )
	        } 
	     } else {
	        EXTERNAL fat_ext spc_target {
		   SPACING < fatTblSpacing
		   NON_PARALLEL = TRUE
		   SET_CORNERS_TO_SPACING = FALSE
		   POINT_TOUCH = FALSE
		} TEMP = mode0_out3
                if (ignoreChildCell == 1) {
                   BOOLEAN mode0_out3 NOT mode0_child_out3 { } TEMP = mode0_diff_out3
                   SELECT mode0_out3 INTERACT mode0_diff_out3 { } TEMP = mode0_out3
                }
                COPY mode0_out3 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range ( fatTblExtensionRange um) minimum spacing = fatTblSpacing um"
                } (27 )
	     }
	  } else if (fatWireExtensionMode == 1) {
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal9  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             if (fatTblParallelLength > 0) {
                EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
		   BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   CHECK_SAME_POLYGON = TRUE 
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
	        SELECT fat_ext INTERACT spacing {  } TEMP = fat_ext
		BOOLEAN fat_ext OR spacing {  } TEMP = combined_fat_ext
                EXTERNAL combined_fat_ext fat {
	           SPACING < fatTblSpacing
		   SET_CORNERS_TO_SPACING = FALSE
		   NON_PARALLEL = TRUE
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
                } TEMP = fat_spacing
		BOOLEAN fat_spacing AND fat_ran {  } TEMP = fat_spacing
		BOOLEAN combined_fat_ext OR fat_spacing {  } TEMP = combined_fat_ext
                SELECT_CONTAINS combined_fat_ext { 
                   WIDTH =  0.0002 
                   HEIGHT = fatTblParallelLength + 0.0001 
                } TEMP = combined_fat_ext
		SELECT spacing INTERACT combined_fat_ext { 
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out1
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out1 NOT mode1_child_out1 { } TEMP = mode1_diff_out1
                   SELECT mode1_out1 INTERACT mode1_diff_out1 { } TEMP = mode1_out1 
                }
                COPY mode1_out1 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um, fatTblParallelLength um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (27 ) 
	     } else {
               	EXTERNAL fat_ext {
	           SPACING < fatTblSpacing
	           BOX_CORNER = FALSE 
	           NON_PARALLEL = TRUE
	           CHECK_SAME_POLYGON = TRUE 
		   TOUCH = FALSE
	           POINT_TOUCH = FALSE
		   PARALLEL_POINT_PROJECTION = FALSE
                } TEMP = spacing
		SELECT spacing INSIDE fat_ran {  } TEMP = spacing
		SELECT spacing OUTSIDE fat {  } TEMP = spacing
                SELECT spacing INTERACT fat_ext {
		   LINE_TOUCH = TRUE
	           POINT_TOUCH = TRUE
                } TEMP = mode1_out2
                if (ignoreChildCell == 1) {
                   BOOLEAN mode1_out2 NOT mode1_child_out2 { } TEMP = mode1_diff_out2
                   SELECT mode1_out2 INTERACT mode1_diff_out2 { } TEMP = mode1_out2
                }
                COPY mode1_out2 {
                   COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 1, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
                } (27 )
	     }
	  } else if (fatWireExtensionMode == 2) {
	     SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
             BOOLEAN fat_ran AND metal9  {  } TEMP = fat_ext
             BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	      	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
             } TEMP = spacing
 	     SELECT spacing INSIDE fat_ran {  } TEMP = spacing
	     SELECT spacing OUTSIDE fat {  } TEMP = spacing
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode2_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode2_out NOT mode2_child_out { } TEMP = mode2_diff_out
                SELECT mode2_out INTERACT mode2_diff_out { } TEMP = mode2_out 
             }
             COPY mode2_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 2, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (27 )
	  } else if (fatWireExtensionMode == 3) {
             SIZE fat {
	        GROW_LEFT = fatTblExtensionRange
	        GROW_RIGHT = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal9  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	       	PARALLEL = TRUE

	       	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	       	POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		HORIZONTAL_ONLY = TRUE
             } TEMP = spacing_hor
	     SELECT spacing_hor INSIDE fat_ran {  } TEMP = spacing_hor
	     SELECT spacing_hor OUTSIDE fat {  } TEMP = spacing_hor
             SIZE fat {
	        GROW_TOP = fatTblExtensionRange
	        GROW_BOTTOM = fatTblExtensionRange
             } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal9  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
             EXTERNAL fat_ext {
	       	SPACING < fatTblSpacing
	       	BOX_CORNER = FALSE 



	      	PARALLEL = TRUE

	      	CHECK_SAME_POLYGON = TRUE 
		TOUCH = FALSE
	        POINT_TOUCH = FALSE
		PARALLEL_POINT_PROJECTION = FALSE
		VERTICAL_ONLY = TRUE
             } TEMP = spacing_ver
	     SELECT spacing_ver INSIDE fat_ran {  } TEMP = spacing_ver
	     SELECT spacing_ver OUTSIDE fat {  } TEMP = spacing_ver
  	     BOOLEAN spacing_hor OR spacing_ver {  } TEMP = spacing
             SIZE fat { EDGESIZE = fatTblExtensionRange } TEMP = fat_ran
  	     BOOLEAN fat_ran AND metal9  {  } TEMP = fat_ext
  	     BOOLEAN fat_ext NOT fat {  } TEMP = fat_ext
  	     /* check overlapped projection length */
 	     if (fatTblParallelLength > 0) {
                POLYGON_FEATURES fat_ext {
                   EQUATIONS {
                      vnum = EV_VNUM_IN;
                      if ( vnum > 0) {
                         bdLeft = EV_VXCOORD_IN[0];
                         bdRight = EV_VXCOORD_IN[0];
                         bdBottom = EV_VYCOORD_IN[0];
                         bdTop = EV_VYCOORD_IN[0];
                         FOR (i = 1; i < vnum; i++) {
                            if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
                            else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
                            if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
                            else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
                         } /* FOR i */
                         if ( (bdRight - bdLeft) >= fatTblParallelLength ||
                  	      (bdTop - bdBottom) >= fatTblParallelLength) {
                            FOR (i = 0; i < vnum; i++) {
                               EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
                               EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
                            }
                            EV_VNUM_OUT = vnum;
                 	    EV_SAVE_POLYGON();
                         }
                      }
                   }
                } TEMP = fat_ext /* POLYGON_FEATURE */
             }
             SELECT spacing INTERACT fat_ext {
 		LINE_TOUCH = TRUE
	        POINT_TOUCH = FALSE
             } TEMP = mode3_out
             if (ignoreChildCell == 1) {
                BOOLEAN mode3_out NOT mode3_child_out { } TEMP = mode3_diff_out
                SELECT mode3_out INTERACT mode3_diff_out { } TEMP = mode3_out
             }
             COPY mode3_out {
                COMMENT = "$layer_name FatExtSpc : fat metal ( fatTblThreshold um) extension range (mode 3, fatTblExtensionRange um ) minimum spacing = fatTblSpacing um"
             } (27 )
          }
       }
       SET fatTblSpacing = 0;
    }
}
@ 1034 "adrc/adrc.ev" 2


SET fatTblThreshold = 0;
SET fatTblEnclosedArea = 0;
SET fatTblExtensionRange = 0;
SET fatTblParallelLength = 0;
SET minWidth = 0;

/* End of Met9 fat table spacing rules */










/*metal 10*/
SET layer_name = "Met10";










SET minWidth = 2;
SET maxWidth = 30;
SET minArea = 4;
SET minEnclosedArea = 0.2;
SET minSpacing = 2;
SET stub2StubSpacing = 0;

SET fatTblDimension = 0;
@ 1 "adrc/adrc_check_metal.ev" 1
/* Data Preparation */
if (fatTblDimension > 1 || fatWireThreshold > 0 || maxWidth > 0) {
  if (ignoreBlockage) {
      /* Let the real blockage be treated as thin */
      BOOLEAN metal10  NOT metal10_rbkg  {} TEMP=fat_candidate
  } else {
      COPY metal10  {} TEMP=fat_candidate
  }
  COPY fat_candidate {} TEMP=fat_target
}
/*Check width*/
if (minWidth > 0) {
    INTERNAL metal10  { 
        COMMENT = "$layer_name MinWidth  : minimum width = minWidth um" 
        SPACING < minWidth
        POINT_TOUCH = FALSE
    } (41 )
}
 
if (maxWidth > 0) {
    SIZE  fat_candidate {
        COMMENT = "$layer_name MaxWidth  : maximum width = maxWidth um"
 	UNDER_OVER = maxWidth / 2 
    } (41 ) 
}
 
/*Check area*/
if (minArea > 0) {
    AREA metal10  { 
	COMMENT = "$layer_name MinArea   : minimum area = minArea um*um"
	RANGE = [0.0001 * 0.0001 , minArea - 0.0001 * 0.0001 ]
    } (41 )
}
/* check min length of bounding box on polygon */
if (minLength > 0) {
  if (minLengthMode == 1) {
    INTERNAL metal10  {
        SPACING < minLength
        VERTICAL_ONLY = TRUE
        SET_CORNERS_TO_SPACING = FALSE
    } TEMP = ver_short
    BOOLEAN metal10  NOT ver_short { } TEMP = ver_long
    INTERNAL metal10  {
        SPACING < minLength
        HORIZONTAL_ONLY = TRUE
        SET_CORNERS_TO_SPACING = FALSE
    } TEMP = hor_short
    BOOLEAN metal10  NOT hor_short { } TEMP = hor_long
    SELECT CUT_LAYER1 INSIDE ver_long { } TEMP = good_cut
    BOOLEAN CUT_LAYER1 NOT good_cut { } TEMP = fail_cut_1
    SELECT fail_cut_1 INSIDE hor_long { } TEMP = good_cut
    BOOLEAN fail_cut_1 NOT good_cut { } TEMP = fail_cut_1
    SELECT CUT_LAYER2 INSIDE ver_long { } TEMP = good_cut
    BOOLEAN CUT_LAYER2 NOT good_cut { } TEMP = fail_cut_2
    SELECT fail_cut_2 INSIDE hor_long { } TEMP = good_cut
    BOOLEAN fail_cut_2 NOT good_cut { } TEMP = fail_cut_2
    BOOLEAN fail_cut_1 OR fail_cut_2 { } TEMP = fail_cut
    BOOLEAN hor_short NOT ver_long { } TEMP = hor_short
    BOOLEAN ver_short NOT hor_long { } TEMP = ver_short
    SELECT ver_short INTERACT fail_cut { } TEMP = ver_fail
    SELECT hor_short INTERACT fail_cut { } TEMP = hor_fail
    BOOLEAN ver_fail OR hor_fail { } TEMP = all_fail
    INTERNAL all_fail {
        COMMENT = "$layer_name MinLength : minimum length = minLength um"
        SPACING < minLength
        VERTICAL_ONLY = TRUE
        SET_CORNERS_TO_SPACING = FALSE
    } (41 )
  } else {
    POLYGON_FEATURES metal10  {
      COMMENT = "$layer_name MinLength : minimum length = minLength um"
      EQUATIONS {
        vnum = EV_VNUM_IN;
        if ( vnum > 0) {
	  bdLeft = EV_VXCOORD_IN[0];
	  bdRight = EV_VXCOORD_IN[0];
	  bdBottom = EV_VYCOORD_IN[0];
	  bdTop = EV_VYCOORD_IN[0];
          FOR (i = 1; i < vnum; i++) {
	    if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
            else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
	    if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
            else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
          }
	  if ( (bdRight - bdLeft) < minLength &&
	       (bdTop - bdBottom) < minLength) {
	    FOR (i = 0; i < vnum; i++) {
              EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
	      EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
            }
	    EV_VNUM_OUT = vnum;
	    EV_SAVE_POLYGON();
          }
        }
      }
    } (41 ) 
  }
  SET minLength = 0;
}
/* check max length of bounding box on polygon */
if (maxLength > 0) {
  POLYGON_FEATURES metal10  {
    COMMENT = "$layer_name MaxLength : maximum length = maxLength um"
    EQUATIONS {
      vnum = EV_VNUM_IN;
      if ( vnum > 0) {
	bdLeft = EV_VXCOORD_IN[0];
	bdRight = EV_VXCOORD_IN[0];
	bdBottom = EV_VYCOORD_IN[0];
	bdTop = EV_VYCOORD_IN[0];
        FOR (i = 1; i < vnum; i++) {
	  if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
          else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
	  if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
          else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
        }
	if ( (bdRight - bdLeft + bdTop - bdBottom) > maxLength ) {
          EV_VXCOORD_OUT[0] = bdLeft;
	  EV_VYCOORD_OUT[0] = bdBottom;
          EV_VXCOORD_OUT[1] = bdLeft;
	  EV_VYCOORD_OUT[1] = bdTop;
          EV_VXCOORD_OUT[2] = bdRight;
	  EV_VYCOORD_OUT[2] = bdTop;
          EV_VXCOORD_OUT[3] = bdRight;
	  EV_VYCOORD_OUT[3] = bdBottom;
          EV_VXCOORD_OUT[4] = bdLeft;
	  EV_VYCOORD_OUT[4] = bdBottom;
	  EV_VNUM_OUT = 5;
	  EV_SAVE_POLYGON();
        }
      }
    }
  } (41 ) 
  SET maxLength = 0;
}
 
/*Check enclosed area*/
if (minEnclosedArea > 0) {
    SELECT metal10  INSIDE_HOLE {
        INNER_HOLE_ONLY
    } TEMP = holes
    BOOLEAN holes NOT metal10  { } TEMP = holes
 
    AREA holes {
        COMMENT = "$layer_name EnclsArea : minimum enclosed area = minEnclosedArea um*um"
        RANGE = [0.0001 * 0.0001 , minEnclosedArea - 0.0001 * 0.0001 ]
    } (41 )
    /* check min length of bounding box on polygon */
    if (minEnclosedWidth > 0) {
      POLYGON_FEATURES holes {
        COMMENT = "$layer_name EnclsWidth: minimum enclosed Width = minEnclosedWidth um"
        EQUATIONS {
          vnum = EV_VNUM_IN;
          if ( vnum > 0) {
            bdLeft = EV_VXCOORD_IN[0];
            bdRight = EV_VXCOORD_IN[0];
            bdBottom = EV_VYCOORD_IN[0];
            bdTop = EV_VYCOORD_IN[0];
            FOR (i = 1; i < vnum; i++) {
              if (bdLeft > EV_VXCOORD_IN[i]) bdLeft = EV_VXCOORD_IN[i];
              else if (bdRight < EV_VXCOORD_IN[i]) bdRight = EV_VXCOORD_IN[i];
              if (bdBottom > EV_VYCOORD_IN[i]) bdBottom = EV_VYCOORD_IN[i];
              else if (bdTop < EV_VYCOORD_IN[i]) bdTop = EV_VYCOORD_IN[i];
            }
            if ( (bdRight - bdLeft) < minEnclosedWidth &&
                 (bdTop - bdBottom) < minEnclosedWidth) {
              FOR (i = 0; i < vnum; i++) {
                EV_VXCOORD_OUT[i] = EV_VXCOORD_IN[i];
                EV_VYCOORD_OUT[i] = EV_VYCOORD_IN[i];
              }
              EV_VNUM_OUT = vnum;
              EV_SAVE_POLYGON();
            }
          }
        }
      } (41 ) 
    }
}
 
/*check special notch rule*/
if ((minEdgeLength2 > 0.0001  && minEdgeLength3 > 0.0001 ) || minEdgeMode==2) {
  if (minEdgeMode==2) {
    SET minEdgeLength3 = minEdgeLength ;
  }
  NOTCH metal10  {
     SPACING < minEdgeLength3
     SET_CORNERS_TO_SPACING=FALSE
     PARALLEL = TRUE
     OUTPUT_EDGES = TRUE
  } TEMP = notch_vectors
  SELECT_VECTOR notch_vectors {
     LENGTH_RANGE = [0.0001 , minEdgeLength2 - 0.0001 ]
  } TEMP = short_edges
  EXTERNAL short_edges metal10  {
     SPACING < minEdgeLength3
     SET_CORNERS_TO_SPACING=FALSE
     PARALLEL = TRUE
  } TEMP = notch_err
  /* Choose the real U-shaped notch */
  SIZE notch_err { OVERSIZE = 0.0002 *10 } TEMP = neighbors 
  BOOLEAN neighbors AND metal10  { } TEMP = neighbors
  VERTEX neighbors { 
     CONCAVE = TRUE
     CONVEX = TRUE
     SIZE = 0.0002 
  } TEMP = corners
  SELECT_EDGE neighbors INTERACT notch_err { } TEMP = target_edges
  BOOLEAN target_edges NOT corners { } TEMP = target_edges
  VERTEX neighbors { 
     CONCAVE = TRUE
     SIZE = 2* 0.0002 
  } TEMP = corners
  SELECT target_edges INTERACT corners { RANGE = [2, 2] } TEMP=target_edges
  SELECT notch_err INTERACT target_edges {
     COMMENT = "$layer_name SpeclNotch: sameNetSp = minEdgeLength3 um (sideLen minEdgeLength2 um)" 
  } (41 )
}
/*check consecutive short edges*/
if (minEdgeLength > 0.0001  && minEdgeMode != 2) { 
  INTERNAL metal10_top  {
     SEGMENT < minEdgeLength
     FLAG_ACUTE_ANGLE = FALSE
     FLAG_ACUTE_EDGE = FALSE
     OUTPUT_EDGES = TRUE
  } TEMP = short_edges
  if ((minEdgeMode == 0 && maxTotalMinEdgeLength>0) || maxNumMinEdge > 0) {
    SET temporary_1 = 0.0002 *2;
    SET temporary_2 = 2*temporary_1+ 0.0001 ;
    SELECT metal10_top  INTERACT short_edges { } TEMP = target_top
    CLASSIFY_EDGES target_top {
       LENGTH = temporary_1
       DMIN   = temporary_2
       INSIDE_CORNER  TEMP = inside_corner_edges
       OUTSIDE_CORNER TEMP = outside_corner_edges
       REMAINDER      TEMP = remainder_edges
    }
    if (minEdgeMode == 0 && (maxNumMinEdge>0 || maxTotalMinEdgeLength > 0)) {
       SELECT short_edges ENCLOSING inside_corner_edges { } TEMP = short_edges
    }
  }
  if (maxTotalMinEdgeLength > 0) {
    LENGTH short_edges {
       RANGE = [maxTotalMinEdgeLength + 0.0001 , 9999999999 ]
    } TEMP = max_length_err
    /* Work around: translate polygons into dimensional check output */
    SIZE max_length_err { OVERSIZE = 2* 0.0002  } TEMP = max_length_err
    INTERNAL max_length_err {
       SPACING < 3* 0.0002 
       SET_CORNERS_TO_SPACING=FALSE
       COMMENT = "$layer_name MinEdgeLen: maximum total length ( minEdgeLength um)= maxTotalMinEdgeLength um"
    } (41 )
  }
  if (maxTotalMinEdgeLength == 0 || maxNumMinEdge > 0) {
    if (maxNumMinEdge==0)  {
       COPY short_edges {} TEMP=max_edge_err
    } else {
       SIZE short_edges {
         VSIZE_HEAD = - 0.0002 
        VSIZE_TAIL = - 0.0002 
       } TEMP = short_edges
       SIZE short_edges {
          OVERSIZE = 5* 0.0002 
          SIZE_ENDPOINTS = FALSE
       } TEMP = short_contours
       SELECT short_contours ENCLOSING remainder_edges {
          RANGE = [maxNumMinEdge + 1, 9999999999 ]
       } TEMP = short_contours
       SELECT short_edges INSIDE short_contours { } TEMP=max_edge_err
    }
    /* Work around: translate polygons into dimensional check output */
    SIZE max_edge_err { OVERSIZE = 2* 0.0002  } TEMP = max_edge_error
    INTERNAL max_edge_error {
       SPACING < 3* 0.0002 
       SET_CORNERS_TO_SPACING=FALSE
       COMMENT = "$layer_name MinEdgeLen: maximum number of consecutive short edges ( minEdgeLength um)= maxNumMinEdge"
    } (41 ) 
  }
}
 
/*check basic spacing*/
if (sameNetMinSpacing > 0 && sameNetMinSpacing != minSpacing) {
  if (sameNetMinSpacing > minSpacing) {
    /* Special condition for U-shaped Metal spacing rule */
    NOTCH metal10_pin  {
        SPACING < sameNetMinSpacing
        BOX_CORNER = FALSE 
        SET_CORNERS_TO_SPACING=FALSE
        NON_PARALLEL = TRUE
        OUTPUT_EDGES = TRUE
    } TEMP = errs_to_be_waived
    NOTCH metal10_top  {
	SPACING < sameNetMinSpacing
	BOX_CORNER = FALSE 
        SET_CORNERS_TO_SPACING=FALSE
	NON_PARALLEL = TRUE
        OUTPUT_EDGES = TRUE
    } TEMP = all_errs
    BOOLEAN all_errs NOT errs_to_be_waived { } TEMP=err_edge
    EXTERNAL err_edge metal10_top  {
	SPACING < sameNetMinSpacing
	BOX_CORNER = FALSE 
        SET_CORNERS_TO_SPACING=FALSE
	NON_PARALLEL = TRUE
    } TEMP = notch_err
    SIZE notch_err { OVERSIZE = 0.0002 *10 } TEMP = neighbors
    BOOLEAN neighbors AND metal10_top  { } TEMP = neighbors
    VERTEX neighbors { 
       CONCAVE = TRUE
       CONVEX = TRUE
       SIZE = 0.0002 
    } TEMP = corners
    SELECT_EDGE neighbors INTERACT notch_err { } TEMP = target_edges
    BOOLEAN target_edges AND notch_err { } TEMP = target_edges
    BOOLEAN target_edges NOT corners { } TEMP = target_edges
    VERTEX neighbors {
       CONCAVE = TRUE
       SIZE = 2* 0.0002 
    } TEMP = corners
    SELECT target_edges INTERACT corners { RANGE = [2, 2] } TEMP = target_edges
    SELECT notch_err TOUCHING target_edges {
      COMMENT = "$layer_name U-ShpNotch: U-shape notch minimum spacing = sameNetMinSpacing um" 
    } (41 )
  } else {
    NOTCH metal10  {
        COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = sameNetMinSpacing um" 
	SPACING < sameNetMinSpacing
	BOX_CORNER = FALSE 
	NON_PARALLEL = TRUE
    } (41 )
  }
  if (minSpacing > 0) {
    if (stubMode == 0 && stubSpacing > 0 && stubSpacing < minSpacing) {
	EXTERNAL metal10  {
	    COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um"
            LONGEDGE > stubThreshold + 0.0001 
	    LONGEDGE_TO_EDGE < minSpacing
	    SPACING <= 0
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            CHECK_SAME_POLYGON = TRUE 
	} (41 )
    } else {
        EXTERNAL metal10  {
	    COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um" 
	    SPACING < minSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
	    CHECK_SAME_POLYGON = FALSE
        } (41 )
    }
  }
} else {
  if (minSpacing > 0) {
    if (stubMode == 0 && stubSpacing > 0 && stubSpacing < minSpacing) {
        EXTERNAL metal10  {
            COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um"
            LONGEDGE > stubThreshold + 0.0001  
            LONGEDGE_TO_EDGE < minSpacing
            SPACING <= 0 
            BOX_CORNER = FALSE 
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            CHECK_SAME_POLYGON = TRUE 
        } (41 )
    } else {
        EXTERNAL metal10  {
	    COMMENT = "$layer_name Spacing   : minimum spacing = minSpacing um" 
            SPACING < minSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
	    CHECK_SAME_POLYGON = TRUE 
        } (41 )
    }
  }
}
 
/*check dogbone */
if (sameNetMinSpacing > 0 && sameNetWidthThreshold) {
  NOTCH metal10  {
    SPACING < sameNetMinSpacing
    BOX_CORNER = FALSE 
    NON_PARALLEL = TRUE
  } TEMP = dog_bone
 
  if (!layer_empty(dog_bone)) {
    SIZE dog_bone {EDGESIZE = sameNetWidthThreshold} TEMP = dog_ext
    BOOLEAN dog_ext NOT dog_bone {} TEMP = dog_ext
    BOOLEAN dog_ext AND metal10  {} TEMP = dog_ext
    if (!layer_empty(dog_ext)) {
      SELECT dog_ext EDGE_TOUCH dog_bone { OUTSIDE RANGE = [1, 9999999999 ] } TEMP = dog_ext
      NOTCH metal10  {
        SPACING < sameNetMinSpacing
        BOX_CORNER = FALSE 
        NON_PARALLEL = TRUE
	OUTPUT_EDGES = TRUE
      } TEMP = dog_bone
      SELECT dog_ext OUTSIDE dog_bone {} TEMP = dog_ext
      INTERNAL dog_ext {
	COMMENT = "$layer_name dogBone   : notch spacing = sameNetMinSpacing um width sameNetWidthThreshold um" 
	SPACING < sameNetWidthThreshold
      } (41 )
    }
  }
}
/*check basic fat spacing*/
if (fatWireThreshold > 0 && fatTblDimension == 0) {
    SIZE fat_candidate { UNDER_OVER = fatWireThreshold / 2.0 - 0.0001  } TEMP = m_fat
    BOOLEAN m_fat AND metal10  {  } TEMP = m_fat
    BOOLEAN metal10  NOT m_fat {  } TEMP = m_thin
    if (ignoreBlockage == 0) {
        /* the blockages on the metal_blockage layer are treated as thin blockages */
        BOOLEAN m_thin OR metal10_blockage  {  } TEMP = m_thin
    }
 
    if (fatFatMinSpacing > 0) {
	EXTERNAL m_fat {
	    COMMENT = "$layer_name FatWireSpc: fat & fat ( fatWireThreshold um) minimum spacing = fatFatMinSpacing um"
	    SPACING < fatFatMinSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = FALSE
	    CHECK_SAME_POLYGON = TRUE 
       } (41 )
    }
 
    if (fatThinMinSpacing > 0) {
	EXTERNAL m_fat m_thin {
	    COMMENT = "$layer_name FatWireSpc: fat & thin ( fatWireThreshold um) minimum spacing fatThinMinSpacing um"
	    SPACING < fatThinMinSpacing
 	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = FALSE
        } (41 )
    }
}
 
/*check thin blockage spacing*/
if (minSpacing > 0 && ignoreBlockage == 0) {
    if (!layer_empty (metal10_blockage )) {
	EXTERNAL metal10_blockage  metal10  {
	    COMMENT = "$layer_name Spacing   : metal & thin blockage minimum spacing = minSpacing um"
	    SPACING < minSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
            TOUCH = TRUE
        } (41 )
    }
}
/*check blockage overlap*/
/*check shorts between top_level routing and fram_blockages*/
if (minSpacing>0 || checkCrossHierShort>0) {
   if (ignoreBlockage == 0) {
      BOOLEAN metal10_blockage  or metal10_rbkg  {} TEMP=all_blockage
   } else {
      COPY metal10_rbkg  {} TEMP=all_blockage
   }
   BOOLEAN all_blockage AND metal10_top  {} TEMP = overlap_shape1
   EXTERNAL all_blockage metal10_top  {
      SPACING <= 0
      TOUCH = TRUE
   } TEMP = overlap_shape2
   if (checkCrossHierShort>0) {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
         COMMENT = "$layer_name Short Cross Hierarchy"
      } (41 )
   } else {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
         COMMENT = "$layer_name Overlap   : metal & blockage overlap"
      } (41 )
   }
}
 
if (fatPolyContactRule > 0) {
  /* Fat Poly Contact Rule: not new fat wire formed */
  if (readCellView > 0) {
     SIZE metal1 { UNDER_OVER = fatPolyContactRule / 2.0 - 0.0001  } TEMP = fat
     BOOLEAN fat AND metal1 {  } TEMP = fat 
  } else {
     SIZE metal1_top { UNDER_OVER = fatPolyContactRule / 2.0 - 0.0001  } TEMP = fat
     BOOLEAN fat AND metal1_top {  } TEMP = fat 
  }
  SIZE metal1_pin { UNDER_OVER = fatPolyContactRule / 2.0 - 0.0001  } TEMP = fat_pin
  BOOLEAN fat_pin AND metal1_pin {  } TEMP = fat_pin
  BOOLEAN fat NOT fat_pin {
    COMMENT = "$layer_name FatPolyContactRule: fatPolyContactRule um" 
  } (41 )
}
/* Special End-of-Line Spacing Rule */
if (stubMode == 0 && stubSpacing > 0 && stubSpacing < minSpacing) {
  EXTERNAL metal10  {
     COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 0)"
     LONGEDGE > stubThreshold + 0.0001 
     LONGEDGE_TO_EDGE <= 0 
     SPACING < stubSpacing 
     SET_CORNERS_TO_SPACING = FALSE
     PARALLEL_POINT_PROJECTION = FALSE
  } (41 )
} else if (stubMode > 0 && stubSpacing > minSpacing) {
  if (stubMode == 4) {
     INTERNAL metal10  {
        SEGMENT[90,90] < stubThreshold
        OUTPUT_EDGES = TRUE
     } TEMP = end_of_line
  } else {
     INTERNAL metal10  {
        SEGMENT[90,90] <= stubThreshold
        OUTPUT_EDGES = TRUE
     } TEMP = end_of_line
  }
  /* Quick filter to reduce the size of possible end of line */
  if (sideStubExt > 0) {
    SIZE end_of_line {
       VSIZE_HEAD = sideStubExt
       VSIZE_TAIL = sideStubExt
       OUTPUT_EDGES = TRUE
    } TEMP = eol_ext
  } else {
    COPY end_of_line { } TEMP=eol_ext
  }
  if (stub2StubSpacing > stubSpacing) {
     SET temporary_1 = stub2StubSpacing;
  } else {
     SET temporary_1 = stubSpacing; 
  }
  EXTERNAL eol_ext metal10  {
     SPACING < temporary_1
     TOUCH = TRUE
     OVERLAP = TRUE 
     SET_CORNERS_TO_SPACING = FALSE
     PARALLEL_POINT_PROJECTION = FALSE
     OUTPUT_EDGES = TRUE
  } TEMP=err_edge
  SELECT eol_ext INTERACT err_edge { } TEMP=eol_ext
  SELECT end_of_line INTERACT eol_ext { } TEMP=end_of_line 
  /* Reduce the size of METAL_LAYER */
  if (stubMode==3) {
     SIZE end_of_line {
        VSIZE_HEAD = stubSpacing 
        VSIZE_TAIL = stubSpacing 
        VSIZE_INSIDE = sideStubThreshold
        VSIZE_OUTSIDE = stubSpacing
     } TEMP = eol_filter 
  } else {
     if (stubMode == 1 && stubRange > 0) {
        SIZE end_of_line {
           VSIZE_HEAD = stubSpacing- 0.0001 
           VSIZE_TAIL = stubSpacing- 0.0001 
           VSIZE_OUTSIDE = stubSpacing- 0.0001 
        } TEMP = eol_filter
     } else {
        SIZE end_of_line {
           VSIZE_HEAD = stubSpacing- 0.0001 
           VSIZE_TAIL = stubSpacing- 0.0001 
           VSIZE_INSIDE = sideStubThreshold- 0.0001 
           VSIZE_OUTSIDE = stubSpacing- 0.0001 
        } TEMP = eol_filter
     }
  }
  SELECT metal10  INTERACT eol_filter { } TEMP=target_top
  /* Get the side edges and the whole eol of line set */
  SELECT_EDGE target_top INTERACT end_of_line { 
    POINT_TOUCH = TRUE
  } TEMP = eol_set
  VERTEX target_top { 
     CONCAVE = TRUE 
     CONVEX = TRUE
     SIZE = 0.0002 
  } TEMP = corners
  SELECT corners OUTSIDE end_of_line {} TEMP =corners 
  BOOLEAN eol_set NOT corners { } TEMP=eol_set
  BOOLEAN eol_set NOT end_of_line { } TEMP=side_edge
  /* find out the real end of line */
  if (stubRange > 0) {
     if (stubMode == 1) {
         COPY side_edge { } TEMP = all_side_edge
         LENGTH side_edge { SPACING <= stubRange- 0.0001  } TEMP=side_edge
     } else {
         LENGTH side_edge { SPACING < stubRange- 0.0002  } TEMP=eol_filter
         BOOLEAN side_edge NOT eol_filter { } TEMP=side_edge
     }
     SELECT end_of_line INTERACT side_edge { RANGE = [1,2] } TEMP = end_of_line
  } 
  if (stubMode == 1) {
    if (stub2StubSpacing > 0) {
       if (sideStubExt < 0) {
          SIZE end_of_line {
            VSIZE_HEAD = sideStubExt / 2
            VSIZE_TAIL = sideStubExt / 2
            OUTPUT_EDGES = TRUE
          } TEMP = eol_ext_tip
	 
          EXTERNAL eol_ext_tip {
            COMMENT = "$layer_name specEoLSpc: stub2Stubspacing= stub2StubSpacing um (mode = 1)"
            SPACING < stub2StubSpacing
            SET_CORNERS_TO_SPACING = FALSE
            PARALLEL_POINT_PROJECTION = TRUE
          } (41 )
       } else {
          EXTERNAL end_of_line {
            COMMENT = "$layer_name specEoLSpc: stub2Stubspacing= stub2StubSpacing um (mode = 1)"
            SPACING < stub2StubSpacing
            SET_CORNERS_TO_SPACING = FALSE
            PARALLEL_POINT_PROJECTION = FALSE
          } (41 )
       }
    }
    if (stubRange > 0) {
       SIZE end_of_line {
         VSIZE_INSIDE = 0.0002 
       } TEMP = eol_poly
       SELECT_EDGE eol_poly TOUCHING target_top { } TEMP=eol_edge
       EXTERNAL eol_edge target_top {
         COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
         CONVEX_TO_CONVEX < stubSpacing
         CONVEX_TO_CONVEX [POINT_PROJECTION] < stubSpacing
         CONVEX_TO_EDGE < stubSpacing
         CONCAVE_TO_CONVEX < stubSpacing
         LONGEDGE > 0.0002 
         LONGEDGE_TO_EDGE < stubSpacing
         SPACING <= 0
         SET_CORNERS_TO_SPACING = TRUE
         PARALLEL_POINT_PROJECTION = TRUE
       } (41 )
       SELECT all_side_edge INTERACT end_of_line { } TEMP = side_edge
       SIZE side_edge {
         VSIZE_HEAD = 0.0002 
         VSIZE_TAIL = 0.0002 
       } TEMP = side_edge_ext
       BOOLEAN side_edge_ext NOT side_edge { } TEMP = side_edge_ext
       SELECT side_edge_ext INTERACT end_of_line { } TEMP = side_edge_ext
       EXTERNAL side_edge_ext target_top {
         COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
         SPACING < stubSpacing
         SET_CORNERS_TO_SPACING = FALSE
         PARALLEL_POINT_PROJECTION = FALSE
       } (41 )
    } else {
       if (stub2StubSpacing > 0) {
         VECTORIZE target_top {
            DIRECTED=TRUE
         } TEMP=target_edges
         BOOLEAN target_edges NOT end_of_line { } TEMP = target_edges
         EXTERNAL end_of_line target_edges {
            COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
            SPACING < stubSpacing
            TOUCH=TRUE
            OVERLAP=TRUE
            SET_CORNERS_TO_SPACING=FALSE
            PARALLEL_POINT_PROJECTION=FALSE
         } (41 )
       } else {
         if (sideStubExt > 0) {
            SIZE end_of_line {
               VSIZE_HEAD = sideStubExt
               VSIZE_TAIL = sideStubExt
               OUTPUT_EDGES = TRUE
            } TEMP = end_of_line
            EXTERNAL end_of_line target_top {
               COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing ,crnKeepOut= sideStubExt um (mode = 1)"
               SPACING < stubSpacing
               TOUCH=TRUE
               OVERLAP=TRUE
               SET_CORNERS_TO_SPACING=FALSE
               PARALLEL_POINT_PROJECTION=FALSE
            } (41 )
         } else {
            EXTERNAL end_of_line target_top {
               COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 1)"
               SPACING < stubSpacing
               TOUCH=TRUE
               OVERLAP=TRUE
               SET_CORNERS_TO_SPACING=FALSE
               PARALLEL_POINT_PROJECTION=FALSE
            } (41 )
         }
       }
    }
  } else { /* stubMode == 2,3,4 */
    /* stubMode 2 eol classify and reduction */
    if (stubMode !=3 && sideStubExt > 0) {
      if (stubMode == 4) {
        SIZE end_of_line {
           VSIZE_HEAD = sideStubExt
           VSIZE_TAIL = sideStubExt
           OUTPUT_EDGES = TRUE
        } TEMP = eol_ext
        EXTERNAL eol_ext target_top {
           SPACING < stubSpacing
           SET_CORNERS_TO_SPACING=FALSE
           PARALLEL_POINT_PROJECTION=FALSE
           OUTPUT_EDGES = TRUE
        } TEMP=err_edge
        SELECT eol_ext INTERACT err_edge { } TEMP=eol_ext
      } else {
        EXTERNAL end_of_line target_top {
           SPACING < stubSpacing
           SET_CORNERS_TO_SPACING=FALSE
           PARALLEL_POINT_PROJECTION=FALSE
           OUTPUT_EDGES = TRUE
        } TEMP=err_edge
        SELECT end_of_line INTERACT err_edge { } TEMP=eol_body
        SIZE end_of_line {
           VSIZE_HEAD = sideStubExt
           VSIZE_TAIL = sideStubExt
           OUTPUT_EDGES = TRUE
        } TEMP = eol_ext
        BOOLEAN eol_ext NOT end_of_line {} TEMP=eol_ext
        EXTERNAL eol_ext target_top {
           SPACING < stubSpacing
           SET_CORNERS_TO_SPACING=FALSE
           PARALLEL_POINT_PROJECTION=FALSE
           OUTPUT_EDGES = TRUE
        } TEMP=err_edge
        SELECT eol_ext INTERACT err_edge { } TEMP=eol_ext
        BOOLEAN eol_body OR eol_ext { } TEMP=eol_ext
      } 
    } else {
      COPY end_of_line { } TEMP=eol_ext
    }
    SELECT side_edge INTERACT eol_ext { } TEMP=side_edge
    SIZE eol_ext {
       VSIZE_INSIDE = sideStubThreshold 
       VSIZE_OUTSIDE = sideStubExt
    } TEMP = eol_range
    if (sideStubExt > 0) {
       SIZE side_edge {
          VSIZE_HEAD = sideStubExt
          VSIZE_TAIL = sideStubExt
          OUTPUT_EDGES = TRUE
       } TEMP = check_edge
    } else {
       COPY side_edge { } TEMP = check_edge
    }
    BOOLEAN check_edge AND eol_range { } TEMP=check_edge
    EXTERNAL check_edge target_top {
       SPACING < temporary_1
       SET_CORNERS_TO_SPACING = FALSE
       SHADOW_OTHER_LAYER = TRUE
       PARALLEL_POINT_PROJECTION = FALSE
       OUTPUT_EDGES = TRUE
    } TEMP=err_edge
    if (0 && stubMode!=4) { /* Temporarily do not check mode 2,3 side edge length */
       LENGTH side_edge { SPACING < stubSpacing- 0.0001 *2 } TEMP=err_edge_1
       BOOLEAN err_edge OR err_edge_1 { } TEMP=err_edge
    }
    SELECT check_edge INTERACT err_edge { } TEMP=side_edge
    if (stubMode!=3) {
       SELECT eol_ext INTERACT side_edge {} TEMP=err_eol
       EXTERNAL err_eol target_top {
          COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing ,crnKeepOut= sideStubExt um (mode = stubMode )"
          SPACING < temporary_1
          PARALLEL_POINT_PROJECTION=FALSE
          SET_CORNERS_TO_SPACING=FALSE
       } (41 )
    } else { /* stubMode == 3 */
       SELECT eol_ext INTERACT side_edge { RANGE = [2, 2] } TEMP=err_eol
       EXTERNAL err_eol target_top {
          COMMENT = "$layer_name specEoLSpc: spacing= stubSpacing um (mode = 3)"
          SPACING < temporary_1
          PARALLEL_POINT_PROJECTION=FALSE
          SET_CORNERS_TO_SPACING=FALSE
       } (41 )
    }
  }
} /* stubMode > 0, not aligned */
/* Avoid empty optimization result parsing error */
if (addEmptyMetalCheck) {
   BOOLEAN empty OR empty {
      COMMENT = "$layer_name Empty: Dummy Output"
   } (41 )
   SET addEmptyMetalCheck=0;
}
/* reset variables */


 
SET minWidth = 0;
SET maxWidth = 0;
SET minArea = 0;
SET minEnclosedArea = 0;
SET minSpacing = 0;
SET sameNetMinSpacing = 0;
SET maxNumMinEdge = 0;
SET maxTotalMinEdgeLength = 0;
SET minEdgeLength = 0;
SET minEdgeLength2 = 0;
SET minEdgeLength3 = 0;
SET stubRange = 0;
SET stubSpacing = 0;
SET stub2StubSpacing = 0;
SET sideStubExt = 0;
SET sideStubThreshold = 0;
SET stubThreshold = 0;
SET fatPolyContactRule = 0;
SET fatWireThreshold = 0;
SET fatThinMinSpacing = 0;
SET fatFatMinSpacing = 0;
SET fatTblDimension = 0;
@ 1073 "adrc/adrc.ev" 2









/*Via rules*/

SET ignoreContactCodeSpacing = 1;
/*via 1*/
SET layer_name = "Via1";












SET cornerSpacingMode = 0;
SET cut_minSpacing = 0.07;
SET cut_fatContactThreshold1 = 0.16;
SET cut_fatContactThreshold2 = 0.16;
SET cut_fatTblDimension = 2;
@ 1 "adrc/adrc_check_via.ev" 1
/* check size */
if (cut_size > 0) {
    INTERNAL via1  {  
        COMMENT = "$layer_name Size      : contact size = cut_size um" 
	DIMENSION = [cut_size , cut_size]
    } (12 )
}
if (cut_minSpacing > 0) {
   if (ignoreContactCodeSpacing) {
      COPY via1  { } TEMP= default_via1 
   } else {
      SIZE metal1  { UNDER_OVER = cut_fatContactThreshold1 } TEMP = m_fat1
      SIZE metal2  { UNDER_OVER = cut_fatContactThreshold2 } TEMP = m_fat2
      BOOLEAN m_fat1 OR m_fat2 {} TEMP=m_fat
      SELECT via1  OUTSIDE m_fat { } TEMP= default_via1 
   }
}
 
/*check basic spacing*/
if (cut_sameNetMinSpacing > 0 && cut_sameNetMinSpacing < cut_minSpacing) {
  CONNECT { default_via1  BY via1  }
  if (cut_cornerMinSpacing > 0) {
    if (cornerSpacingMode == 1) {
        /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
        EXTERNAL default_via1  {
             SPACING <= 0
             CONVEX_TO_CONVEX [POINT_PROJECTION] < cut_cornerMinSpacing
             FLAG_DISCONNECTED = FALSE
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = FALSE
        } TEMP = sameNet_corner_err1
        EXTERNAL default_via1  {
             SPACING <= 0
             CONVEX_TO_CONVEX < cut_cornerMinSpacing
             FLAG_DISCONNECTED = FALSE
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = TRUE
        } TEMP = sameNet_corner_err2 
        BOOLEAN sameNet_corner_err1 OR sameNet_corner_err2 {
             COMMENT = "$layer_name SameNetSpc: corner to corner spacing = cut_cornerMinSpacing um "
        } (12 ) 
        EXTERNAL default_via1  {
             COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = cut_sameNetMinSpacing um "
             SPACING < cut_sameNetMinSpacing
             FLAG_DISCONNECTED = FALSE
             SET_CORNERS_TO_SPACING = FALSE
             PARALLEL_POINT_PROJECTION = FALSE
             NON_PARALLEL = TRUE
             TOUCH = FALSE
             POINT_TOUCH = FALSE
        } (12 )
    } else {
        EXTERNAL default_via1  {
            COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = cut_sameNetMinSpacing um (corner to corner spacing = cut_cornerMinSpacing um) "
            SPACING < cut_sameNetMinSpacing
            CONVEX_TO_CONVEX < cut_cornerMinSpacing
            FLAG_DISCONNECTED = FALSE
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
        } (12 )
    }
  } else {
    EXTERNAL default_via1  {
        COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = cut_sameNetMinSpacing um"
        SPACING < cut_sameNetMinSpacing
	BOX_CORNER = FALSE 
        FLAG_DISCONNECTED = FALSE
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
    } (12 )
  }
  if (cut_cornerMinSpacing > 0) {
    if (cornerSpacingMode == 1) {
        /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
        EXTERNAL default_via1  {
          SPACING <= 0
          CONVEX_TO_CONVEX [POINT_PROJECTION] < cut_cornerMinSpacing
          NON_PARALLEL = TRUE
          POINT_TOUCH = TRUE
          BOX_CORNER = FALSE
          NODAL = TRUE
        } TEMP = diffNet_corner_err1 
        EXTERNAL default_via1  {
          SPACING <= 0
          CONVEX_TO_CONVEX < cut_cornerMinSpacing
          NON_PARALLEL = TRUE
          POINT_TOUCH = TRUE
          BOX_CORNER = TRUE
          NODAL = TRUE
        } TEMP = diffNet_corner_err2 
        BOOLEAN diffNet_corner_err1 OR diffNet_corner_err2 {
          COMMENT = "$layer_name Spacing   : corner to corner spacing = cut_cornerMinSpacing um "
        } (12 )
        EXTERNAL default_via1  {
          COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
          SPACING < cut_minSpacing
          SET_CORNERS_TO_SPACING = FALSE
          PARALLEL_POINT_PROJECTION = FALSE
          NON_PARALLEL = TRUE
          TOUCH = FALSE
          POINT_TOUCH = FALSE
          NODAL = TRUE
        } (12 )
    } else {
        EXTERNAL default_via1  {
          COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um (corner to corner spacing = cut_cornerMinSpacing um) "
          SPACING < cut_minSpacing
          CONVEX_TO_CONVEX < cut_cornerMinSpacing
          NON_PARALLEL = TRUE
          POINT_TOUCH = TRUE
          NODAL = TRUE
        } (12 )
    }
  } else {
    EXTERNAL default_via1  {
      COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
      SPACING < cut_minSpacing
      BOX_CORNER = FALSE 
      NON_PARALLEL = TRUE
      POINT_TOUCH = TRUE
      NODAL = TRUE
    } (12 ) 
  }
} else {
   if (cut_minSpacing > 0) {
     if (cut_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
           /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
           EXTERNAL default_via1  {
             SPACING <= 0
             CONVEX_TO_CONVEX [POINT_PROJECTION] < cut_cornerMinSpacing
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = FALSE 
           } TEMP = corner_err1 
           EXTERNAL default_via1  {
             SPACING <= 0
             CONVEX_TO_CONVEX < cut_cornerMinSpacing
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = TRUE
           } TEMP = corner_err2 
           BOOLEAN corner_err1 OR corner_err2 {
             COMMENT = "$layer_name Spacing   : corner to corner spacing = cut_cornerMinSpacing um "
           } (12 )
           EXTERNAL default_via1  {
             COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
             SPACING < cut_minSpacing
             SET_CORNERS_TO_SPACING = FALSE
             PARALLEL_POINT_PROJECTION = FALSE
             NON_PARALLEL = TRUE
             TOUCH = FALSE
             POINT_TOUCH = FALSE
           } (12 )
        } else {
           EXTERNAL default_via1  {
             COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um (corner to corner spacing = cut_cornerMinSpacing um) "
             SPACING < cut_minSpacing
             CONVEX_TO_CONVEX < cut_cornerMinSpacing
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
           } (12 )
        }
    } else {
       EXTERNAL default_via1  {
          COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
          SPACING < cut_minSpacing
	  BOX_CORNER = FALSE 
	  NON_PARALLEL = TRUE
	  POINT_TOUCH = TRUE
       } (12 )
    }
  }
}
 
/*check blockage spacing*/
if (ignoreBlockage == 0) {
   if (!layer_empty (via1_blockage )) {
      if (cutBlkg_minSpacing > 0) {
	  EXTERNAL via1_blockage  via1  {
              COMMENT = "$layer_name Spacing   : contact & blockage minimum spacing = cutBlkg_minSpacing um"
	      SPACING < cutBlkg_minSpacing
	      BOX_CORNER = FALSE 
	      NON_PARALLEL = TRUE
	      POINT_TOUCH = TRUE
          } (12 )
      }
   }
}
/*check blockage overlap*/ 
/*check shorts between top_level routing and fram_blockages*/
if (cutBlkg_minSpacing > 0 || checkCrossHierShort > 0) {
   if (readCellView > 0) {
       COPY empty {} TEMP = real_blockage
       COPY via1  {} TEMP = top_cut
   } else {
       COPY via1_fram  {} TEMP = real_blockage
       COPY via1_top  {} TEMP = top_cut
   }
   if (ignoreBlockage == 0) {
      BOOLEAN via1_blockage  OR real_blockage {} TEMP=all_blockage
   } else {
      COPY real_blockage {} TEMP=all_blockage
   }
   
   BOOLEAN all_blockage AND top_cut {} TEMP = overlap_shape1
   EXTERNAL all_blockage top_cut {
      SPACING <= 0
      TOUCH = TRUE
   } TEMP = overlap_shape2
   if (checkCrossHierShort > 0) {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
          COMMENT = "$layer_name Short Cross Hierarchy"
      } (12 )
   } else {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
          COMMENT = "$layer_name Overlap   : cut & blockage overlap"
      } (12 )
   }
}
/*check adjacent via number*/
if (cut_adjacentCutRange > 0 && cut_maxNumAdjacentCut > 0) {
    if (router_ignoreSameNetAdjacentViaDRC) {
       EXTERNAL via1  {  
	   SPACING < cut_adjacentCutRange
	   SET_CORNERS_TO_SPACING = FALSE
	   PARALLEL_POINT_PROJECTION = FALSE
	   NON_PARALLEL = TRUE
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
           NODAL = TRUE
       } TEMP=edge_spacing
       EXTERNAL via1  {
	   SPACING < 0
	   CONVEX_TO_EDGE < cut_adjacentCutRange
	   CONVEX_TO_CONVEX < cut_adjacentCutRange
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
           NODAL = TRUE
       } TEMP=corner_spacing
    } else {
       EXTERNAL via1  {  
	   SPACING < cut_adjacentCutRange
	   SET_CORNERS_TO_SPACING = FALSE
	   PARALLEL_POINT_PROJECTION = FALSE
	   NON_PARALLEL = TRUE
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
       } TEMP=edge_spacing
 
       EXTERNAL via1  {
	   SPACING < 0
	   CONVEX_TO_EDGE < cut_adjacentCutRange
	   CONVEX_TO_CONVEX < cut_adjacentCutRange
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
       } TEMP=corner_spacing
    }
    SIZE edge_spacing { UNDERSIZE = 0.0002  } TEMP = edge_spacing1
    SIZE edge_spacing1 { OVERSIZE = 0.0002  } TEMP = edge_spacing2
    BOOLEAN (edge_spacing NOT edge_spacing2) OR edge_spacing1 { } TEMP=edge_spacing
 
    SIZE corner_spacing { UNDERSIZE = 0.0002  } TEMP = corner_spacing1
    SIZE corner_spacing1 { OVERSIZE = 0.0002  } TEMP = corner_spacing2
    BOOLEAN (corner_spacing NOT corner_spacing2) OR corner_spacing1 { } TEMP=corner_spacing
  
    BOOLEAN edge_spacing OR corner_spacing { } TEMP = spacing
 
    SIZE via1  { OVERSIZE = 5* 0.0002  } TEMP = cut
 
    SELECT cut INTERACT spacing {
        POINT_TOUCH = TRUE
        RANGE = [cut_maxNumAdjacentCut + 1, 9999999999 ]
    } TEMP = enclosed_cut
 
    SELECT via1  INSIDE enclosed_cut {
        COMMENT = "$layer_name AdjContNum: maximum number of the adjacent contacts ( cut_adjacentCutRange um) = cut_maxNumAdjacentCut "
    } (12 )
}
 
/*check enclosed via spacing*/
if (cut_enclosedCutNeighborRange > 0 && cut_enclosedCutNumNeighbor > 0) {
    if (cut_enclosedCutDiagViaExcluded) {
       EXTERNAL via1  {
          SPACING < cut_enclosedCutNeighborRange
          SET_CORNERS_TO_SPACING = FALSE
          PARALLEL_POINT_PROJECTION = FALSE
          NON_PARALLEL = TRUE
          BOX_CORNER = FALSE
          SHADOW = FALSE
       } TEMP = edge_spacing
       SELECT via1  TOUCHING edge_spacing {
          RANGE = [cut_enclosedCutNumNeighbor, 9999999999 ]
       } TEMP = enclosed_cut
    } else {
       /* Work around: for SIZE_RECT FLAG_INTERACTION_COUNT parser bug */
       
@ 308 "adrc/adrc_check_via.ev"
       if (cut_enclosedCutNumNeighbor==1) {
          
@-         SIZE_RECT via1  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  0  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==2) {
          
@-         SIZE_RECT via1  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  1  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==3) {
          
@-         SIZE_RECT via1  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  2  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==4) {
          
@-         SIZE_RECT via1  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  3  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==5) {
          
@-         SIZE_RECT via1  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  4  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==6) {
          
@-         SIZE_RECT via1  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  5  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==7) {
          
@-         SIZE_RECT via1  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  6  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==8) {
          
@-         SIZE_RECT via1  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  7  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==9) {
          
@-         SIZE_RECT via1  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  8  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor>9) {
          
@-         SIZE_RECT via1  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  9  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       }
    }
    if (router_ignoreSameNetAdjacentViaDRC) {
      /* Good approximation for same net via filter */
      CENTER_TO_CENTER via1  {
        NODAL=TRUE
        SPACING < cut_enclosedCutNeighborRange + 1.41421*cut_size + 0.0001 
        OUTPUT_VECTOR = TRUE
      } TEMP = c2c_spacing
      SIZE via1  { UNDERSIZE = (cut_size/2.0- 0.0001 ) } TEMP=cut_center
      BOOLEAN c2c_spacing NOT cut_center { } TEMP=c2c_spacing
      SIZE cut_center { OVERSIZE = 0.0002  } TEMP=cut_center
      BOOLEAN c2c_spacing AND via1   { } TEMP=c2c_filter
      SELECT cut_center INTERACT c2c_filter {
        POINT_TOUCH=TRUE
        RANGE = [cut_enclosedCutNumNeighbor, 9999999999 ]
      } TEMP = target_cut
   
      SELECT enclosed_cut ENCLOSING target_cut { } TEMP = enclosed_cut
    }
  
    if (cut_enclosedCutMinSpacing > 0) {
        EXTERNAL enclosed_cut {
        COMMENT = "$layer_name EncContSpc: minimum spacing between enclosed contacts ( cut_enclosedCutNeighborRange um / cut_enclosedCutNumNeighbor ) = cut_enclosedCutMinSpacing "
            SPACING < cut_enclosedCutMinSpacing
            SET_CORNERS_TO_SPACING = TRUE 
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
        } (12 )
    }
 
    if (cut_enclosedCutToNeighborMinSpacing > 0) {
       if (router_ignoreSameNetAdjacentViaDRC) {
          CONNECT { enclosed_cut BY via1  }
          EXTERNAL enclosed_cut via1  {
              COMMENT = "$layer_name EncContSpc: minimum spacing between enclosed and neighboring contacts ( cut_enclosedCutNeighborRange um / cut_enclosedCutNumNeighbor ) = cut_enclosedCutToNeighborMinSpacing "
              SPACING < cut_enclosedCutToNeighborMinSpacing
              SET_CORNERS_TO_SPACING = TRUE 
	      BOX_CORNER = FALSE 
	      NON_PARALLEL = TRUE
	      POINT_TOUCH = TRUE
              NODAL = TRUE
          } (12 )
       } else {
          EXTERNAL enclosed_cut via1  {
              COMMENT = "$layer_name EncContSpc: minimum spacing between enclosed and neighboring contacts ( cut_enclosedCutNeighborRange um / cut_enclosedCutNumNeighbor ) = cut_enclosedCutToNeighborMinSpacing "
              SPACING < cut_enclosedCutToNeighborMinSpacing
              SET_CORNERS_TO_SPACING = TRUE 
	      BOX_CORNER = FALSE 
	      NON_PARALLEL = TRUE
	      POINT_TOUCH = TRUE
          } (12 )
       }
    }
}
 
/*check max stack level, upward only*/
if (cut_maxStackLevel > 0 && cut_stackLevelSpacing > 0) {
    if (cut_maxStackLevel == 1) {
      BOOLEAN via1  AND CUT_LAYER1 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 2) {
      BOOLEAN (via1  AND CUT_LAYER1) AND CUT_LAYER2 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 3) {
      BOOLEAN (via1  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3)
        { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 4) {
      BOOLEAN ((via1  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND CUT_LAYER4 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 5) {
      BOOLEAN ((via1  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND (CUT_LAYER4 AND CUT_LAYER5) { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 6) {
      BOOLEAN ((via1  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND ((CUT_LAYER4 AND CUT_LAYER5) AND CUT_LAYER6) { } TEMP = neighbors
    }
    else if (cut_maxStackLevel >= 7) { 
      BOOLEAN ((via1  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND ((CUT_LAYER4 AND CUT_LAYER5) AND (CUT_LAYER6 AND CUT_LAYER7))
       { } TEMP = neighbors
    }
 
    if (!layer_empty(neighbors)) {
      SELECT CUT_LAYER0 INTERACT neighbors {
        LINE_TOUCH = FALSE POINT_TOUCH = FALSE 
      } TEMP = neighbors
      EXTERNAL neighbors {
	spacing <= cut_stackLevelSpacing
      } TEMP = via_arr_ext
      if (!layer_empty (via_arr_ext)) {
	SELECT neighbors OUTSIDE via_arr_ext {
         COMMENT = "$layer_name StackLevel: maximum stack level = cut_maxStackLevel "
          LINE_TOUCH = FALSE
          POINT_TOUCH = FALSE	    
        } (12 )
      }
      else {
        BOOLEAN via1  AND neighbors {
            COMMENT = "$layer_name StackLevel: maximum stack level = cut_maxStackLevel "
        } (12 )
      }
    }
  }
  else if (cut_maxStackLevel > 0) {
    if (cut_maxStackLevel == 1) {
      COPY CUT_LAYER1 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 2) {
      BOOLEAN CUT_LAYER1 AND CUT_LAYER2 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 3) {
      BOOLEAN CUT_LAYER1 AND (CUT_LAYER2 AND CUT_LAYER3)
        { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 4) {
      BOOLEAN (CUT_LAYER1 AND CUT_LAYER2) AND (CUT_LAYER3 AND CUT_LAYER4)
        { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 5) {
      BOOLEAN ((CUT_LAYER1 AND CUT_LAYER2) AND (CUT_LAYER3 AND CUT_LAYER4))
        AND CUT_LAYER5 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 6) {
      BOOLEAN ((CUT_LAYER6 AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND (CUT_LAYER4 AND CUT_LAYER5) { } TEMP = neighbors
    }
    else if (cut_maxStackLevel >= 7) { 
      BOOLEAN ((CUT_LAYER7 AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND ((CUT_LAYER4 AND CUT_LAYER5) AND CUT_LAYER6) { } TEMP = neighbors
    }
 
    if (!layer_empty (neighbors)) {
        BOOLEAN via1  AND neighbors {
            COMMENT = "$layer_name StackLevel: maximum stack level = cut_maxStackLevel "
        } (12 )
    }
}
 
/*Check fat contact*/
if (cut_fatContactMinSpacing > 0 && cut_fatTblDimension == 0) {
    if (cut_fatContactThreshold1 > 0) {
    	SIZE metal1    { UNDER_OVER = cut_fatContactThreshold1 / 2.0 - 0.0001  } TEMP = m_fat
    	BOOLEAN m_fat AND metal1  { } TEMP = m_fat
 
    	SELECT via1  INSIDE  m_fat { } TEMP = v_fat
 
    	EXTERNAL v_fat via1  {
            COMMENT = "$layer_name FatContSpc: fat contact ( cut_fatContactThreshold1 um, lower layer) minimum spacing = cut_fatContactMinSpacing um"
            SPACING < cut_fatContactMinSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
        } (12 )
    }
 
    if (cut_fatContactThreshold2 > 0) {
    	SIZE metal2    { UNDER_OVER = cut_fatContactThreshold2 / 2.0 - 0.0001  } TEMP = m_fat
    	BOOLEAN m_fat AND metal2  { } TEMP = m_fat
 
    	SELECT via1  INSIDE  m_fat { } TEMP = v_fat
 
    	EXTERNAL v_fat via1  {
            COMMENT = "$layer_name FatContSpc: fat contact ( cut_fatContactThreshold2 um, upper layer) minimum spacing = cut_fatContactMinSpacing um"
            SPACING < cut_fatContactMinSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
        } (12 )
    }
}
/* Avoid empty optimization result parsing error */
if (addEmptyViaCheck) {
   BOOLEAN empty OR empty {
      COMMENT = "$layer_name Empty: Dummy Output"
   } (12 )
   SET addEmptyViaCheck=0;
}
 
/* reset variables */















SET cut_size = 0;
SET cut_minSpacing = 0;
SET cut_sameNetMinSpacing = 0;
SET cut_cornerMinSpacing = 0;
SET cutBlkg_minSpacing = 0;
SET cut_maxNumAdjacentCut = 0;
SET cut_adjacentCutRange = 0;
SET cut_enclosedCutNeighborRange = 0;
SET cut_enclosedCutNumNeighbor = 0;
SET cut_enclosedCutMinSpacing = 0;
SET cut_enclosedCutToNeighborMinSpacing = 0;
SET cut_enclosedCutDiagViaExcluded = 0;
SET cut_maxStackLevel = 0;
SET cut_defaultContactMinSpacing = 0;
SET cut_fatContactThreshold1 = 0;
SET cut_fatContactThreshold2 = 0;
SET cut_fatContactMinSpacing = 0;
SET cut_maxCutSpacing = 0; 
SET cut_fatTblDimension = 0;
SET cut_fatTblThreshold_1 = 0;
SET cut_fatTblThreshold_2 = 0;
SET cut_fatTblNextThreshold_1 = 0;
SET cut_fatTblNextThreshold_2 = 0;
SET cut_fatTblMinCuts = 0;
SET cut_fatTblMinSpacing = 0;
SET cut_fatTblExtensionRange = 0;
SET cut_fatTblExtensionMinCuts = 0;
SET cut_fatTblExtensionMinSpacing = 0;
@ 1104 "adrc/adrc.ev" 2



/* Start of Via1 fat table spacing rules */
SET cut_maxCutSpacing = 0.1285;
SIZE via1  {
   OVER_UNDER = cut_maxCutSpacing/2.0
} TEMP = via_cluster
SET cut_fatMetalAndMode = 0;
SET cut_fatTblThreshold_1 = 0.16;
SET cut_fatTblNextThreshold_1 = 0;
SET cut_fatTblThreshold_2 = 0.16;
SET cut_fatTblNextThreshold_2 = 0;
SET cut_fatTblMinCuts = 0;
@ 1 "adrc/adrc_fatVia.ev" 1
/*Check fat contact table*/
if (cut_fatTblThreshold_1 > 0 && cut_fatTblThreshold_2 > 0) {
   SIZE metal1     { UNDER_OVER = cut_fatTblThreshold_1 / 2.0 - 0.0001  } TEMP = m_fat1
   if (cut_fatTblNextThreshold_1 > 0.0001 ) {
      SIZE m_fat1 { UNDER_OVER = cut_fatTblNextThreshold_1 / 2.0 - 0.0001  } TEMP = m_fat1_next
      BOOLEAN m_fat1 NOT m_fat1_next { } TEMP = m_fat1
   } else {
      COPY empty {} TEMP = m_fat1_next
   }
   BOOLEAN m_fat1 AND metal1  {  } TEMP = m_fat1
 
   SIZE metal2     { UNDER_OVER = cut_fatTblThreshold_2 / 2.0 - 0.0001  } TEMP = m_fat2
   if (cut_fatTblNextThreshold_2 > 0.0001 ) {
      SIZE m_fat2 { UNDER_OVER = cut_fatTblNextThreshold_2 / 2.0 - 0.0001  } TEMP = m_fat2_next
      BOOLEAN m_fat2 NOT m_fat2_next { } TEMP = m_fat2
   } else {
      COPY empty {} TEMP = m_fat2_next
   }
   BOOLEAN m_fat2 AND metal2  {  } TEMP = m_fat2
   if (cut_fatTblMinSpacing > 0 || cut_fatTblMinCuts > 1 || 
       cut_minEnclosure1 >=0 || cut_minEnclosure2 >=0 ||
       cut_EOLEnclosure1 > 0 || cut_EOLEnclosure2 > 0 ||
      (cut_ViaFarm_maxNum > 0 && cut_ViaFarm_spacing > 0)) {
      if (cut_fatMetalAndMode) {
        BOOLEAN m_fat1 AND m_fat2 { } TEMP = m_fat
        SELECT via1  INSIDE m_fat { } TEMP = v_fat
      } else {
        BOOLEAN m_fat1 OR m_fat2 { } TEMP = m_fat
        SELECT via1  INTERACT m_fat { } TEMP = v_fat
      }
   }
   if (cut_ViaFarm_maxNum > 0 && cut_ViaFarm_spacing > 0 || 
       cut_minEnclosure1 >=0 || cut_minEnclosure2 >=0 ||
       cut_EOLEnclosure1 > 0 || cut_EOLEnclosure2 > 0) {
      SET viaFarm_maxNum    = cut_ViaFarm_maxNum;
      SET viaFarm_spacing   = cut_ViaFarm_spacing;
      SET via_minEnclosure1 = cut_minEnclosure1;
      SET via_minEnclosure2 = cut_minEnclosure2;
      SET via_EOLEnclosure1 = cut_EOLEnclosure1;
      SET via_EOLEnclosure2 = cut_EOLEnclosure2;
      
      
@ 1 "adrc/adrc_viaCode.ev" 1
if (viaFarm_maxNum > 0 && viaFarm_spacing > 0) {
   SIZE v_fat  {  
     GROW_right = viaFarm_spacing - 0.0001 
   } TEMP = size_hor
   SELECT size_hor INTERACT v_fat  {
      RANGE = [viaFarm_maxNum + 1, 9999999999 ]
   } TEMP = size_hor
   SIZE v_fat  {  
      GROW_top = viaFarm_spacing - 0.0001 
   } TEMP = size_ver
   SELECT size_ver INTERACT v_fat  {
      RANGE = [viaFarm_maxNum + 1, 9999999999 ]
   } TEMP = size_ver
   BOOLEAN (size_hor OR size_ver) AND v_fat  {
      COMMENT = "$layer_name ViaFarmRule: max row/col number (spacing viaFarm_spacing um) = viaFarm_maxNum"
   } (12 )
   SET viaFarm_maxNum = 0;
   SET viaFarm_spacing = 0;      
}
/*check enclosure*/
if (via_minEnclosure1 > 0) {
    ENCLOSE v_fat  BY metal1  {
        COMMENT = "$layer_name Enclosure : min lower layer enclosure ( via_minEnclosure1 um)"
        SPACING < via_minEnclosure1
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
	TOUCH = TRUE
    } (12 )
}
/* Check out-side of enclosure */
if (via_minEnclosure1 >= 0) {
    BOOLEAN v_fat  NOT metal1  {
        COMMENT = "$layer_name Enclosure : min lower layer enclosure ( via_minEnclosure1 um)"
    } (12 )
    SET via_minEnclosure1 = -1;
}
/*check end_of_line enclosure*/
if (via_EOLEnclosure1 > 0) {
   ENCLOSE v_fat  BY metal1  {
      SPACING < via_EOLEnclosure1
      SET_CORNERS_TO_SPACING = FALSE
      PARALLEL_POINT_PROJECTION = FALSE
      SHADOW_OTHER_LAYER = TRUE  
      TOUCH = TRUE
      POINT_TOUCH = FALSE
      NON_PARALLEL = TRUE
      OUTPUT_EDGES = TRUE
   } TEMP = violation
 
   SELECT_EDGE v_fat  TOUCHING violation {  } TEMP = edges
   SELECT_VECTOR edges { ANGLE_RANGE = [0, 0] } TEMP = h_edges
   SELECT_VECTOR edges { ANGLE_RANGE = [90, 90] } TEMP = v_edges
   SELECT h_edges INTERACT v_edges { POINT_TOUCH = TRUE } TEMP = h_edges
 
   SELECT v_fat  ENCLOSING h_edges {
      COMMENT = "$layer_name Enclosure: min lower layer EoL enclosure ( via_EOLEnclosure1 um)"
   } (12 )
   SET via_EOLEnclosure1 = 0;
}
if (via_minEnclosure2 > 0) {
    ENCLOSE v_fat  BY metal2  {
        COMMENT = "$layer_name Enclosure : min upper layer enclosure ( via_minEnclosure2 um)"
        SPACING < via_minEnclosure2
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
	TOUCH = TRUE
    } (12 )
}
if (via_minEnclosure2 >= 0) {
    BOOLEAN v_fat  NOT metal2  {
        COMMENT = "$layer_name Enclosure : min upper layer enclosure ( via_minEnclosure2 um)"
    } (12 )
    SET via_minEnclosure2 = 0;
}
if (via_EOLEnclosure2 > 0) {
   ENCLOSE v_fat  BY metal2  {
      SPACING < via_EOLEnclosure2
      SET_CORNERS_TO_SPACING = FALSE
      PARALLEL_POINT_PROJECTION = FALSE
      SHADOW_OTHER_LAYER = TRUE  
      TOUCH = TRUE
      POINT_TOUCH = FALSE
      NON_PARALLEL = TRUE
      OUTPUT_EDGES = TRUE
   } TEMP = violation
 
   SELECT_EDGE v_fat  TOUCHING violation {  } TEMP = edges
   SELECT_VECTOR edges { ANGLE_RANGE = [0, 0] } TEMP = h_edges
   SELECT_VECTOR edges { ANGLE_RANGE = [90, 90] } TEMP = v_edges
   SELECT h_edges INTERACT v_edges { POINT_TOUCH = TRUE } TEMP = h_edges
 
   SELECT v_fat  ENCLOSING h_edges {
      COMMENT = "$layer_name Enclosure : min upper layer EoL enclosure ( via_EOLEnclosure2 um)"
   } (12 )
   SET via_EOLEnclosure2 = 0;
}
@ 42 "adrc/adrc_fatVia.ev" 2

      
      SET cut_ViaFarm_maxNum = 0;
      SET cut_ViaFarm_spacing = 0;
      SET cut_minEnclosure1 = 0;
      SET cut_minEnclosure2 = 0;
      SET cut_EOLEnclosure1 = 0;
      SET cut_EOLEnclosure2 = 0;
   }
 
   if (cut_fatTblMinSpacing > 0) {
      EXTERNAL v_fat via1  {
         COMMENT = "$layer_name FatContSpc: fat contact ( cut_fatTblThreshold_1 , cut_fatTblThreshold_2 um) minimum spacing = cut_fatTblMinSpacing um"
          SPACING < cut_fatTblMinSpacing
	  BOX_CORNER = FALSE 
	  NON_PARALLEL = TRUE
	  POINT_TOUCH = TRUE
      } (12 )
      SET cut_fatTblMinSpacing = 0;
   }
   if (cut_fatTblMinCuts > 1) {
      SELECT via_cluster INTERACT v_fat { } TEMP = v_fat_cluster 
      if (cut_fatMetalAndMode == 0) { 
         BOOLEAN metal1  AND metal2  { } TEMP = m_fat   
      }
      BOOLEAN v_fat_cluster AND m_fat { } TEMP = v_fat_cluster 
      SELECT v_fat_cluster INTERACT via1  {
         RANGE = [1, cut_fatTblMinCuts - 1]
      }  TEMP = v_fat_cluster
      SELECT v_fat INTERACT v_fat_cluster {
         COMMENT = "$layer_name MinContNum: fat contact ( cut_fatTblThreshold_1 , cut_fatTblThreshold_2 um) minimum number of contacts = cut_fatTblMinCuts "
      } (12 )
      SET cut_fatTblMinCuts = 0;
   }
 
   if (cut_fatTblExtensionRange > 0) {
      SIZE m_fat1 { OVERSIZE = cut_fatTblExtensionRange+ 0.0001  } TEMP = m_fat1_ran
      BOOLEAN m_fat1_ran AND metal1  {  } TEMP = m_fat1_ext
      BOOLEAN m_fat1_ext NOT m_fat1_next { } TEMP = m_fat1_ext
      BOOLEAN m_fat1_ext NOT m_fat1 { } TEMP = m_fat1_ext
      SELECT_EDGE m_fat1_ext TOUCHING m_fat1 { } TEMP = ext_filter
      SIZE ext_filter { VSIZE_INSIDE = 0.0002  } TEMP = ext_filter
      SIZE ext_filter INSIDE m_fat1_ext {
         OVERSIZE = cut_fatTblExtensionRange- 0.0002 
         INCREMENT = metalLayer1_minSpacing
      } TEMP=dummy TEMP = m_fat1_ext
      SIZE m_fat2 { OVERSIZE = cut_fatTblExtensionRange+ 0.0001  } TEMP = m_fat2_ran
      BOOLEAN m_fat2_ran AND metal2  {  } TEMP = m_fat2_ext
      BOOLEAN m_fat2_ext NOT m_fat2_next { } TEMP = m_fat2_ext
      BOOLEAN m_fat2_ext NOT m_fat2 { } TEMP = m_fat2_ext 
      SELECT_EDGE m_fat2_ext TOUCHING m_fat2 { } TEMP = ext_filter
      SIZE ext_filter { VSIZE_INSIDE = 0.0002  } TEMP = ext_filter
      SIZE ext_filter INSIDE m_fat2_ext {
         OVERSIZE = cut_fatTblExtensionRange- 0.0002 
         INCREMENT = metalLayer2_minSpacing
      } TEMP=dummy TEMP = m_fat2_ext
      BOOLEAN m_fat1_ext OR m_fat2_ext { } TEMP = m_fat_ext
      SELECT via1  INTERACT m_fat_ext {  } TEMP = v_fat_ext
      if (cut_ExtViaFarm_maxNum > 0 && cut_ExtViaFarm_spacing > 0 || 
          cut_ExtMinEnclosure1 >=0 || cut_ExtMinEnclosure2 >=0 ||
          cut_ExtEOLEnclosure1 > 0 || cut_ExtEOLEnclosure2 > 0) {
         SET viaFarm_maxNum    = cut_ExtViaFarm_maxNum;
         SET viaFarm_spacing   = cut_ExtViaFarm_spacing;
         SET via_minEnclosure1 = cut_ExtMinEnclosure1;
         SET via_minEnclosure2 = cut_ExtMinEnclosure2;
         SET via_EOLEnclosure1 = cut_ExtEOLEnclosure1;
         SET via_EOLEnclosure2 = cut_ExtEOLEnclosure2;
         
         
@ 1 "adrc/adrc_viaCode.ev" 1
if (viaFarm_maxNum > 0 && viaFarm_spacing > 0) {
   SIZE v_fat_ext  {  
     GROW_right = viaFarm_spacing - 0.0001 
   } TEMP = size_hor
   SELECT size_hor INTERACT v_fat_ext  {
      RANGE = [viaFarm_maxNum + 1, 9999999999 ]
   } TEMP = size_hor
   SIZE v_fat_ext  {  
      GROW_top = viaFarm_spacing - 0.0001 
   } TEMP = size_ver
   SELECT size_ver INTERACT v_fat_ext  {
      RANGE = [viaFarm_maxNum + 1, 9999999999 ]
   } TEMP = size_ver
   BOOLEAN (size_hor OR size_ver) AND v_fat_ext  {
      COMMENT = "$layer_name ViaFarmRule: max row/col number (spacing viaFarm_spacing um) = viaFarm_maxNum"
   } (12 )
   SET viaFarm_maxNum = 0;
   SET viaFarm_spacing = 0;      
}
/*check enclosure*/
if (via_minEnclosure1 > 0) {
    ENCLOSE v_fat_ext  BY metal1  {
        COMMENT = "$layer_name Enclosure : min lower layer enclosure ( via_minEnclosure1 um)"
        SPACING < via_minEnclosure1
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
	TOUCH = TRUE
    } (12 )
}
/* Check out-side of enclosure */
if (via_minEnclosure1 >= 0) {
    BOOLEAN v_fat_ext  NOT metal1  {
        COMMENT = "$layer_name Enclosure : min lower layer enclosure ( via_minEnclosure1 um)"
    } (12 )
    SET via_minEnclosure1 = -1;
}
/*check end_of_line enclosure*/
if (via_EOLEnclosure1 > 0) {
   ENCLOSE v_fat_ext  BY metal1  {
      SPACING < via_EOLEnclosure1
      SET_CORNERS_TO_SPACING = FALSE
      PARALLEL_POINT_PROJECTION = FALSE
      SHADOW_OTHER_LAYER = TRUE  
      TOUCH = TRUE
      POINT_TOUCH = FALSE
      NON_PARALLEL = TRUE
      OUTPUT_EDGES = TRUE
   } TEMP = violation
 
   SELECT_EDGE v_fat_ext  TOUCHING violation {  } TEMP = edges
   SELECT_VECTOR edges { ANGLE_RANGE = [0, 0] } TEMP = h_edges
   SELECT_VECTOR edges { ANGLE_RANGE = [90, 90] } TEMP = v_edges
   SELECT h_edges INTERACT v_edges { POINT_TOUCH = TRUE } TEMP = h_edges
 
   SELECT v_fat_ext  ENCLOSING h_edges {
      COMMENT = "$layer_name Enclosure: min lower layer EoL enclosure ( via_EOLEnclosure1 um)"
   } (12 )
   SET via_EOLEnclosure1 = 0;
}
if (via_minEnclosure2 > 0) {
    ENCLOSE v_fat_ext  BY metal2  {
        COMMENT = "$layer_name Enclosure : min upper layer enclosure ( via_minEnclosure2 um)"
        SPACING < via_minEnclosure2
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
	TOUCH = TRUE
    } (12 )
}
if (via_minEnclosure2 >= 0) {
    BOOLEAN v_fat_ext  NOT metal2  {
        COMMENT = "$layer_name Enclosure : min upper layer enclosure ( via_minEnclosure2 um)"
    } (12 )
    SET via_minEnclosure2 = 0;
}
if (via_EOLEnclosure2 > 0) {
   ENCLOSE v_fat_ext  BY metal2  {
      SPACING < via_EOLEnclosure2
      SET_CORNERS_TO_SPACING = FALSE
      PARALLEL_POINT_PROJECTION = FALSE
      SHADOW_OTHER_LAYER = TRUE  
      TOUCH = TRUE
      POINT_TOUCH = FALSE
      NON_PARALLEL = TRUE
      OUTPUT_EDGES = TRUE
   } TEMP = violation
 
   SELECT_EDGE v_fat_ext  TOUCHING violation {  } TEMP = edges
   SELECT_VECTOR edges { ANGLE_RANGE = [0, 0] } TEMP = h_edges
   SELECT_VECTOR edges { ANGLE_RANGE = [90, 90] } TEMP = v_edges
   SELECT h_edges INTERACT v_edges { POINT_TOUCH = TRUE } TEMP = h_edges
 
   SELECT v_fat_ext  ENCLOSING h_edges {
      COMMENT = "$layer_name Enclosure : min upper layer EoL enclosure ( via_EOLEnclosure2 um)"
   } (12 )
   SET via_EOLEnclosure2 = 0;
}
@ 110 "adrc/adrc_fatVia.ev" 2

         
         SET cut_ExtViaFarm_maxNum = 0;
         SET cut_ExtViaFarm_spacing = 0;
         SET cut_ExtMinEnclosure1 = 0;
         SET cut_ExtMinEnclosure2 = 0;
         SET cut_ExtEOLEnclosure1 = 0;
         SET cut_ExtEOLEnclosure2 = 0;
      }
 
      if (cut_fatTblExtensionMinSpacing > 0) {
         EXTERNAL v_fat_ext via1  {
            COMMENT = "$layer_name FatExtSpc : fat contact ( cut_fatTblThreshold_1 , cut_fatTblThreshold_2 um) extension range ( cut_fatTblExtensionRange um) minimum spacing = cut_fatTblExtensionMinSpacing um"
            SPACING < cut_fatTblExtensionMinSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
         } (12 )
      }
 
      if (cut_fatTblExtensionMinCuts > 1) {
         BOOLEAN metal1  AND metal2  { } TEMP = m_fat_ext
         BOOLEAN via_cluster AND m_fat_ext { } TEMP = via_cluster
         SELECT via_cluster INTERACT v_fat_ext { } TEMP = v_fat_ext_cluster
	 SELECT v_fat_ext_cluster INTERACT via1  {
            RANGE = [1, cut_fatTblExtensionMinCuts - 1]
	 }  TEMP = v_fat_ext_cluster
	 SELECT v_fat_ext INTERACT v_fat_ext_cluster {
            COMMENT = "$layer_name MinContNum: fat contact ( cut_fatTblThreshold_1 , cut_fatTblThreshold_2 um) extension range ( cut_fatTblExtensionRange um)  minimum number of contacts = cut_fatTblExtensionMinCuts "
	 } (12 )
      }
      SET cut_fatTblExtensionRange=0;
   }
}
@ 1118 "adrc/adrc.ev" 2




/* End of Via1 fat table spacing rules */











/*via 2*/
SET layer_name = "Via2";












SET cornerSpacingMode = 0;
SET cut_minSpacing = 0.07;
SET cut_fatContactThreshold1 = 0.16;
SET cut_fatContactThreshold2 = 0.16;
SET cut_fatTblDimension = 2;
@ 1 "adrc/adrc_check_via.ev" 1
/* check size */
if (cut_size > 0) {
    INTERNAL via2  {  
        COMMENT = "$layer_name Size      : contact size = cut_size um" 
	DIMENSION = [cut_size , cut_size]
    } (14 )
}
if (cut_minSpacing > 0) {
   if (ignoreContactCodeSpacing) {
      COPY via2  { } TEMP= default_via2 
   } else {
      SIZE metal2  { UNDER_OVER = cut_fatContactThreshold1 } TEMP = m_fat1
      SIZE metal3  { UNDER_OVER = cut_fatContactThreshold2 } TEMP = m_fat2
      BOOLEAN m_fat1 OR m_fat2 {} TEMP=m_fat
      SELECT via2  OUTSIDE m_fat { } TEMP= default_via2 
   }
}
 
/*check basic spacing*/
if (cut_sameNetMinSpacing > 0 && cut_sameNetMinSpacing < cut_minSpacing) {
  CONNECT { default_via2  BY via2  }
  if (cut_cornerMinSpacing > 0) {
    if (cornerSpacingMode == 1) {
        /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
        EXTERNAL default_via2  {
             SPACING <= 0
             CONVEX_TO_CONVEX [POINT_PROJECTION] < cut_cornerMinSpacing
             FLAG_DISCONNECTED = FALSE
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = FALSE
        } TEMP = sameNet_corner_err1
        EXTERNAL default_via2  {
             SPACING <= 0
             CONVEX_TO_CONVEX < cut_cornerMinSpacing
             FLAG_DISCONNECTED = FALSE
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = TRUE
        } TEMP = sameNet_corner_err2 
        BOOLEAN sameNet_corner_err1 OR sameNet_corner_err2 {
             COMMENT = "$layer_name SameNetSpc: corner to corner spacing = cut_cornerMinSpacing um "
        } (14 ) 
        EXTERNAL default_via2  {
             COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = cut_sameNetMinSpacing um "
             SPACING < cut_sameNetMinSpacing
             FLAG_DISCONNECTED = FALSE
             SET_CORNERS_TO_SPACING = FALSE
             PARALLEL_POINT_PROJECTION = FALSE
             NON_PARALLEL = TRUE
             TOUCH = FALSE
             POINT_TOUCH = FALSE
        } (14 )
    } else {
        EXTERNAL default_via2  {
            COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = cut_sameNetMinSpacing um (corner to corner spacing = cut_cornerMinSpacing um) "
            SPACING < cut_sameNetMinSpacing
            CONVEX_TO_CONVEX < cut_cornerMinSpacing
            FLAG_DISCONNECTED = FALSE
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
        } (14 )
    }
  } else {
    EXTERNAL default_via2  {
        COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = cut_sameNetMinSpacing um"
        SPACING < cut_sameNetMinSpacing
	BOX_CORNER = FALSE 
        FLAG_DISCONNECTED = FALSE
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
    } (14 )
  }
  if (cut_cornerMinSpacing > 0) {
    if (cornerSpacingMode == 1) {
        /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
        EXTERNAL default_via2  {
          SPACING <= 0
          CONVEX_TO_CONVEX [POINT_PROJECTION] < cut_cornerMinSpacing
          NON_PARALLEL = TRUE
          POINT_TOUCH = TRUE
          BOX_CORNER = FALSE
          NODAL = TRUE
        } TEMP = diffNet_corner_err1 
        EXTERNAL default_via2  {
          SPACING <= 0
          CONVEX_TO_CONVEX < cut_cornerMinSpacing
          NON_PARALLEL = TRUE
          POINT_TOUCH = TRUE
          BOX_CORNER = TRUE
          NODAL = TRUE
        } TEMP = diffNet_corner_err2 
        BOOLEAN diffNet_corner_err1 OR diffNet_corner_err2 {
          COMMENT = "$layer_name Spacing   : corner to corner spacing = cut_cornerMinSpacing um "
        } (14 )
        EXTERNAL default_via2  {
          COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
          SPACING < cut_minSpacing
          SET_CORNERS_TO_SPACING = FALSE
          PARALLEL_POINT_PROJECTION = FALSE
          NON_PARALLEL = TRUE
          TOUCH = FALSE
          POINT_TOUCH = FALSE
          NODAL = TRUE
        } (14 )
    } else {
        EXTERNAL default_via2  {
          COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um (corner to corner spacing = cut_cornerMinSpacing um) "
          SPACING < cut_minSpacing
          CONVEX_TO_CONVEX < cut_cornerMinSpacing
          NON_PARALLEL = TRUE
          POINT_TOUCH = TRUE
          NODAL = TRUE
        } (14 )
    }
  } else {
    EXTERNAL default_via2  {
      COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
      SPACING < cut_minSpacing
      BOX_CORNER = FALSE 
      NON_PARALLEL = TRUE
      POINT_TOUCH = TRUE
      NODAL = TRUE
    } (14 ) 
  }
} else {
   if (cut_minSpacing > 0) {
     if (cut_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
           /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
           EXTERNAL default_via2  {
             SPACING <= 0
             CONVEX_TO_CONVEX [POINT_PROJECTION] < cut_cornerMinSpacing
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = FALSE 
           } TEMP = corner_err1 
           EXTERNAL default_via2  {
             SPACING <= 0
             CONVEX_TO_CONVEX < cut_cornerMinSpacing
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = TRUE
           } TEMP = corner_err2 
           BOOLEAN corner_err1 OR corner_err2 {
             COMMENT = "$layer_name Spacing   : corner to corner spacing = cut_cornerMinSpacing um "
           } (14 )
           EXTERNAL default_via2  {
             COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
             SPACING < cut_minSpacing
             SET_CORNERS_TO_SPACING = FALSE
             PARALLEL_POINT_PROJECTION = FALSE
             NON_PARALLEL = TRUE
             TOUCH = FALSE
             POINT_TOUCH = FALSE
           } (14 )
        } else {
           EXTERNAL default_via2  {
             COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um (corner to corner spacing = cut_cornerMinSpacing um) "
             SPACING < cut_minSpacing
             CONVEX_TO_CONVEX < cut_cornerMinSpacing
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
           } (14 )
        }
    } else {
       EXTERNAL default_via2  {
          COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
          SPACING < cut_minSpacing
	  BOX_CORNER = FALSE 
	  NON_PARALLEL = TRUE
	  POINT_TOUCH = TRUE
       } (14 )
    }
  }
}
 
/*check blockage spacing*/
if (ignoreBlockage == 0) {
   if (!layer_empty (via2_blockage )) {
      if (cutBlkg_minSpacing > 0) {
	  EXTERNAL via2_blockage  via2  {
              COMMENT = "$layer_name Spacing   : contact & blockage minimum spacing = cutBlkg_minSpacing um"
	      SPACING < cutBlkg_minSpacing
	      BOX_CORNER = FALSE 
	      NON_PARALLEL = TRUE
	      POINT_TOUCH = TRUE
          } (14 )
      }
   }
}
/*check blockage overlap*/ 
/*check shorts between top_level routing and fram_blockages*/
if (cutBlkg_minSpacing > 0 || checkCrossHierShort > 0) {
   if (readCellView > 0) {
       COPY empty {} TEMP = real_blockage
       COPY via2  {} TEMP = top_cut
   } else {
       COPY via2_fram  {} TEMP = real_blockage
       COPY via2_top  {} TEMP = top_cut
   }
   if (ignoreBlockage == 0) {
      BOOLEAN via2_blockage  OR real_blockage {} TEMP=all_blockage
   } else {
      COPY real_blockage {} TEMP=all_blockage
   }
   
   BOOLEAN all_blockage AND top_cut {} TEMP = overlap_shape1
   EXTERNAL all_blockage top_cut {
      SPACING <= 0
      TOUCH = TRUE
   } TEMP = overlap_shape2
   if (checkCrossHierShort > 0) {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
          COMMENT = "$layer_name Short Cross Hierarchy"
      } (14 )
   } else {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
          COMMENT = "$layer_name Overlap   : cut & blockage overlap"
      } (14 )
   }
}
/*check adjacent via number*/
if (cut_adjacentCutRange > 0 && cut_maxNumAdjacentCut > 0) {
    if (router_ignoreSameNetAdjacentViaDRC) {
       EXTERNAL via2  {  
	   SPACING < cut_adjacentCutRange
	   SET_CORNERS_TO_SPACING = FALSE
	   PARALLEL_POINT_PROJECTION = FALSE
	   NON_PARALLEL = TRUE
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
           NODAL = TRUE
       } TEMP=edge_spacing
       EXTERNAL via2  {
	   SPACING < 0
	   CONVEX_TO_EDGE < cut_adjacentCutRange
	   CONVEX_TO_CONVEX < cut_adjacentCutRange
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
           NODAL = TRUE
       } TEMP=corner_spacing
    } else {
       EXTERNAL via2  {  
	   SPACING < cut_adjacentCutRange
	   SET_CORNERS_TO_SPACING = FALSE
	   PARALLEL_POINT_PROJECTION = FALSE
	   NON_PARALLEL = TRUE
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
       } TEMP=edge_spacing
 
       EXTERNAL via2  {
	   SPACING < 0
	   CONVEX_TO_EDGE < cut_adjacentCutRange
	   CONVEX_TO_CONVEX < cut_adjacentCutRange
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
       } TEMP=corner_spacing
    }
    SIZE edge_spacing { UNDERSIZE = 0.0002  } TEMP = edge_spacing1
    SIZE edge_spacing1 { OVERSIZE = 0.0002  } TEMP = edge_spacing2
    BOOLEAN (edge_spacing NOT edge_spacing2) OR edge_spacing1 { } TEMP=edge_spacing
 
    SIZE corner_spacing { UNDERSIZE = 0.0002  } TEMP = corner_spacing1
    SIZE corner_spacing1 { OVERSIZE = 0.0002  } TEMP = corner_spacing2
    BOOLEAN (corner_spacing NOT corner_spacing2) OR corner_spacing1 { } TEMP=corner_spacing
  
    BOOLEAN edge_spacing OR corner_spacing { } TEMP = spacing
 
    SIZE via2  { OVERSIZE = 5* 0.0002  } TEMP = cut
 
    SELECT cut INTERACT spacing {
        POINT_TOUCH = TRUE
        RANGE = [cut_maxNumAdjacentCut + 1, 9999999999 ]
    } TEMP = enclosed_cut
 
    SELECT via2  INSIDE enclosed_cut {
        COMMENT = "$layer_name AdjContNum: maximum number of the adjacent contacts ( cut_adjacentCutRange um) = cut_maxNumAdjacentCut "
    } (14 )
}
 
/*check enclosed via spacing*/
if (cut_enclosedCutNeighborRange > 0 && cut_enclosedCutNumNeighbor > 0) {
    if (cut_enclosedCutDiagViaExcluded) {
       EXTERNAL via2  {
          SPACING < cut_enclosedCutNeighborRange
          SET_CORNERS_TO_SPACING = FALSE
          PARALLEL_POINT_PROJECTION = FALSE
          NON_PARALLEL = TRUE
          BOX_CORNER = FALSE
          SHADOW = FALSE
       } TEMP = edge_spacing
       SELECT via2  TOUCHING edge_spacing {
          RANGE = [cut_enclosedCutNumNeighbor, 9999999999 ]
       } TEMP = enclosed_cut
    } else {
       /* Work around: for SIZE_RECT FLAG_INTERACTION_COUNT parser bug */
       
@ 308 "adrc/adrc_check_via.ev"
       if (cut_enclosedCutNumNeighbor==1) {
          
@-         SIZE_RECT via2  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  0  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==2) {
          
@-         SIZE_RECT via2  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  1  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==3) {
          
@-         SIZE_RECT via2  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  2  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==4) {
          
@-         SIZE_RECT via2  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  3  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==5) {
          
@-         SIZE_RECT via2  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  4  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==6) {
          
@-         SIZE_RECT via2  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  5  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==7) {
          
@-         SIZE_RECT via2  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  6  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==8) {
          
@-         SIZE_RECT via2  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  7  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==9) {
          
@-         SIZE_RECT via2  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  8  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor>9) {
          
@-         SIZE_RECT via2  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  9  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       }
    }
    if (router_ignoreSameNetAdjacentViaDRC) {
      /* Good approximation for same net via filter */
      CENTER_TO_CENTER via2  {
        NODAL=TRUE
        SPACING < cut_enclosedCutNeighborRange + 1.41421*cut_size + 0.0001 
        OUTPUT_VECTOR = TRUE
      } TEMP = c2c_spacing
      SIZE via2  { UNDERSIZE = (cut_size/2.0- 0.0001 ) } TEMP=cut_center
      BOOLEAN c2c_spacing NOT cut_center { } TEMP=c2c_spacing
      SIZE cut_center { OVERSIZE = 0.0002  } TEMP=cut_center
      BOOLEAN c2c_spacing AND via2   { } TEMP=c2c_filter
      SELECT cut_center INTERACT c2c_filter {
        POINT_TOUCH=TRUE
        RANGE = [cut_enclosedCutNumNeighbor, 9999999999 ]
      } TEMP = target_cut
   
      SELECT enclosed_cut ENCLOSING target_cut { } TEMP = enclosed_cut
    }
  
    if (cut_enclosedCutMinSpacing > 0) {
        EXTERNAL enclosed_cut {
        COMMENT = "$layer_name EncContSpc: minimum spacing between enclosed contacts ( cut_enclosedCutNeighborRange um / cut_enclosedCutNumNeighbor ) = cut_enclosedCutMinSpacing "
            SPACING < cut_enclosedCutMinSpacing
            SET_CORNERS_TO_SPACING = TRUE 
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
        } (14 )
    }
 
    if (cut_enclosedCutToNeighborMinSpacing > 0) {
       if (router_ignoreSameNetAdjacentViaDRC) {
          CONNECT { enclosed_cut BY via2  }
          EXTERNAL enclosed_cut via2  {
              COMMENT = "$layer_name EncContSpc: minimum spacing between enclosed and neighboring contacts ( cut_enclosedCutNeighborRange um / cut_enclosedCutNumNeighbor ) = cut_enclosedCutToNeighborMinSpacing "
              SPACING < cut_enclosedCutToNeighborMinSpacing
              SET_CORNERS_TO_SPACING = TRUE 
	      BOX_CORNER = FALSE 
	      NON_PARALLEL = TRUE
	      POINT_TOUCH = TRUE
              NODAL = TRUE
          } (14 )
       } else {
          EXTERNAL enclosed_cut via2  {
              COMMENT = "$layer_name EncContSpc: minimum spacing between enclosed and neighboring contacts ( cut_enclosedCutNeighborRange um / cut_enclosedCutNumNeighbor ) = cut_enclosedCutToNeighborMinSpacing "
              SPACING < cut_enclosedCutToNeighborMinSpacing
              SET_CORNERS_TO_SPACING = TRUE 
	      BOX_CORNER = FALSE 
	      NON_PARALLEL = TRUE
	      POINT_TOUCH = TRUE
          } (14 )
       }
    }
}
 
/*check max stack level, upward only*/
if (cut_maxStackLevel > 0 && cut_stackLevelSpacing > 0) {
    if (cut_maxStackLevel == 1) {
      BOOLEAN via2  AND CUT_LAYER1 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 2) {
      BOOLEAN (via2  AND CUT_LAYER1) AND CUT_LAYER2 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 3) {
      BOOLEAN (via2  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3)
        { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 4) {
      BOOLEAN ((via2  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND CUT_LAYER4 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 5) {
      BOOLEAN ((via2  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND (CUT_LAYER4 AND CUT_LAYER5) { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 6) {
      BOOLEAN ((via2  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND ((CUT_LAYER4 AND CUT_LAYER5) AND CUT_LAYER6) { } TEMP = neighbors
    }
    else if (cut_maxStackLevel >= 7) { 
      BOOLEAN ((via2  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND ((CUT_LAYER4 AND CUT_LAYER5) AND (CUT_LAYER6 AND CUT_LAYER7))
       { } TEMP = neighbors
    }
 
    if (!layer_empty(neighbors)) {
      SELECT CUT_LAYER0 INTERACT neighbors {
        LINE_TOUCH = FALSE POINT_TOUCH = FALSE 
      } TEMP = neighbors
      EXTERNAL neighbors {
	spacing <= cut_stackLevelSpacing
      } TEMP = via_arr_ext
      if (!layer_empty (via_arr_ext)) {
	SELECT neighbors OUTSIDE via_arr_ext {
         COMMENT = "$layer_name StackLevel: maximum stack level = cut_maxStackLevel "
          LINE_TOUCH = FALSE
          POINT_TOUCH = FALSE	    
        } (14 )
      }
      else {
        BOOLEAN via2  AND neighbors {
            COMMENT = "$layer_name StackLevel: maximum stack level = cut_maxStackLevel "
        } (14 )
      }
    }
  }
  else if (cut_maxStackLevel > 0) {
    if (cut_maxStackLevel == 1) {
      COPY CUT_LAYER1 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 2) {
      BOOLEAN CUT_LAYER1 AND CUT_LAYER2 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 3) {
      BOOLEAN CUT_LAYER1 AND (CUT_LAYER2 AND CUT_LAYER3)
        { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 4) {
      BOOLEAN (CUT_LAYER1 AND CUT_LAYER2) AND (CUT_LAYER3 AND CUT_LAYER4)
        { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 5) {
      BOOLEAN ((CUT_LAYER1 AND CUT_LAYER2) AND (CUT_LAYER3 AND CUT_LAYER4))
        AND CUT_LAYER5 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 6) {
      BOOLEAN ((CUT_LAYER6 AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND (CUT_LAYER4 AND CUT_LAYER5) { } TEMP = neighbors
    }
    else if (cut_maxStackLevel >= 7) { 
      BOOLEAN ((CUT_LAYER7 AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND ((CUT_LAYER4 AND CUT_LAYER5) AND CUT_LAYER6) { } TEMP = neighbors
    }
 
    if (!layer_empty (neighbors)) {
        BOOLEAN via2  AND neighbors {
            COMMENT = "$layer_name StackLevel: maximum stack level = cut_maxStackLevel "
        } (14 )
    }
}
 
/*Check fat contact*/
if (cut_fatContactMinSpacing > 0 && cut_fatTblDimension == 0) {
    if (cut_fatContactThreshold1 > 0) {
    	SIZE metal2    { UNDER_OVER = cut_fatContactThreshold1 / 2.0 - 0.0001  } TEMP = m_fat
    	BOOLEAN m_fat AND metal2  { } TEMP = m_fat
 
    	SELECT via2  INSIDE  m_fat { } TEMP = v_fat
 
    	EXTERNAL v_fat via2  {
            COMMENT = "$layer_name FatContSpc: fat contact ( cut_fatContactThreshold1 um, lower layer) minimum spacing = cut_fatContactMinSpacing um"
            SPACING < cut_fatContactMinSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
        } (14 )
    }
 
    if (cut_fatContactThreshold2 > 0) {
    	SIZE metal3    { UNDER_OVER = cut_fatContactThreshold2 / 2.0 - 0.0001  } TEMP = m_fat
    	BOOLEAN m_fat AND metal3  { } TEMP = m_fat
 
    	SELECT via2  INSIDE  m_fat { } TEMP = v_fat
 
    	EXTERNAL v_fat via2  {
            COMMENT = "$layer_name FatContSpc: fat contact ( cut_fatContactThreshold2 um, upper layer) minimum spacing = cut_fatContactMinSpacing um"
            SPACING < cut_fatContactMinSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
        } (14 )
    }
}
/* Avoid empty optimization result parsing error */
if (addEmptyViaCheck) {
   BOOLEAN empty OR empty {
      COMMENT = "$layer_name Empty: Dummy Output"
   } (14 )
   SET addEmptyViaCheck=0;
}
 
/* reset variables */















SET cut_size = 0;
SET cut_minSpacing = 0;
SET cut_sameNetMinSpacing = 0;
SET cut_cornerMinSpacing = 0;
SET cutBlkg_minSpacing = 0;
SET cut_maxNumAdjacentCut = 0;
SET cut_adjacentCutRange = 0;
SET cut_enclosedCutNeighborRange = 0;
SET cut_enclosedCutNumNeighbor = 0;
SET cut_enclosedCutMinSpacing = 0;
SET cut_enclosedCutToNeighborMinSpacing = 0;
SET cut_enclosedCutDiagViaExcluded = 0;
SET cut_maxStackLevel = 0;
SET cut_defaultContactMinSpacing = 0;
SET cut_fatContactThreshold1 = 0;
SET cut_fatContactThreshold2 = 0;
SET cut_fatContactMinSpacing = 0;
SET cut_maxCutSpacing = 0; 
SET cut_fatTblDimension = 0;
SET cut_fatTblThreshold_1 = 0;
SET cut_fatTblThreshold_2 = 0;
SET cut_fatTblNextThreshold_1 = 0;
SET cut_fatTblNextThreshold_2 = 0;
SET cut_fatTblMinCuts = 0;
SET cut_fatTblMinSpacing = 0;
SET cut_fatTblExtensionRange = 0;
SET cut_fatTblExtensionMinCuts = 0;
SET cut_fatTblExtensionMinSpacing = 0;
@ 1153 "adrc/adrc.ev" 2



/* Start of Via2 fat table spacing rules */
SET cut_maxCutSpacing = 0.1285;
SIZE via2  {
   OVER_UNDER = cut_maxCutSpacing/2.0
} TEMP = via_cluster
SET cut_fatMetalAndMode = 0;
SET cut_fatTblThreshold_1 = 0.16;
SET cut_fatTblNextThreshold_1 = 0;
SET cut_fatTblThreshold_2 = 0.16;
SET cut_fatTblNextThreshold_2 = 0;
SET cut_fatTblMinCuts = 0;
@ 1 "adrc/adrc_fatVia.ev" 1
/*Check fat contact table*/
if (cut_fatTblThreshold_1 > 0 && cut_fatTblThreshold_2 > 0) {
   SIZE metal2     { UNDER_OVER = cut_fatTblThreshold_1 / 2.0 - 0.0001  } TEMP = m_fat1
   if (cut_fatTblNextThreshold_1 > 0.0001 ) {
      SIZE m_fat1 { UNDER_OVER = cut_fatTblNextThreshold_1 / 2.0 - 0.0001  } TEMP = m_fat1_next
      BOOLEAN m_fat1 NOT m_fat1_next { } TEMP = m_fat1
   } else {
      COPY empty {} TEMP = m_fat1_next
   }
   BOOLEAN m_fat1 AND metal2  {  } TEMP = m_fat1
 
   SIZE metal3     { UNDER_OVER = cut_fatTblThreshold_2 / 2.0 - 0.0001  } TEMP = m_fat2
   if (cut_fatTblNextThreshold_2 > 0.0001 ) {
      SIZE m_fat2 { UNDER_OVER = cut_fatTblNextThreshold_2 / 2.0 - 0.0001  } TEMP = m_fat2_next
      BOOLEAN m_fat2 NOT m_fat2_next { } TEMP = m_fat2
   } else {
      COPY empty {} TEMP = m_fat2_next
   }
   BOOLEAN m_fat2 AND metal3  {  } TEMP = m_fat2
   if (cut_fatTblMinSpacing > 0 || cut_fatTblMinCuts > 1 || 
       cut_minEnclosure1 >=0 || cut_minEnclosure2 >=0 ||
       cut_EOLEnclosure1 > 0 || cut_EOLEnclosure2 > 0 ||
      (cut_ViaFarm_maxNum > 0 && cut_ViaFarm_spacing > 0)) {
      if (cut_fatMetalAndMode) {
        BOOLEAN m_fat1 AND m_fat2 { } TEMP = m_fat
        SELECT via2  INSIDE m_fat { } TEMP = v_fat
      } else {
        BOOLEAN m_fat1 OR m_fat2 { } TEMP = m_fat
        SELECT via2  INTERACT m_fat { } TEMP = v_fat
      }
   }
   if (cut_ViaFarm_maxNum > 0 && cut_ViaFarm_spacing > 0 || 
       cut_minEnclosure1 >=0 || cut_minEnclosure2 >=0 ||
       cut_EOLEnclosure1 > 0 || cut_EOLEnclosure2 > 0) {
      SET viaFarm_maxNum    = cut_ViaFarm_maxNum;
      SET viaFarm_spacing   = cut_ViaFarm_spacing;
      SET via_minEnclosure1 = cut_minEnclosure1;
      SET via_minEnclosure2 = cut_minEnclosure2;
      SET via_EOLEnclosure1 = cut_EOLEnclosure1;
      SET via_EOLEnclosure2 = cut_EOLEnclosure2;
      
      
@ 1 "adrc/adrc_viaCode.ev" 1
if (viaFarm_maxNum > 0 && viaFarm_spacing > 0) {
   SIZE v_fat  {  
     GROW_right = viaFarm_spacing - 0.0001 
   } TEMP = size_hor
   SELECT size_hor INTERACT v_fat  {
      RANGE = [viaFarm_maxNum + 1, 9999999999 ]
   } TEMP = size_hor
   SIZE v_fat  {  
      GROW_top = viaFarm_spacing - 0.0001 
   } TEMP = size_ver
   SELECT size_ver INTERACT v_fat  {
      RANGE = [viaFarm_maxNum + 1, 9999999999 ]
   } TEMP = size_ver
   BOOLEAN (size_hor OR size_ver) AND v_fat  {
      COMMENT = "$layer_name ViaFarmRule: max row/col number (spacing viaFarm_spacing um) = viaFarm_maxNum"
   } (14 )
   SET viaFarm_maxNum = 0;
   SET viaFarm_spacing = 0;      
}
/*check enclosure*/
if (via_minEnclosure1 > 0) {
    ENCLOSE v_fat  BY metal2  {
        COMMENT = "$layer_name Enclosure : min lower layer enclosure ( via_minEnclosure1 um)"
        SPACING < via_minEnclosure1
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
	TOUCH = TRUE
    } (14 )
}
/* Check out-side of enclosure */
if (via_minEnclosure1 >= 0) {
    BOOLEAN v_fat  NOT metal2  {
        COMMENT = "$layer_name Enclosure : min lower layer enclosure ( via_minEnclosure1 um)"
    } (14 )
    SET via_minEnclosure1 = -1;
}
/*check end_of_line enclosure*/
if (via_EOLEnclosure1 > 0) {
   ENCLOSE v_fat  BY metal2  {
      SPACING < via_EOLEnclosure1
      SET_CORNERS_TO_SPACING = FALSE
      PARALLEL_POINT_PROJECTION = FALSE
      SHADOW_OTHER_LAYER = TRUE  
      TOUCH = TRUE
      POINT_TOUCH = FALSE
      NON_PARALLEL = TRUE
      OUTPUT_EDGES = TRUE
   } TEMP = violation
 
   SELECT_EDGE v_fat  TOUCHING violation {  } TEMP = edges
   SELECT_VECTOR edges { ANGLE_RANGE = [0, 0] } TEMP = h_edges
   SELECT_VECTOR edges { ANGLE_RANGE = [90, 90] } TEMP = v_edges
   SELECT h_edges INTERACT v_edges { POINT_TOUCH = TRUE } TEMP = h_edges
 
   SELECT v_fat  ENCLOSING h_edges {
      COMMENT = "$layer_name Enclosure: min lower layer EoL enclosure ( via_EOLEnclosure1 um)"
   } (14 )
   SET via_EOLEnclosure1 = 0;
}
if (via_minEnclosure2 > 0) {
    ENCLOSE v_fat  BY metal3  {
        COMMENT = "$layer_name Enclosure : min upper layer enclosure ( via_minEnclosure2 um)"
        SPACING < via_minEnclosure2
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
	TOUCH = TRUE
    } (14 )
}
if (via_minEnclosure2 >= 0) {
    BOOLEAN v_fat  NOT metal3  {
        COMMENT = "$layer_name Enclosure : min upper layer enclosure ( via_minEnclosure2 um)"
    } (14 )
    SET via_minEnclosure2 = 0;
}
if (via_EOLEnclosure2 > 0) {
   ENCLOSE v_fat  BY metal3  {
      SPACING < via_EOLEnclosure2
      SET_CORNERS_TO_SPACING = FALSE
      PARALLEL_POINT_PROJECTION = FALSE
      SHADOW_OTHER_LAYER = TRUE  
      TOUCH = TRUE
      POINT_TOUCH = FALSE
      NON_PARALLEL = TRUE
      OUTPUT_EDGES = TRUE
   } TEMP = violation
 
   SELECT_EDGE v_fat  TOUCHING violation {  } TEMP = edges
   SELECT_VECTOR edges { ANGLE_RANGE = [0, 0] } TEMP = h_edges
   SELECT_VECTOR edges { ANGLE_RANGE = [90, 90] } TEMP = v_edges
   SELECT h_edges INTERACT v_edges { POINT_TOUCH = TRUE } TEMP = h_edges
 
   SELECT v_fat  ENCLOSING h_edges {
      COMMENT = "$layer_name Enclosure : min upper layer EoL enclosure ( via_EOLEnclosure2 um)"
   } (14 )
   SET via_EOLEnclosure2 = 0;
}
@ 42 "adrc/adrc_fatVia.ev" 2

      
      SET cut_ViaFarm_maxNum = 0;
      SET cut_ViaFarm_spacing = 0;
      SET cut_minEnclosure1 = 0;
      SET cut_minEnclosure2 = 0;
      SET cut_EOLEnclosure1 = 0;
      SET cut_EOLEnclosure2 = 0;
   }
 
   if (cut_fatTblMinSpacing > 0) {
      EXTERNAL v_fat via2  {
         COMMENT = "$layer_name FatContSpc: fat contact ( cut_fatTblThreshold_1 , cut_fatTblThreshold_2 um) minimum spacing = cut_fatTblMinSpacing um"
          SPACING < cut_fatTblMinSpacing
	  BOX_CORNER = FALSE 
	  NON_PARALLEL = TRUE
	  POINT_TOUCH = TRUE
      } (14 )
      SET cut_fatTblMinSpacing = 0;
   }
   if (cut_fatTblMinCuts > 1) {
      SELECT via_cluster INTERACT v_fat { } TEMP = v_fat_cluster 
      if (cut_fatMetalAndMode == 0) { 
         BOOLEAN metal2  AND metal3  { } TEMP = m_fat   
      }
      BOOLEAN v_fat_cluster AND m_fat { } TEMP = v_fat_cluster 
      SELECT v_fat_cluster INTERACT via2  {
         RANGE = [1, cut_fatTblMinCuts - 1]
      }  TEMP = v_fat_cluster
      SELECT v_fat INTERACT v_fat_cluster {
         COMMENT = "$layer_name MinContNum: fat contact ( cut_fatTblThreshold_1 , cut_fatTblThreshold_2 um) minimum number of contacts = cut_fatTblMinCuts "
      } (14 )
      SET cut_fatTblMinCuts = 0;
   }
 
   if (cut_fatTblExtensionRange > 0) {
      SIZE m_fat1 { OVERSIZE = cut_fatTblExtensionRange+ 0.0001  } TEMP = m_fat1_ran
      BOOLEAN m_fat1_ran AND metal2  {  } TEMP = m_fat1_ext
      BOOLEAN m_fat1_ext NOT m_fat1_next { } TEMP = m_fat1_ext
      BOOLEAN m_fat1_ext NOT m_fat1 { } TEMP = m_fat1_ext
      SELECT_EDGE m_fat1_ext TOUCHING m_fat1 { } TEMP = ext_filter
      SIZE ext_filter { VSIZE_INSIDE = 0.0002  } TEMP = ext_filter
      SIZE ext_filter INSIDE m_fat1_ext {
         OVERSIZE = cut_fatTblExtensionRange- 0.0002 
         INCREMENT = metalLayer1_minSpacing
      } TEMP=dummy TEMP = m_fat1_ext
      SIZE m_fat2 { OVERSIZE = cut_fatTblExtensionRange+ 0.0001  } TEMP = m_fat2_ran
      BOOLEAN m_fat2_ran AND metal3  {  } TEMP = m_fat2_ext
      BOOLEAN m_fat2_ext NOT m_fat2_next { } TEMP = m_fat2_ext
      BOOLEAN m_fat2_ext NOT m_fat2 { } TEMP = m_fat2_ext 
      SELECT_EDGE m_fat2_ext TOUCHING m_fat2 { } TEMP = ext_filter
      SIZE ext_filter { VSIZE_INSIDE = 0.0002  } TEMP = ext_filter
      SIZE ext_filter INSIDE m_fat2_ext {
         OVERSIZE = cut_fatTblExtensionRange- 0.0002 
         INCREMENT = metalLayer2_minSpacing
      } TEMP=dummy TEMP = m_fat2_ext
      BOOLEAN m_fat1_ext OR m_fat2_ext { } TEMP = m_fat_ext
      SELECT via2  INTERACT m_fat_ext {  } TEMP = v_fat_ext
      if (cut_ExtViaFarm_maxNum > 0 && cut_ExtViaFarm_spacing > 0 || 
          cut_ExtMinEnclosure1 >=0 || cut_ExtMinEnclosure2 >=0 ||
          cut_ExtEOLEnclosure1 > 0 || cut_ExtEOLEnclosure2 > 0) {
         SET viaFarm_maxNum    = cut_ExtViaFarm_maxNum;
         SET viaFarm_spacing   = cut_ExtViaFarm_spacing;
         SET via_minEnclosure1 = cut_ExtMinEnclosure1;
         SET via_minEnclosure2 = cut_ExtMinEnclosure2;
         SET via_EOLEnclosure1 = cut_ExtEOLEnclosure1;
         SET via_EOLEnclosure2 = cut_ExtEOLEnclosure2;
         
         
@ 1 "adrc/adrc_viaCode.ev" 1
if (viaFarm_maxNum > 0 && viaFarm_spacing > 0) {
   SIZE v_fat_ext  {  
     GROW_right = viaFarm_spacing - 0.0001 
   } TEMP = size_hor
   SELECT size_hor INTERACT v_fat_ext  {
      RANGE = [viaFarm_maxNum + 1, 9999999999 ]
   } TEMP = size_hor
   SIZE v_fat_ext  {  
      GROW_top = viaFarm_spacing - 0.0001 
   } TEMP = size_ver
   SELECT size_ver INTERACT v_fat_ext  {
      RANGE = [viaFarm_maxNum + 1, 9999999999 ]
   } TEMP = size_ver
   BOOLEAN (size_hor OR size_ver) AND v_fat_ext  {
      COMMENT = "$layer_name ViaFarmRule: max row/col number (spacing viaFarm_spacing um) = viaFarm_maxNum"
   } (14 )
   SET viaFarm_maxNum = 0;
   SET viaFarm_spacing = 0;      
}
/*check enclosure*/
if (via_minEnclosure1 > 0) {
    ENCLOSE v_fat_ext  BY metal2  {
        COMMENT = "$layer_name Enclosure : min lower layer enclosure ( via_minEnclosure1 um)"
        SPACING < via_minEnclosure1
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
	TOUCH = TRUE
    } (14 )
}
/* Check out-side of enclosure */
if (via_minEnclosure1 >= 0) {
    BOOLEAN v_fat_ext  NOT metal2  {
        COMMENT = "$layer_name Enclosure : min lower layer enclosure ( via_minEnclosure1 um)"
    } (14 )
    SET via_minEnclosure1 = -1;
}
/*check end_of_line enclosure*/
if (via_EOLEnclosure1 > 0) {
   ENCLOSE v_fat_ext  BY metal2  {
      SPACING < via_EOLEnclosure1
      SET_CORNERS_TO_SPACING = FALSE
      PARALLEL_POINT_PROJECTION = FALSE
      SHADOW_OTHER_LAYER = TRUE  
      TOUCH = TRUE
      POINT_TOUCH = FALSE
      NON_PARALLEL = TRUE
      OUTPUT_EDGES = TRUE
   } TEMP = violation
 
   SELECT_EDGE v_fat_ext  TOUCHING violation {  } TEMP = edges
   SELECT_VECTOR edges { ANGLE_RANGE = [0, 0] } TEMP = h_edges
   SELECT_VECTOR edges { ANGLE_RANGE = [90, 90] } TEMP = v_edges
   SELECT h_edges INTERACT v_edges { POINT_TOUCH = TRUE } TEMP = h_edges
 
   SELECT v_fat_ext  ENCLOSING h_edges {
      COMMENT = "$layer_name Enclosure: min lower layer EoL enclosure ( via_EOLEnclosure1 um)"
   } (14 )
   SET via_EOLEnclosure1 = 0;
}
if (via_minEnclosure2 > 0) {
    ENCLOSE v_fat_ext  BY metal3  {
        COMMENT = "$layer_name Enclosure : min upper layer enclosure ( via_minEnclosure2 um)"
        SPACING < via_minEnclosure2
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
	TOUCH = TRUE
    } (14 )
}
if (via_minEnclosure2 >= 0) {
    BOOLEAN v_fat_ext  NOT metal3  {
        COMMENT = "$layer_name Enclosure : min upper layer enclosure ( via_minEnclosure2 um)"
    } (14 )
    SET via_minEnclosure2 = 0;
}
if (via_EOLEnclosure2 > 0) {
   ENCLOSE v_fat_ext  BY metal3  {
      SPACING < via_EOLEnclosure2
      SET_CORNERS_TO_SPACING = FALSE
      PARALLEL_POINT_PROJECTION = FALSE
      SHADOW_OTHER_LAYER = TRUE  
      TOUCH = TRUE
      POINT_TOUCH = FALSE
      NON_PARALLEL = TRUE
      OUTPUT_EDGES = TRUE
   } TEMP = violation
 
   SELECT_EDGE v_fat_ext  TOUCHING violation {  } TEMP = edges
   SELECT_VECTOR edges { ANGLE_RANGE = [0, 0] } TEMP = h_edges
   SELECT_VECTOR edges { ANGLE_RANGE = [90, 90] } TEMP = v_edges
   SELECT h_edges INTERACT v_edges { POINT_TOUCH = TRUE } TEMP = h_edges
 
   SELECT v_fat_ext  ENCLOSING h_edges {
      COMMENT = "$layer_name Enclosure : min upper layer EoL enclosure ( via_EOLEnclosure2 um)"
   } (14 )
   SET via_EOLEnclosure2 = 0;
}
@ 110 "adrc/adrc_fatVia.ev" 2

         
         SET cut_ExtViaFarm_maxNum = 0;
         SET cut_ExtViaFarm_spacing = 0;
         SET cut_ExtMinEnclosure1 = 0;
         SET cut_ExtMinEnclosure2 = 0;
         SET cut_ExtEOLEnclosure1 = 0;
         SET cut_ExtEOLEnclosure2 = 0;
      }
 
      if (cut_fatTblExtensionMinSpacing > 0) {
         EXTERNAL v_fat_ext via2  {
            COMMENT = "$layer_name FatExtSpc : fat contact ( cut_fatTblThreshold_1 , cut_fatTblThreshold_2 um) extension range ( cut_fatTblExtensionRange um) minimum spacing = cut_fatTblExtensionMinSpacing um"
            SPACING < cut_fatTblExtensionMinSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
         } (14 )
      }
 
      if (cut_fatTblExtensionMinCuts > 1) {
         BOOLEAN metal2  AND metal3  { } TEMP = m_fat_ext
         BOOLEAN via_cluster AND m_fat_ext { } TEMP = via_cluster
         SELECT via_cluster INTERACT v_fat_ext { } TEMP = v_fat_ext_cluster
	 SELECT v_fat_ext_cluster INTERACT via2  {
            RANGE = [1, cut_fatTblExtensionMinCuts - 1]
	 }  TEMP = v_fat_ext_cluster
	 SELECT v_fat_ext INTERACT v_fat_ext_cluster {
            COMMENT = "$layer_name MinContNum: fat contact ( cut_fatTblThreshold_1 , cut_fatTblThreshold_2 um) extension range ( cut_fatTblExtensionRange um)  minimum number of contacts = cut_fatTblExtensionMinCuts "
	 } (14 )
      }
      SET cut_fatTblExtensionRange=0;
   }
}
@ 1167 "adrc/adrc.ev" 2




/* End of Via2 fat table spacing rules */











/*via 3*/
SET layer_name = "Via3";












SET cornerSpacingMode = 0;
SET cut_minSpacing = 0.07;
SET cut_fatContactThreshold1 = 0.16;
SET cut_fatContactThreshold2 = 0.16;
SET cut_fatTblDimension = 2;
@ 1 "adrc/adrc_check_via.ev" 1
/* check size */
if (cut_size > 0) {
    INTERNAL via3  {  
        COMMENT = "$layer_name Size      : contact size = cut_size um" 
	DIMENSION = [cut_size , cut_size]
    } (16 )
}
if (cut_minSpacing > 0) {
   if (ignoreContactCodeSpacing) {
      COPY via3  { } TEMP= default_via3 
   } else {
      SIZE metal3  { UNDER_OVER = cut_fatContactThreshold1 } TEMP = m_fat1
      SIZE metal4  { UNDER_OVER = cut_fatContactThreshold2 } TEMP = m_fat2
      BOOLEAN m_fat1 OR m_fat2 {} TEMP=m_fat
      SELECT via3  OUTSIDE m_fat { } TEMP= default_via3 
   }
}
 
/*check basic spacing*/
if (cut_sameNetMinSpacing > 0 && cut_sameNetMinSpacing < cut_minSpacing) {
  CONNECT { default_via3  BY via3  }
  if (cut_cornerMinSpacing > 0) {
    if (cornerSpacingMode == 1) {
        /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
        EXTERNAL default_via3  {
             SPACING <= 0
             CONVEX_TO_CONVEX [POINT_PROJECTION] < cut_cornerMinSpacing
             FLAG_DISCONNECTED = FALSE
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = FALSE
        } TEMP = sameNet_corner_err1
        EXTERNAL default_via3  {
             SPACING <= 0
             CONVEX_TO_CONVEX < cut_cornerMinSpacing
             FLAG_DISCONNECTED = FALSE
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = TRUE
        } TEMP = sameNet_corner_err2 
        BOOLEAN sameNet_corner_err1 OR sameNet_corner_err2 {
             COMMENT = "$layer_name SameNetSpc: corner to corner spacing = cut_cornerMinSpacing um "
        } (16 ) 
        EXTERNAL default_via3  {
             COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = cut_sameNetMinSpacing um "
             SPACING < cut_sameNetMinSpacing
             FLAG_DISCONNECTED = FALSE
             SET_CORNERS_TO_SPACING = FALSE
             PARALLEL_POINT_PROJECTION = FALSE
             NON_PARALLEL = TRUE
             TOUCH = FALSE
             POINT_TOUCH = FALSE
        } (16 )
    } else {
        EXTERNAL default_via3  {
            COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = cut_sameNetMinSpacing um (corner to corner spacing = cut_cornerMinSpacing um) "
            SPACING < cut_sameNetMinSpacing
            CONVEX_TO_CONVEX < cut_cornerMinSpacing
            FLAG_DISCONNECTED = FALSE
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
        } (16 )
    }
  } else {
    EXTERNAL default_via3  {
        COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = cut_sameNetMinSpacing um"
        SPACING < cut_sameNetMinSpacing
	BOX_CORNER = FALSE 
        FLAG_DISCONNECTED = FALSE
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
    } (16 )
  }
  if (cut_cornerMinSpacing > 0) {
    if (cornerSpacingMode == 1) {
        /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
        EXTERNAL default_via3  {
          SPACING <= 0
          CONVEX_TO_CONVEX [POINT_PROJECTION] < cut_cornerMinSpacing
          NON_PARALLEL = TRUE
          POINT_TOUCH = TRUE
          BOX_CORNER = FALSE
          NODAL = TRUE
        } TEMP = diffNet_corner_err1 
        EXTERNAL default_via3  {
          SPACING <= 0
          CONVEX_TO_CONVEX < cut_cornerMinSpacing
          NON_PARALLEL = TRUE
          POINT_TOUCH = TRUE
          BOX_CORNER = TRUE
          NODAL = TRUE
        } TEMP = diffNet_corner_err2 
        BOOLEAN diffNet_corner_err1 OR diffNet_corner_err2 {
          COMMENT = "$layer_name Spacing   : corner to corner spacing = cut_cornerMinSpacing um "
        } (16 )
        EXTERNAL default_via3  {
          COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
          SPACING < cut_minSpacing
          SET_CORNERS_TO_SPACING = FALSE
          PARALLEL_POINT_PROJECTION = FALSE
          NON_PARALLEL = TRUE
          TOUCH = FALSE
          POINT_TOUCH = FALSE
          NODAL = TRUE
        } (16 )
    } else {
        EXTERNAL default_via3  {
          COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um (corner to corner spacing = cut_cornerMinSpacing um) "
          SPACING < cut_minSpacing
          CONVEX_TO_CONVEX < cut_cornerMinSpacing
          NON_PARALLEL = TRUE
          POINT_TOUCH = TRUE
          NODAL = TRUE
        } (16 )
    }
  } else {
    EXTERNAL default_via3  {
      COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
      SPACING < cut_minSpacing
      BOX_CORNER = FALSE 
      NON_PARALLEL = TRUE
      POINT_TOUCH = TRUE
      NODAL = TRUE
    } (16 ) 
  }
} else {
   if (cut_minSpacing > 0) {
     if (cut_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
           /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
           EXTERNAL default_via3  {
             SPACING <= 0
             CONVEX_TO_CONVEX [POINT_PROJECTION] < cut_cornerMinSpacing
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = FALSE 
           } TEMP = corner_err1 
           EXTERNAL default_via3  {
             SPACING <= 0
             CONVEX_TO_CONVEX < cut_cornerMinSpacing
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = TRUE
           } TEMP = corner_err2 
           BOOLEAN corner_err1 OR corner_err2 {
             COMMENT = "$layer_name Spacing   : corner to corner spacing = cut_cornerMinSpacing um "
           } (16 )
           EXTERNAL default_via3  {
             COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
             SPACING < cut_minSpacing
             SET_CORNERS_TO_SPACING = FALSE
             PARALLEL_POINT_PROJECTION = FALSE
             NON_PARALLEL = TRUE
             TOUCH = FALSE
             POINT_TOUCH = FALSE
           } (16 )
        } else {
           EXTERNAL default_via3  {
             COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um (corner to corner spacing = cut_cornerMinSpacing um) "
             SPACING < cut_minSpacing
             CONVEX_TO_CONVEX < cut_cornerMinSpacing
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
           } (16 )
        }
    } else {
       EXTERNAL default_via3  {
          COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
          SPACING < cut_minSpacing
	  BOX_CORNER = FALSE 
	  NON_PARALLEL = TRUE
	  POINT_TOUCH = TRUE
       } (16 )
    }
  }
}
 
/*check blockage spacing*/
if (ignoreBlockage == 0) {
   if (!layer_empty (via3_blockage )) {
      if (cutBlkg_minSpacing > 0) {
	  EXTERNAL via3_blockage  via3  {
              COMMENT = "$layer_name Spacing   : contact & blockage minimum spacing = cutBlkg_minSpacing um"
	      SPACING < cutBlkg_minSpacing
	      BOX_CORNER = FALSE 
	      NON_PARALLEL = TRUE
	      POINT_TOUCH = TRUE
          } (16 )
      }
   }
}
/*check blockage overlap*/ 
/*check shorts between top_level routing and fram_blockages*/
if (cutBlkg_minSpacing > 0 || checkCrossHierShort > 0) {
   if (readCellView > 0) {
       COPY empty {} TEMP = real_blockage
       COPY via3  {} TEMP = top_cut
   } else {
       COPY via3_fram  {} TEMP = real_blockage
       COPY via3_top  {} TEMP = top_cut
   }
   if (ignoreBlockage == 0) {
      BOOLEAN via3_blockage  OR real_blockage {} TEMP=all_blockage
   } else {
      COPY real_blockage {} TEMP=all_blockage
   }
   
   BOOLEAN all_blockage AND top_cut {} TEMP = overlap_shape1
   EXTERNAL all_blockage top_cut {
      SPACING <= 0
      TOUCH = TRUE
   } TEMP = overlap_shape2
   if (checkCrossHierShort > 0) {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
          COMMENT = "$layer_name Short Cross Hierarchy"
      } (16 )
   } else {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
          COMMENT = "$layer_name Overlap   : cut & blockage overlap"
      } (16 )
   }
}
/*check adjacent via number*/
if (cut_adjacentCutRange > 0 && cut_maxNumAdjacentCut > 0) {
    if (router_ignoreSameNetAdjacentViaDRC) {
       EXTERNAL via3  {  
	   SPACING < cut_adjacentCutRange
	   SET_CORNERS_TO_SPACING = FALSE
	   PARALLEL_POINT_PROJECTION = FALSE
	   NON_PARALLEL = TRUE
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
           NODAL = TRUE
       } TEMP=edge_spacing
       EXTERNAL via3  {
	   SPACING < 0
	   CONVEX_TO_EDGE < cut_adjacentCutRange
	   CONVEX_TO_CONVEX < cut_adjacentCutRange
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
           NODAL = TRUE
       } TEMP=corner_spacing
    } else {
       EXTERNAL via3  {  
	   SPACING < cut_adjacentCutRange
	   SET_CORNERS_TO_SPACING = FALSE
	   PARALLEL_POINT_PROJECTION = FALSE
	   NON_PARALLEL = TRUE
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
       } TEMP=edge_spacing
 
       EXTERNAL via3  {
	   SPACING < 0
	   CONVEX_TO_EDGE < cut_adjacentCutRange
	   CONVEX_TO_CONVEX < cut_adjacentCutRange
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
       } TEMP=corner_spacing
    }
    SIZE edge_spacing { UNDERSIZE = 0.0002  } TEMP = edge_spacing1
    SIZE edge_spacing1 { OVERSIZE = 0.0002  } TEMP = edge_spacing2
    BOOLEAN (edge_spacing NOT edge_spacing2) OR edge_spacing1 { } TEMP=edge_spacing
 
    SIZE corner_spacing { UNDERSIZE = 0.0002  } TEMP = corner_spacing1
    SIZE corner_spacing1 { OVERSIZE = 0.0002  } TEMP = corner_spacing2
    BOOLEAN (corner_spacing NOT corner_spacing2) OR corner_spacing1 { } TEMP=corner_spacing
  
    BOOLEAN edge_spacing OR corner_spacing { } TEMP = spacing
 
    SIZE via3  { OVERSIZE = 5* 0.0002  } TEMP = cut
 
    SELECT cut INTERACT spacing {
        POINT_TOUCH = TRUE
        RANGE = [cut_maxNumAdjacentCut + 1, 9999999999 ]
    } TEMP = enclosed_cut
 
    SELECT via3  INSIDE enclosed_cut {
        COMMENT = "$layer_name AdjContNum: maximum number of the adjacent contacts ( cut_adjacentCutRange um) = cut_maxNumAdjacentCut "
    } (16 )
}
 
/*check enclosed via spacing*/
if (cut_enclosedCutNeighborRange > 0 && cut_enclosedCutNumNeighbor > 0) {
    if (cut_enclosedCutDiagViaExcluded) {
       EXTERNAL via3  {
          SPACING < cut_enclosedCutNeighborRange
          SET_CORNERS_TO_SPACING = FALSE
          PARALLEL_POINT_PROJECTION = FALSE
          NON_PARALLEL = TRUE
          BOX_CORNER = FALSE
          SHADOW = FALSE
       } TEMP = edge_spacing
       SELECT via3  TOUCHING edge_spacing {
          RANGE = [cut_enclosedCutNumNeighbor, 9999999999 ]
       } TEMP = enclosed_cut
    } else {
       /* Work around: for SIZE_RECT FLAG_INTERACTION_COUNT parser bug */
       
@ 308 "adrc/adrc_check_via.ev"
       if (cut_enclosedCutNumNeighbor==1) {
          
@-         SIZE_RECT via3  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  0  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==2) {
          
@-         SIZE_RECT via3  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  1  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==3) {
          
@-         SIZE_RECT via3  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  2  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==4) {
          
@-         SIZE_RECT via3  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  3  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==5) {
          
@-         SIZE_RECT via3  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  4  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==6) {
          
@-         SIZE_RECT via3  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  5  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==7) {
          
@-         SIZE_RECT via3  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  6  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==8) {
          
@-         SIZE_RECT via3  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  7  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==9) {
          
@-         SIZE_RECT via3  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  8  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor>9) {
          
@-         SIZE_RECT via3  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  9  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       }
    }
    if (router_ignoreSameNetAdjacentViaDRC) {
      /* Good approximation for same net via filter */
      CENTER_TO_CENTER via3  {
        NODAL=TRUE
        SPACING < cut_enclosedCutNeighborRange + 1.41421*cut_size + 0.0001 
        OUTPUT_VECTOR = TRUE
      } TEMP = c2c_spacing
      SIZE via3  { UNDERSIZE = (cut_size/2.0- 0.0001 ) } TEMP=cut_center
      BOOLEAN c2c_spacing NOT cut_center { } TEMP=c2c_spacing
      SIZE cut_center { OVERSIZE = 0.0002  } TEMP=cut_center
      BOOLEAN c2c_spacing AND via3   { } TEMP=c2c_filter
      SELECT cut_center INTERACT c2c_filter {
        POINT_TOUCH=TRUE
        RANGE = [cut_enclosedCutNumNeighbor, 9999999999 ]
      } TEMP = target_cut
   
      SELECT enclosed_cut ENCLOSING target_cut { } TEMP = enclosed_cut
    }
  
    if (cut_enclosedCutMinSpacing > 0) {
        EXTERNAL enclosed_cut {
        COMMENT = "$layer_name EncContSpc: minimum spacing between enclosed contacts ( cut_enclosedCutNeighborRange um / cut_enclosedCutNumNeighbor ) = cut_enclosedCutMinSpacing "
            SPACING < cut_enclosedCutMinSpacing
            SET_CORNERS_TO_SPACING = TRUE 
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
        } (16 )
    }
 
    if (cut_enclosedCutToNeighborMinSpacing > 0) {
       if (router_ignoreSameNetAdjacentViaDRC) {
          CONNECT { enclosed_cut BY via3  }
          EXTERNAL enclosed_cut via3  {
              COMMENT = "$layer_name EncContSpc: minimum spacing between enclosed and neighboring contacts ( cut_enclosedCutNeighborRange um / cut_enclosedCutNumNeighbor ) = cut_enclosedCutToNeighborMinSpacing "
              SPACING < cut_enclosedCutToNeighborMinSpacing
              SET_CORNERS_TO_SPACING = TRUE 
	      BOX_CORNER = FALSE 
	      NON_PARALLEL = TRUE
	      POINT_TOUCH = TRUE
              NODAL = TRUE
          } (16 )
       } else {
          EXTERNAL enclosed_cut via3  {
              COMMENT = "$layer_name EncContSpc: minimum spacing between enclosed and neighboring contacts ( cut_enclosedCutNeighborRange um / cut_enclosedCutNumNeighbor ) = cut_enclosedCutToNeighborMinSpacing "
              SPACING < cut_enclosedCutToNeighborMinSpacing
              SET_CORNERS_TO_SPACING = TRUE 
	      BOX_CORNER = FALSE 
	      NON_PARALLEL = TRUE
	      POINT_TOUCH = TRUE
          } (16 )
       }
    }
}
 
/*check max stack level, upward only*/
if (cut_maxStackLevel > 0 && cut_stackLevelSpacing > 0) {
    if (cut_maxStackLevel == 1) {
      BOOLEAN via3  AND CUT_LAYER1 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 2) {
      BOOLEAN (via3  AND CUT_LAYER1) AND CUT_LAYER2 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 3) {
      BOOLEAN (via3  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3)
        { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 4) {
      BOOLEAN ((via3  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND CUT_LAYER4 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 5) {
      BOOLEAN ((via3  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND (CUT_LAYER4 AND CUT_LAYER5) { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 6) {
      BOOLEAN ((via3  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND ((CUT_LAYER4 AND CUT_LAYER5) AND CUT_LAYER6) { } TEMP = neighbors
    }
    else if (cut_maxStackLevel >= 7) { 
      BOOLEAN ((via3  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND ((CUT_LAYER4 AND CUT_LAYER5) AND (CUT_LAYER6 AND CUT_LAYER7))
       { } TEMP = neighbors
    }
 
    if (!layer_empty(neighbors)) {
      SELECT CUT_LAYER0 INTERACT neighbors {
        LINE_TOUCH = FALSE POINT_TOUCH = FALSE 
      } TEMP = neighbors
      EXTERNAL neighbors {
	spacing <= cut_stackLevelSpacing
      } TEMP = via_arr_ext
      if (!layer_empty (via_arr_ext)) {
	SELECT neighbors OUTSIDE via_arr_ext {
         COMMENT = "$layer_name StackLevel: maximum stack level = cut_maxStackLevel "
          LINE_TOUCH = FALSE
          POINT_TOUCH = FALSE	    
        } (16 )
      }
      else {
        BOOLEAN via3  AND neighbors {
            COMMENT = "$layer_name StackLevel: maximum stack level = cut_maxStackLevel "
        } (16 )
      }
    }
  }
  else if (cut_maxStackLevel > 0) {
    if (cut_maxStackLevel == 1) {
      COPY CUT_LAYER1 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 2) {
      BOOLEAN CUT_LAYER1 AND CUT_LAYER2 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 3) {
      BOOLEAN CUT_LAYER1 AND (CUT_LAYER2 AND CUT_LAYER3)
        { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 4) {
      BOOLEAN (CUT_LAYER1 AND CUT_LAYER2) AND (CUT_LAYER3 AND CUT_LAYER4)
        { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 5) {
      BOOLEAN ((CUT_LAYER1 AND CUT_LAYER2) AND (CUT_LAYER3 AND CUT_LAYER4))
        AND CUT_LAYER5 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 6) {
      BOOLEAN ((CUT_LAYER6 AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND (CUT_LAYER4 AND CUT_LAYER5) { } TEMP = neighbors
    }
    else if (cut_maxStackLevel >= 7) { 
      BOOLEAN ((CUT_LAYER7 AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND ((CUT_LAYER4 AND CUT_LAYER5) AND CUT_LAYER6) { } TEMP = neighbors
    }
 
    if (!layer_empty (neighbors)) {
        BOOLEAN via3  AND neighbors {
            COMMENT = "$layer_name StackLevel: maximum stack level = cut_maxStackLevel "
        } (16 )
    }
}
 
/*Check fat contact*/
if (cut_fatContactMinSpacing > 0 && cut_fatTblDimension == 0) {
    if (cut_fatContactThreshold1 > 0) {
    	SIZE metal3    { UNDER_OVER = cut_fatContactThreshold1 / 2.0 - 0.0001  } TEMP = m_fat
    	BOOLEAN m_fat AND metal3  { } TEMP = m_fat
 
    	SELECT via3  INSIDE  m_fat { } TEMP = v_fat
 
    	EXTERNAL v_fat via3  {
            COMMENT = "$layer_name FatContSpc: fat contact ( cut_fatContactThreshold1 um, lower layer) minimum spacing = cut_fatContactMinSpacing um"
            SPACING < cut_fatContactMinSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
        } (16 )
    }
 
    if (cut_fatContactThreshold2 > 0) {
    	SIZE metal4    { UNDER_OVER = cut_fatContactThreshold2 / 2.0 - 0.0001  } TEMP = m_fat
    	BOOLEAN m_fat AND metal4  { } TEMP = m_fat
 
    	SELECT via3  INSIDE  m_fat { } TEMP = v_fat
 
    	EXTERNAL v_fat via3  {
            COMMENT = "$layer_name FatContSpc: fat contact ( cut_fatContactThreshold2 um, upper layer) minimum spacing = cut_fatContactMinSpacing um"
            SPACING < cut_fatContactMinSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
        } (16 )
    }
}
/* Avoid empty optimization result parsing error */
if (addEmptyViaCheck) {
   BOOLEAN empty OR empty {
      COMMENT = "$layer_name Empty: Dummy Output"
   } (16 )
   SET addEmptyViaCheck=0;
}
 
/* reset variables */















SET cut_size = 0;
SET cut_minSpacing = 0;
SET cut_sameNetMinSpacing = 0;
SET cut_cornerMinSpacing = 0;
SET cutBlkg_minSpacing = 0;
SET cut_maxNumAdjacentCut = 0;
SET cut_adjacentCutRange = 0;
SET cut_enclosedCutNeighborRange = 0;
SET cut_enclosedCutNumNeighbor = 0;
SET cut_enclosedCutMinSpacing = 0;
SET cut_enclosedCutToNeighborMinSpacing = 0;
SET cut_enclosedCutDiagViaExcluded = 0;
SET cut_maxStackLevel = 0;
SET cut_defaultContactMinSpacing = 0;
SET cut_fatContactThreshold1 = 0;
SET cut_fatContactThreshold2 = 0;
SET cut_fatContactMinSpacing = 0;
SET cut_maxCutSpacing = 0; 
SET cut_fatTblDimension = 0;
SET cut_fatTblThreshold_1 = 0;
SET cut_fatTblThreshold_2 = 0;
SET cut_fatTblNextThreshold_1 = 0;
SET cut_fatTblNextThreshold_2 = 0;
SET cut_fatTblMinCuts = 0;
SET cut_fatTblMinSpacing = 0;
SET cut_fatTblExtensionRange = 0;
SET cut_fatTblExtensionMinCuts = 0;
SET cut_fatTblExtensionMinSpacing = 0;
@ 1202 "adrc/adrc.ev" 2



/* Start of Via3 fat table spacing rules */
SET cut_maxCutSpacing = 0.1285;
SIZE via3  {
   OVER_UNDER = cut_maxCutSpacing/2.0
} TEMP = via_cluster
SET cut_fatMetalAndMode = 0;
SET cut_fatTblThreshold_1 = 0.16;
SET cut_fatTblNextThreshold_1 = 0;
SET cut_fatTblThreshold_2 = 0.16;
SET cut_fatTblNextThreshold_2 = 0;
SET cut_fatTblMinCuts = 0;
@ 1 "adrc/adrc_fatVia.ev" 1
/*Check fat contact table*/
if (cut_fatTblThreshold_1 > 0 && cut_fatTblThreshold_2 > 0) {
   SIZE metal3     { UNDER_OVER = cut_fatTblThreshold_1 / 2.0 - 0.0001  } TEMP = m_fat1
   if (cut_fatTblNextThreshold_1 > 0.0001 ) {
      SIZE m_fat1 { UNDER_OVER = cut_fatTblNextThreshold_1 / 2.0 - 0.0001  } TEMP = m_fat1_next
      BOOLEAN m_fat1 NOT m_fat1_next { } TEMP = m_fat1
   } else {
      COPY empty {} TEMP = m_fat1_next
   }
   BOOLEAN m_fat1 AND metal3  {  } TEMP = m_fat1
 
   SIZE metal4     { UNDER_OVER = cut_fatTblThreshold_2 / 2.0 - 0.0001  } TEMP = m_fat2
   if (cut_fatTblNextThreshold_2 > 0.0001 ) {
      SIZE m_fat2 { UNDER_OVER = cut_fatTblNextThreshold_2 / 2.0 - 0.0001  } TEMP = m_fat2_next
      BOOLEAN m_fat2 NOT m_fat2_next { } TEMP = m_fat2
   } else {
      COPY empty {} TEMP = m_fat2_next
   }
   BOOLEAN m_fat2 AND metal4  {  } TEMP = m_fat2
   if (cut_fatTblMinSpacing > 0 || cut_fatTblMinCuts > 1 || 
       cut_minEnclosure1 >=0 || cut_minEnclosure2 >=0 ||
       cut_EOLEnclosure1 > 0 || cut_EOLEnclosure2 > 0 ||
      (cut_ViaFarm_maxNum > 0 && cut_ViaFarm_spacing > 0)) {
      if (cut_fatMetalAndMode) {
        BOOLEAN m_fat1 AND m_fat2 { } TEMP = m_fat
        SELECT via3  INSIDE m_fat { } TEMP = v_fat
      } else {
        BOOLEAN m_fat1 OR m_fat2 { } TEMP = m_fat
        SELECT via3  INTERACT m_fat { } TEMP = v_fat
      }
   }
   if (cut_ViaFarm_maxNum > 0 && cut_ViaFarm_spacing > 0 || 
       cut_minEnclosure1 >=0 || cut_minEnclosure2 >=0 ||
       cut_EOLEnclosure1 > 0 || cut_EOLEnclosure2 > 0) {
      SET viaFarm_maxNum    = cut_ViaFarm_maxNum;
      SET viaFarm_spacing   = cut_ViaFarm_spacing;
      SET via_minEnclosure1 = cut_minEnclosure1;
      SET via_minEnclosure2 = cut_minEnclosure2;
      SET via_EOLEnclosure1 = cut_EOLEnclosure1;
      SET via_EOLEnclosure2 = cut_EOLEnclosure2;
      
      
@ 1 "adrc/adrc_viaCode.ev" 1
if (viaFarm_maxNum > 0 && viaFarm_spacing > 0) {
   SIZE v_fat  {  
     GROW_right = viaFarm_spacing - 0.0001 
   } TEMP = size_hor
   SELECT size_hor INTERACT v_fat  {
      RANGE = [viaFarm_maxNum + 1, 9999999999 ]
   } TEMP = size_hor
   SIZE v_fat  {  
      GROW_top = viaFarm_spacing - 0.0001 
   } TEMP = size_ver
   SELECT size_ver INTERACT v_fat  {
      RANGE = [viaFarm_maxNum + 1, 9999999999 ]
   } TEMP = size_ver
   BOOLEAN (size_hor OR size_ver) AND v_fat  {
      COMMENT = "$layer_name ViaFarmRule: max row/col number (spacing viaFarm_spacing um) = viaFarm_maxNum"
   } (16 )
   SET viaFarm_maxNum = 0;
   SET viaFarm_spacing = 0;      
}
/*check enclosure*/
if (via_minEnclosure1 > 0) {
    ENCLOSE v_fat  BY metal3  {
        COMMENT = "$layer_name Enclosure : min lower layer enclosure ( via_minEnclosure1 um)"
        SPACING < via_minEnclosure1
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
	TOUCH = TRUE
    } (16 )
}
/* Check out-side of enclosure */
if (via_minEnclosure1 >= 0) {
    BOOLEAN v_fat  NOT metal3  {
        COMMENT = "$layer_name Enclosure : min lower layer enclosure ( via_minEnclosure1 um)"
    } (16 )
    SET via_minEnclosure1 = -1;
}
/*check end_of_line enclosure*/
if (via_EOLEnclosure1 > 0) {
   ENCLOSE v_fat  BY metal3  {
      SPACING < via_EOLEnclosure1
      SET_CORNERS_TO_SPACING = FALSE
      PARALLEL_POINT_PROJECTION = FALSE
      SHADOW_OTHER_LAYER = TRUE  
      TOUCH = TRUE
      POINT_TOUCH = FALSE
      NON_PARALLEL = TRUE
      OUTPUT_EDGES = TRUE
   } TEMP = violation
 
   SELECT_EDGE v_fat  TOUCHING violation {  } TEMP = edges
   SELECT_VECTOR edges { ANGLE_RANGE = [0, 0] } TEMP = h_edges
   SELECT_VECTOR edges { ANGLE_RANGE = [90, 90] } TEMP = v_edges
   SELECT h_edges INTERACT v_edges { POINT_TOUCH = TRUE } TEMP = h_edges
 
   SELECT v_fat  ENCLOSING h_edges {
      COMMENT = "$layer_name Enclosure: min lower layer EoL enclosure ( via_EOLEnclosure1 um)"
   } (16 )
   SET via_EOLEnclosure1 = 0;
}
if (via_minEnclosure2 > 0) {
    ENCLOSE v_fat  BY metal4  {
        COMMENT = "$layer_name Enclosure : min upper layer enclosure ( via_minEnclosure2 um)"
        SPACING < via_minEnclosure2
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
	TOUCH = TRUE
    } (16 )
}
if (via_minEnclosure2 >= 0) {
    BOOLEAN v_fat  NOT metal4  {
        COMMENT = "$layer_name Enclosure : min upper layer enclosure ( via_minEnclosure2 um)"
    } (16 )
    SET via_minEnclosure2 = 0;
}
if (via_EOLEnclosure2 > 0) {
   ENCLOSE v_fat  BY metal4  {
      SPACING < via_EOLEnclosure2
      SET_CORNERS_TO_SPACING = FALSE
      PARALLEL_POINT_PROJECTION = FALSE
      SHADOW_OTHER_LAYER = TRUE  
      TOUCH = TRUE
      POINT_TOUCH = FALSE
      NON_PARALLEL = TRUE
      OUTPUT_EDGES = TRUE
   } TEMP = violation
 
   SELECT_EDGE v_fat  TOUCHING violation {  } TEMP = edges
   SELECT_VECTOR edges { ANGLE_RANGE = [0, 0] } TEMP = h_edges
   SELECT_VECTOR edges { ANGLE_RANGE = [90, 90] } TEMP = v_edges
   SELECT h_edges INTERACT v_edges { POINT_TOUCH = TRUE } TEMP = h_edges
 
   SELECT v_fat  ENCLOSING h_edges {
      COMMENT = "$layer_name Enclosure : min upper layer EoL enclosure ( via_EOLEnclosure2 um)"
   } (16 )
   SET via_EOLEnclosure2 = 0;
}
@ 42 "adrc/adrc_fatVia.ev" 2

      
      SET cut_ViaFarm_maxNum = 0;
      SET cut_ViaFarm_spacing = 0;
      SET cut_minEnclosure1 = 0;
      SET cut_minEnclosure2 = 0;
      SET cut_EOLEnclosure1 = 0;
      SET cut_EOLEnclosure2 = 0;
   }
 
   if (cut_fatTblMinSpacing > 0) {
      EXTERNAL v_fat via3  {
         COMMENT = "$layer_name FatContSpc: fat contact ( cut_fatTblThreshold_1 , cut_fatTblThreshold_2 um) minimum spacing = cut_fatTblMinSpacing um"
          SPACING < cut_fatTblMinSpacing
	  BOX_CORNER = FALSE 
	  NON_PARALLEL = TRUE
	  POINT_TOUCH = TRUE
      } (16 )
      SET cut_fatTblMinSpacing = 0;
   }
   if (cut_fatTblMinCuts > 1) {
      SELECT via_cluster INTERACT v_fat { } TEMP = v_fat_cluster 
      if (cut_fatMetalAndMode == 0) { 
         BOOLEAN metal3  AND metal4  { } TEMP = m_fat   
      }
      BOOLEAN v_fat_cluster AND m_fat { } TEMP = v_fat_cluster 
      SELECT v_fat_cluster INTERACT via3  {
         RANGE = [1, cut_fatTblMinCuts - 1]
      }  TEMP = v_fat_cluster
      SELECT v_fat INTERACT v_fat_cluster {
         COMMENT = "$layer_name MinContNum: fat contact ( cut_fatTblThreshold_1 , cut_fatTblThreshold_2 um) minimum number of contacts = cut_fatTblMinCuts "
      } (16 )
      SET cut_fatTblMinCuts = 0;
   }
 
   if (cut_fatTblExtensionRange > 0) {
      SIZE m_fat1 { OVERSIZE = cut_fatTblExtensionRange+ 0.0001  } TEMP = m_fat1_ran
      BOOLEAN m_fat1_ran AND metal3  {  } TEMP = m_fat1_ext
      BOOLEAN m_fat1_ext NOT m_fat1_next { } TEMP = m_fat1_ext
      BOOLEAN m_fat1_ext NOT m_fat1 { } TEMP = m_fat1_ext
      SELECT_EDGE m_fat1_ext TOUCHING m_fat1 { } TEMP = ext_filter
      SIZE ext_filter { VSIZE_INSIDE = 0.0002  } TEMP = ext_filter
      SIZE ext_filter INSIDE m_fat1_ext {
         OVERSIZE = cut_fatTblExtensionRange- 0.0002 
         INCREMENT = metalLayer1_minSpacing
      } TEMP=dummy TEMP = m_fat1_ext
      SIZE m_fat2 { OVERSIZE = cut_fatTblExtensionRange+ 0.0001  } TEMP = m_fat2_ran
      BOOLEAN m_fat2_ran AND metal4  {  } TEMP = m_fat2_ext
      BOOLEAN m_fat2_ext NOT m_fat2_next { } TEMP = m_fat2_ext
      BOOLEAN m_fat2_ext NOT m_fat2 { } TEMP = m_fat2_ext 
      SELECT_EDGE m_fat2_ext TOUCHING m_fat2 { } TEMP = ext_filter
      SIZE ext_filter { VSIZE_INSIDE = 0.0002  } TEMP = ext_filter
      SIZE ext_filter INSIDE m_fat2_ext {
         OVERSIZE = cut_fatTblExtensionRange- 0.0002 
         INCREMENT = metalLayer2_minSpacing
      } TEMP=dummy TEMP = m_fat2_ext
      BOOLEAN m_fat1_ext OR m_fat2_ext { } TEMP = m_fat_ext
      SELECT via3  INTERACT m_fat_ext {  } TEMP = v_fat_ext
      if (cut_ExtViaFarm_maxNum > 0 && cut_ExtViaFarm_spacing > 0 || 
          cut_ExtMinEnclosure1 >=0 || cut_ExtMinEnclosure2 >=0 ||
          cut_ExtEOLEnclosure1 > 0 || cut_ExtEOLEnclosure2 > 0) {
         SET viaFarm_maxNum    = cut_ExtViaFarm_maxNum;
         SET viaFarm_spacing   = cut_ExtViaFarm_spacing;
         SET via_minEnclosure1 = cut_ExtMinEnclosure1;
         SET via_minEnclosure2 = cut_ExtMinEnclosure2;
         SET via_EOLEnclosure1 = cut_ExtEOLEnclosure1;
         SET via_EOLEnclosure2 = cut_ExtEOLEnclosure2;
         
         
@ 1 "adrc/adrc_viaCode.ev" 1
if (viaFarm_maxNum > 0 && viaFarm_spacing > 0) {
   SIZE v_fat_ext  {  
     GROW_right = viaFarm_spacing - 0.0001 
   } TEMP = size_hor
   SELECT size_hor INTERACT v_fat_ext  {
      RANGE = [viaFarm_maxNum + 1, 9999999999 ]
   } TEMP = size_hor
   SIZE v_fat_ext  {  
      GROW_top = viaFarm_spacing - 0.0001 
   } TEMP = size_ver
   SELECT size_ver INTERACT v_fat_ext  {
      RANGE = [viaFarm_maxNum + 1, 9999999999 ]
   } TEMP = size_ver
   BOOLEAN (size_hor OR size_ver) AND v_fat_ext  {
      COMMENT = "$layer_name ViaFarmRule: max row/col number (spacing viaFarm_spacing um) = viaFarm_maxNum"
   } (16 )
   SET viaFarm_maxNum = 0;
   SET viaFarm_spacing = 0;      
}
/*check enclosure*/
if (via_minEnclosure1 > 0) {
    ENCLOSE v_fat_ext  BY metal3  {
        COMMENT = "$layer_name Enclosure : min lower layer enclosure ( via_minEnclosure1 um)"
        SPACING < via_minEnclosure1
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
	TOUCH = TRUE
    } (16 )
}
/* Check out-side of enclosure */
if (via_minEnclosure1 >= 0) {
    BOOLEAN v_fat_ext  NOT metal3  {
        COMMENT = "$layer_name Enclosure : min lower layer enclosure ( via_minEnclosure1 um)"
    } (16 )
    SET via_minEnclosure1 = -1;
}
/*check end_of_line enclosure*/
if (via_EOLEnclosure1 > 0) {
   ENCLOSE v_fat_ext  BY metal3  {
      SPACING < via_EOLEnclosure1
      SET_CORNERS_TO_SPACING = FALSE
      PARALLEL_POINT_PROJECTION = FALSE
      SHADOW_OTHER_LAYER = TRUE  
      TOUCH = TRUE
      POINT_TOUCH = FALSE
      NON_PARALLEL = TRUE
      OUTPUT_EDGES = TRUE
   } TEMP = violation
 
   SELECT_EDGE v_fat_ext  TOUCHING violation {  } TEMP = edges
   SELECT_VECTOR edges { ANGLE_RANGE = [0, 0] } TEMP = h_edges
   SELECT_VECTOR edges { ANGLE_RANGE = [90, 90] } TEMP = v_edges
   SELECT h_edges INTERACT v_edges { POINT_TOUCH = TRUE } TEMP = h_edges
 
   SELECT v_fat_ext  ENCLOSING h_edges {
      COMMENT = "$layer_name Enclosure: min lower layer EoL enclosure ( via_EOLEnclosure1 um)"
   } (16 )
   SET via_EOLEnclosure1 = 0;
}
if (via_minEnclosure2 > 0) {
    ENCLOSE v_fat_ext  BY metal4  {
        COMMENT = "$layer_name Enclosure : min upper layer enclosure ( via_minEnclosure2 um)"
        SPACING < via_minEnclosure2
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
	TOUCH = TRUE
    } (16 )
}
if (via_minEnclosure2 >= 0) {
    BOOLEAN v_fat_ext  NOT metal4  {
        COMMENT = "$layer_name Enclosure : min upper layer enclosure ( via_minEnclosure2 um)"
    } (16 )
    SET via_minEnclosure2 = 0;
}
if (via_EOLEnclosure2 > 0) {
   ENCLOSE v_fat_ext  BY metal4  {
      SPACING < via_EOLEnclosure2
      SET_CORNERS_TO_SPACING = FALSE
      PARALLEL_POINT_PROJECTION = FALSE
      SHADOW_OTHER_LAYER = TRUE  
      TOUCH = TRUE
      POINT_TOUCH = FALSE
      NON_PARALLEL = TRUE
      OUTPUT_EDGES = TRUE
   } TEMP = violation
 
   SELECT_EDGE v_fat_ext  TOUCHING violation {  } TEMP = edges
   SELECT_VECTOR edges { ANGLE_RANGE = [0, 0] } TEMP = h_edges
   SELECT_VECTOR edges { ANGLE_RANGE = [90, 90] } TEMP = v_edges
   SELECT h_edges INTERACT v_edges { POINT_TOUCH = TRUE } TEMP = h_edges
 
   SELECT v_fat_ext  ENCLOSING h_edges {
      COMMENT = "$layer_name Enclosure : min upper layer EoL enclosure ( via_EOLEnclosure2 um)"
   } (16 )
   SET via_EOLEnclosure2 = 0;
}
@ 110 "adrc/adrc_fatVia.ev" 2

         
         SET cut_ExtViaFarm_maxNum = 0;
         SET cut_ExtViaFarm_spacing = 0;
         SET cut_ExtMinEnclosure1 = 0;
         SET cut_ExtMinEnclosure2 = 0;
         SET cut_ExtEOLEnclosure1 = 0;
         SET cut_ExtEOLEnclosure2 = 0;
      }
 
      if (cut_fatTblExtensionMinSpacing > 0) {
         EXTERNAL v_fat_ext via3  {
            COMMENT = "$layer_name FatExtSpc : fat contact ( cut_fatTblThreshold_1 , cut_fatTblThreshold_2 um) extension range ( cut_fatTblExtensionRange um) minimum spacing = cut_fatTblExtensionMinSpacing um"
            SPACING < cut_fatTblExtensionMinSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
         } (16 )
      }
 
      if (cut_fatTblExtensionMinCuts > 1) {
         BOOLEAN metal3  AND metal4  { } TEMP = m_fat_ext
         BOOLEAN via_cluster AND m_fat_ext { } TEMP = via_cluster
         SELECT via_cluster INTERACT v_fat_ext { } TEMP = v_fat_ext_cluster
	 SELECT v_fat_ext_cluster INTERACT via3  {
            RANGE = [1, cut_fatTblExtensionMinCuts - 1]
	 }  TEMP = v_fat_ext_cluster
	 SELECT v_fat_ext INTERACT v_fat_ext_cluster {
            COMMENT = "$layer_name MinContNum: fat contact ( cut_fatTblThreshold_1 , cut_fatTblThreshold_2 um) extension range ( cut_fatTblExtensionRange um)  minimum number of contacts = cut_fatTblExtensionMinCuts "
	 } (16 )
      }
      SET cut_fatTblExtensionRange=0;
   }
}
@ 1216 "adrc/adrc.ev" 2




/* End of Via3 fat table spacing rules */











/*via 4*/
SET layer_name = "Via4";












SET cornerSpacingMode = 0;
SET cut_minSpacing = 0.07;
SET cut_fatContactThreshold1 = 0.16;
SET cut_fatContactThreshold2 = 0.16;
SET cut_fatTblDimension = 2;
@ 1 "adrc/adrc_check_via.ev" 1
/* check size */
if (cut_size > 0) {
    INTERNAL via4  {  
        COMMENT = "$layer_name Size      : contact size = cut_size um" 
	DIMENSION = [cut_size , cut_size]
    } (18 )
}
if (cut_minSpacing > 0) {
   if (ignoreContactCodeSpacing) {
      COPY via4  { } TEMP= default_via4 
   } else {
      SIZE metal4  { UNDER_OVER = cut_fatContactThreshold1 } TEMP = m_fat1
      SIZE metal5  { UNDER_OVER = cut_fatContactThreshold2 } TEMP = m_fat2
      BOOLEAN m_fat1 OR m_fat2 {} TEMP=m_fat
      SELECT via4  OUTSIDE m_fat { } TEMP= default_via4 
   }
}
 
/*check basic spacing*/
if (cut_sameNetMinSpacing > 0 && cut_sameNetMinSpacing < cut_minSpacing) {
  CONNECT { default_via4  BY via4  }
  if (cut_cornerMinSpacing > 0) {
    if (cornerSpacingMode == 1) {
        /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
        EXTERNAL default_via4  {
             SPACING <= 0
             CONVEX_TO_CONVEX [POINT_PROJECTION] < cut_cornerMinSpacing
             FLAG_DISCONNECTED = FALSE
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = FALSE
        } TEMP = sameNet_corner_err1
        EXTERNAL default_via4  {
             SPACING <= 0
             CONVEX_TO_CONVEX < cut_cornerMinSpacing
             FLAG_DISCONNECTED = FALSE
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = TRUE
        } TEMP = sameNet_corner_err2 
        BOOLEAN sameNet_corner_err1 OR sameNet_corner_err2 {
             COMMENT = "$layer_name SameNetSpc: corner to corner spacing = cut_cornerMinSpacing um "
        } (18 ) 
        EXTERNAL default_via4  {
             COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = cut_sameNetMinSpacing um "
             SPACING < cut_sameNetMinSpacing
             FLAG_DISCONNECTED = FALSE
             SET_CORNERS_TO_SPACING = FALSE
             PARALLEL_POINT_PROJECTION = FALSE
             NON_PARALLEL = TRUE
             TOUCH = FALSE
             POINT_TOUCH = FALSE
        } (18 )
    } else {
        EXTERNAL default_via4  {
            COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = cut_sameNetMinSpacing um (corner to corner spacing = cut_cornerMinSpacing um) "
            SPACING < cut_sameNetMinSpacing
            CONVEX_TO_CONVEX < cut_cornerMinSpacing
            FLAG_DISCONNECTED = FALSE
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
        } (18 )
    }
  } else {
    EXTERNAL default_via4  {
        COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = cut_sameNetMinSpacing um"
        SPACING < cut_sameNetMinSpacing
	BOX_CORNER = FALSE 
        FLAG_DISCONNECTED = FALSE
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
    } (18 )
  }
  if (cut_cornerMinSpacing > 0) {
    if (cornerSpacingMode == 1) {
        /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
        EXTERNAL default_via4  {
          SPACING <= 0
          CONVEX_TO_CONVEX [POINT_PROJECTION] < cut_cornerMinSpacing
          NON_PARALLEL = TRUE
          POINT_TOUCH = TRUE
          BOX_CORNER = FALSE
          NODAL = TRUE
        } TEMP = diffNet_corner_err1 
        EXTERNAL default_via4  {
          SPACING <= 0
          CONVEX_TO_CONVEX < cut_cornerMinSpacing
          NON_PARALLEL = TRUE
          POINT_TOUCH = TRUE
          BOX_CORNER = TRUE
          NODAL = TRUE
        } TEMP = diffNet_corner_err2 
        BOOLEAN diffNet_corner_err1 OR diffNet_corner_err2 {
          COMMENT = "$layer_name Spacing   : corner to corner spacing = cut_cornerMinSpacing um "
        } (18 )
        EXTERNAL default_via4  {
          COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
          SPACING < cut_minSpacing
          SET_CORNERS_TO_SPACING = FALSE
          PARALLEL_POINT_PROJECTION = FALSE
          NON_PARALLEL = TRUE
          TOUCH = FALSE
          POINT_TOUCH = FALSE
          NODAL = TRUE
        } (18 )
    } else {
        EXTERNAL default_via4  {
          COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um (corner to corner spacing = cut_cornerMinSpacing um) "
          SPACING < cut_minSpacing
          CONVEX_TO_CONVEX < cut_cornerMinSpacing
          NON_PARALLEL = TRUE
          POINT_TOUCH = TRUE
          NODAL = TRUE
        } (18 )
    }
  } else {
    EXTERNAL default_via4  {
      COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
      SPACING < cut_minSpacing
      BOX_CORNER = FALSE 
      NON_PARALLEL = TRUE
      POINT_TOUCH = TRUE
      NODAL = TRUE
    } (18 ) 
  }
} else {
   if (cut_minSpacing > 0) {
     if (cut_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
           /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
           EXTERNAL default_via4  {
             SPACING <= 0
             CONVEX_TO_CONVEX [POINT_PROJECTION] < cut_cornerMinSpacing
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = FALSE 
           } TEMP = corner_err1 
           EXTERNAL default_via4  {
             SPACING <= 0
             CONVEX_TO_CONVEX < cut_cornerMinSpacing
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = TRUE
           } TEMP = corner_err2 
           BOOLEAN corner_err1 OR corner_err2 {
             COMMENT = "$layer_name Spacing   : corner to corner spacing = cut_cornerMinSpacing um "
           } (18 )
           EXTERNAL default_via4  {
             COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
             SPACING < cut_minSpacing
             SET_CORNERS_TO_SPACING = FALSE
             PARALLEL_POINT_PROJECTION = FALSE
             NON_PARALLEL = TRUE
             TOUCH = FALSE
             POINT_TOUCH = FALSE
           } (18 )
        } else {
           EXTERNAL default_via4  {
             COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um (corner to corner spacing = cut_cornerMinSpacing um) "
             SPACING < cut_minSpacing
             CONVEX_TO_CONVEX < cut_cornerMinSpacing
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
           } (18 )
        }
    } else {
       EXTERNAL default_via4  {
          COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
          SPACING < cut_minSpacing
	  BOX_CORNER = FALSE 
	  NON_PARALLEL = TRUE
	  POINT_TOUCH = TRUE
       } (18 )
    }
  }
}
 
/*check blockage spacing*/
if (ignoreBlockage == 0) {
   if (!layer_empty (via4_blockage )) {
      if (cutBlkg_minSpacing > 0) {
	  EXTERNAL via4_blockage  via4  {
              COMMENT = "$layer_name Spacing   : contact & blockage minimum spacing = cutBlkg_minSpacing um"
	      SPACING < cutBlkg_minSpacing
	      BOX_CORNER = FALSE 
	      NON_PARALLEL = TRUE
	      POINT_TOUCH = TRUE
          } (18 )
      }
   }
}
/*check blockage overlap*/ 
/*check shorts between top_level routing and fram_blockages*/
if (cutBlkg_minSpacing > 0 || checkCrossHierShort > 0) {
   if (readCellView > 0) {
       COPY empty {} TEMP = real_blockage
       COPY via4  {} TEMP = top_cut
   } else {
       COPY via4_fram  {} TEMP = real_blockage
       COPY via4_top  {} TEMP = top_cut
   }
   if (ignoreBlockage == 0) {
      BOOLEAN via4_blockage  OR real_blockage {} TEMP=all_blockage
   } else {
      COPY real_blockage {} TEMP=all_blockage
   }
   
   BOOLEAN all_blockage AND top_cut {} TEMP = overlap_shape1
   EXTERNAL all_blockage top_cut {
      SPACING <= 0
      TOUCH = TRUE
   } TEMP = overlap_shape2
   if (checkCrossHierShort > 0) {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
          COMMENT = "$layer_name Short Cross Hierarchy"
      } (18 )
   } else {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
          COMMENT = "$layer_name Overlap   : cut & blockage overlap"
      } (18 )
   }
}
/*check adjacent via number*/
if (cut_adjacentCutRange > 0 && cut_maxNumAdjacentCut > 0) {
    if (router_ignoreSameNetAdjacentViaDRC) {
       EXTERNAL via4  {  
	   SPACING < cut_adjacentCutRange
	   SET_CORNERS_TO_SPACING = FALSE
	   PARALLEL_POINT_PROJECTION = FALSE
	   NON_PARALLEL = TRUE
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
           NODAL = TRUE
       } TEMP=edge_spacing
       EXTERNAL via4  {
	   SPACING < 0
	   CONVEX_TO_EDGE < cut_adjacentCutRange
	   CONVEX_TO_CONVEX < cut_adjacentCutRange
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
           NODAL = TRUE
       } TEMP=corner_spacing
    } else {
       EXTERNAL via4  {  
	   SPACING < cut_adjacentCutRange
	   SET_CORNERS_TO_SPACING = FALSE
	   PARALLEL_POINT_PROJECTION = FALSE
	   NON_PARALLEL = TRUE
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
       } TEMP=edge_spacing
 
       EXTERNAL via4  {
	   SPACING < 0
	   CONVEX_TO_EDGE < cut_adjacentCutRange
	   CONVEX_TO_CONVEX < cut_adjacentCutRange
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
       } TEMP=corner_spacing
    }
    SIZE edge_spacing { UNDERSIZE = 0.0002  } TEMP = edge_spacing1
    SIZE edge_spacing1 { OVERSIZE = 0.0002  } TEMP = edge_spacing2
    BOOLEAN (edge_spacing NOT edge_spacing2) OR edge_spacing1 { } TEMP=edge_spacing
 
    SIZE corner_spacing { UNDERSIZE = 0.0002  } TEMP = corner_spacing1
    SIZE corner_spacing1 { OVERSIZE = 0.0002  } TEMP = corner_spacing2
    BOOLEAN (corner_spacing NOT corner_spacing2) OR corner_spacing1 { } TEMP=corner_spacing
  
    BOOLEAN edge_spacing OR corner_spacing { } TEMP = spacing
 
    SIZE via4  { OVERSIZE = 5* 0.0002  } TEMP = cut
 
    SELECT cut INTERACT spacing {
        POINT_TOUCH = TRUE
        RANGE = [cut_maxNumAdjacentCut + 1, 9999999999 ]
    } TEMP = enclosed_cut
 
    SELECT via4  INSIDE enclosed_cut {
        COMMENT = "$layer_name AdjContNum: maximum number of the adjacent contacts ( cut_adjacentCutRange um) = cut_maxNumAdjacentCut "
    } (18 )
}
 
/*check enclosed via spacing*/
if (cut_enclosedCutNeighborRange > 0 && cut_enclosedCutNumNeighbor > 0) {
    if (cut_enclosedCutDiagViaExcluded) {
       EXTERNAL via4  {
          SPACING < cut_enclosedCutNeighborRange
          SET_CORNERS_TO_SPACING = FALSE
          PARALLEL_POINT_PROJECTION = FALSE
          NON_PARALLEL = TRUE
          BOX_CORNER = FALSE
          SHADOW = FALSE
       } TEMP = edge_spacing
       SELECT via4  TOUCHING edge_spacing {
          RANGE = [cut_enclosedCutNumNeighbor, 9999999999 ]
       } TEMP = enclosed_cut
    } else {
       /* Work around: for SIZE_RECT FLAG_INTERACTION_COUNT parser bug */
       
@ 308 "adrc/adrc_check_via.ev"
       if (cut_enclosedCutNumNeighbor==1) {
          
@-         SIZE_RECT via4  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  0  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==2) {
          
@-         SIZE_RECT via4  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  1  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==3) {
          
@-         SIZE_RECT via4  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  2  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==4) {
          
@-         SIZE_RECT via4  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  3  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==5) {
          
@-         SIZE_RECT via4  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  4  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==6) {
          
@-         SIZE_RECT via4  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  5  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==7) {
          
@-         SIZE_RECT via4  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  6  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==8) {
          
@-         SIZE_RECT via4  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  7  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==9) {
          
@-         SIZE_RECT via4  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  8  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor>9) {
          
@-         SIZE_RECT via4  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  9  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       }
    }
    if (router_ignoreSameNetAdjacentViaDRC) {
      /* Good approximation for same net via filter */
      CENTER_TO_CENTER via4  {
        NODAL=TRUE
        SPACING < cut_enclosedCutNeighborRange + 1.41421*cut_size + 0.0001 
        OUTPUT_VECTOR = TRUE
      } TEMP = c2c_spacing
      SIZE via4  { UNDERSIZE = (cut_size/2.0- 0.0001 ) } TEMP=cut_center
      BOOLEAN c2c_spacing NOT cut_center { } TEMP=c2c_spacing
      SIZE cut_center { OVERSIZE = 0.0002  } TEMP=cut_center
      BOOLEAN c2c_spacing AND via4   { } TEMP=c2c_filter
      SELECT cut_center INTERACT c2c_filter {
        POINT_TOUCH=TRUE
        RANGE = [cut_enclosedCutNumNeighbor, 9999999999 ]
      } TEMP = target_cut
   
      SELECT enclosed_cut ENCLOSING target_cut { } TEMP = enclosed_cut
    }
  
    if (cut_enclosedCutMinSpacing > 0) {
        EXTERNAL enclosed_cut {
        COMMENT = "$layer_name EncContSpc: minimum spacing between enclosed contacts ( cut_enclosedCutNeighborRange um / cut_enclosedCutNumNeighbor ) = cut_enclosedCutMinSpacing "
            SPACING < cut_enclosedCutMinSpacing
            SET_CORNERS_TO_SPACING = TRUE 
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
        } (18 )
    }
 
    if (cut_enclosedCutToNeighborMinSpacing > 0) {
       if (router_ignoreSameNetAdjacentViaDRC) {
          CONNECT { enclosed_cut BY via4  }
          EXTERNAL enclosed_cut via4  {
              COMMENT = "$layer_name EncContSpc: minimum spacing between enclosed and neighboring contacts ( cut_enclosedCutNeighborRange um / cut_enclosedCutNumNeighbor ) = cut_enclosedCutToNeighborMinSpacing "
              SPACING < cut_enclosedCutToNeighborMinSpacing
              SET_CORNERS_TO_SPACING = TRUE 
	      BOX_CORNER = FALSE 
	      NON_PARALLEL = TRUE
	      POINT_TOUCH = TRUE
              NODAL = TRUE
          } (18 )
       } else {
          EXTERNAL enclosed_cut via4  {
              COMMENT = "$layer_name EncContSpc: minimum spacing between enclosed and neighboring contacts ( cut_enclosedCutNeighborRange um / cut_enclosedCutNumNeighbor ) = cut_enclosedCutToNeighborMinSpacing "
              SPACING < cut_enclosedCutToNeighborMinSpacing
              SET_CORNERS_TO_SPACING = TRUE 
	      BOX_CORNER = FALSE 
	      NON_PARALLEL = TRUE
	      POINT_TOUCH = TRUE
          } (18 )
       }
    }
}
 
/*check max stack level, upward only*/
if (cut_maxStackLevel > 0 && cut_stackLevelSpacing > 0) {
    if (cut_maxStackLevel == 1) {
      BOOLEAN via4  AND CUT_LAYER1 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 2) {
      BOOLEAN (via4  AND CUT_LAYER1) AND CUT_LAYER2 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 3) {
      BOOLEAN (via4  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3)
        { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 4) {
      BOOLEAN ((via4  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND CUT_LAYER4 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 5) {
      BOOLEAN ((via4  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND (CUT_LAYER4 AND CUT_LAYER5) { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 6) {
      BOOLEAN ((via4  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND ((CUT_LAYER4 AND CUT_LAYER5) AND CUT_LAYER6) { } TEMP = neighbors
    }
    else if (cut_maxStackLevel >= 7) { 
      BOOLEAN ((via4  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND ((CUT_LAYER4 AND CUT_LAYER5) AND (CUT_LAYER6 AND CUT_LAYER7))
       { } TEMP = neighbors
    }
 
    if (!layer_empty(neighbors)) {
      SELECT CUT_LAYER0 INTERACT neighbors {
        LINE_TOUCH = FALSE POINT_TOUCH = FALSE 
      } TEMP = neighbors
      EXTERNAL neighbors {
	spacing <= cut_stackLevelSpacing
      } TEMP = via_arr_ext
      if (!layer_empty (via_arr_ext)) {
	SELECT neighbors OUTSIDE via_arr_ext {
         COMMENT = "$layer_name StackLevel: maximum stack level = cut_maxStackLevel "
          LINE_TOUCH = FALSE
          POINT_TOUCH = FALSE	    
        } (18 )
      }
      else {
        BOOLEAN via4  AND neighbors {
            COMMENT = "$layer_name StackLevel: maximum stack level = cut_maxStackLevel "
        } (18 )
      }
    }
  }
  else if (cut_maxStackLevel > 0) {
    if (cut_maxStackLevel == 1) {
      COPY CUT_LAYER1 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 2) {
      BOOLEAN CUT_LAYER1 AND CUT_LAYER2 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 3) {
      BOOLEAN CUT_LAYER1 AND (CUT_LAYER2 AND CUT_LAYER3)
        { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 4) {
      BOOLEAN (CUT_LAYER1 AND CUT_LAYER2) AND (CUT_LAYER3 AND CUT_LAYER4)
        { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 5) {
      BOOLEAN ((CUT_LAYER1 AND CUT_LAYER2) AND (CUT_LAYER3 AND CUT_LAYER4))
        AND CUT_LAYER5 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 6) {
      BOOLEAN ((CUT_LAYER6 AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND (CUT_LAYER4 AND CUT_LAYER5) { } TEMP = neighbors
    }
    else if (cut_maxStackLevel >= 7) { 
      BOOLEAN ((CUT_LAYER7 AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND ((CUT_LAYER4 AND CUT_LAYER5) AND CUT_LAYER6) { } TEMP = neighbors
    }
 
    if (!layer_empty (neighbors)) {
        BOOLEAN via4  AND neighbors {
            COMMENT = "$layer_name StackLevel: maximum stack level = cut_maxStackLevel "
        } (18 )
    }
}
 
/*Check fat contact*/
if (cut_fatContactMinSpacing > 0 && cut_fatTblDimension == 0) {
    if (cut_fatContactThreshold1 > 0) {
    	SIZE metal4    { UNDER_OVER = cut_fatContactThreshold1 / 2.0 - 0.0001  } TEMP = m_fat
    	BOOLEAN m_fat AND metal4  { } TEMP = m_fat
 
    	SELECT via4  INSIDE  m_fat { } TEMP = v_fat
 
    	EXTERNAL v_fat via4  {
            COMMENT = "$layer_name FatContSpc: fat contact ( cut_fatContactThreshold1 um, lower layer) minimum spacing = cut_fatContactMinSpacing um"
            SPACING < cut_fatContactMinSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
        } (18 )
    }
 
    if (cut_fatContactThreshold2 > 0) {
    	SIZE metal5    { UNDER_OVER = cut_fatContactThreshold2 / 2.0 - 0.0001  } TEMP = m_fat
    	BOOLEAN m_fat AND metal5  { } TEMP = m_fat
 
    	SELECT via4  INSIDE  m_fat { } TEMP = v_fat
 
    	EXTERNAL v_fat via4  {
            COMMENT = "$layer_name FatContSpc: fat contact ( cut_fatContactThreshold2 um, upper layer) minimum spacing = cut_fatContactMinSpacing um"
            SPACING < cut_fatContactMinSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
        } (18 )
    }
}
/* Avoid empty optimization result parsing error */
if (addEmptyViaCheck) {
   BOOLEAN empty OR empty {
      COMMENT = "$layer_name Empty: Dummy Output"
   } (18 )
   SET addEmptyViaCheck=0;
}
 
/* reset variables */















SET cut_size = 0;
SET cut_minSpacing = 0;
SET cut_sameNetMinSpacing = 0;
SET cut_cornerMinSpacing = 0;
SET cutBlkg_minSpacing = 0;
SET cut_maxNumAdjacentCut = 0;
SET cut_adjacentCutRange = 0;
SET cut_enclosedCutNeighborRange = 0;
SET cut_enclosedCutNumNeighbor = 0;
SET cut_enclosedCutMinSpacing = 0;
SET cut_enclosedCutToNeighborMinSpacing = 0;
SET cut_enclosedCutDiagViaExcluded = 0;
SET cut_maxStackLevel = 0;
SET cut_defaultContactMinSpacing = 0;
SET cut_fatContactThreshold1 = 0;
SET cut_fatContactThreshold2 = 0;
SET cut_fatContactMinSpacing = 0;
SET cut_maxCutSpacing = 0; 
SET cut_fatTblDimension = 0;
SET cut_fatTblThreshold_1 = 0;
SET cut_fatTblThreshold_2 = 0;
SET cut_fatTblNextThreshold_1 = 0;
SET cut_fatTblNextThreshold_2 = 0;
SET cut_fatTblMinCuts = 0;
SET cut_fatTblMinSpacing = 0;
SET cut_fatTblExtensionRange = 0;
SET cut_fatTblExtensionMinCuts = 0;
SET cut_fatTblExtensionMinSpacing = 0;
@ 1251 "adrc/adrc.ev" 2



/* Start of Via4 fat table spacing rules */
SET cut_maxCutSpacing = 0.1285;
SIZE via4  {
   OVER_UNDER = cut_maxCutSpacing/2.0
} TEMP = via_cluster
SET cut_fatMetalAndMode = 0;
SET cut_fatTblThreshold_1 = 0.16;
SET cut_fatTblNextThreshold_1 = 0;
SET cut_fatTblThreshold_2 = 0.16;
SET cut_fatTblNextThreshold_2 = 0;
SET cut_fatTblMinCuts = 0;
@ 1 "adrc/adrc_fatVia.ev" 1
/*Check fat contact table*/
if (cut_fatTblThreshold_1 > 0 && cut_fatTblThreshold_2 > 0) {
   SIZE metal4     { UNDER_OVER = cut_fatTblThreshold_1 / 2.0 - 0.0001  } TEMP = m_fat1
   if (cut_fatTblNextThreshold_1 > 0.0001 ) {
      SIZE m_fat1 { UNDER_OVER = cut_fatTblNextThreshold_1 / 2.0 - 0.0001  } TEMP = m_fat1_next
      BOOLEAN m_fat1 NOT m_fat1_next { } TEMP = m_fat1
   } else {
      COPY empty {} TEMP = m_fat1_next
   }
   BOOLEAN m_fat1 AND metal4  {  } TEMP = m_fat1
 
   SIZE metal5     { UNDER_OVER = cut_fatTblThreshold_2 / 2.0 - 0.0001  } TEMP = m_fat2
   if (cut_fatTblNextThreshold_2 > 0.0001 ) {
      SIZE m_fat2 { UNDER_OVER = cut_fatTblNextThreshold_2 / 2.0 - 0.0001  } TEMP = m_fat2_next
      BOOLEAN m_fat2 NOT m_fat2_next { } TEMP = m_fat2
   } else {
      COPY empty {} TEMP = m_fat2_next
   }
   BOOLEAN m_fat2 AND metal5  {  } TEMP = m_fat2
   if (cut_fatTblMinSpacing > 0 || cut_fatTblMinCuts > 1 || 
       cut_minEnclosure1 >=0 || cut_minEnclosure2 >=0 ||
       cut_EOLEnclosure1 > 0 || cut_EOLEnclosure2 > 0 ||
      (cut_ViaFarm_maxNum > 0 && cut_ViaFarm_spacing > 0)) {
      if (cut_fatMetalAndMode) {
        BOOLEAN m_fat1 AND m_fat2 { } TEMP = m_fat
        SELECT via4  INSIDE m_fat { } TEMP = v_fat
      } else {
        BOOLEAN m_fat1 OR m_fat2 { } TEMP = m_fat
        SELECT via4  INTERACT m_fat { } TEMP = v_fat
      }
   }
   if (cut_ViaFarm_maxNum > 0 && cut_ViaFarm_spacing > 0 || 
       cut_minEnclosure1 >=0 || cut_minEnclosure2 >=0 ||
       cut_EOLEnclosure1 > 0 || cut_EOLEnclosure2 > 0) {
      SET viaFarm_maxNum    = cut_ViaFarm_maxNum;
      SET viaFarm_spacing   = cut_ViaFarm_spacing;
      SET via_minEnclosure1 = cut_minEnclosure1;
      SET via_minEnclosure2 = cut_minEnclosure2;
      SET via_EOLEnclosure1 = cut_EOLEnclosure1;
      SET via_EOLEnclosure2 = cut_EOLEnclosure2;
      
      
@ 1 "adrc/adrc_viaCode.ev" 1
if (viaFarm_maxNum > 0 && viaFarm_spacing > 0) {
   SIZE v_fat  {  
     GROW_right = viaFarm_spacing - 0.0001 
   } TEMP = size_hor
   SELECT size_hor INTERACT v_fat  {
      RANGE = [viaFarm_maxNum + 1, 9999999999 ]
   } TEMP = size_hor
   SIZE v_fat  {  
      GROW_top = viaFarm_spacing - 0.0001 
   } TEMP = size_ver
   SELECT size_ver INTERACT v_fat  {
      RANGE = [viaFarm_maxNum + 1, 9999999999 ]
   } TEMP = size_ver
   BOOLEAN (size_hor OR size_ver) AND v_fat  {
      COMMENT = "$layer_name ViaFarmRule: max row/col number (spacing viaFarm_spacing um) = viaFarm_maxNum"
   } (18 )
   SET viaFarm_maxNum = 0;
   SET viaFarm_spacing = 0;      
}
/*check enclosure*/
if (via_minEnclosure1 > 0) {
    ENCLOSE v_fat  BY metal4  {
        COMMENT = "$layer_name Enclosure : min lower layer enclosure ( via_minEnclosure1 um)"
        SPACING < via_minEnclosure1
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
	TOUCH = TRUE
    } (18 )
}
/* Check out-side of enclosure */
if (via_minEnclosure1 >= 0) {
    BOOLEAN v_fat  NOT metal4  {
        COMMENT = "$layer_name Enclosure : min lower layer enclosure ( via_minEnclosure1 um)"
    } (18 )
    SET via_minEnclosure1 = -1;
}
/*check end_of_line enclosure*/
if (via_EOLEnclosure1 > 0) {
   ENCLOSE v_fat  BY metal4  {
      SPACING < via_EOLEnclosure1
      SET_CORNERS_TO_SPACING = FALSE
      PARALLEL_POINT_PROJECTION = FALSE
      SHADOW_OTHER_LAYER = TRUE  
      TOUCH = TRUE
      POINT_TOUCH = FALSE
      NON_PARALLEL = TRUE
      OUTPUT_EDGES = TRUE
   } TEMP = violation
 
   SELECT_EDGE v_fat  TOUCHING violation {  } TEMP = edges
   SELECT_VECTOR edges { ANGLE_RANGE = [0, 0] } TEMP = h_edges
   SELECT_VECTOR edges { ANGLE_RANGE = [90, 90] } TEMP = v_edges
   SELECT h_edges INTERACT v_edges { POINT_TOUCH = TRUE } TEMP = h_edges
 
   SELECT v_fat  ENCLOSING h_edges {
      COMMENT = "$layer_name Enclosure: min lower layer EoL enclosure ( via_EOLEnclosure1 um)"
   } (18 )
   SET via_EOLEnclosure1 = 0;
}
if (via_minEnclosure2 > 0) {
    ENCLOSE v_fat  BY metal5  {
        COMMENT = "$layer_name Enclosure : min upper layer enclosure ( via_minEnclosure2 um)"
        SPACING < via_minEnclosure2
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
	TOUCH = TRUE
    } (18 )
}
if (via_minEnclosure2 >= 0) {
    BOOLEAN v_fat  NOT metal5  {
        COMMENT = "$layer_name Enclosure : min upper layer enclosure ( via_minEnclosure2 um)"
    } (18 )
    SET via_minEnclosure2 = 0;
}
if (via_EOLEnclosure2 > 0) {
   ENCLOSE v_fat  BY metal5  {
      SPACING < via_EOLEnclosure2
      SET_CORNERS_TO_SPACING = FALSE
      PARALLEL_POINT_PROJECTION = FALSE
      SHADOW_OTHER_LAYER = TRUE  
      TOUCH = TRUE
      POINT_TOUCH = FALSE
      NON_PARALLEL = TRUE
      OUTPUT_EDGES = TRUE
   } TEMP = violation
 
   SELECT_EDGE v_fat  TOUCHING violation {  } TEMP = edges
   SELECT_VECTOR edges { ANGLE_RANGE = [0, 0] } TEMP = h_edges
   SELECT_VECTOR edges { ANGLE_RANGE = [90, 90] } TEMP = v_edges
   SELECT h_edges INTERACT v_edges { POINT_TOUCH = TRUE } TEMP = h_edges
 
   SELECT v_fat  ENCLOSING h_edges {
      COMMENT = "$layer_name Enclosure : min upper layer EoL enclosure ( via_EOLEnclosure2 um)"
   } (18 )
   SET via_EOLEnclosure2 = 0;
}
@ 42 "adrc/adrc_fatVia.ev" 2

      
      SET cut_ViaFarm_maxNum = 0;
      SET cut_ViaFarm_spacing = 0;
      SET cut_minEnclosure1 = 0;
      SET cut_minEnclosure2 = 0;
      SET cut_EOLEnclosure1 = 0;
      SET cut_EOLEnclosure2 = 0;
   }
 
   if (cut_fatTblMinSpacing > 0) {
      EXTERNAL v_fat via4  {
         COMMENT = "$layer_name FatContSpc: fat contact ( cut_fatTblThreshold_1 , cut_fatTblThreshold_2 um) minimum spacing = cut_fatTblMinSpacing um"
          SPACING < cut_fatTblMinSpacing
	  BOX_CORNER = FALSE 
	  NON_PARALLEL = TRUE
	  POINT_TOUCH = TRUE
      } (18 )
      SET cut_fatTblMinSpacing = 0;
   }
   if (cut_fatTblMinCuts > 1) {
      SELECT via_cluster INTERACT v_fat { } TEMP = v_fat_cluster 
      if (cut_fatMetalAndMode == 0) { 
         BOOLEAN metal4  AND metal5  { } TEMP = m_fat   
      }
      BOOLEAN v_fat_cluster AND m_fat { } TEMP = v_fat_cluster 
      SELECT v_fat_cluster INTERACT via4  {
         RANGE = [1, cut_fatTblMinCuts - 1]
      }  TEMP = v_fat_cluster
      SELECT v_fat INTERACT v_fat_cluster {
         COMMENT = "$layer_name MinContNum: fat contact ( cut_fatTblThreshold_1 , cut_fatTblThreshold_2 um) minimum number of contacts = cut_fatTblMinCuts "
      } (18 )
      SET cut_fatTblMinCuts = 0;
   }
 
   if (cut_fatTblExtensionRange > 0) {
      SIZE m_fat1 { OVERSIZE = cut_fatTblExtensionRange+ 0.0001  } TEMP = m_fat1_ran
      BOOLEAN m_fat1_ran AND metal4  {  } TEMP = m_fat1_ext
      BOOLEAN m_fat1_ext NOT m_fat1_next { } TEMP = m_fat1_ext
      BOOLEAN m_fat1_ext NOT m_fat1 { } TEMP = m_fat1_ext
      SELECT_EDGE m_fat1_ext TOUCHING m_fat1 { } TEMP = ext_filter
      SIZE ext_filter { VSIZE_INSIDE = 0.0002  } TEMP = ext_filter
      SIZE ext_filter INSIDE m_fat1_ext {
         OVERSIZE = cut_fatTblExtensionRange- 0.0002 
         INCREMENT = metalLayer1_minSpacing
      } TEMP=dummy TEMP = m_fat1_ext
      SIZE m_fat2 { OVERSIZE = cut_fatTblExtensionRange+ 0.0001  } TEMP = m_fat2_ran
      BOOLEAN m_fat2_ran AND metal5  {  } TEMP = m_fat2_ext
      BOOLEAN m_fat2_ext NOT m_fat2_next { } TEMP = m_fat2_ext
      BOOLEAN m_fat2_ext NOT m_fat2 { } TEMP = m_fat2_ext 
      SELECT_EDGE m_fat2_ext TOUCHING m_fat2 { } TEMP = ext_filter
      SIZE ext_filter { VSIZE_INSIDE = 0.0002  } TEMP = ext_filter
      SIZE ext_filter INSIDE m_fat2_ext {
         OVERSIZE = cut_fatTblExtensionRange- 0.0002 
         INCREMENT = metalLayer2_minSpacing
      } TEMP=dummy TEMP = m_fat2_ext
      BOOLEAN m_fat1_ext OR m_fat2_ext { } TEMP = m_fat_ext
      SELECT via4  INTERACT m_fat_ext {  } TEMP = v_fat_ext
      if (cut_ExtViaFarm_maxNum > 0 && cut_ExtViaFarm_spacing > 0 || 
          cut_ExtMinEnclosure1 >=0 || cut_ExtMinEnclosure2 >=0 ||
          cut_ExtEOLEnclosure1 > 0 || cut_ExtEOLEnclosure2 > 0) {
         SET viaFarm_maxNum    = cut_ExtViaFarm_maxNum;
         SET viaFarm_spacing   = cut_ExtViaFarm_spacing;
         SET via_minEnclosure1 = cut_ExtMinEnclosure1;
         SET via_minEnclosure2 = cut_ExtMinEnclosure2;
         SET via_EOLEnclosure1 = cut_ExtEOLEnclosure1;
         SET via_EOLEnclosure2 = cut_ExtEOLEnclosure2;
         
         
@ 1 "adrc/adrc_viaCode.ev" 1
if (viaFarm_maxNum > 0 && viaFarm_spacing > 0) {
   SIZE v_fat_ext  {  
     GROW_right = viaFarm_spacing - 0.0001 
   } TEMP = size_hor
   SELECT size_hor INTERACT v_fat_ext  {
      RANGE = [viaFarm_maxNum + 1, 9999999999 ]
   } TEMP = size_hor
   SIZE v_fat_ext  {  
      GROW_top = viaFarm_spacing - 0.0001 
   } TEMP = size_ver
   SELECT size_ver INTERACT v_fat_ext  {
      RANGE = [viaFarm_maxNum + 1, 9999999999 ]
   } TEMP = size_ver
   BOOLEAN (size_hor OR size_ver) AND v_fat_ext  {
      COMMENT = "$layer_name ViaFarmRule: max row/col number (spacing viaFarm_spacing um) = viaFarm_maxNum"
   } (18 )
   SET viaFarm_maxNum = 0;
   SET viaFarm_spacing = 0;      
}
/*check enclosure*/
if (via_minEnclosure1 > 0) {
    ENCLOSE v_fat_ext  BY metal4  {
        COMMENT = "$layer_name Enclosure : min lower layer enclosure ( via_minEnclosure1 um)"
        SPACING < via_minEnclosure1
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
	TOUCH = TRUE
    } (18 )
}
/* Check out-side of enclosure */
if (via_minEnclosure1 >= 0) {
    BOOLEAN v_fat_ext  NOT metal4  {
        COMMENT = "$layer_name Enclosure : min lower layer enclosure ( via_minEnclosure1 um)"
    } (18 )
    SET via_minEnclosure1 = -1;
}
/*check end_of_line enclosure*/
if (via_EOLEnclosure1 > 0) {
   ENCLOSE v_fat_ext  BY metal4  {
      SPACING < via_EOLEnclosure1
      SET_CORNERS_TO_SPACING = FALSE
      PARALLEL_POINT_PROJECTION = FALSE
      SHADOW_OTHER_LAYER = TRUE  
      TOUCH = TRUE
      POINT_TOUCH = FALSE
      NON_PARALLEL = TRUE
      OUTPUT_EDGES = TRUE
   } TEMP = violation
 
   SELECT_EDGE v_fat_ext  TOUCHING violation {  } TEMP = edges
   SELECT_VECTOR edges { ANGLE_RANGE = [0, 0] } TEMP = h_edges
   SELECT_VECTOR edges { ANGLE_RANGE = [90, 90] } TEMP = v_edges
   SELECT h_edges INTERACT v_edges { POINT_TOUCH = TRUE } TEMP = h_edges
 
   SELECT v_fat_ext  ENCLOSING h_edges {
      COMMENT = "$layer_name Enclosure: min lower layer EoL enclosure ( via_EOLEnclosure1 um)"
   } (18 )
   SET via_EOLEnclosure1 = 0;
}
if (via_minEnclosure2 > 0) {
    ENCLOSE v_fat_ext  BY metal5  {
        COMMENT = "$layer_name Enclosure : min upper layer enclosure ( via_minEnclosure2 um)"
        SPACING < via_minEnclosure2
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
	TOUCH = TRUE
    } (18 )
}
if (via_minEnclosure2 >= 0) {
    BOOLEAN v_fat_ext  NOT metal5  {
        COMMENT = "$layer_name Enclosure : min upper layer enclosure ( via_minEnclosure2 um)"
    } (18 )
    SET via_minEnclosure2 = 0;
}
if (via_EOLEnclosure2 > 0) {
   ENCLOSE v_fat_ext  BY metal5  {
      SPACING < via_EOLEnclosure2
      SET_CORNERS_TO_SPACING = FALSE
      PARALLEL_POINT_PROJECTION = FALSE
      SHADOW_OTHER_LAYER = TRUE  
      TOUCH = TRUE
      POINT_TOUCH = FALSE
      NON_PARALLEL = TRUE
      OUTPUT_EDGES = TRUE
   } TEMP = violation
 
   SELECT_EDGE v_fat_ext  TOUCHING violation {  } TEMP = edges
   SELECT_VECTOR edges { ANGLE_RANGE = [0, 0] } TEMP = h_edges
   SELECT_VECTOR edges { ANGLE_RANGE = [90, 90] } TEMP = v_edges
   SELECT h_edges INTERACT v_edges { POINT_TOUCH = TRUE } TEMP = h_edges
 
   SELECT v_fat_ext  ENCLOSING h_edges {
      COMMENT = "$layer_name Enclosure : min upper layer EoL enclosure ( via_EOLEnclosure2 um)"
   } (18 )
   SET via_EOLEnclosure2 = 0;
}
@ 110 "adrc/adrc_fatVia.ev" 2

         
         SET cut_ExtViaFarm_maxNum = 0;
         SET cut_ExtViaFarm_spacing = 0;
         SET cut_ExtMinEnclosure1 = 0;
         SET cut_ExtMinEnclosure2 = 0;
         SET cut_ExtEOLEnclosure1 = 0;
         SET cut_ExtEOLEnclosure2 = 0;
      }
 
      if (cut_fatTblExtensionMinSpacing > 0) {
         EXTERNAL v_fat_ext via4  {
            COMMENT = "$layer_name FatExtSpc : fat contact ( cut_fatTblThreshold_1 , cut_fatTblThreshold_2 um) extension range ( cut_fatTblExtensionRange um) minimum spacing = cut_fatTblExtensionMinSpacing um"
            SPACING < cut_fatTblExtensionMinSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
         } (18 )
      }
 
      if (cut_fatTblExtensionMinCuts > 1) {
         BOOLEAN metal4  AND metal5  { } TEMP = m_fat_ext
         BOOLEAN via_cluster AND m_fat_ext { } TEMP = via_cluster
         SELECT via_cluster INTERACT v_fat_ext { } TEMP = v_fat_ext_cluster
	 SELECT v_fat_ext_cluster INTERACT via4  {
            RANGE = [1, cut_fatTblExtensionMinCuts - 1]
	 }  TEMP = v_fat_ext_cluster
	 SELECT v_fat_ext INTERACT v_fat_ext_cluster {
            COMMENT = "$layer_name MinContNum: fat contact ( cut_fatTblThreshold_1 , cut_fatTblThreshold_2 um) extension range ( cut_fatTblExtensionRange um)  minimum number of contacts = cut_fatTblExtensionMinCuts "
	 } (18 )
      }
      SET cut_fatTblExtensionRange=0;
   }
}
@ 1265 "adrc/adrc.ev" 2




/* End of Via4 fat table spacing rules */











/*via 5*/
SET layer_name = "Via5";












SET cornerSpacingMode = 0;
SET cut_minSpacing = 0.07;
SET cut_fatContactThreshold1 = 0.16;
SET cut_fatContactThreshold2 = 0.16;
SET cut_fatTblDimension = 2;
@ 1 "adrc/adrc_check_via.ev" 1
/* check size */
if (cut_size > 0) {
    INTERNAL via5  {  
        COMMENT = "$layer_name Size      : contact size = cut_size um" 
	DIMENSION = [cut_size , cut_size]
    } (20 )
}
if (cut_minSpacing > 0) {
   if (ignoreContactCodeSpacing) {
      COPY via5  { } TEMP= default_via5 
   } else {
      SIZE metal5  { UNDER_OVER = cut_fatContactThreshold1 } TEMP = m_fat1
      SIZE metal6  { UNDER_OVER = cut_fatContactThreshold2 } TEMP = m_fat2
      BOOLEAN m_fat1 OR m_fat2 {} TEMP=m_fat
      SELECT via5  OUTSIDE m_fat { } TEMP= default_via5 
   }
}
 
/*check basic spacing*/
if (cut_sameNetMinSpacing > 0 && cut_sameNetMinSpacing < cut_minSpacing) {
  CONNECT { default_via5  BY via5  }
  if (cut_cornerMinSpacing > 0) {
    if (cornerSpacingMode == 1) {
        /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
        EXTERNAL default_via5  {
             SPACING <= 0
             CONVEX_TO_CONVEX [POINT_PROJECTION] < cut_cornerMinSpacing
             FLAG_DISCONNECTED = FALSE
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = FALSE
        } TEMP = sameNet_corner_err1
        EXTERNAL default_via5  {
             SPACING <= 0
             CONVEX_TO_CONVEX < cut_cornerMinSpacing
             FLAG_DISCONNECTED = FALSE
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = TRUE
        } TEMP = sameNet_corner_err2 
        BOOLEAN sameNet_corner_err1 OR sameNet_corner_err2 {
             COMMENT = "$layer_name SameNetSpc: corner to corner spacing = cut_cornerMinSpacing um "
        } (20 ) 
        EXTERNAL default_via5  {
             COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = cut_sameNetMinSpacing um "
             SPACING < cut_sameNetMinSpacing
             FLAG_DISCONNECTED = FALSE
             SET_CORNERS_TO_SPACING = FALSE
             PARALLEL_POINT_PROJECTION = FALSE
             NON_PARALLEL = TRUE
             TOUCH = FALSE
             POINT_TOUCH = FALSE
        } (20 )
    } else {
        EXTERNAL default_via5  {
            COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = cut_sameNetMinSpacing um (corner to corner spacing = cut_cornerMinSpacing um) "
            SPACING < cut_sameNetMinSpacing
            CONVEX_TO_CONVEX < cut_cornerMinSpacing
            FLAG_DISCONNECTED = FALSE
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
        } (20 )
    }
  } else {
    EXTERNAL default_via5  {
        COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = cut_sameNetMinSpacing um"
        SPACING < cut_sameNetMinSpacing
	BOX_CORNER = FALSE 
        FLAG_DISCONNECTED = FALSE
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
    } (20 )
  }
  if (cut_cornerMinSpacing > 0) {
    if (cornerSpacingMode == 1) {
        /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
        EXTERNAL default_via5  {
          SPACING <= 0
          CONVEX_TO_CONVEX [POINT_PROJECTION] < cut_cornerMinSpacing
          NON_PARALLEL = TRUE
          POINT_TOUCH = TRUE
          BOX_CORNER = FALSE
          NODAL = TRUE
        } TEMP = diffNet_corner_err1 
        EXTERNAL default_via5  {
          SPACING <= 0
          CONVEX_TO_CONVEX < cut_cornerMinSpacing
          NON_PARALLEL = TRUE
          POINT_TOUCH = TRUE
          BOX_CORNER = TRUE
          NODAL = TRUE
        } TEMP = diffNet_corner_err2 
        BOOLEAN diffNet_corner_err1 OR diffNet_corner_err2 {
          COMMENT = "$layer_name Spacing   : corner to corner spacing = cut_cornerMinSpacing um "
        } (20 )
        EXTERNAL default_via5  {
          COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
          SPACING < cut_minSpacing
          SET_CORNERS_TO_SPACING = FALSE
          PARALLEL_POINT_PROJECTION = FALSE
          NON_PARALLEL = TRUE
          TOUCH = FALSE
          POINT_TOUCH = FALSE
          NODAL = TRUE
        } (20 )
    } else {
        EXTERNAL default_via5  {
          COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um (corner to corner spacing = cut_cornerMinSpacing um) "
          SPACING < cut_minSpacing
          CONVEX_TO_CONVEX < cut_cornerMinSpacing
          NON_PARALLEL = TRUE
          POINT_TOUCH = TRUE
          NODAL = TRUE
        } (20 )
    }
  } else {
    EXTERNAL default_via5  {
      COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
      SPACING < cut_minSpacing
      BOX_CORNER = FALSE 
      NON_PARALLEL = TRUE
      POINT_TOUCH = TRUE
      NODAL = TRUE
    } (20 ) 
  }
} else {
   if (cut_minSpacing > 0) {
     if (cut_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
           /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
           EXTERNAL default_via5  {
             SPACING <= 0
             CONVEX_TO_CONVEX [POINT_PROJECTION] < cut_cornerMinSpacing
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = FALSE 
           } TEMP = corner_err1 
           EXTERNAL default_via5  {
             SPACING <= 0
             CONVEX_TO_CONVEX < cut_cornerMinSpacing
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = TRUE
           } TEMP = corner_err2 
           BOOLEAN corner_err1 OR corner_err2 {
             COMMENT = "$layer_name Spacing   : corner to corner spacing = cut_cornerMinSpacing um "
           } (20 )
           EXTERNAL default_via5  {
             COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
             SPACING < cut_minSpacing
             SET_CORNERS_TO_SPACING = FALSE
             PARALLEL_POINT_PROJECTION = FALSE
             NON_PARALLEL = TRUE
             TOUCH = FALSE
             POINT_TOUCH = FALSE
           } (20 )
        } else {
           EXTERNAL default_via5  {
             COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um (corner to corner spacing = cut_cornerMinSpacing um) "
             SPACING < cut_minSpacing
             CONVEX_TO_CONVEX < cut_cornerMinSpacing
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
           } (20 )
        }
    } else {
       EXTERNAL default_via5  {
          COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
          SPACING < cut_minSpacing
	  BOX_CORNER = FALSE 
	  NON_PARALLEL = TRUE
	  POINT_TOUCH = TRUE
       } (20 )
    }
  }
}
 
/*check blockage spacing*/
if (ignoreBlockage == 0) {
   if (!layer_empty (via5_blockage )) {
      if (cutBlkg_minSpacing > 0) {
	  EXTERNAL via5_blockage  via5  {
              COMMENT = "$layer_name Spacing   : contact & blockage minimum spacing = cutBlkg_minSpacing um"
	      SPACING < cutBlkg_minSpacing
	      BOX_CORNER = FALSE 
	      NON_PARALLEL = TRUE
	      POINT_TOUCH = TRUE
          } (20 )
      }
   }
}
/*check blockage overlap*/ 
/*check shorts between top_level routing and fram_blockages*/
if (cutBlkg_minSpacing > 0 || checkCrossHierShort > 0) {
   if (readCellView > 0) {
       COPY empty {} TEMP = real_blockage
       COPY via5  {} TEMP = top_cut
   } else {
       COPY via5_fram  {} TEMP = real_blockage
       COPY via5_top  {} TEMP = top_cut
   }
   if (ignoreBlockage == 0) {
      BOOLEAN via5_blockage  OR real_blockage {} TEMP=all_blockage
   } else {
      COPY real_blockage {} TEMP=all_blockage
   }
   
   BOOLEAN all_blockage AND top_cut {} TEMP = overlap_shape1
   EXTERNAL all_blockage top_cut {
      SPACING <= 0
      TOUCH = TRUE
   } TEMP = overlap_shape2
   if (checkCrossHierShort > 0) {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
          COMMENT = "$layer_name Short Cross Hierarchy"
      } (20 )
   } else {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
          COMMENT = "$layer_name Overlap   : cut & blockage overlap"
      } (20 )
   }
}
/*check adjacent via number*/
if (cut_adjacentCutRange > 0 && cut_maxNumAdjacentCut > 0) {
    if (router_ignoreSameNetAdjacentViaDRC) {
       EXTERNAL via5  {  
	   SPACING < cut_adjacentCutRange
	   SET_CORNERS_TO_SPACING = FALSE
	   PARALLEL_POINT_PROJECTION = FALSE
	   NON_PARALLEL = TRUE
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
           NODAL = TRUE
       } TEMP=edge_spacing
       EXTERNAL via5  {
	   SPACING < 0
	   CONVEX_TO_EDGE < cut_adjacentCutRange
	   CONVEX_TO_CONVEX < cut_adjacentCutRange
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
           NODAL = TRUE
       } TEMP=corner_spacing
    } else {
       EXTERNAL via5  {  
	   SPACING < cut_adjacentCutRange
	   SET_CORNERS_TO_SPACING = FALSE
	   PARALLEL_POINT_PROJECTION = FALSE
	   NON_PARALLEL = TRUE
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
       } TEMP=edge_spacing
 
       EXTERNAL via5  {
	   SPACING < 0
	   CONVEX_TO_EDGE < cut_adjacentCutRange
	   CONVEX_TO_CONVEX < cut_adjacentCutRange
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
       } TEMP=corner_spacing
    }
    SIZE edge_spacing { UNDERSIZE = 0.0002  } TEMP = edge_spacing1
    SIZE edge_spacing1 { OVERSIZE = 0.0002  } TEMP = edge_spacing2
    BOOLEAN (edge_spacing NOT edge_spacing2) OR edge_spacing1 { } TEMP=edge_spacing
 
    SIZE corner_spacing { UNDERSIZE = 0.0002  } TEMP = corner_spacing1
    SIZE corner_spacing1 { OVERSIZE = 0.0002  } TEMP = corner_spacing2
    BOOLEAN (corner_spacing NOT corner_spacing2) OR corner_spacing1 { } TEMP=corner_spacing
  
    BOOLEAN edge_spacing OR corner_spacing { } TEMP = spacing
 
    SIZE via5  { OVERSIZE = 5* 0.0002  } TEMP = cut
 
    SELECT cut INTERACT spacing {
        POINT_TOUCH = TRUE
        RANGE = [cut_maxNumAdjacentCut + 1, 9999999999 ]
    } TEMP = enclosed_cut
 
    SELECT via5  INSIDE enclosed_cut {
        COMMENT = "$layer_name AdjContNum: maximum number of the adjacent contacts ( cut_adjacentCutRange um) = cut_maxNumAdjacentCut "
    } (20 )
}
 
/*check enclosed via spacing*/
if (cut_enclosedCutNeighborRange > 0 && cut_enclosedCutNumNeighbor > 0) {
    if (cut_enclosedCutDiagViaExcluded) {
       EXTERNAL via5  {
          SPACING < cut_enclosedCutNeighborRange
          SET_CORNERS_TO_SPACING = FALSE
          PARALLEL_POINT_PROJECTION = FALSE
          NON_PARALLEL = TRUE
          BOX_CORNER = FALSE
          SHADOW = FALSE
       } TEMP = edge_spacing
       SELECT via5  TOUCHING edge_spacing {
          RANGE = [cut_enclosedCutNumNeighbor, 9999999999 ]
       } TEMP = enclosed_cut
    } else {
       /* Work around: for SIZE_RECT FLAG_INTERACTION_COUNT parser bug */
       
@ 308 "adrc/adrc_check_via.ev"
       if (cut_enclosedCutNumNeighbor==1) {
          
@-         SIZE_RECT via5  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  0  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==2) {
          
@-         SIZE_RECT via5  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  1  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==3) {
          
@-         SIZE_RECT via5  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  2  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==4) {
          
@-         SIZE_RECT via5  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  3  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==5) {
          
@-         SIZE_RECT via5  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  4  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==6) {
          
@-         SIZE_RECT via5  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  5  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==7) {
          
@-         SIZE_RECT via5  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  6  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==8) {
          
@-         SIZE_RECT via5  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  7  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==9) {
          
@-         SIZE_RECT via5  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  8  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor>9) {
          
@-         SIZE_RECT via5  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  9  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       }
    }
    if (router_ignoreSameNetAdjacentViaDRC) {
      /* Good approximation for same net via filter */
      CENTER_TO_CENTER via5  {
        NODAL=TRUE
        SPACING < cut_enclosedCutNeighborRange + 1.41421*cut_size + 0.0001 
        OUTPUT_VECTOR = TRUE
      } TEMP = c2c_spacing
      SIZE via5  { UNDERSIZE = (cut_size/2.0- 0.0001 ) } TEMP=cut_center
      BOOLEAN c2c_spacing NOT cut_center { } TEMP=c2c_spacing
      SIZE cut_center { OVERSIZE = 0.0002  } TEMP=cut_center
      BOOLEAN c2c_spacing AND via5   { } TEMP=c2c_filter
      SELECT cut_center INTERACT c2c_filter {
        POINT_TOUCH=TRUE
        RANGE = [cut_enclosedCutNumNeighbor, 9999999999 ]
      } TEMP = target_cut
   
      SELECT enclosed_cut ENCLOSING target_cut { } TEMP = enclosed_cut
    }
  
    if (cut_enclosedCutMinSpacing > 0) {
        EXTERNAL enclosed_cut {
        COMMENT = "$layer_name EncContSpc: minimum spacing between enclosed contacts ( cut_enclosedCutNeighborRange um / cut_enclosedCutNumNeighbor ) = cut_enclosedCutMinSpacing "
            SPACING < cut_enclosedCutMinSpacing
            SET_CORNERS_TO_SPACING = TRUE 
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
        } (20 )
    }
 
    if (cut_enclosedCutToNeighborMinSpacing > 0) {
       if (router_ignoreSameNetAdjacentViaDRC) {
          CONNECT { enclosed_cut BY via5  }
          EXTERNAL enclosed_cut via5  {
              COMMENT = "$layer_name EncContSpc: minimum spacing between enclosed and neighboring contacts ( cut_enclosedCutNeighborRange um / cut_enclosedCutNumNeighbor ) = cut_enclosedCutToNeighborMinSpacing "
              SPACING < cut_enclosedCutToNeighborMinSpacing
              SET_CORNERS_TO_SPACING = TRUE 
	      BOX_CORNER = FALSE 
	      NON_PARALLEL = TRUE
	      POINT_TOUCH = TRUE
              NODAL = TRUE
          } (20 )
       } else {
          EXTERNAL enclosed_cut via5  {
              COMMENT = "$layer_name EncContSpc: minimum spacing between enclosed and neighboring contacts ( cut_enclosedCutNeighborRange um / cut_enclosedCutNumNeighbor ) = cut_enclosedCutToNeighborMinSpacing "
              SPACING < cut_enclosedCutToNeighborMinSpacing
              SET_CORNERS_TO_SPACING = TRUE 
	      BOX_CORNER = FALSE 
	      NON_PARALLEL = TRUE
	      POINT_TOUCH = TRUE
          } (20 )
       }
    }
}
 
/*check max stack level, upward only*/
if (cut_maxStackLevel > 0 && cut_stackLevelSpacing > 0) {
    if (cut_maxStackLevel == 1) {
      BOOLEAN via5  AND CUT_LAYER1 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 2) {
      BOOLEAN (via5  AND CUT_LAYER1) AND CUT_LAYER2 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 3) {
      BOOLEAN (via5  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3)
        { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 4) {
      BOOLEAN ((via5  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND CUT_LAYER4 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 5) {
      BOOLEAN ((via5  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND (CUT_LAYER4 AND CUT_LAYER5) { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 6) {
      BOOLEAN ((via5  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND ((CUT_LAYER4 AND CUT_LAYER5) AND CUT_LAYER6) { } TEMP = neighbors
    }
    else if (cut_maxStackLevel >= 7) { 
      BOOLEAN ((via5  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND ((CUT_LAYER4 AND CUT_LAYER5) AND (CUT_LAYER6 AND CUT_LAYER7))
       { } TEMP = neighbors
    }
 
    if (!layer_empty(neighbors)) {
      SELECT CUT_LAYER0 INTERACT neighbors {
        LINE_TOUCH = FALSE POINT_TOUCH = FALSE 
      } TEMP = neighbors
      EXTERNAL neighbors {
	spacing <= cut_stackLevelSpacing
      } TEMP = via_arr_ext
      if (!layer_empty (via_arr_ext)) {
	SELECT neighbors OUTSIDE via_arr_ext {
         COMMENT = "$layer_name StackLevel: maximum stack level = cut_maxStackLevel "
          LINE_TOUCH = FALSE
          POINT_TOUCH = FALSE	    
        } (20 )
      }
      else {
        BOOLEAN via5  AND neighbors {
            COMMENT = "$layer_name StackLevel: maximum stack level = cut_maxStackLevel "
        } (20 )
      }
    }
  }
  else if (cut_maxStackLevel > 0) {
    if (cut_maxStackLevel == 1) {
      COPY CUT_LAYER1 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 2) {
      BOOLEAN CUT_LAYER1 AND CUT_LAYER2 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 3) {
      BOOLEAN CUT_LAYER1 AND (CUT_LAYER2 AND CUT_LAYER3)
        { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 4) {
      BOOLEAN (CUT_LAYER1 AND CUT_LAYER2) AND (CUT_LAYER3 AND CUT_LAYER4)
        { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 5) {
      BOOLEAN ((CUT_LAYER1 AND CUT_LAYER2) AND (CUT_LAYER3 AND CUT_LAYER4))
        AND CUT_LAYER5 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 6) {
      BOOLEAN ((CUT_LAYER6 AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND (CUT_LAYER4 AND CUT_LAYER5) { } TEMP = neighbors
    }
    else if (cut_maxStackLevel >= 7) { 
      BOOLEAN ((CUT_LAYER7 AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND ((CUT_LAYER4 AND CUT_LAYER5) AND CUT_LAYER6) { } TEMP = neighbors
    }
 
    if (!layer_empty (neighbors)) {
        BOOLEAN via5  AND neighbors {
            COMMENT = "$layer_name StackLevel: maximum stack level = cut_maxStackLevel "
        } (20 )
    }
}
 
/*Check fat contact*/
if (cut_fatContactMinSpacing > 0 && cut_fatTblDimension == 0) {
    if (cut_fatContactThreshold1 > 0) {
    	SIZE metal5    { UNDER_OVER = cut_fatContactThreshold1 / 2.0 - 0.0001  } TEMP = m_fat
    	BOOLEAN m_fat AND metal5  { } TEMP = m_fat
 
    	SELECT via5  INSIDE  m_fat { } TEMP = v_fat
 
    	EXTERNAL v_fat via5  {
            COMMENT = "$layer_name FatContSpc: fat contact ( cut_fatContactThreshold1 um, lower layer) minimum spacing = cut_fatContactMinSpacing um"
            SPACING < cut_fatContactMinSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
        } (20 )
    }
 
    if (cut_fatContactThreshold2 > 0) {
    	SIZE metal6    { UNDER_OVER = cut_fatContactThreshold2 / 2.0 - 0.0001  } TEMP = m_fat
    	BOOLEAN m_fat AND metal6  { } TEMP = m_fat
 
    	SELECT via5  INSIDE  m_fat { } TEMP = v_fat
 
    	EXTERNAL v_fat via5  {
            COMMENT = "$layer_name FatContSpc: fat contact ( cut_fatContactThreshold2 um, upper layer) minimum spacing = cut_fatContactMinSpacing um"
            SPACING < cut_fatContactMinSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
        } (20 )
    }
}
/* Avoid empty optimization result parsing error */
if (addEmptyViaCheck) {
   BOOLEAN empty OR empty {
      COMMENT = "$layer_name Empty: Dummy Output"
   } (20 )
   SET addEmptyViaCheck=0;
}
 
/* reset variables */















SET cut_size = 0;
SET cut_minSpacing = 0;
SET cut_sameNetMinSpacing = 0;
SET cut_cornerMinSpacing = 0;
SET cutBlkg_minSpacing = 0;
SET cut_maxNumAdjacentCut = 0;
SET cut_adjacentCutRange = 0;
SET cut_enclosedCutNeighborRange = 0;
SET cut_enclosedCutNumNeighbor = 0;
SET cut_enclosedCutMinSpacing = 0;
SET cut_enclosedCutToNeighborMinSpacing = 0;
SET cut_enclosedCutDiagViaExcluded = 0;
SET cut_maxStackLevel = 0;
SET cut_defaultContactMinSpacing = 0;
SET cut_fatContactThreshold1 = 0;
SET cut_fatContactThreshold2 = 0;
SET cut_fatContactMinSpacing = 0;
SET cut_maxCutSpacing = 0; 
SET cut_fatTblDimension = 0;
SET cut_fatTblThreshold_1 = 0;
SET cut_fatTblThreshold_2 = 0;
SET cut_fatTblNextThreshold_1 = 0;
SET cut_fatTblNextThreshold_2 = 0;
SET cut_fatTblMinCuts = 0;
SET cut_fatTblMinSpacing = 0;
SET cut_fatTblExtensionRange = 0;
SET cut_fatTblExtensionMinCuts = 0;
SET cut_fatTblExtensionMinSpacing = 0;
@ 1300 "adrc/adrc.ev" 2



/* Start of Via5 fat table spacing rules */
SET cut_maxCutSpacing = 0.1285;
SIZE via5  {
   OVER_UNDER = cut_maxCutSpacing/2.0
} TEMP = via_cluster
SET cut_fatMetalAndMode = 0;
SET cut_fatTblThreshold_1 = 0.16;
SET cut_fatTblNextThreshold_1 = 0;
SET cut_fatTblThreshold_2 = 0.16;
SET cut_fatTblNextThreshold_2 = 0;
SET cut_fatTblMinCuts = 0;
@ 1 "adrc/adrc_fatVia.ev" 1
/*Check fat contact table*/
if (cut_fatTblThreshold_1 > 0 && cut_fatTblThreshold_2 > 0) {
   SIZE metal5     { UNDER_OVER = cut_fatTblThreshold_1 / 2.0 - 0.0001  } TEMP = m_fat1
   if (cut_fatTblNextThreshold_1 > 0.0001 ) {
      SIZE m_fat1 { UNDER_OVER = cut_fatTblNextThreshold_1 / 2.0 - 0.0001  } TEMP = m_fat1_next
      BOOLEAN m_fat1 NOT m_fat1_next { } TEMP = m_fat1
   } else {
      COPY empty {} TEMP = m_fat1_next
   }
   BOOLEAN m_fat1 AND metal5  {  } TEMP = m_fat1
 
   SIZE metal6     { UNDER_OVER = cut_fatTblThreshold_2 / 2.0 - 0.0001  } TEMP = m_fat2
   if (cut_fatTblNextThreshold_2 > 0.0001 ) {
      SIZE m_fat2 { UNDER_OVER = cut_fatTblNextThreshold_2 / 2.0 - 0.0001  } TEMP = m_fat2_next
      BOOLEAN m_fat2 NOT m_fat2_next { } TEMP = m_fat2
   } else {
      COPY empty {} TEMP = m_fat2_next
   }
   BOOLEAN m_fat2 AND metal6  {  } TEMP = m_fat2
   if (cut_fatTblMinSpacing > 0 || cut_fatTblMinCuts > 1 || 
       cut_minEnclosure1 >=0 || cut_minEnclosure2 >=0 ||
       cut_EOLEnclosure1 > 0 || cut_EOLEnclosure2 > 0 ||
      (cut_ViaFarm_maxNum > 0 && cut_ViaFarm_spacing > 0)) {
      if (cut_fatMetalAndMode) {
        BOOLEAN m_fat1 AND m_fat2 { } TEMP = m_fat
        SELECT via5  INSIDE m_fat { } TEMP = v_fat
      } else {
        BOOLEAN m_fat1 OR m_fat2 { } TEMP = m_fat
        SELECT via5  INTERACT m_fat { } TEMP = v_fat
      }
   }
   if (cut_ViaFarm_maxNum > 0 && cut_ViaFarm_spacing > 0 || 
       cut_minEnclosure1 >=0 || cut_minEnclosure2 >=0 ||
       cut_EOLEnclosure1 > 0 || cut_EOLEnclosure2 > 0) {
      SET viaFarm_maxNum    = cut_ViaFarm_maxNum;
      SET viaFarm_spacing   = cut_ViaFarm_spacing;
      SET via_minEnclosure1 = cut_minEnclosure1;
      SET via_minEnclosure2 = cut_minEnclosure2;
      SET via_EOLEnclosure1 = cut_EOLEnclosure1;
      SET via_EOLEnclosure2 = cut_EOLEnclosure2;
      
      
@ 1 "adrc/adrc_viaCode.ev" 1
if (viaFarm_maxNum > 0 && viaFarm_spacing > 0) {
   SIZE v_fat  {  
     GROW_right = viaFarm_spacing - 0.0001 
   } TEMP = size_hor
   SELECT size_hor INTERACT v_fat  {
      RANGE = [viaFarm_maxNum + 1, 9999999999 ]
   } TEMP = size_hor
   SIZE v_fat  {  
      GROW_top = viaFarm_spacing - 0.0001 
   } TEMP = size_ver
   SELECT size_ver INTERACT v_fat  {
      RANGE = [viaFarm_maxNum + 1, 9999999999 ]
   } TEMP = size_ver
   BOOLEAN (size_hor OR size_ver) AND v_fat  {
      COMMENT = "$layer_name ViaFarmRule: max row/col number (spacing viaFarm_spacing um) = viaFarm_maxNum"
   } (20 )
   SET viaFarm_maxNum = 0;
   SET viaFarm_spacing = 0;      
}
/*check enclosure*/
if (via_minEnclosure1 > 0) {
    ENCLOSE v_fat  BY metal5  {
        COMMENT = "$layer_name Enclosure : min lower layer enclosure ( via_minEnclosure1 um)"
        SPACING < via_minEnclosure1
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
	TOUCH = TRUE
    } (20 )
}
/* Check out-side of enclosure */
if (via_minEnclosure1 >= 0) {
    BOOLEAN v_fat  NOT metal5  {
        COMMENT = "$layer_name Enclosure : min lower layer enclosure ( via_minEnclosure1 um)"
    } (20 )
    SET via_minEnclosure1 = -1;
}
/*check end_of_line enclosure*/
if (via_EOLEnclosure1 > 0) {
   ENCLOSE v_fat  BY metal5  {
      SPACING < via_EOLEnclosure1
      SET_CORNERS_TO_SPACING = FALSE
      PARALLEL_POINT_PROJECTION = FALSE
      SHADOW_OTHER_LAYER = TRUE  
      TOUCH = TRUE
      POINT_TOUCH = FALSE
      NON_PARALLEL = TRUE
      OUTPUT_EDGES = TRUE
   } TEMP = violation
 
   SELECT_EDGE v_fat  TOUCHING violation {  } TEMP = edges
   SELECT_VECTOR edges { ANGLE_RANGE = [0, 0] } TEMP = h_edges
   SELECT_VECTOR edges { ANGLE_RANGE = [90, 90] } TEMP = v_edges
   SELECT h_edges INTERACT v_edges { POINT_TOUCH = TRUE } TEMP = h_edges
 
   SELECT v_fat  ENCLOSING h_edges {
      COMMENT = "$layer_name Enclosure: min lower layer EoL enclosure ( via_EOLEnclosure1 um)"
   } (20 )
   SET via_EOLEnclosure1 = 0;
}
if (via_minEnclosure2 > 0) {
    ENCLOSE v_fat  BY metal6  {
        COMMENT = "$layer_name Enclosure : min upper layer enclosure ( via_minEnclosure2 um)"
        SPACING < via_minEnclosure2
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
	TOUCH = TRUE
    } (20 )
}
if (via_minEnclosure2 >= 0) {
    BOOLEAN v_fat  NOT metal6  {
        COMMENT = "$layer_name Enclosure : min upper layer enclosure ( via_minEnclosure2 um)"
    } (20 )
    SET via_minEnclosure2 = 0;
}
if (via_EOLEnclosure2 > 0) {
   ENCLOSE v_fat  BY metal6  {
      SPACING < via_EOLEnclosure2
      SET_CORNERS_TO_SPACING = FALSE
      PARALLEL_POINT_PROJECTION = FALSE
      SHADOW_OTHER_LAYER = TRUE  
      TOUCH = TRUE
      POINT_TOUCH = FALSE
      NON_PARALLEL = TRUE
      OUTPUT_EDGES = TRUE
   } TEMP = violation
 
   SELECT_EDGE v_fat  TOUCHING violation {  } TEMP = edges
   SELECT_VECTOR edges { ANGLE_RANGE = [0, 0] } TEMP = h_edges
   SELECT_VECTOR edges { ANGLE_RANGE = [90, 90] } TEMP = v_edges
   SELECT h_edges INTERACT v_edges { POINT_TOUCH = TRUE } TEMP = h_edges
 
   SELECT v_fat  ENCLOSING h_edges {
      COMMENT = "$layer_name Enclosure : min upper layer EoL enclosure ( via_EOLEnclosure2 um)"
   } (20 )
   SET via_EOLEnclosure2 = 0;
}
@ 42 "adrc/adrc_fatVia.ev" 2

      
      SET cut_ViaFarm_maxNum = 0;
      SET cut_ViaFarm_spacing = 0;
      SET cut_minEnclosure1 = 0;
      SET cut_minEnclosure2 = 0;
      SET cut_EOLEnclosure1 = 0;
      SET cut_EOLEnclosure2 = 0;
   }
 
   if (cut_fatTblMinSpacing > 0) {
      EXTERNAL v_fat via5  {
         COMMENT = "$layer_name FatContSpc: fat contact ( cut_fatTblThreshold_1 , cut_fatTblThreshold_2 um) minimum spacing = cut_fatTblMinSpacing um"
          SPACING < cut_fatTblMinSpacing
	  BOX_CORNER = FALSE 
	  NON_PARALLEL = TRUE
	  POINT_TOUCH = TRUE
      } (20 )
      SET cut_fatTblMinSpacing = 0;
   }
   if (cut_fatTblMinCuts > 1) {
      SELECT via_cluster INTERACT v_fat { } TEMP = v_fat_cluster 
      if (cut_fatMetalAndMode == 0) { 
         BOOLEAN metal5  AND metal6  { } TEMP = m_fat   
      }
      BOOLEAN v_fat_cluster AND m_fat { } TEMP = v_fat_cluster 
      SELECT v_fat_cluster INTERACT via5  {
         RANGE = [1, cut_fatTblMinCuts - 1]
      }  TEMP = v_fat_cluster
      SELECT v_fat INTERACT v_fat_cluster {
         COMMENT = "$layer_name MinContNum: fat contact ( cut_fatTblThreshold_1 , cut_fatTblThreshold_2 um) minimum number of contacts = cut_fatTblMinCuts "
      } (20 )
      SET cut_fatTblMinCuts = 0;
   }
 
   if (cut_fatTblExtensionRange > 0) {
      SIZE m_fat1 { OVERSIZE = cut_fatTblExtensionRange+ 0.0001  } TEMP = m_fat1_ran
      BOOLEAN m_fat1_ran AND metal5  {  } TEMP = m_fat1_ext
      BOOLEAN m_fat1_ext NOT m_fat1_next { } TEMP = m_fat1_ext
      BOOLEAN m_fat1_ext NOT m_fat1 { } TEMP = m_fat1_ext
      SELECT_EDGE m_fat1_ext TOUCHING m_fat1 { } TEMP = ext_filter
      SIZE ext_filter { VSIZE_INSIDE = 0.0002  } TEMP = ext_filter
      SIZE ext_filter INSIDE m_fat1_ext {
         OVERSIZE = cut_fatTblExtensionRange- 0.0002 
         INCREMENT = metalLayer1_minSpacing
      } TEMP=dummy TEMP = m_fat1_ext
      SIZE m_fat2 { OVERSIZE = cut_fatTblExtensionRange+ 0.0001  } TEMP = m_fat2_ran
      BOOLEAN m_fat2_ran AND metal6  {  } TEMP = m_fat2_ext
      BOOLEAN m_fat2_ext NOT m_fat2_next { } TEMP = m_fat2_ext
      BOOLEAN m_fat2_ext NOT m_fat2 { } TEMP = m_fat2_ext 
      SELECT_EDGE m_fat2_ext TOUCHING m_fat2 { } TEMP = ext_filter
      SIZE ext_filter { VSIZE_INSIDE = 0.0002  } TEMP = ext_filter
      SIZE ext_filter INSIDE m_fat2_ext {
         OVERSIZE = cut_fatTblExtensionRange- 0.0002 
         INCREMENT = metalLayer2_minSpacing
      } TEMP=dummy TEMP = m_fat2_ext
      BOOLEAN m_fat1_ext OR m_fat2_ext { } TEMP = m_fat_ext
      SELECT via5  INTERACT m_fat_ext {  } TEMP = v_fat_ext
      if (cut_ExtViaFarm_maxNum > 0 && cut_ExtViaFarm_spacing > 0 || 
          cut_ExtMinEnclosure1 >=0 || cut_ExtMinEnclosure2 >=0 ||
          cut_ExtEOLEnclosure1 > 0 || cut_ExtEOLEnclosure2 > 0) {
         SET viaFarm_maxNum    = cut_ExtViaFarm_maxNum;
         SET viaFarm_spacing   = cut_ExtViaFarm_spacing;
         SET via_minEnclosure1 = cut_ExtMinEnclosure1;
         SET via_minEnclosure2 = cut_ExtMinEnclosure2;
         SET via_EOLEnclosure1 = cut_ExtEOLEnclosure1;
         SET via_EOLEnclosure2 = cut_ExtEOLEnclosure2;
         
         
@ 1 "adrc/adrc_viaCode.ev" 1
if (viaFarm_maxNum > 0 && viaFarm_spacing > 0) {
   SIZE v_fat_ext  {  
     GROW_right = viaFarm_spacing - 0.0001 
   } TEMP = size_hor
   SELECT size_hor INTERACT v_fat_ext  {
      RANGE = [viaFarm_maxNum + 1, 9999999999 ]
   } TEMP = size_hor
   SIZE v_fat_ext  {  
      GROW_top = viaFarm_spacing - 0.0001 
   } TEMP = size_ver
   SELECT size_ver INTERACT v_fat_ext  {
      RANGE = [viaFarm_maxNum + 1, 9999999999 ]
   } TEMP = size_ver
   BOOLEAN (size_hor OR size_ver) AND v_fat_ext  {
      COMMENT = "$layer_name ViaFarmRule: max row/col number (spacing viaFarm_spacing um) = viaFarm_maxNum"
   } (20 )
   SET viaFarm_maxNum = 0;
   SET viaFarm_spacing = 0;      
}
/*check enclosure*/
if (via_minEnclosure1 > 0) {
    ENCLOSE v_fat_ext  BY metal5  {
        COMMENT = "$layer_name Enclosure : min lower layer enclosure ( via_minEnclosure1 um)"
        SPACING < via_minEnclosure1
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
	TOUCH = TRUE
    } (20 )
}
/* Check out-side of enclosure */
if (via_minEnclosure1 >= 0) {
    BOOLEAN v_fat_ext  NOT metal5  {
        COMMENT = "$layer_name Enclosure : min lower layer enclosure ( via_minEnclosure1 um)"
    } (20 )
    SET via_minEnclosure1 = -1;
}
/*check end_of_line enclosure*/
if (via_EOLEnclosure1 > 0) {
   ENCLOSE v_fat_ext  BY metal5  {
      SPACING < via_EOLEnclosure1
      SET_CORNERS_TO_SPACING = FALSE
      PARALLEL_POINT_PROJECTION = FALSE
      SHADOW_OTHER_LAYER = TRUE  
      TOUCH = TRUE
      POINT_TOUCH = FALSE
      NON_PARALLEL = TRUE
      OUTPUT_EDGES = TRUE
   } TEMP = violation
 
   SELECT_EDGE v_fat_ext  TOUCHING violation {  } TEMP = edges
   SELECT_VECTOR edges { ANGLE_RANGE = [0, 0] } TEMP = h_edges
   SELECT_VECTOR edges { ANGLE_RANGE = [90, 90] } TEMP = v_edges
   SELECT h_edges INTERACT v_edges { POINT_TOUCH = TRUE } TEMP = h_edges
 
   SELECT v_fat_ext  ENCLOSING h_edges {
      COMMENT = "$layer_name Enclosure: min lower layer EoL enclosure ( via_EOLEnclosure1 um)"
   } (20 )
   SET via_EOLEnclosure1 = 0;
}
if (via_minEnclosure2 > 0) {
    ENCLOSE v_fat_ext  BY metal6  {
        COMMENT = "$layer_name Enclosure : min upper layer enclosure ( via_minEnclosure2 um)"
        SPACING < via_minEnclosure2
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
	TOUCH = TRUE
    } (20 )
}
if (via_minEnclosure2 >= 0) {
    BOOLEAN v_fat_ext  NOT metal6  {
        COMMENT = "$layer_name Enclosure : min upper layer enclosure ( via_minEnclosure2 um)"
    } (20 )
    SET via_minEnclosure2 = 0;
}
if (via_EOLEnclosure2 > 0) {
   ENCLOSE v_fat_ext  BY metal6  {
      SPACING < via_EOLEnclosure2
      SET_CORNERS_TO_SPACING = FALSE
      PARALLEL_POINT_PROJECTION = FALSE
      SHADOW_OTHER_LAYER = TRUE  
      TOUCH = TRUE
      POINT_TOUCH = FALSE
      NON_PARALLEL = TRUE
      OUTPUT_EDGES = TRUE
   } TEMP = violation
 
   SELECT_EDGE v_fat_ext  TOUCHING violation {  } TEMP = edges
   SELECT_VECTOR edges { ANGLE_RANGE = [0, 0] } TEMP = h_edges
   SELECT_VECTOR edges { ANGLE_RANGE = [90, 90] } TEMP = v_edges
   SELECT h_edges INTERACT v_edges { POINT_TOUCH = TRUE } TEMP = h_edges
 
   SELECT v_fat_ext  ENCLOSING h_edges {
      COMMENT = "$layer_name Enclosure : min upper layer EoL enclosure ( via_EOLEnclosure2 um)"
   } (20 )
   SET via_EOLEnclosure2 = 0;
}
@ 110 "adrc/adrc_fatVia.ev" 2

         
         SET cut_ExtViaFarm_maxNum = 0;
         SET cut_ExtViaFarm_spacing = 0;
         SET cut_ExtMinEnclosure1 = 0;
         SET cut_ExtMinEnclosure2 = 0;
         SET cut_ExtEOLEnclosure1 = 0;
         SET cut_ExtEOLEnclosure2 = 0;
      }
 
      if (cut_fatTblExtensionMinSpacing > 0) {
         EXTERNAL v_fat_ext via5  {
            COMMENT = "$layer_name FatExtSpc : fat contact ( cut_fatTblThreshold_1 , cut_fatTblThreshold_2 um) extension range ( cut_fatTblExtensionRange um) minimum spacing = cut_fatTblExtensionMinSpacing um"
            SPACING < cut_fatTblExtensionMinSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
         } (20 )
      }
 
      if (cut_fatTblExtensionMinCuts > 1) {
         BOOLEAN metal5  AND metal6  { } TEMP = m_fat_ext
         BOOLEAN via_cluster AND m_fat_ext { } TEMP = via_cluster
         SELECT via_cluster INTERACT v_fat_ext { } TEMP = v_fat_ext_cluster
	 SELECT v_fat_ext_cluster INTERACT via5  {
            RANGE = [1, cut_fatTblExtensionMinCuts - 1]
	 }  TEMP = v_fat_ext_cluster
	 SELECT v_fat_ext INTERACT v_fat_ext_cluster {
            COMMENT = "$layer_name MinContNum: fat contact ( cut_fatTblThreshold_1 , cut_fatTblThreshold_2 um) extension range ( cut_fatTblExtensionRange um)  minimum number of contacts = cut_fatTblExtensionMinCuts "
	 } (20 )
      }
      SET cut_fatTblExtensionRange=0;
   }
}
@ 1314 "adrc/adrc.ev" 2




/* End of Via5 fat table spacing rules */











/*via 6*/
SET layer_name = "Via6";












SET cornerSpacingMode = 0;
SET cut_minSpacing = 0.07;
SET cut_fatContactThreshold1 = 0.16;
SET cut_fatContactThreshold2 = 0.16;
SET cut_fatTblDimension = 2;
@ 1 "adrc/adrc_check_via.ev" 1
/* check size */
if (cut_size > 0) {
    INTERNAL via6  {  
        COMMENT = "$layer_name Size      : contact size = cut_size um" 
	DIMENSION = [cut_size , cut_size]
    } (22 )
}
if (cut_minSpacing > 0) {
   if (ignoreContactCodeSpacing) {
      COPY via6  { } TEMP= default_via6 
   } else {
      SIZE metal6  { UNDER_OVER = cut_fatContactThreshold1 } TEMP = m_fat1
      SIZE metal7  { UNDER_OVER = cut_fatContactThreshold2 } TEMP = m_fat2
      BOOLEAN m_fat1 OR m_fat2 {} TEMP=m_fat
      SELECT via6  OUTSIDE m_fat { } TEMP= default_via6 
   }
}
 
/*check basic spacing*/
if (cut_sameNetMinSpacing > 0 && cut_sameNetMinSpacing < cut_minSpacing) {
  CONNECT { default_via6  BY via6  }
  if (cut_cornerMinSpacing > 0) {
    if (cornerSpacingMode == 1) {
        /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
        EXTERNAL default_via6  {
             SPACING <= 0
             CONVEX_TO_CONVEX [POINT_PROJECTION] < cut_cornerMinSpacing
             FLAG_DISCONNECTED = FALSE
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = FALSE
        } TEMP = sameNet_corner_err1
        EXTERNAL default_via6  {
             SPACING <= 0
             CONVEX_TO_CONVEX < cut_cornerMinSpacing
             FLAG_DISCONNECTED = FALSE
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = TRUE
        } TEMP = sameNet_corner_err2 
        BOOLEAN sameNet_corner_err1 OR sameNet_corner_err2 {
             COMMENT = "$layer_name SameNetSpc: corner to corner spacing = cut_cornerMinSpacing um "
        } (22 ) 
        EXTERNAL default_via6  {
             COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = cut_sameNetMinSpacing um "
             SPACING < cut_sameNetMinSpacing
             FLAG_DISCONNECTED = FALSE
             SET_CORNERS_TO_SPACING = FALSE
             PARALLEL_POINT_PROJECTION = FALSE
             NON_PARALLEL = TRUE
             TOUCH = FALSE
             POINT_TOUCH = FALSE
        } (22 )
    } else {
        EXTERNAL default_via6  {
            COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = cut_sameNetMinSpacing um (corner to corner spacing = cut_cornerMinSpacing um) "
            SPACING < cut_sameNetMinSpacing
            CONVEX_TO_CONVEX < cut_cornerMinSpacing
            FLAG_DISCONNECTED = FALSE
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
        } (22 )
    }
  } else {
    EXTERNAL default_via6  {
        COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = cut_sameNetMinSpacing um"
        SPACING < cut_sameNetMinSpacing
	BOX_CORNER = FALSE 
        FLAG_DISCONNECTED = FALSE
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
    } (22 )
  }
  if (cut_cornerMinSpacing > 0) {
    if (cornerSpacingMode == 1) {
        /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
        EXTERNAL default_via6  {
          SPACING <= 0
          CONVEX_TO_CONVEX [POINT_PROJECTION] < cut_cornerMinSpacing
          NON_PARALLEL = TRUE
          POINT_TOUCH = TRUE
          BOX_CORNER = FALSE
          NODAL = TRUE
        } TEMP = diffNet_corner_err1 
        EXTERNAL default_via6  {
          SPACING <= 0
          CONVEX_TO_CONVEX < cut_cornerMinSpacing
          NON_PARALLEL = TRUE
          POINT_TOUCH = TRUE
          BOX_CORNER = TRUE
          NODAL = TRUE
        } TEMP = diffNet_corner_err2 
        BOOLEAN diffNet_corner_err1 OR diffNet_corner_err2 {
          COMMENT = "$layer_name Spacing   : corner to corner spacing = cut_cornerMinSpacing um "
        } (22 )
        EXTERNAL default_via6  {
          COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
          SPACING < cut_minSpacing
          SET_CORNERS_TO_SPACING = FALSE
          PARALLEL_POINT_PROJECTION = FALSE
          NON_PARALLEL = TRUE
          TOUCH = FALSE
          POINT_TOUCH = FALSE
          NODAL = TRUE
        } (22 )
    } else {
        EXTERNAL default_via6  {
          COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um (corner to corner spacing = cut_cornerMinSpacing um) "
          SPACING < cut_minSpacing
          CONVEX_TO_CONVEX < cut_cornerMinSpacing
          NON_PARALLEL = TRUE
          POINT_TOUCH = TRUE
          NODAL = TRUE
        } (22 )
    }
  } else {
    EXTERNAL default_via6  {
      COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
      SPACING < cut_minSpacing
      BOX_CORNER = FALSE 
      NON_PARALLEL = TRUE
      POINT_TOUCH = TRUE
      NODAL = TRUE
    } (22 ) 
  }
} else {
   if (cut_minSpacing > 0) {
     if (cut_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
           /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
           EXTERNAL default_via6  {
             SPACING <= 0
             CONVEX_TO_CONVEX [POINT_PROJECTION] < cut_cornerMinSpacing
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = FALSE 
           } TEMP = corner_err1 
           EXTERNAL default_via6  {
             SPACING <= 0
             CONVEX_TO_CONVEX < cut_cornerMinSpacing
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = TRUE
           } TEMP = corner_err2 
           BOOLEAN corner_err1 OR corner_err2 {
             COMMENT = "$layer_name Spacing   : corner to corner spacing = cut_cornerMinSpacing um "
           } (22 )
           EXTERNAL default_via6  {
             COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
             SPACING < cut_minSpacing
             SET_CORNERS_TO_SPACING = FALSE
             PARALLEL_POINT_PROJECTION = FALSE
             NON_PARALLEL = TRUE
             TOUCH = FALSE
             POINT_TOUCH = FALSE
           } (22 )
        } else {
           EXTERNAL default_via6  {
             COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um (corner to corner spacing = cut_cornerMinSpacing um) "
             SPACING < cut_minSpacing
             CONVEX_TO_CONVEX < cut_cornerMinSpacing
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
           } (22 )
        }
    } else {
       EXTERNAL default_via6  {
          COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
          SPACING < cut_minSpacing
	  BOX_CORNER = FALSE 
	  NON_PARALLEL = TRUE
	  POINT_TOUCH = TRUE
       } (22 )
    }
  }
}
 
/*check blockage spacing*/
if (ignoreBlockage == 0) {
   if (!layer_empty (via6_blockage )) {
      if (cutBlkg_minSpacing > 0) {
	  EXTERNAL via6_blockage  via6  {
              COMMENT = "$layer_name Spacing   : contact & blockage minimum spacing = cutBlkg_minSpacing um"
	      SPACING < cutBlkg_minSpacing
	      BOX_CORNER = FALSE 
	      NON_PARALLEL = TRUE
	      POINT_TOUCH = TRUE
          } (22 )
      }
   }
}
/*check blockage overlap*/ 
/*check shorts between top_level routing and fram_blockages*/
if (cutBlkg_minSpacing > 0 || checkCrossHierShort > 0) {
   if (readCellView > 0) {
       COPY empty {} TEMP = real_blockage
       COPY via6  {} TEMP = top_cut
   } else {
       COPY via6_fram  {} TEMP = real_blockage
       COPY via6_top  {} TEMP = top_cut
   }
   if (ignoreBlockage == 0) {
      BOOLEAN via6_blockage  OR real_blockage {} TEMP=all_blockage
   } else {
      COPY real_blockage {} TEMP=all_blockage
   }
   
   BOOLEAN all_blockage AND top_cut {} TEMP = overlap_shape1
   EXTERNAL all_blockage top_cut {
      SPACING <= 0
      TOUCH = TRUE
   } TEMP = overlap_shape2
   if (checkCrossHierShort > 0) {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
          COMMENT = "$layer_name Short Cross Hierarchy"
      } (22 )
   } else {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
          COMMENT = "$layer_name Overlap   : cut & blockage overlap"
      } (22 )
   }
}
/*check adjacent via number*/
if (cut_adjacentCutRange > 0 && cut_maxNumAdjacentCut > 0) {
    if (router_ignoreSameNetAdjacentViaDRC) {
       EXTERNAL via6  {  
	   SPACING < cut_adjacentCutRange
	   SET_CORNERS_TO_SPACING = FALSE
	   PARALLEL_POINT_PROJECTION = FALSE
	   NON_PARALLEL = TRUE
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
           NODAL = TRUE
       } TEMP=edge_spacing
       EXTERNAL via6  {
	   SPACING < 0
	   CONVEX_TO_EDGE < cut_adjacentCutRange
	   CONVEX_TO_CONVEX < cut_adjacentCutRange
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
           NODAL = TRUE
       } TEMP=corner_spacing
    } else {
       EXTERNAL via6  {  
	   SPACING < cut_adjacentCutRange
	   SET_CORNERS_TO_SPACING = FALSE
	   PARALLEL_POINT_PROJECTION = FALSE
	   NON_PARALLEL = TRUE
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
       } TEMP=edge_spacing
 
       EXTERNAL via6  {
	   SPACING < 0
	   CONVEX_TO_EDGE < cut_adjacentCutRange
	   CONVEX_TO_CONVEX < cut_adjacentCutRange
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
       } TEMP=corner_spacing
    }
    SIZE edge_spacing { UNDERSIZE = 0.0002  } TEMP = edge_spacing1
    SIZE edge_spacing1 { OVERSIZE = 0.0002  } TEMP = edge_spacing2
    BOOLEAN (edge_spacing NOT edge_spacing2) OR edge_spacing1 { } TEMP=edge_spacing
 
    SIZE corner_spacing { UNDERSIZE = 0.0002  } TEMP = corner_spacing1
    SIZE corner_spacing1 { OVERSIZE = 0.0002  } TEMP = corner_spacing2
    BOOLEAN (corner_spacing NOT corner_spacing2) OR corner_spacing1 { } TEMP=corner_spacing
  
    BOOLEAN edge_spacing OR corner_spacing { } TEMP = spacing
 
    SIZE via6  { OVERSIZE = 5* 0.0002  } TEMP = cut
 
    SELECT cut INTERACT spacing {
        POINT_TOUCH = TRUE
        RANGE = [cut_maxNumAdjacentCut + 1, 9999999999 ]
    } TEMP = enclosed_cut
 
    SELECT via6  INSIDE enclosed_cut {
        COMMENT = "$layer_name AdjContNum: maximum number of the adjacent contacts ( cut_adjacentCutRange um) = cut_maxNumAdjacentCut "
    } (22 )
}
 
/*check enclosed via spacing*/
if (cut_enclosedCutNeighborRange > 0 && cut_enclosedCutNumNeighbor > 0) {
    if (cut_enclosedCutDiagViaExcluded) {
       EXTERNAL via6  {
          SPACING < cut_enclosedCutNeighborRange
          SET_CORNERS_TO_SPACING = FALSE
          PARALLEL_POINT_PROJECTION = FALSE
          NON_PARALLEL = TRUE
          BOX_CORNER = FALSE
          SHADOW = FALSE
       } TEMP = edge_spacing
       SELECT via6  TOUCHING edge_spacing {
          RANGE = [cut_enclosedCutNumNeighbor, 9999999999 ]
       } TEMP = enclosed_cut
    } else {
       /* Work around: for SIZE_RECT FLAG_INTERACTION_COUNT parser bug */
       
@ 308 "adrc/adrc_check_via.ev"
       if (cut_enclosedCutNumNeighbor==1) {
          
@-         SIZE_RECT via6  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  0  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==2) {
          
@-         SIZE_RECT via6  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  1  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==3) {
          
@-         SIZE_RECT via6  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  2  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==4) {
          
@-         SIZE_RECT via6  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  3  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==5) {
          
@-         SIZE_RECT via6  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  4  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==6) {
          
@-         SIZE_RECT via6  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  5  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==7) {
          
@-         SIZE_RECT via6  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  6  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==8) {
          
@-         SIZE_RECT via6  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  7  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==9) {
          
@-         SIZE_RECT via6  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  8  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor>9) {
          
@-         SIZE_RECT via6  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  9  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       }
    }
    if (router_ignoreSameNetAdjacentViaDRC) {
      /* Good approximation for same net via filter */
      CENTER_TO_CENTER via6  {
        NODAL=TRUE
        SPACING < cut_enclosedCutNeighborRange + 1.41421*cut_size + 0.0001 
        OUTPUT_VECTOR = TRUE
      } TEMP = c2c_spacing
      SIZE via6  { UNDERSIZE = (cut_size/2.0- 0.0001 ) } TEMP=cut_center
      BOOLEAN c2c_spacing NOT cut_center { } TEMP=c2c_spacing
      SIZE cut_center { OVERSIZE = 0.0002  } TEMP=cut_center
      BOOLEAN c2c_spacing AND via6   { } TEMP=c2c_filter
      SELECT cut_center INTERACT c2c_filter {
        POINT_TOUCH=TRUE
        RANGE = [cut_enclosedCutNumNeighbor, 9999999999 ]
      } TEMP = target_cut
   
      SELECT enclosed_cut ENCLOSING target_cut { } TEMP = enclosed_cut
    }
  
    if (cut_enclosedCutMinSpacing > 0) {
        EXTERNAL enclosed_cut {
        COMMENT = "$layer_name EncContSpc: minimum spacing between enclosed contacts ( cut_enclosedCutNeighborRange um / cut_enclosedCutNumNeighbor ) = cut_enclosedCutMinSpacing "
            SPACING < cut_enclosedCutMinSpacing
            SET_CORNERS_TO_SPACING = TRUE 
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
        } (22 )
    }
 
    if (cut_enclosedCutToNeighborMinSpacing > 0) {
       if (router_ignoreSameNetAdjacentViaDRC) {
          CONNECT { enclosed_cut BY via6  }
          EXTERNAL enclosed_cut via6  {
              COMMENT = "$layer_name EncContSpc: minimum spacing between enclosed and neighboring contacts ( cut_enclosedCutNeighborRange um / cut_enclosedCutNumNeighbor ) = cut_enclosedCutToNeighborMinSpacing "
              SPACING < cut_enclosedCutToNeighborMinSpacing
              SET_CORNERS_TO_SPACING = TRUE 
	      BOX_CORNER = FALSE 
	      NON_PARALLEL = TRUE
	      POINT_TOUCH = TRUE
              NODAL = TRUE
          } (22 )
       } else {
          EXTERNAL enclosed_cut via6  {
              COMMENT = "$layer_name EncContSpc: minimum spacing between enclosed and neighboring contacts ( cut_enclosedCutNeighborRange um / cut_enclosedCutNumNeighbor ) = cut_enclosedCutToNeighborMinSpacing "
              SPACING < cut_enclosedCutToNeighborMinSpacing
              SET_CORNERS_TO_SPACING = TRUE 
	      BOX_CORNER = FALSE 
	      NON_PARALLEL = TRUE
	      POINT_TOUCH = TRUE
          } (22 )
       }
    }
}
 
/*check max stack level, upward only*/
if (cut_maxStackLevel > 0 && cut_stackLevelSpacing > 0) {
    if (cut_maxStackLevel == 1) {
      BOOLEAN via6  AND CUT_LAYER1 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 2) {
      BOOLEAN (via6  AND CUT_LAYER1) AND CUT_LAYER2 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 3) {
      BOOLEAN (via6  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3)
        { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 4) {
      BOOLEAN ((via6  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND CUT_LAYER4 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 5) {
      BOOLEAN ((via6  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND (CUT_LAYER4 AND CUT_LAYER5) { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 6) {
      BOOLEAN ((via6  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND ((CUT_LAYER4 AND CUT_LAYER5) AND CUT_LAYER6) { } TEMP = neighbors
    }
    else if (cut_maxStackLevel >= 7) { 
      BOOLEAN ((via6  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND ((CUT_LAYER4 AND CUT_LAYER5) AND (CUT_LAYER6 AND CUT_LAYER7))
       { } TEMP = neighbors
    }
 
    if (!layer_empty(neighbors)) {
      SELECT CUT_LAYER0 INTERACT neighbors {
        LINE_TOUCH = FALSE POINT_TOUCH = FALSE 
      } TEMP = neighbors
      EXTERNAL neighbors {
	spacing <= cut_stackLevelSpacing
      } TEMP = via_arr_ext
      if (!layer_empty (via_arr_ext)) {
	SELECT neighbors OUTSIDE via_arr_ext {
         COMMENT = "$layer_name StackLevel: maximum stack level = cut_maxStackLevel "
          LINE_TOUCH = FALSE
          POINT_TOUCH = FALSE	    
        } (22 )
      }
      else {
        BOOLEAN via6  AND neighbors {
            COMMENT = "$layer_name StackLevel: maximum stack level = cut_maxStackLevel "
        } (22 )
      }
    }
  }
  else if (cut_maxStackLevel > 0) {
    if (cut_maxStackLevel == 1) {
      COPY CUT_LAYER1 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 2) {
      BOOLEAN CUT_LAYER1 AND CUT_LAYER2 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 3) {
      BOOLEAN CUT_LAYER1 AND (CUT_LAYER2 AND CUT_LAYER3)
        { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 4) {
      BOOLEAN (CUT_LAYER1 AND CUT_LAYER2) AND (CUT_LAYER3 AND CUT_LAYER4)
        { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 5) {
      BOOLEAN ((CUT_LAYER1 AND CUT_LAYER2) AND (CUT_LAYER3 AND CUT_LAYER4))
        AND CUT_LAYER5 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 6) {
      BOOLEAN ((CUT_LAYER6 AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND (CUT_LAYER4 AND CUT_LAYER5) { } TEMP = neighbors
    }
    else if (cut_maxStackLevel >= 7) { 
      BOOLEAN ((CUT_LAYER7 AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND ((CUT_LAYER4 AND CUT_LAYER5) AND CUT_LAYER6) { } TEMP = neighbors
    }
 
    if (!layer_empty (neighbors)) {
        BOOLEAN via6  AND neighbors {
            COMMENT = "$layer_name StackLevel: maximum stack level = cut_maxStackLevel "
        } (22 )
    }
}
 
/*Check fat contact*/
if (cut_fatContactMinSpacing > 0 && cut_fatTblDimension == 0) {
    if (cut_fatContactThreshold1 > 0) {
    	SIZE metal6    { UNDER_OVER = cut_fatContactThreshold1 / 2.0 - 0.0001  } TEMP = m_fat
    	BOOLEAN m_fat AND metal6  { } TEMP = m_fat
 
    	SELECT via6  INSIDE  m_fat { } TEMP = v_fat
 
    	EXTERNAL v_fat via6  {
            COMMENT = "$layer_name FatContSpc: fat contact ( cut_fatContactThreshold1 um, lower layer) minimum spacing = cut_fatContactMinSpacing um"
            SPACING < cut_fatContactMinSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
        } (22 )
    }
 
    if (cut_fatContactThreshold2 > 0) {
    	SIZE metal7    { UNDER_OVER = cut_fatContactThreshold2 / 2.0 - 0.0001  } TEMP = m_fat
    	BOOLEAN m_fat AND metal7  { } TEMP = m_fat
 
    	SELECT via6  INSIDE  m_fat { } TEMP = v_fat
 
    	EXTERNAL v_fat via6  {
            COMMENT = "$layer_name FatContSpc: fat contact ( cut_fatContactThreshold2 um, upper layer) minimum spacing = cut_fatContactMinSpacing um"
            SPACING < cut_fatContactMinSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
        } (22 )
    }
}
/* Avoid empty optimization result parsing error */
if (addEmptyViaCheck) {
   BOOLEAN empty OR empty {
      COMMENT = "$layer_name Empty: Dummy Output"
   } (22 )
   SET addEmptyViaCheck=0;
}
 
/* reset variables */















SET cut_size = 0;
SET cut_minSpacing = 0;
SET cut_sameNetMinSpacing = 0;
SET cut_cornerMinSpacing = 0;
SET cutBlkg_minSpacing = 0;
SET cut_maxNumAdjacentCut = 0;
SET cut_adjacentCutRange = 0;
SET cut_enclosedCutNeighborRange = 0;
SET cut_enclosedCutNumNeighbor = 0;
SET cut_enclosedCutMinSpacing = 0;
SET cut_enclosedCutToNeighborMinSpacing = 0;
SET cut_enclosedCutDiagViaExcluded = 0;
SET cut_maxStackLevel = 0;
SET cut_defaultContactMinSpacing = 0;
SET cut_fatContactThreshold1 = 0;
SET cut_fatContactThreshold2 = 0;
SET cut_fatContactMinSpacing = 0;
SET cut_maxCutSpacing = 0; 
SET cut_fatTblDimension = 0;
SET cut_fatTblThreshold_1 = 0;
SET cut_fatTblThreshold_2 = 0;
SET cut_fatTblNextThreshold_1 = 0;
SET cut_fatTblNextThreshold_2 = 0;
SET cut_fatTblMinCuts = 0;
SET cut_fatTblMinSpacing = 0;
SET cut_fatTblExtensionRange = 0;
SET cut_fatTblExtensionMinCuts = 0;
SET cut_fatTblExtensionMinSpacing = 0;
@ 1349 "adrc/adrc.ev" 2



/* Start of Via6 fat table spacing rules */
SET cut_maxCutSpacing = 0.1285;
SIZE via6  {
   OVER_UNDER = cut_maxCutSpacing/2.0
} TEMP = via_cluster
SET cut_fatMetalAndMode = 0;
SET cut_fatTblThreshold_1 = 0.16;
SET cut_fatTblNextThreshold_1 = 0;
SET cut_fatTblThreshold_2 = 0.16;
SET cut_fatTblNextThreshold_2 = 0;
SET cut_fatTblMinCuts = 0;
@ 1 "adrc/adrc_fatVia.ev" 1
/*Check fat contact table*/
if (cut_fatTblThreshold_1 > 0 && cut_fatTblThreshold_2 > 0) {
   SIZE metal6     { UNDER_OVER = cut_fatTblThreshold_1 / 2.0 - 0.0001  } TEMP = m_fat1
   if (cut_fatTblNextThreshold_1 > 0.0001 ) {
      SIZE m_fat1 { UNDER_OVER = cut_fatTblNextThreshold_1 / 2.0 - 0.0001  } TEMP = m_fat1_next
      BOOLEAN m_fat1 NOT m_fat1_next { } TEMP = m_fat1
   } else {
      COPY empty {} TEMP = m_fat1_next
   }
   BOOLEAN m_fat1 AND metal6  {  } TEMP = m_fat1
 
   SIZE metal7     { UNDER_OVER = cut_fatTblThreshold_2 / 2.0 - 0.0001  } TEMP = m_fat2
   if (cut_fatTblNextThreshold_2 > 0.0001 ) {
      SIZE m_fat2 { UNDER_OVER = cut_fatTblNextThreshold_2 / 2.0 - 0.0001  } TEMP = m_fat2_next
      BOOLEAN m_fat2 NOT m_fat2_next { } TEMP = m_fat2
   } else {
      COPY empty {} TEMP = m_fat2_next
   }
   BOOLEAN m_fat2 AND metal7  {  } TEMP = m_fat2
   if (cut_fatTblMinSpacing > 0 || cut_fatTblMinCuts > 1 || 
       cut_minEnclosure1 >=0 || cut_minEnclosure2 >=0 ||
       cut_EOLEnclosure1 > 0 || cut_EOLEnclosure2 > 0 ||
      (cut_ViaFarm_maxNum > 0 && cut_ViaFarm_spacing > 0)) {
      if (cut_fatMetalAndMode) {
        BOOLEAN m_fat1 AND m_fat2 { } TEMP = m_fat
        SELECT via6  INSIDE m_fat { } TEMP = v_fat
      } else {
        BOOLEAN m_fat1 OR m_fat2 { } TEMP = m_fat
        SELECT via6  INTERACT m_fat { } TEMP = v_fat
      }
   }
   if (cut_ViaFarm_maxNum > 0 && cut_ViaFarm_spacing > 0 || 
       cut_minEnclosure1 >=0 || cut_minEnclosure2 >=0 ||
       cut_EOLEnclosure1 > 0 || cut_EOLEnclosure2 > 0) {
      SET viaFarm_maxNum    = cut_ViaFarm_maxNum;
      SET viaFarm_spacing   = cut_ViaFarm_spacing;
      SET via_minEnclosure1 = cut_minEnclosure1;
      SET via_minEnclosure2 = cut_minEnclosure2;
      SET via_EOLEnclosure1 = cut_EOLEnclosure1;
      SET via_EOLEnclosure2 = cut_EOLEnclosure2;
      
      
@ 1 "adrc/adrc_viaCode.ev" 1
if (viaFarm_maxNum > 0 && viaFarm_spacing > 0) {
   SIZE v_fat  {  
     GROW_right = viaFarm_spacing - 0.0001 
   } TEMP = size_hor
   SELECT size_hor INTERACT v_fat  {
      RANGE = [viaFarm_maxNum + 1, 9999999999 ]
   } TEMP = size_hor
   SIZE v_fat  {  
      GROW_top = viaFarm_spacing - 0.0001 
   } TEMP = size_ver
   SELECT size_ver INTERACT v_fat  {
      RANGE = [viaFarm_maxNum + 1, 9999999999 ]
   } TEMP = size_ver
   BOOLEAN (size_hor OR size_ver) AND v_fat  {
      COMMENT = "$layer_name ViaFarmRule: max row/col number (spacing viaFarm_spacing um) = viaFarm_maxNum"
   } (22 )
   SET viaFarm_maxNum = 0;
   SET viaFarm_spacing = 0;      
}
/*check enclosure*/
if (via_minEnclosure1 > 0) {
    ENCLOSE v_fat  BY metal6  {
        COMMENT = "$layer_name Enclosure : min lower layer enclosure ( via_minEnclosure1 um)"
        SPACING < via_minEnclosure1
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
	TOUCH = TRUE
    } (22 )
}
/* Check out-side of enclosure */
if (via_minEnclosure1 >= 0) {
    BOOLEAN v_fat  NOT metal6  {
        COMMENT = "$layer_name Enclosure : min lower layer enclosure ( via_minEnclosure1 um)"
    } (22 )
    SET via_minEnclosure1 = -1;
}
/*check end_of_line enclosure*/
if (via_EOLEnclosure1 > 0) {
   ENCLOSE v_fat  BY metal6  {
      SPACING < via_EOLEnclosure1
      SET_CORNERS_TO_SPACING = FALSE
      PARALLEL_POINT_PROJECTION = FALSE
      SHADOW_OTHER_LAYER = TRUE  
      TOUCH = TRUE
      POINT_TOUCH = FALSE
      NON_PARALLEL = TRUE
      OUTPUT_EDGES = TRUE
   } TEMP = violation
 
   SELECT_EDGE v_fat  TOUCHING violation {  } TEMP = edges
   SELECT_VECTOR edges { ANGLE_RANGE = [0, 0] } TEMP = h_edges
   SELECT_VECTOR edges { ANGLE_RANGE = [90, 90] } TEMP = v_edges
   SELECT h_edges INTERACT v_edges { POINT_TOUCH = TRUE } TEMP = h_edges
 
   SELECT v_fat  ENCLOSING h_edges {
      COMMENT = "$layer_name Enclosure: min lower layer EoL enclosure ( via_EOLEnclosure1 um)"
   } (22 )
   SET via_EOLEnclosure1 = 0;
}
if (via_minEnclosure2 > 0) {
    ENCLOSE v_fat  BY metal7  {
        COMMENT = "$layer_name Enclosure : min upper layer enclosure ( via_minEnclosure2 um)"
        SPACING < via_minEnclosure2
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
	TOUCH = TRUE
    } (22 )
}
if (via_minEnclosure2 >= 0) {
    BOOLEAN v_fat  NOT metal7  {
        COMMENT = "$layer_name Enclosure : min upper layer enclosure ( via_minEnclosure2 um)"
    } (22 )
    SET via_minEnclosure2 = 0;
}
if (via_EOLEnclosure2 > 0) {
   ENCLOSE v_fat  BY metal7  {
      SPACING < via_EOLEnclosure2
      SET_CORNERS_TO_SPACING = FALSE
      PARALLEL_POINT_PROJECTION = FALSE
      SHADOW_OTHER_LAYER = TRUE  
      TOUCH = TRUE
      POINT_TOUCH = FALSE
      NON_PARALLEL = TRUE
      OUTPUT_EDGES = TRUE
   } TEMP = violation
 
   SELECT_EDGE v_fat  TOUCHING violation {  } TEMP = edges
   SELECT_VECTOR edges { ANGLE_RANGE = [0, 0] } TEMP = h_edges
   SELECT_VECTOR edges { ANGLE_RANGE = [90, 90] } TEMP = v_edges
   SELECT h_edges INTERACT v_edges { POINT_TOUCH = TRUE } TEMP = h_edges
 
   SELECT v_fat  ENCLOSING h_edges {
      COMMENT = "$layer_name Enclosure : min upper layer EoL enclosure ( via_EOLEnclosure2 um)"
   } (22 )
   SET via_EOLEnclosure2 = 0;
}
@ 42 "adrc/adrc_fatVia.ev" 2

      
      SET cut_ViaFarm_maxNum = 0;
      SET cut_ViaFarm_spacing = 0;
      SET cut_minEnclosure1 = 0;
      SET cut_minEnclosure2 = 0;
      SET cut_EOLEnclosure1 = 0;
      SET cut_EOLEnclosure2 = 0;
   }
 
   if (cut_fatTblMinSpacing > 0) {
      EXTERNAL v_fat via6  {
         COMMENT = "$layer_name FatContSpc: fat contact ( cut_fatTblThreshold_1 , cut_fatTblThreshold_2 um) minimum spacing = cut_fatTblMinSpacing um"
          SPACING < cut_fatTblMinSpacing
	  BOX_CORNER = FALSE 
	  NON_PARALLEL = TRUE
	  POINT_TOUCH = TRUE
      } (22 )
      SET cut_fatTblMinSpacing = 0;
   }
   if (cut_fatTblMinCuts > 1) {
      SELECT via_cluster INTERACT v_fat { } TEMP = v_fat_cluster 
      if (cut_fatMetalAndMode == 0) { 
         BOOLEAN metal6  AND metal7  { } TEMP = m_fat   
      }
      BOOLEAN v_fat_cluster AND m_fat { } TEMP = v_fat_cluster 
      SELECT v_fat_cluster INTERACT via6  {
         RANGE = [1, cut_fatTblMinCuts - 1]
      }  TEMP = v_fat_cluster
      SELECT v_fat INTERACT v_fat_cluster {
         COMMENT = "$layer_name MinContNum: fat contact ( cut_fatTblThreshold_1 , cut_fatTblThreshold_2 um) minimum number of contacts = cut_fatTblMinCuts "
      } (22 )
      SET cut_fatTblMinCuts = 0;
   }
 
   if (cut_fatTblExtensionRange > 0) {
      SIZE m_fat1 { OVERSIZE = cut_fatTblExtensionRange+ 0.0001  } TEMP = m_fat1_ran
      BOOLEAN m_fat1_ran AND metal6  {  } TEMP = m_fat1_ext
      BOOLEAN m_fat1_ext NOT m_fat1_next { } TEMP = m_fat1_ext
      BOOLEAN m_fat1_ext NOT m_fat1 { } TEMP = m_fat1_ext
      SELECT_EDGE m_fat1_ext TOUCHING m_fat1 { } TEMP = ext_filter
      SIZE ext_filter { VSIZE_INSIDE = 0.0002  } TEMP = ext_filter
      SIZE ext_filter INSIDE m_fat1_ext {
         OVERSIZE = cut_fatTblExtensionRange- 0.0002 
         INCREMENT = metalLayer1_minSpacing
      } TEMP=dummy TEMP = m_fat1_ext
      SIZE m_fat2 { OVERSIZE = cut_fatTblExtensionRange+ 0.0001  } TEMP = m_fat2_ran
      BOOLEAN m_fat2_ran AND metal7  {  } TEMP = m_fat2_ext
      BOOLEAN m_fat2_ext NOT m_fat2_next { } TEMP = m_fat2_ext
      BOOLEAN m_fat2_ext NOT m_fat2 { } TEMP = m_fat2_ext 
      SELECT_EDGE m_fat2_ext TOUCHING m_fat2 { } TEMP = ext_filter
      SIZE ext_filter { VSIZE_INSIDE = 0.0002  } TEMP = ext_filter
      SIZE ext_filter INSIDE m_fat2_ext {
         OVERSIZE = cut_fatTblExtensionRange- 0.0002 
         INCREMENT = metalLayer2_minSpacing
      } TEMP=dummy TEMP = m_fat2_ext
      BOOLEAN m_fat1_ext OR m_fat2_ext { } TEMP = m_fat_ext
      SELECT via6  INTERACT m_fat_ext {  } TEMP = v_fat_ext
      if (cut_ExtViaFarm_maxNum > 0 && cut_ExtViaFarm_spacing > 0 || 
          cut_ExtMinEnclosure1 >=0 || cut_ExtMinEnclosure2 >=0 ||
          cut_ExtEOLEnclosure1 > 0 || cut_ExtEOLEnclosure2 > 0) {
         SET viaFarm_maxNum    = cut_ExtViaFarm_maxNum;
         SET viaFarm_spacing   = cut_ExtViaFarm_spacing;
         SET via_minEnclosure1 = cut_ExtMinEnclosure1;
         SET via_minEnclosure2 = cut_ExtMinEnclosure2;
         SET via_EOLEnclosure1 = cut_ExtEOLEnclosure1;
         SET via_EOLEnclosure2 = cut_ExtEOLEnclosure2;
         
         
@ 1 "adrc/adrc_viaCode.ev" 1
if (viaFarm_maxNum > 0 && viaFarm_spacing > 0) {
   SIZE v_fat_ext  {  
     GROW_right = viaFarm_spacing - 0.0001 
   } TEMP = size_hor
   SELECT size_hor INTERACT v_fat_ext  {
      RANGE = [viaFarm_maxNum + 1, 9999999999 ]
   } TEMP = size_hor
   SIZE v_fat_ext  {  
      GROW_top = viaFarm_spacing - 0.0001 
   } TEMP = size_ver
   SELECT size_ver INTERACT v_fat_ext  {
      RANGE = [viaFarm_maxNum + 1, 9999999999 ]
   } TEMP = size_ver
   BOOLEAN (size_hor OR size_ver) AND v_fat_ext  {
      COMMENT = "$layer_name ViaFarmRule: max row/col number (spacing viaFarm_spacing um) = viaFarm_maxNum"
   } (22 )
   SET viaFarm_maxNum = 0;
   SET viaFarm_spacing = 0;      
}
/*check enclosure*/
if (via_minEnclosure1 > 0) {
    ENCLOSE v_fat_ext  BY metal6  {
        COMMENT = "$layer_name Enclosure : min lower layer enclosure ( via_minEnclosure1 um)"
        SPACING < via_minEnclosure1
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
	TOUCH = TRUE
    } (22 )
}
/* Check out-side of enclosure */
if (via_minEnclosure1 >= 0) {
    BOOLEAN v_fat_ext  NOT metal6  {
        COMMENT = "$layer_name Enclosure : min lower layer enclosure ( via_minEnclosure1 um)"
    } (22 )
    SET via_minEnclosure1 = -1;
}
/*check end_of_line enclosure*/
if (via_EOLEnclosure1 > 0) {
   ENCLOSE v_fat_ext  BY metal6  {
      SPACING < via_EOLEnclosure1
      SET_CORNERS_TO_SPACING = FALSE
      PARALLEL_POINT_PROJECTION = FALSE
      SHADOW_OTHER_LAYER = TRUE  
      TOUCH = TRUE
      POINT_TOUCH = FALSE
      NON_PARALLEL = TRUE
      OUTPUT_EDGES = TRUE
   } TEMP = violation
 
   SELECT_EDGE v_fat_ext  TOUCHING violation {  } TEMP = edges
   SELECT_VECTOR edges { ANGLE_RANGE = [0, 0] } TEMP = h_edges
   SELECT_VECTOR edges { ANGLE_RANGE = [90, 90] } TEMP = v_edges
   SELECT h_edges INTERACT v_edges { POINT_TOUCH = TRUE } TEMP = h_edges
 
   SELECT v_fat_ext  ENCLOSING h_edges {
      COMMENT = "$layer_name Enclosure: min lower layer EoL enclosure ( via_EOLEnclosure1 um)"
   } (22 )
   SET via_EOLEnclosure1 = 0;
}
if (via_minEnclosure2 > 0) {
    ENCLOSE v_fat_ext  BY metal7  {
        COMMENT = "$layer_name Enclosure : min upper layer enclosure ( via_minEnclosure2 um)"
        SPACING < via_minEnclosure2
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
	TOUCH = TRUE
    } (22 )
}
if (via_minEnclosure2 >= 0) {
    BOOLEAN v_fat_ext  NOT metal7  {
        COMMENT = "$layer_name Enclosure : min upper layer enclosure ( via_minEnclosure2 um)"
    } (22 )
    SET via_minEnclosure2 = 0;
}
if (via_EOLEnclosure2 > 0) {
   ENCLOSE v_fat_ext  BY metal7  {
      SPACING < via_EOLEnclosure2
      SET_CORNERS_TO_SPACING = FALSE
      PARALLEL_POINT_PROJECTION = FALSE
      SHADOW_OTHER_LAYER = TRUE  
      TOUCH = TRUE
      POINT_TOUCH = FALSE
      NON_PARALLEL = TRUE
      OUTPUT_EDGES = TRUE
   } TEMP = violation
 
   SELECT_EDGE v_fat_ext  TOUCHING violation {  } TEMP = edges
   SELECT_VECTOR edges { ANGLE_RANGE = [0, 0] } TEMP = h_edges
   SELECT_VECTOR edges { ANGLE_RANGE = [90, 90] } TEMP = v_edges
   SELECT h_edges INTERACT v_edges { POINT_TOUCH = TRUE } TEMP = h_edges
 
   SELECT v_fat_ext  ENCLOSING h_edges {
      COMMENT = "$layer_name Enclosure : min upper layer EoL enclosure ( via_EOLEnclosure2 um)"
   } (22 )
   SET via_EOLEnclosure2 = 0;
}
@ 110 "adrc/adrc_fatVia.ev" 2

         
         SET cut_ExtViaFarm_maxNum = 0;
         SET cut_ExtViaFarm_spacing = 0;
         SET cut_ExtMinEnclosure1 = 0;
         SET cut_ExtMinEnclosure2 = 0;
         SET cut_ExtEOLEnclosure1 = 0;
         SET cut_ExtEOLEnclosure2 = 0;
      }
 
      if (cut_fatTblExtensionMinSpacing > 0) {
         EXTERNAL v_fat_ext via6  {
            COMMENT = "$layer_name FatExtSpc : fat contact ( cut_fatTblThreshold_1 , cut_fatTblThreshold_2 um) extension range ( cut_fatTblExtensionRange um) minimum spacing = cut_fatTblExtensionMinSpacing um"
            SPACING < cut_fatTblExtensionMinSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
         } (22 )
      }
 
      if (cut_fatTblExtensionMinCuts > 1) {
         BOOLEAN metal6  AND metal7  { } TEMP = m_fat_ext
         BOOLEAN via_cluster AND m_fat_ext { } TEMP = via_cluster
         SELECT via_cluster INTERACT v_fat_ext { } TEMP = v_fat_ext_cluster
	 SELECT v_fat_ext_cluster INTERACT via6  {
            RANGE = [1, cut_fatTblExtensionMinCuts - 1]
	 }  TEMP = v_fat_ext_cluster
	 SELECT v_fat_ext INTERACT v_fat_ext_cluster {
            COMMENT = "$layer_name MinContNum: fat contact ( cut_fatTblThreshold_1 , cut_fatTblThreshold_2 um) extension range ( cut_fatTblExtensionRange um)  minimum number of contacts = cut_fatTblExtensionMinCuts "
	 } (22 )
      }
      SET cut_fatTblExtensionRange=0;
   }
}
@ 1363 "adrc/adrc.ev" 2




/* End of Via6 fat table spacing rules */











/*via 7*/
SET layer_name = "Via7";












SET cornerSpacingMode = 0;
SET cut_minSpacing = 0.07;
SET cut_fatContactThreshold1 = 0.16;
SET cut_fatContactThreshold2 = 0.16;
SET cut_fatTblDimension = 2;
@ 1 "adrc/adrc_check_via.ev" 1
/* check size */
if (cut_size > 0) {
    INTERNAL via7  {  
        COMMENT = "$layer_name Size      : contact size = cut_size um" 
	DIMENSION = [cut_size , cut_size]
    } (24 )
}
if (cut_minSpacing > 0) {
   if (ignoreContactCodeSpacing) {
      COPY via7  { } TEMP= default_via7 
   } else {
      SIZE metal7  { UNDER_OVER = cut_fatContactThreshold1 } TEMP = m_fat1
      SIZE metal8  { UNDER_OVER = cut_fatContactThreshold2 } TEMP = m_fat2
      BOOLEAN m_fat1 OR m_fat2 {} TEMP=m_fat
      SELECT via7  OUTSIDE m_fat { } TEMP= default_via7 
   }
}
 
/*check basic spacing*/
if (cut_sameNetMinSpacing > 0 && cut_sameNetMinSpacing < cut_minSpacing) {
  CONNECT { default_via7  BY via7  }
  if (cut_cornerMinSpacing > 0) {
    if (cornerSpacingMode == 1) {
        /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
        EXTERNAL default_via7  {
             SPACING <= 0
             CONVEX_TO_CONVEX [POINT_PROJECTION] < cut_cornerMinSpacing
             FLAG_DISCONNECTED = FALSE
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = FALSE
        } TEMP = sameNet_corner_err1
        EXTERNAL default_via7  {
             SPACING <= 0
             CONVEX_TO_CONVEX < cut_cornerMinSpacing
             FLAG_DISCONNECTED = FALSE
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = TRUE
        } TEMP = sameNet_corner_err2 
        BOOLEAN sameNet_corner_err1 OR sameNet_corner_err2 {
             COMMENT = "$layer_name SameNetSpc: corner to corner spacing = cut_cornerMinSpacing um "
        } (24 ) 
        EXTERNAL default_via7  {
             COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = cut_sameNetMinSpacing um "
             SPACING < cut_sameNetMinSpacing
             FLAG_DISCONNECTED = FALSE
             SET_CORNERS_TO_SPACING = FALSE
             PARALLEL_POINT_PROJECTION = FALSE
             NON_PARALLEL = TRUE
             TOUCH = FALSE
             POINT_TOUCH = FALSE
        } (24 )
    } else {
        EXTERNAL default_via7  {
            COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = cut_sameNetMinSpacing um (corner to corner spacing = cut_cornerMinSpacing um) "
            SPACING < cut_sameNetMinSpacing
            CONVEX_TO_CONVEX < cut_cornerMinSpacing
            FLAG_DISCONNECTED = FALSE
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
        } (24 )
    }
  } else {
    EXTERNAL default_via7  {
        COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = cut_sameNetMinSpacing um"
        SPACING < cut_sameNetMinSpacing
	BOX_CORNER = FALSE 
        FLAG_DISCONNECTED = FALSE
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
    } (24 )
  }
  if (cut_cornerMinSpacing > 0) {
    if (cornerSpacingMode == 1) {
        /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
        EXTERNAL default_via7  {
          SPACING <= 0
          CONVEX_TO_CONVEX [POINT_PROJECTION] < cut_cornerMinSpacing
          NON_PARALLEL = TRUE
          POINT_TOUCH = TRUE
          BOX_CORNER = FALSE
          NODAL = TRUE
        } TEMP = diffNet_corner_err1 
        EXTERNAL default_via7  {
          SPACING <= 0
          CONVEX_TO_CONVEX < cut_cornerMinSpacing
          NON_PARALLEL = TRUE
          POINT_TOUCH = TRUE
          BOX_CORNER = TRUE
          NODAL = TRUE
        } TEMP = diffNet_corner_err2 
        BOOLEAN diffNet_corner_err1 OR diffNet_corner_err2 {
          COMMENT = "$layer_name Spacing   : corner to corner spacing = cut_cornerMinSpacing um "
        } (24 )
        EXTERNAL default_via7  {
          COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
          SPACING < cut_minSpacing
          SET_CORNERS_TO_SPACING = FALSE
          PARALLEL_POINT_PROJECTION = FALSE
          NON_PARALLEL = TRUE
          TOUCH = FALSE
          POINT_TOUCH = FALSE
          NODAL = TRUE
        } (24 )
    } else {
        EXTERNAL default_via7  {
          COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um (corner to corner spacing = cut_cornerMinSpacing um) "
          SPACING < cut_minSpacing
          CONVEX_TO_CONVEX < cut_cornerMinSpacing
          NON_PARALLEL = TRUE
          POINT_TOUCH = TRUE
          NODAL = TRUE
        } (24 )
    }
  } else {
    EXTERNAL default_via7  {
      COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
      SPACING < cut_minSpacing
      BOX_CORNER = FALSE 
      NON_PARALLEL = TRUE
      POINT_TOUCH = TRUE
      NODAL = TRUE
    } (24 ) 
  }
} else {
   if (cut_minSpacing > 0) {
     if (cut_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
           /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
           EXTERNAL default_via7  {
             SPACING <= 0
             CONVEX_TO_CONVEX [POINT_PROJECTION] < cut_cornerMinSpacing
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = FALSE 
           } TEMP = corner_err1 
           EXTERNAL default_via7  {
             SPACING <= 0
             CONVEX_TO_CONVEX < cut_cornerMinSpacing
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = TRUE
           } TEMP = corner_err2 
           BOOLEAN corner_err1 OR corner_err2 {
             COMMENT = "$layer_name Spacing   : corner to corner spacing = cut_cornerMinSpacing um "
           } (24 )
           EXTERNAL default_via7  {
             COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
             SPACING < cut_minSpacing
             SET_CORNERS_TO_SPACING = FALSE
             PARALLEL_POINT_PROJECTION = FALSE
             NON_PARALLEL = TRUE
             TOUCH = FALSE
             POINT_TOUCH = FALSE
           } (24 )
        } else {
           EXTERNAL default_via7  {
             COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um (corner to corner spacing = cut_cornerMinSpacing um) "
             SPACING < cut_minSpacing
             CONVEX_TO_CONVEX < cut_cornerMinSpacing
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
           } (24 )
        }
    } else {
       EXTERNAL default_via7  {
          COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
          SPACING < cut_minSpacing
	  BOX_CORNER = FALSE 
	  NON_PARALLEL = TRUE
	  POINT_TOUCH = TRUE
       } (24 )
    }
  }
}
 
/*check blockage spacing*/
if (ignoreBlockage == 0) {
   if (!layer_empty (via7_blockage )) {
      if (cutBlkg_minSpacing > 0) {
	  EXTERNAL via7_blockage  via7  {
              COMMENT = "$layer_name Spacing   : contact & blockage minimum spacing = cutBlkg_minSpacing um"
	      SPACING < cutBlkg_minSpacing
	      BOX_CORNER = FALSE 
	      NON_PARALLEL = TRUE
	      POINT_TOUCH = TRUE
          } (24 )
      }
   }
}
/*check blockage overlap*/ 
/*check shorts between top_level routing and fram_blockages*/
if (cutBlkg_minSpacing > 0 || checkCrossHierShort > 0) {
   if (readCellView > 0) {
       COPY empty {} TEMP = real_blockage
       COPY via7  {} TEMP = top_cut
   } else {
       COPY via7_fram  {} TEMP = real_blockage
       COPY via7_top  {} TEMP = top_cut
   }
   if (ignoreBlockage == 0) {
      BOOLEAN via7_blockage  OR real_blockage {} TEMP=all_blockage
   } else {
      COPY real_blockage {} TEMP=all_blockage
   }
   
   BOOLEAN all_blockage AND top_cut {} TEMP = overlap_shape1
   EXTERNAL all_blockage top_cut {
      SPACING <= 0
      TOUCH = TRUE
   } TEMP = overlap_shape2
   if (checkCrossHierShort > 0) {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
          COMMENT = "$layer_name Short Cross Hierarchy"
      } (24 )
   } else {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
          COMMENT = "$layer_name Overlap   : cut & blockage overlap"
      } (24 )
   }
}
/*check adjacent via number*/
if (cut_adjacentCutRange > 0 && cut_maxNumAdjacentCut > 0) {
    if (router_ignoreSameNetAdjacentViaDRC) {
       EXTERNAL via7  {  
	   SPACING < cut_adjacentCutRange
	   SET_CORNERS_TO_SPACING = FALSE
	   PARALLEL_POINT_PROJECTION = FALSE
	   NON_PARALLEL = TRUE
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
           NODAL = TRUE
       } TEMP=edge_spacing
       EXTERNAL via7  {
	   SPACING < 0
	   CONVEX_TO_EDGE < cut_adjacentCutRange
	   CONVEX_TO_CONVEX < cut_adjacentCutRange
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
           NODAL = TRUE
       } TEMP=corner_spacing
    } else {
       EXTERNAL via7  {  
	   SPACING < cut_adjacentCutRange
	   SET_CORNERS_TO_SPACING = FALSE
	   PARALLEL_POINT_PROJECTION = FALSE
	   NON_PARALLEL = TRUE
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
       } TEMP=edge_spacing
 
       EXTERNAL via7  {
	   SPACING < 0
	   CONVEX_TO_EDGE < cut_adjacentCutRange
	   CONVEX_TO_CONVEX < cut_adjacentCutRange
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
       } TEMP=corner_spacing
    }
    SIZE edge_spacing { UNDERSIZE = 0.0002  } TEMP = edge_spacing1
    SIZE edge_spacing1 { OVERSIZE = 0.0002  } TEMP = edge_spacing2
    BOOLEAN (edge_spacing NOT edge_spacing2) OR edge_spacing1 { } TEMP=edge_spacing
 
    SIZE corner_spacing { UNDERSIZE = 0.0002  } TEMP = corner_spacing1
    SIZE corner_spacing1 { OVERSIZE = 0.0002  } TEMP = corner_spacing2
    BOOLEAN (corner_spacing NOT corner_spacing2) OR corner_spacing1 { } TEMP=corner_spacing
  
    BOOLEAN edge_spacing OR corner_spacing { } TEMP = spacing
 
    SIZE via7  { OVERSIZE = 5* 0.0002  } TEMP = cut
 
    SELECT cut INTERACT spacing {
        POINT_TOUCH = TRUE
        RANGE = [cut_maxNumAdjacentCut + 1, 9999999999 ]
    } TEMP = enclosed_cut
 
    SELECT via7  INSIDE enclosed_cut {
        COMMENT = "$layer_name AdjContNum: maximum number of the adjacent contacts ( cut_adjacentCutRange um) = cut_maxNumAdjacentCut "
    } (24 )
}
 
/*check enclosed via spacing*/
if (cut_enclosedCutNeighborRange > 0 && cut_enclosedCutNumNeighbor > 0) {
    if (cut_enclosedCutDiagViaExcluded) {
       EXTERNAL via7  {
          SPACING < cut_enclosedCutNeighborRange
          SET_CORNERS_TO_SPACING = FALSE
          PARALLEL_POINT_PROJECTION = FALSE
          NON_PARALLEL = TRUE
          BOX_CORNER = FALSE
          SHADOW = FALSE
       } TEMP = edge_spacing
       SELECT via7  TOUCHING edge_spacing {
          RANGE = [cut_enclosedCutNumNeighbor, 9999999999 ]
       } TEMP = enclosed_cut
    } else {
       /* Work around: for SIZE_RECT FLAG_INTERACTION_COUNT parser bug */
       
@ 308 "adrc/adrc_check_via.ev"
       if (cut_enclosedCutNumNeighbor==1) {
          
@-         SIZE_RECT via7  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  0  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==2) {
          
@-         SIZE_RECT via7  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  1  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==3) {
          
@-         SIZE_RECT via7  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  2  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==4) {
          
@-         SIZE_RECT via7  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  3  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==5) {
          
@-         SIZE_RECT via7  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  4  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==6) {
          
@-         SIZE_RECT via7  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  5  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==7) {
          
@-         SIZE_RECT via7  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  6  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==8) {
          
@-         SIZE_RECT via7  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  7  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==9) {
          
@-         SIZE_RECT via7  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  8  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor>9) {
          
@-         SIZE_RECT via7  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  9  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       }
    }
    if (router_ignoreSameNetAdjacentViaDRC) {
      /* Good approximation for same net via filter */
      CENTER_TO_CENTER via7  {
        NODAL=TRUE
        SPACING < cut_enclosedCutNeighborRange + 1.41421*cut_size + 0.0001 
        OUTPUT_VECTOR = TRUE
      } TEMP = c2c_spacing
      SIZE via7  { UNDERSIZE = (cut_size/2.0- 0.0001 ) } TEMP=cut_center
      BOOLEAN c2c_spacing NOT cut_center { } TEMP=c2c_spacing
      SIZE cut_center { OVERSIZE = 0.0002  } TEMP=cut_center
      BOOLEAN c2c_spacing AND via7   { } TEMP=c2c_filter
      SELECT cut_center INTERACT c2c_filter {
        POINT_TOUCH=TRUE
        RANGE = [cut_enclosedCutNumNeighbor, 9999999999 ]
      } TEMP = target_cut
   
      SELECT enclosed_cut ENCLOSING target_cut { } TEMP = enclosed_cut
    }
  
    if (cut_enclosedCutMinSpacing > 0) {
        EXTERNAL enclosed_cut {
        COMMENT = "$layer_name EncContSpc: minimum spacing between enclosed contacts ( cut_enclosedCutNeighborRange um / cut_enclosedCutNumNeighbor ) = cut_enclosedCutMinSpacing "
            SPACING < cut_enclosedCutMinSpacing
            SET_CORNERS_TO_SPACING = TRUE 
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
        } (24 )
    }
 
    if (cut_enclosedCutToNeighborMinSpacing > 0) {
       if (router_ignoreSameNetAdjacentViaDRC) {
          CONNECT { enclosed_cut BY via7  }
          EXTERNAL enclosed_cut via7  {
              COMMENT = "$layer_name EncContSpc: minimum spacing between enclosed and neighboring contacts ( cut_enclosedCutNeighborRange um / cut_enclosedCutNumNeighbor ) = cut_enclosedCutToNeighborMinSpacing "
              SPACING < cut_enclosedCutToNeighborMinSpacing
              SET_CORNERS_TO_SPACING = TRUE 
	      BOX_CORNER = FALSE 
	      NON_PARALLEL = TRUE
	      POINT_TOUCH = TRUE
              NODAL = TRUE
          } (24 )
       } else {
          EXTERNAL enclosed_cut via7  {
              COMMENT = "$layer_name EncContSpc: minimum spacing between enclosed and neighboring contacts ( cut_enclosedCutNeighborRange um / cut_enclosedCutNumNeighbor ) = cut_enclosedCutToNeighborMinSpacing "
              SPACING < cut_enclosedCutToNeighborMinSpacing
              SET_CORNERS_TO_SPACING = TRUE 
	      BOX_CORNER = FALSE 
	      NON_PARALLEL = TRUE
	      POINT_TOUCH = TRUE
          } (24 )
       }
    }
}
 
/*check max stack level, upward only*/
if (cut_maxStackLevel > 0 && cut_stackLevelSpacing > 0) {
    if (cut_maxStackLevel == 1) {
      BOOLEAN via7  AND CUT_LAYER1 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 2) {
      BOOLEAN (via7  AND CUT_LAYER1) AND CUT_LAYER2 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 3) {
      BOOLEAN (via7  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3)
        { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 4) {
      BOOLEAN ((via7  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND CUT_LAYER4 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 5) {
      BOOLEAN ((via7  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND (CUT_LAYER4 AND CUT_LAYER5) { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 6) {
      BOOLEAN ((via7  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND ((CUT_LAYER4 AND CUT_LAYER5) AND CUT_LAYER6) { } TEMP = neighbors
    }
    else if (cut_maxStackLevel >= 7) { 
      BOOLEAN ((via7  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND ((CUT_LAYER4 AND CUT_LAYER5) AND (CUT_LAYER6 AND CUT_LAYER7))
       { } TEMP = neighbors
    }
 
    if (!layer_empty(neighbors)) {
      SELECT CUT_LAYER0 INTERACT neighbors {
        LINE_TOUCH = FALSE POINT_TOUCH = FALSE 
      } TEMP = neighbors
      EXTERNAL neighbors {
	spacing <= cut_stackLevelSpacing
      } TEMP = via_arr_ext
      if (!layer_empty (via_arr_ext)) {
	SELECT neighbors OUTSIDE via_arr_ext {
         COMMENT = "$layer_name StackLevel: maximum stack level = cut_maxStackLevel "
          LINE_TOUCH = FALSE
          POINT_TOUCH = FALSE	    
        } (24 )
      }
      else {
        BOOLEAN via7  AND neighbors {
            COMMENT = "$layer_name StackLevel: maximum stack level = cut_maxStackLevel "
        } (24 )
      }
    }
  }
  else if (cut_maxStackLevel > 0) {
    if (cut_maxStackLevel == 1) {
      COPY CUT_LAYER1 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 2) {
      BOOLEAN CUT_LAYER1 AND CUT_LAYER2 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 3) {
      BOOLEAN CUT_LAYER1 AND (CUT_LAYER2 AND CUT_LAYER3)
        { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 4) {
      BOOLEAN (CUT_LAYER1 AND CUT_LAYER2) AND (CUT_LAYER3 AND CUT_LAYER4)
        { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 5) {
      BOOLEAN ((CUT_LAYER1 AND CUT_LAYER2) AND (CUT_LAYER3 AND CUT_LAYER4))
        AND CUT_LAYER5 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 6) {
      BOOLEAN ((CUT_LAYER6 AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND (CUT_LAYER4 AND CUT_LAYER5) { } TEMP = neighbors
    }
    else if (cut_maxStackLevel >= 7) { 
      BOOLEAN ((CUT_LAYER7 AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND ((CUT_LAYER4 AND CUT_LAYER5) AND CUT_LAYER6) { } TEMP = neighbors
    }
 
    if (!layer_empty (neighbors)) {
        BOOLEAN via7  AND neighbors {
            COMMENT = "$layer_name StackLevel: maximum stack level = cut_maxStackLevel "
        } (24 )
    }
}
 
/*Check fat contact*/
if (cut_fatContactMinSpacing > 0 && cut_fatTblDimension == 0) {
    if (cut_fatContactThreshold1 > 0) {
    	SIZE metal7    { UNDER_OVER = cut_fatContactThreshold1 / 2.0 - 0.0001  } TEMP = m_fat
    	BOOLEAN m_fat AND metal7  { } TEMP = m_fat
 
    	SELECT via7  INSIDE  m_fat { } TEMP = v_fat
 
    	EXTERNAL v_fat via7  {
            COMMENT = "$layer_name FatContSpc: fat contact ( cut_fatContactThreshold1 um, lower layer) minimum spacing = cut_fatContactMinSpacing um"
            SPACING < cut_fatContactMinSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
        } (24 )
    }
 
    if (cut_fatContactThreshold2 > 0) {
    	SIZE metal8    { UNDER_OVER = cut_fatContactThreshold2 / 2.0 - 0.0001  } TEMP = m_fat
    	BOOLEAN m_fat AND metal8  { } TEMP = m_fat
 
    	SELECT via7  INSIDE  m_fat { } TEMP = v_fat
 
    	EXTERNAL v_fat via7  {
            COMMENT = "$layer_name FatContSpc: fat contact ( cut_fatContactThreshold2 um, upper layer) minimum spacing = cut_fatContactMinSpacing um"
            SPACING < cut_fatContactMinSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
        } (24 )
    }
}
/* Avoid empty optimization result parsing error */
if (addEmptyViaCheck) {
   BOOLEAN empty OR empty {
      COMMENT = "$layer_name Empty: Dummy Output"
   } (24 )
   SET addEmptyViaCheck=0;
}
 
/* reset variables */















SET cut_size = 0;
SET cut_minSpacing = 0;
SET cut_sameNetMinSpacing = 0;
SET cut_cornerMinSpacing = 0;
SET cutBlkg_minSpacing = 0;
SET cut_maxNumAdjacentCut = 0;
SET cut_adjacentCutRange = 0;
SET cut_enclosedCutNeighborRange = 0;
SET cut_enclosedCutNumNeighbor = 0;
SET cut_enclosedCutMinSpacing = 0;
SET cut_enclosedCutToNeighborMinSpacing = 0;
SET cut_enclosedCutDiagViaExcluded = 0;
SET cut_maxStackLevel = 0;
SET cut_defaultContactMinSpacing = 0;
SET cut_fatContactThreshold1 = 0;
SET cut_fatContactThreshold2 = 0;
SET cut_fatContactMinSpacing = 0;
SET cut_maxCutSpacing = 0; 
SET cut_fatTblDimension = 0;
SET cut_fatTblThreshold_1 = 0;
SET cut_fatTblThreshold_2 = 0;
SET cut_fatTblNextThreshold_1 = 0;
SET cut_fatTblNextThreshold_2 = 0;
SET cut_fatTblMinCuts = 0;
SET cut_fatTblMinSpacing = 0;
SET cut_fatTblExtensionRange = 0;
SET cut_fatTblExtensionMinCuts = 0;
SET cut_fatTblExtensionMinSpacing = 0;
@ 1398 "adrc/adrc.ev" 2



/* Start of Via7 fat table spacing rules */
SET cut_maxCutSpacing = 0.1285;
SIZE via7  {
   OVER_UNDER = cut_maxCutSpacing/2.0
} TEMP = via_cluster
SET cut_fatMetalAndMode = 0;
SET cut_fatTblThreshold_1 = 0.16;
SET cut_fatTblNextThreshold_1 = 0;
SET cut_fatTblThreshold_2 = 0.16;
SET cut_fatTblNextThreshold_2 = 0;
SET cut_fatTblMinCuts = 0;
@ 1 "adrc/adrc_fatVia.ev" 1
/*Check fat contact table*/
if (cut_fatTblThreshold_1 > 0 && cut_fatTblThreshold_2 > 0) {
   SIZE metal7     { UNDER_OVER = cut_fatTblThreshold_1 / 2.0 - 0.0001  } TEMP = m_fat1
   if (cut_fatTblNextThreshold_1 > 0.0001 ) {
      SIZE m_fat1 { UNDER_OVER = cut_fatTblNextThreshold_1 / 2.0 - 0.0001  } TEMP = m_fat1_next
      BOOLEAN m_fat1 NOT m_fat1_next { } TEMP = m_fat1
   } else {
      COPY empty {} TEMP = m_fat1_next
   }
   BOOLEAN m_fat1 AND metal7  {  } TEMP = m_fat1
 
   SIZE metal8     { UNDER_OVER = cut_fatTblThreshold_2 / 2.0 - 0.0001  } TEMP = m_fat2
   if (cut_fatTblNextThreshold_2 > 0.0001 ) {
      SIZE m_fat2 { UNDER_OVER = cut_fatTblNextThreshold_2 / 2.0 - 0.0001  } TEMP = m_fat2_next
      BOOLEAN m_fat2 NOT m_fat2_next { } TEMP = m_fat2
   } else {
      COPY empty {} TEMP = m_fat2_next
   }
   BOOLEAN m_fat2 AND metal8  {  } TEMP = m_fat2
   if (cut_fatTblMinSpacing > 0 || cut_fatTblMinCuts > 1 || 
       cut_minEnclosure1 >=0 || cut_minEnclosure2 >=0 ||
       cut_EOLEnclosure1 > 0 || cut_EOLEnclosure2 > 0 ||
      (cut_ViaFarm_maxNum > 0 && cut_ViaFarm_spacing > 0)) {
      if (cut_fatMetalAndMode) {
        BOOLEAN m_fat1 AND m_fat2 { } TEMP = m_fat
        SELECT via7  INSIDE m_fat { } TEMP = v_fat
      } else {
        BOOLEAN m_fat1 OR m_fat2 { } TEMP = m_fat
        SELECT via7  INTERACT m_fat { } TEMP = v_fat
      }
   }
   if (cut_ViaFarm_maxNum > 0 && cut_ViaFarm_spacing > 0 || 
       cut_minEnclosure1 >=0 || cut_minEnclosure2 >=0 ||
       cut_EOLEnclosure1 > 0 || cut_EOLEnclosure2 > 0) {
      SET viaFarm_maxNum    = cut_ViaFarm_maxNum;
      SET viaFarm_spacing   = cut_ViaFarm_spacing;
      SET via_minEnclosure1 = cut_minEnclosure1;
      SET via_minEnclosure2 = cut_minEnclosure2;
      SET via_EOLEnclosure1 = cut_EOLEnclosure1;
      SET via_EOLEnclosure2 = cut_EOLEnclosure2;
      
      
@ 1 "adrc/adrc_viaCode.ev" 1
if (viaFarm_maxNum > 0 && viaFarm_spacing > 0) {
   SIZE v_fat  {  
     GROW_right = viaFarm_spacing - 0.0001 
   } TEMP = size_hor
   SELECT size_hor INTERACT v_fat  {
      RANGE = [viaFarm_maxNum + 1, 9999999999 ]
   } TEMP = size_hor
   SIZE v_fat  {  
      GROW_top = viaFarm_spacing - 0.0001 
   } TEMP = size_ver
   SELECT size_ver INTERACT v_fat  {
      RANGE = [viaFarm_maxNum + 1, 9999999999 ]
   } TEMP = size_ver
   BOOLEAN (size_hor OR size_ver) AND v_fat  {
      COMMENT = "$layer_name ViaFarmRule: max row/col number (spacing viaFarm_spacing um) = viaFarm_maxNum"
   } (24 )
   SET viaFarm_maxNum = 0;
   SET viaFarm_spacing = 0;      
}
/*check enclosure*/
if (via_minEnclosure1 > 0) {
    ENCLOSE v_fat  BY metal7  {
        COMMENT = "$layer_name Enclosure : min lower layer enclosure ( via_minEnclosure1 um)"
        SPACING < via_minEnclosure1
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
	TOUCH = TRUE
    } (24 )
}
/* Check out-side of enclosure */
if (via_minEnclosure1 >= 0) {
    BOOLEAN v_fat  NOT metal7  {
        COMMENT = "$layer_name Enclosure : min lower layer enclosure ( via_minEnclosure1 um)"
    } (24 )
    SET via_minEnclosure1 = -1;
}
/*check end_of_line enclosure*/
if (via_EOLEnclosure1 > 0) {
   ENCLOSE v_fat  BY metal7  {
      SPACING < via_EOLEnclosure1
      SET_CORNERS_TO_SPACING = FALSE
      PARALLEL_POINT_PROJECTION = FALSE
      SHADOW_OTHER_LAYER = TRUE  
      TOUCH = TRUE
      POINT_TOUCH = FALSE
      NON_PARALLEL = TRUE
      OUTPUT_EDGES = TRUE
   } TEMP = violation
 
   SELECT_EDGE v_fat  TOUCHING violation {  } TEMP = edges
   SELECT_VECTOR edges { ANGLE_RANGE = [0, 0] } TEMP = h_edges
   SELECT_VECTOR edges { ANGLE_RANGE = [90, 90] } TEMP = v_edges
   SELECT h_edges INTERACT v_edges { POINT_TOUCH = TRUE } TEMP = h_edges
 
   SELECT v_fat  ENCLOSING h_edges {
      COMMENT = "$layer_name Enclosure: min lower layer EoL enclosure ( via_EOLEnclosure1 um)"
   } (24 )
   SET via_EOLEnclosure1 = 0;
}
if (via_minEnclosure2 > 0) {
    ENCLOSE v_fat  BY metal8  {
        COMMENT = "$layer_name Enclosure : min upper layer enclosure ( via_minEnclosure2 um)"
        SPACING < via_minEnclosure2
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
	TOUCH = TRUE
    } (24 )
}
if (via_minEnclosure2 >= 0) {
    BOOLEAN v_fat  NOT metal8  {
        COMMENT = "$layer_name Enclosure : min upper layer enclosure ( via_minEnclosure2 um)"
    } (24 )
    SET via_minEnclosure2 = 0;
}
if (via_EOLEnclosure2 > 0) {
   ENCLOSE v_fat  BY metal8  {
      SPACING < via_EOLEnclosure2
      SET_CORNERS_TO_SPACING = FALSE
      PARALLEL_POINT_PROJECTION = FALSE
      SHADOW_OTHER_LAYER = TRUE  
      TOUCH = TRUE
      POINT_TOUCH = FALSE
      NON_PARALLEL = TRUE
      OUTPUT_EDGES = TRUE
   } TEMP = violation
 
   SELECT_EDGE v_fat  TOUCHING violation {  } TEMP = edges
   SELECT_VECTOR edges { ANGLE_RANGE = [0, 0] } TEMP = h_edges
   SELECT_VECTOR edges { ANGLE_RANGE = [90, 90] } TEMP = v_edges
   SELECT h_edges INTERACT v_edges { POINT_TOUCH = TRUE } TEMP = h_edges
 
   SELECT v_fat  ENCLOSING h_edges {
      COMMENT = "$layer_name Enclosure : min upper layer EoL enclosure ( via_EOLEnclosure2 um)"
   } (24 )
   SET via_EOLEnclosure2 = 0;
}
@ 42 "adrc/adrc_fatVia.ev" 2

      
      SET cut_ViaFarm_maxNum = 0;
      SET cut_ViaFarm_spacing = 0;
      SET cut_minEnclosure1 = 0;
      SET cut_minEnclosure2 = 0;
      SET cut_EOLEnclosure1 = 0;
      SET cut_EOLEnclosure2 = 0;
   }
 
   if (cut_fatTblMinSpacing > 0) {
      EXTERNAL v_fat via7  {
         COMMENT = "$layer_name FatContSpc: fat contact ( cut_fatTblThreshold_1 , cut_fatTblThreshold_2 um) minimum spacing = cut_fatTblMinSpacing um"
          SPACING < cut_fatTblMinSpacing
	  BOX_CORNER = FALSE 
	  NON_PARALLEL = TRUE
	  POINT_TOUCH = TRUE
      } (24 )
      SET cut_fatTblMinSpacing = 0;
   }
   if (cut_fatTblMinCuts > 1) {
      SELECT via_cluster INTERACT v_fat { } TEMP = v_fat_cluster 
      if (cut_fatMetalAndMode == 0) { 
         BOOLEAN metal7  AND metal8  { } TEMP = m_fat   
      }
      BOOLEAN v_fat_cluster AND m_fat { } TEMP = v_fat_cluster 
      SELECT v_fat_cluster INTERACT via7  {
         RANGE = [1, cut_fatTblMinCuts - 1]
      }  TEMP = v_fat_cluster
      SELECT v_fat INTERACT v_fat_cluster {
         COMMENT = "$layer_name MinContNum: fat contact ( cut_fatTblThreshold_1 , cut_fatTblThreshold_2 um) minimum number of contacts = cut_fatTblMinCuts "
      } (24 )
      SET cut_fatTblMinCuts = 0;
   }
 
   if (cut_fatTblExtensionRange > 0) {
      SIZE m_fat1 { OVERSIZE = cut_fatTblExtensionRange+ 0.0001  } TEMP = m_fat1_ran
      BOOLEAN m_fat1_ran AND metal7  {  } TEMP = m_fat1_ext
      BOOLEAN m_fat1_ext NOT m_fat1_next { } TEMP = m_fat1_ext
      BOOLEAN m_fat1_ext NOT m_fat1 { } TEMP = m_fat1_ext
      SELECT_EDGE m_fat1_ext TOUCHING m_fat1 { } TEMP = ext_filter
      SIZE ext_filter { VSIZE_INSIDE = 0.0002  } TEMP = ext_filter
      SIZE ext_filter INSIDE m_fat1_ext {
         OVERSIZE = cut_fatTblExtensionRange- 0.0002 
         INCREMENT = metalLayer1_minSpacing
      } TEMP=dummy TEMP = m_fat1_ext
      SIZE m_fat2 { OVERSIZE = cut_fatTblExtensionRange+ 0.0001  } TEMP = m_fat2_ran
      BOOLEAN m_fat2_ran AND metal8  {  } TEMP = m_fat2_ext
      BOOLEAN m_fat2_ext NOT m_fat2_next { } TEMP = m_fat2_ext
      BOOLEAN m_fat2_ext NOT m_fat2 { } TEMP = m_fat2_ext 
      SELECT_EDGE m_fat2_ext TOUCHING m_fat2 { } TEMP = ext_filter
      SIZE ext_filter { VSIZE_INSIDE = 0.0002  } TEMP = ext_filter
      SIZE ext_filter INSIDE m_fat2_ext {
         OVERSIZE = cut_fatTblExtensionRange- 0.0002 
         INCREMENT = metalLayer2_minSpacing
      } TEMP=dummy TEMP = m_fat2_ext
      BOOLEAN m_fat1_ext OR m_fat2_ext { } TEMP = m_fat_ext
      SELECT via7  INTERACT m_fat_ext {  } TEMP = v_fat_ext
      if (cut_ExtViaFarm_maxNum > 0 && cut_ExtViaFarm_spacing > 0 || 
          cut_ExtMinEnclosure1 >=0 || cut_ExtMinEnclosure2 >=0 ||
          cut_ExtEOLEnclosure1 > 0 || cut_ExtEOLEnclosure2 > 0) {
         SET viaFarm_maxNum    = cut_ExtViaFarm_maxNum;
         SET viaFarm_spacing   = cut_ExtViaFarm_spacing;
         SET via_minEnclosure1 = cut_ExtMinEnclosure1;
         SET via_minEnclosure2 = cut_ExtMinEnclosure2;
         SET via_EOLEnclosure1 = cut_ExtEOLEnclosure1;
         SET via_EOLEnclosure2 = cut_ExtEOLEnclosure2;
         
         
@ 1 "adrc/adrc_viaCode.ev" 1
if (viaFarm_maxNum > 0 && viaFarm_spacing > 0) {
   SIZE v_fat_ext  {  
     GROW_right = viaFarm_spacing - 0.0001 
   } TEMP = size_hor
   SELECT size_hor INTERACT v_fat_ext  {
      RANGE = [viaFarm_maxNum + 1, 9999999999 ]
   } TEMP = size_hor
   SIZE v_fat_ext  {  
      GROW_top = viaFarm_spacing - 0.0001 
   } TEMP = size_ver
   SELECT size_ver INTERACT v_fat_ext  {
      RANGE = [viaFarm_maxNum + 1, 9999999999 ]
   } TEMP = size_ver
   BOOLEAN (size_hor OR size_ver) AND v_fat_ext  {
      COMMENT = "$layer_name ViaFarmRule: max row/col number (spacing viaFarm_spacing um) = viaFarm_maxNum"
   } (24 )
   SET viaFarm_maxNum = 0;
   SET viaFarm_spacing = 0;      
}
/*check enclosure*/
if (via_minEnclosure1 > 0) {
    ENCLOSE v_fat_ext  BY metal7  {
        COMMENT = "$layer_name Enclosure : min lower layer enclosure ( via_minEnclosure1 um)"
        SPACING < via_minEnclosure1
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
	TOUCH = TRUE
    } (24 )
}
/* Check out-side of enclosure */
if (via_minEnclosure1 >= 0) {
    BOOLEAN v_fat_ext  NOT metal7  {
        COMMENT = "$layer_name Enclosure : min lower layer enclosure ( via_minEnclosure1 um)"
    } (24 )
    SET via_minEnclosure1 = -1;
}
/*check end_of_line enclosure*/
if (via_EOLEnclosure1 > 0) {
   ENCLOSE v_fat_ext  BY metal7  {
      SPACING < via_EOLEnclosure1
      SET_CORNERS_TO_SPACING = FALSE
      PARALLEL_POINT_PROJECTION = FALSE
      SHADOW_OTHER_LAYER = TRUE  
      TOUCH = TRUE
      POINT_TOUCH = FALSE
      NON_PARALLEL = TRUE
      OUTPUT_EDGES = TRUE
   } TEMP = violation
 
   SELECT_EDGE v_fat_ext  TOUCHING violation {  } TEMP = edges
   SELECT_VECTOR edges { ANGLE_RANGE = [0, 0] } TEMP = h_edges
   SELECT_VECTOR edges { ANGLE_RANGE = [90, 90] } TEMP = v_edges
   SELECT h_edges INTERACT v_edges { POINT_TOUCH = TRUE } TEMP = h_edges
 
   SELECT v_fat_ext  ENCLOSING h_edges {
      COMMENT = "$layer_name Enclosure: min lower layer EoL enclosure ( via_EOLEnclosure1 um)"
   } (24 )
   SET via_EOLEnclosure1 = 0;
}
if (via_minEnclosure2 > 0) {
    ENCLOSE v_fat_ext  BY metal8  {
        COMMENT = "$layer_name Enclosure : min upper layer enclosure ( via_minEnclosure2 um)"
        SPACING < via_minEnclosure2
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
	TOUCH = TRUE
    } (24 )
}
if (via_minEnclosure2 >= 0) {
    BOOLEAN v_fat_ext  NOT metal8  {
        COMMENT = "$layer_name Enclosure : min upper layer enclosure ( via_minEnclosure2 um)"
    } (24 )
    SET via_minEnclosure2 = 0;
}
if (via_EOLEnclosure2 > 0) {
   ENCLOSE v_fat_ext  BY metal8  {
      SPACING < via_EOLEnclosure2
      SET_CORNERS_TO_SPACING = FALSE
      PARALLEL_POINT_PROJECTION = FALSE
      SHADOW_OTHER_LAYER = TRUE  
      TOUCH = TRUE
      POINT_TOUCH = FALSE
      NON_PARALLEL = TRUE
      OUTPUT_EDGES = TRUE
   } TEMP = violation
 
   SELECT_EDGE v_fat_ext  TOUCHING violation {  } TEMP = edges
   SELECT_VECTOR edges { ANGLE_RANGE = [0, 0] } TEMP = h_edges
   SELECT_VECTOR edges { ANGLE_RANGE = [90, 90] } TEMP = v_edges
   SELECT h_edges INTERACT v_edges { POINT_TOUCH = TRUE } TEMP = h_edges
 
   SELECT v_fat_ext  ENCLOSING h_edges {
      COMMENT = "$layer_name Enclosure : min upper layer EoL enclosure ( via_EOLEnclosure2 um)"
   } (24 )
   SET via_EOLEnclosure2 = 0;
}
@ 110 "adrc/adrc_fatVia.ev" 2

         
         SET cut_ExtViaFarm_maxNum = 0;
         SET cut_ExtViaFarm_spacing = 0;
         SET cut_ExtMinEnclosure1 = 0;
         SET cut_ExtMinEnclosure2 = 0;
         SET cut_ExtEOLEnclosure1 = 0;
         SET cut_ExtEOLEnclosure2 = 0;
      }
 
      if (cut_fatTblExtensionMinSpacing > 0) {
         EXTERNAL v_fat_ext via7  {
            COMMENT = "$layer_name FatExtSpc : fat contact ( cut_fatTblThreshold_1 , cut_fatTblThreshold_2 um) extension range ( cut_fatTblExtensionRange um) minimum spacing = cut_fatTblExtensionMinSpacing um"
            SPACING < cut_fatTblExtensionMinSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
         } (24 )
      }
 
      if (cut_fatTblExtensionMinCuts > 1) {
         BOOLEAN metal7  AND metal8  { } TEMP = m_fat_ext
         BOOLEAN via_cluster AND m_fat_ext { } TEMP = via_cluster
         SELECT via_cluster INTERACT v_fat_ext { } TEMP = v_fat_ext_cluster
	 SELECT v_fat_ext_cluster INTERACT via7  {
            RANGE = [1, cut_fatTblExtensionMinCuts - 1]
	 }  TEMP = v_fat_ext_cluster
	 SELECT v_fat_ext INTERACT v_fat_ext_cluster {
            COMMENT = "$layer_name MinContNum: fat contact ( cut_fatTblThreshold_1 , cut_fatTblThreshold_2 um) extension range ( cut_fatTblExtensionRange um)  minimum number of contacts = cut_fatTblExtensionMinCuts "
	 } (24 )
      }
      SET cut_fatTblExtensionRange=0;
   }
}
@ 1412 "adrc/adrc.ev" 2




/* End of Via7 fat table spacing rules */











/*via 8*/
SET layer_name = "Via8";












SET cornerSpacingMode = 0;
SET cut_minSpacing = 0.12;
SET cut_fatTblDimension = 0;
@ 1 "adrc/adrc_check_via.ev" 1
/* check size */
if (cut_size > 0) {
    INTERNAL via8  {  
        COMMENT = "$layer_name Size      : contact size = cut_size um" 
	DIMENSION = [cut_size , cut_size]
    } (26 )
}
if (cut_minSpacing > 0) {
   if (ignoreContactCodeSpacing) {
      COPY via8  { } TEMP= default_via8 
   } else {
      SIZE metal8  { UNDER_OVER = cut_fatContactThreshold1 } TEMP = m_fat1
      SIZE metal9  { UNDER_OVER = cut_fatContactThreshold2 } TEMP = m_fat2
      BOOLEAN m_fat1 OR m_fat2 {} TEMP=m_fat
      SELECT via8  OUTSIDE m_fat { } TEMP= default_via8 
   }
}
 
/*check basic spacing*/
if (cut_sameNetMinSpacing > 0 && cut_sameNetMinSpacing < cut_minSpacing) {
  CONNECT { default_via8  BY via8  }
  if (cut_cornerMinSpacing > 0) {
    if (cornerSpacingMode == 1) {
        /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
        EXTERNAL default_via8  {
             SPACING <= 0
             CONVEX_TO_CONVEX [POINT_PROJECTION] < cut_cornerMinSpacing
             FLAG_DISCONNECTED = FALSE
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = FALSE
        } TEMP = sameNet_corner_err1
        EXTERNAL default_via8  {
             SPACING <= 0
             CONVEX_TO_CONVEX < cut_cornerMinSpacing
             FLAG_DISCONNECTED = FALSE
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = TRUE
        } TEMP = sameNet_corner_err2 
        BOOLEAN sameNet_corner_err1 OR sameNet_corner_err2 {
             COMMENT = "$layer_name SameNetSpc: corner to corner spacing = cut_cornerMinSpacing um "
        } (26 ) 
        EXTERNAL default_via8  {
             COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = cut_sameNetMinSpacing um "
             SPACING < cut_sameNetMinSpacing
             FLAG_DISCONNECTED = FALSE
             SET_CORNERS_TO_SPACING = FALSE
             PARALLEL_POINT_PROJECTION = FALSE
             NON_PARALLEL = TRUE
             TOUCH = FALSE
             POINT_TOUCH = FALSE
        } (26 )
    } else {
        EXTERNAL default_via8  {
            COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = cut_sameNetMinSpacing um (corner to corner spacing = cut_cornerMinSpacing um) "
            SPACING < cut_sameNetMinSpacing
            CONVEX_TO_CONVEX < cut_cornerMinSpacing
            FLAG_DISCONNECTED = FALSE
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
        } (26 )
    }
  } else {
    EXTERNAL default_via8  {
        COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = cut_sameNetMinSpacing um"
        SPACING < cut_sameNetMinSpacing
	BOX_CORNER = FALSE 
        FLAG_DISCONNECTED = FALSE
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
    } (26 )
  }
  if (cut_cornerMinSpacing > 0) {
    if (cornerSpacingMode == 1) {
        /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
        EXTERNAL default_via8  {
          SPACING <= 0
          CONVEX_TO_CONVEX [POINT_PROJECTION] < cut_cornerMinSpacing
          NON_PARALLEL = TRUE
          POINT_TOUCH = TRUE
          BOX_CORNER = FALSE
          NODAL = TRUE
        } TEMP = diffNet_corner_err1 
        EXTERNAL default_via8  {
          SPACING <= 0
          CONVEX_TO_CONVEX < cut_cornerMinSpacing
          NON_PARALLEL = TRUE
          POINT_TOUCH = TRUE
          BOX_CORNER = TRUE
          NODAL = TRUE
        } TEMP = diffNet_corner_err2 
        BOOLEAN diffNet_corner_err1 OR diffNet_corner_err2 {
          COMMENT = "$layer_name Spacing   : corner to corner spacing = cut_cornerMinSpacing um "
        } (26 )
        EXTERNAL default_via8  {
          COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
          SPACING < cut_minSpacing
          SET_CORNERS_TO_SPACING = FALSE
          PARALLEL_POINT_PROJECTION = FALSE
          NON_PARALLEL = TRUE
          TOUCH = FALSE
          POINT_TOUCH = FALSE
          NODAL = TRUE
        } (26 )
    } else {
        EXTERNAL default_via8  {
          COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um (corner to corner spacing = cut_cornerMinSpacing um) "
          SPACING < cut_minSpacing
          CONVEX_TO_CONVEX < cut_cornerMinSpacing
          NON_PARALLEL = TRUE
          POINT_TOUCH = TRUE
          NODAL = TRUE
        } (26 )
    }
  } else {
    EXTERNAL default_via8  {
      COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
      SPACING < cut_minSpacing
      BOX_CORNER = FALSE 
      NON_PARALLEL = TRUE
      POINT_TOUCH = TRUE
      NODAL = TRUE
    } (26 ) 
  }
} else {
   if (cut_minSpacing > 0) {
     if (cut_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
           /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
           EXTERNAL default_via8  {
             SPACING <= 0
             CONVEX_TO_CONVEX [POINT_PROJECTION] < cut_cornerMinSpacing
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = FALSE 
           } TEMP = corner_err1 
           EXTERNAL default_via8  {
             SPACING <= 0
             CONVEX_TO_CONVEX < cut_cornerMinSpacing
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = TRUE
           } TEMP = corner_err2 
           BOOLEAN corner_err1 OR corner_err2 {
             COMMENT = "$layer_name Spacing   : corner to corner spacing = cut_cornerMinSpacing um "
           } (26 )
           EXTERNAL default_via8  {
             COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
             SPACING < cut_minSpacing
             SET_CORNERS_TO_SPACING = FALSE
             PARALLEL_POINT_PROJECTION = FALSE
             NON_PARALLEL = TRUE
             TOUCH = FALSE
             POINT_TOUCH = FALSE
           } (26 )
        } else {
           EXTERNAL default_via8  {
             COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um (corner to corner spacing = cut_cornerMinSpacing um) "
             SPACING < cut_minSpacing
             CONVEX_TO_CONVEX < cut_cornerMinSpacing
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
           } (26 )
        }
    } else {
       EXTERNAL default_via8  {
          COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
          SPACING < cut_minSpacing
	  BOX_CORNER = FALSE 
	  NON_PARALLEL = TRUE
	  POINT_TOUCH = TRUE
       } (26 )
    }
  }
}
 
/*check blockage spacing*/
if (ignoreBlockage == 0) {
   if (!layer_empty (via8_blockage )) {
      if (cutBlkg_minSpacing > 0) {
	  EXTERNAL via8_blockage  via8  {
              COMMENT = "$layer_name Spacing   : contact & blockage minimum spacing = cutBlkg_minSpacing um"
	      SPACING < cutBlkg_minSpacing
	      BOX_CORNER = FALSE 
	      NON_PARALLEL = TRUE
	      POINT_TOUCH = TRUE
          } (26 )
      }
   }
}
/*check blockage overlap*/ 
/*check shorts between top_level routing and fram_blockages*/
if (cutBlkg_minSpacing > 0 || checkCrossHierShort > 0) {
   if (readCellView > 0) {
       COPY empty {} TEMP = real_blockage
       COPY via8  {} TEMP = top_cut
   } else {
       COPY via8_fram  {} TEMP = real_blockage
       COPY via8_top  {} TEMP = top_cut
   }
   if (ignoreBlockage == 0) {
      BOOLEAN via8_blockage  OR real_blockage {} TEMP=all_blockage
   } else {
      COPY real_blockage {} TEMP=all_blockage
   }
   
   BOOLEAN all_blockage AND top_cut {} TEMP = overlap_shape1
   EXTERNAL all_blockage top_cut {
      SPACING <= 0
      TOUCH = TRUE
   } TEMP = overlap_shape2
   if (checkCrossHierShort > 0) {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
          COMMENT = "$layer_name Short Cross Hierarchy"
      } (26 )
   } else {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
          COMMENT = "$layer_name Overlap   : cut & blockage overlap"
      } (26 )
   }
}
/*check adjacent via number*/
if (cut_adjacentCutRange > 0 && cut_maxNumAdjacentCut > 0) {
    if (router_ignoreSameNetAdjacentViaDRC) {
       EXTERNAL via8  {  
	   SPACING < cut_adjacentCutRange
	   SET_CORNERS_TO_SPACING = FALSE
	   PARALLEL_POINT_PROJECTION = FALSE
	   NON_PARALLEL = TRUE
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
           NODAL = TRUE
       } TEMP=edge_spacing
       EXTERNAL via8  {
	   SPACING < 0
	   CONVEX_TO_EDGE < cut_adjacentCutRange
	   CONVEX_TO_CONVEX < cut_adjacentCutRange
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
           NODAL = TRUE
       } TEMP=corner_spacing
    } else {
       EXTERNAL via8  {  
	   SPACING < cut_adjacentCutRange
	   SET_CORNERS_TO_SPACING = FALSE
	   PARALLEL_POINT_PROJECTION = FALSE
	   NON_PARALLEL = TRUE
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
       } TEMP=edge_spacing
 
       EXTERNAL via8  {
	   SPACING < 0
	   CONVEX_TO_EDGE < cut_adjacentCutRange
	   CONVEX_TO_CONVEX < cut_adjacentCutRange
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
       } TEMP=corner_spacing
    }
    SIZE edge_spacing { UNDERSIZE = 0.0002  } TEMP = edge_spacing1
    SIZE edge_spacing1 { OVERSIZE = 0.0002  } TEMP = edge_spacing2
    BOOLEAN (edge_spacing NOT edge_spacing2) OR edge_spacing1 { } TEMP=edge_spacing
 
    SIZE corner_spacing { UNDERSIZE = 0.0002  } TEMP = corner_spacing1
    SIZE corner_spacing1 { OVERSIZE = 0.0002  } TEMP = corner_spacing2
    BOOLEAN (corner_spacing NOT corner_spacing2) OR corner_spacing1 { } TEMP=corner_spacing
  
    BOOLEAN edge_spacing OR corner_spacing { } TEMP = spacing
 
    SIZE via8  { OVERSIZE = 5* 0.0002  } TEMP = cut
 
    SELECT cut INTERACT spacing {
        POINT_TOUCH = TRUE
        RANGE = [cut_maxNumAdjacentCut + 1, 9999999999 ]
    } TEMP = enclosed_cut
 
    SELECT via8  INSIDE enclosed_cut {
        COMMENT = "$layer_name AdjContNum: maximum number of the adjacent contacts ( cut_adjacentCutRange um) = cut_maxNumAdjacentCut "
    } (26 )
}
 
/*check enclosed via spacing*/
if (cut_enclosedCutNeighborRange > 0 && cut_enclosedCutNumNeighbor > 0) {
    if (cut_enclosedCutDiagViaExcluded) {
       EXTERNAL via8  {
          SPACING < cut_enclosedCutNeighborRange
          SET_CORNERS_TO_SPACING = FALSE
          PARALLEL_POINT_PROJECTION = FALSE
          NON_PARALLEL = TRUE
          BOX_CORNER = FALSE
          SHADOW = FALSE
       } TEMP = edge_spacing
       SELECT via8  TOUCHING edge_spacing {
          RANGE = [cut_enclosedCutNumNeighbor, 9999999999 ]
       } TEMP = enclosed_cut
    } else {
       /* Work around: for SIZE_RECT FLAG_INTERACTION_COUNT parser bug */
       
@ 308 "adrc/adrc_check_via.ev"
       if (cut_enclosedCutNumNeighbor==1) {
          
@-         SIZE_RECT via8  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  0  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==2) {
          
@-         SIZE_RECT via8  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  1  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==3) {
          
@-         SIZE_RECT via8  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  2  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==4) {
          
@-         SIZE_RECT via8  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  3  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==5) {
          
@-         SIZE_RECT via8  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  4  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==6) {
          
@-         SIZE_RECT via8  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  5  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==7) {
          
@-         SIZE_RECT via8  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  6  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==8) {
          
@-         SIZE_RECT via8  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  7  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==9) {
          
@-         SIZE_RECT via8  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  8  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor>9) {
          
@-         SIZE_RECT via8  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  9  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       }
    }
    if (router_ignoreSameNetAdjacentViaDRC) {
      /* Good approximation for same net via filter */
      CENTER_TO_CENTER via8  {
        NODAL=TRUE
        SPACING < cut_enclosedCutNeighborRange + 1.41421*cut_size + 0.0001 
        OUTPUT_VECTOR = TRUE
      } TEMP = c2c_spacing
      SIZE via8  { UNDERSIZE = (cut_size/2.0- 0.0001 ) } TEMP=cut_center
      BOOLEAN c2c_spacing NOT cut_center { } TEMP=c2c_spacing
      SIZE cut_center { OVERSIZE = 0.0002  } TEMP=cut_center
      BOOLEAN c2c_spacing AND via8   { } TEMP=c2c_filter
      SELECT cut_center INTERACT c2c_filter {
        POINT_TOUCH=TRUE
        RANGE = [cut_enclosedCutNumNeighbor, 9999999999 ]
      } TEMP = target_cut
   
      SELECT enclosed_cut ENCLOSING target_cut { } TEMP = enclosed_cut
    }
  
    if (cut_enclosedCutMinSpacing > 0) {
        EXTERNAL enclosed_cut {
        COMMENT = "$layer_name EncContSpc: minimum spacing between enclosed contacts ( cut_enclosedCutNeighborRange um / cut_enclosedCutNumNeighbor ) = cut_enclosedCutMinSpacing "
            SPACING < cut_enclosedCutMinSpacing
            SET_CORNERS_TO_SPACING = TRUE 
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
        } (26 )
    }
 
    if (cut_enclosedCutToNeighborMinSpacing > 0) {
       if (router_ignoreSameNetAdjacentViaDRC) {
          CONNECT { enclosed_cut BY via8  }
          EXTERNAL enclosed_cut via8  {
              COMMENT = "$layer_name EncContSpc: minimum spacing between enclosed and neighboring contacts ( cut_enclosedCutNeighborRange um / cut_enclosedCutNumNeighbor ) = cut_enclosedCutToNeighborMinSpacing "
              SPACING < cut_enclosedCutToNeighborMinSpacing
              SET_CORNERS_TO_SPACING = TRUE 
	      BOX_CORNER = FALSE 
	      NON_PARALLEL = TRUE
	      POINT_TOUCH = TRUE
              NODAL = TRUE
          } (26 )
       } else {
          EXTERNAL enclosed_cut via8  {
              COMMENT = "$layer_name EncContSpc: minimum spacing between enclosed and neighboring contacts ( cut_enclosedCutNeighborRange um / cut_enclosedCutNumNeighbor ) = cut_enclosedCutToNeighborMinSpacing "
              SPACING < cut_enclosedCutToNeighborMinSpacing
              SET_CORNERS_TO_SPACING = TRUE 
	      BOX_CORNER = FALSE 
	      NON_PARALLEL = TRUE
	      POINT_TOUCH = TRUE
          } (26 )
       }
    }
}
 
/*check max stack level, upward only*/
if (cut_maxStackLevel > 0 && cut_stackLevelSpacing > 0) {
    if (cut_maxStackLevel == 1) {
      BOOLEAN via8  AND CUT_LAYER1 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 2) {
      BOOLEAN (via8  AND CUT_LAYER1) AND CUT_LAYER2 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 3) {
      BOOLEAN (via8  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3)
        { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 4) {
      BOOLEAN ((via8  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND CUT_LAYER4 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 5) {
      BOOLEAN ((via8  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND (CUT_LAYER4 AND CUT_LAYER5) { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 6) {
      BOOLEAN ((via8  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND ((CUT_LAYER4 AND CUT_LAYER5) AND CUT_LAYER6) { } TEMP = neighbors
    }
    else if (cut_maxStackLevel >= 7) { 
      BOOLEAN ((via8  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND ((CUT_LAYER4 AND CUT_LAYER5) AND (CUT_LAYER6 AND CUT_LAYER7))
       { } TEMP = neighbors
    }
 
    if (!layer_empty(neighbors)) {
      SELECT CUT_LAYER0 INTERACT neighbors {
        LINE_TOUCH = FALSE POINT_TOUCH = FALSE 
      } TEMP = neighbors
      EXTERNAL neighbors {
	spacing <= cut_stackLevelSpacing
      } TEMP = via_arr_ext
      if (!layer_empty (via_arr_ext)) {
	SELECT neighbors OUTSIDE via_arr_ext {
         COMMENT = "$layer_name StackLevel: maximum stack level = cut_maxStackLevel "
          LINE_TOUCH = FALSE
          POINT_TOUCH = FALSE	    
        } (26 )
      }
      else {
        BOOLEAN via8  AND neighbors {
            COMMENT = "$layer_name StackLevel: maximum stack level = cut_maxStackLevel "
        } (26 )
      }
    }
  }
  else if (cut_maxStackLevel > 0) {
    if (cut_maxStackLevel == 1) {
      COPY CUT_LAYER1 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 2) {
      BOOLEAN CUT_LAYER1 AND CUT_LAYER2 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 3) {
      BOOLEAN CUT_LAYER1 AND (CUT_LAYER2 AND CUT_LAYER3)
        { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 4) {
      BOOLEAN (CUT_LAYER1 AND CUT_LAYER2) AND (CUT_LAYER3 AND CUT_LAYER4)
        { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 5) {
      BOOLEAN ((CUT_LAYER1 AND CUT_LAYER2) AND (CUT_LAYER3 AND CUT_LAYER4))
        AND CUT_LAYER5 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 6) {
      BOOLEAN ((CUT_LAYER6 AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND (CUT_LAYER4 AND CUT_LAYER5) { } TEMP = neighbors
    }
    else if (cut_maxStackLevel >= 7) { 
      BOOLEAN ((CUT_LAYER7 AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND ((CUT_LAYER4 AND CUT_LAYER5) AND CUT_LAYER6) { } TEMP = neighbors
    }
 
    if (!layer_empty (neighbors)) {
        BOOLEAN via8  AND neighbors {
            COMMENT = "$layer_name StackLevel: maximum stack level = cut_maxStackLevel "
        } (26 )
    }
}
 
/*Check fat contact*/
if (cut_fatContactMinSpacing > 0 && cut_fatTblDimension == 0) {
    if (cut_fatContactThreshold1 > 0) {
    	SIZE metal8    { UNDER_OVER = cut_fatContactThreshold1 / 2.0 - 0.0001  } TEMP = m_fat
    	BOOLEAN m_fat AND metal8  { } TEMP = m_fat
 
    	SELECT via8  INSIDE  m_fat { } TEMP = v_fat
 
    	EXTERNAL v_fat via8  {
            COMMENT = "$layer_name FatContSpc: fat contact ( cut_fatContactThreshold1 um, lower layer) minimum spacing = cut_fatContactMinSpacing um"
            SPACING < cut_fatContactMinSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
        } (26 )
    }
 
    if (cut_fatContactThreshold2 > 0) {
    	SIZE metal9    { UNDER_OVER = cut_fatContactThreshold2 / 2.0 - 0.0001  } TEMP = m_fat
    	BOOLEAN m_fat AND metal9  { } TEMP = m_fat
 
    	SELECT via8  INSIDE  m_fat { } TEMP = v_fat
 
    	EXTERNAL v_fat via8  {
            COMMENT = "$layer_name FatContSpc: fat contact ( cut_fatContactThreshold2 um, upper layer) minimum spacing = cut_fatContactMinSpacing um"
            SPACING < cut_fatContactMinSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
        } (26 )
    }
}
/* Avoid empty optimization result parsing error */
if (addEmptyViaCheck) {
   BOOLEAN empty OR empty {
      COMMENT = "$layer_name Empty: Dummy Output"
   } (26 )
   SET addEmptyViaCheck=0;
}
 
/* reset variables */















SET cut_size = 0;
SET cut_minSpacing = 0;
SET cut_sameNetMinSpacing = 0;
SET cut_cornerMinSpacing = 0;
SET cutBlkg_minSpacing = 0;
SET cut_maxNumAdjacentCut = 0;
SET cut_adjacentCutRange = 0;
SET cut_enclosedCutNeighborRange = 0;
SET cut_enclosedCutNumNeighbor = 0;
SET cut_enclosedCutMinSpacing = 0;
SET cut_enclosedCutToNeighborMinSpacing = 0;
SET cut_enclosedCutDiagViaExcluded = 0;
SET cut_maxStackLevel = 0;
SET cut_defaultContactMinSpacing = 0;
SET cut_fatContactThreshold1 = 0;
SET cut_fatContactThreshold2 = 0;
SET cut_fatContactMinSpacing = 0;
SET cut_maxCutSpacing = 0; 
SET cut_fatTblDimension = 0;
SET cut_fatTblThreshold_1 = 0;
SET cut_fatTblThreshold_2 = 0;
SET cut_fatTblNextThreshold_1 = 0;
SET cut_fatTblNextThreshold_2 = 0;
SET cut_fatTblMinCuts = 0;
SET cut_fatTblMinSpacing = 0;
SET cut_fatTblExtensionRange = 0;
SET cut_fatTblExtensionMinCuts = 0;
SET cut_fatTblExtensionMinSpacing = 0;
@ 1445 "adrc/adrc.ev" 2











/*via 9*/
SET layer_name = "Via9";












SET cornerSpacingMode = 0;
SET cut_minSpacing = 2;
SET cut_fatTblDimension = 0;
@ 1 "adrc/adrc_check_via.ev" 1
/* check size */
if (cut_size > 0) {
    INTERNAL via9  {  
        COMMENT = "$layer_name Size      : contact size = cut_size um" 
	DIMENSION = [cut_size , cut_size]
    } (42 )
}
if (cut_minSpacing > 0) {
   if (ignoreContactCodeSpacing) {
      COPY via9  { } TEMP= default_via9 
   } else {
      SIZE metal9  { UNDER_OVER = cut_fatContactThreshold1 } TEMP = m_fat1
      SIZE metal10  { UNDER_OVER = cut_fatContactThreshold2 } TEMP = m_fat2
      BOOLEAN m_fat1 OR m_fat2 {} TEMP=m_fat
      SELECT via9  OUTSIDE m_fat { } TEMP= default_via9 
   }
}
 
/*check basic spacing*/
if (cut_sameNetMinSpacing > 0 && cut_sameNetMinSpacing < cut_minSpacing) {
  CONNECT { default_via9  BY via9  }
  if (cut_cornerMinSpacing > 0) {
    if (cornerSpacingMode == 1) {
        /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
        EXTERNAL default_via9  {
             SPACING <= 0
             CONVEX_TO_CONVEX [POINT_PROJECTION] < cut_cornerMinSpacing
             FLAG_DISCONNECTED = FALSE
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = FALSE
        } TEMP = sameNet_corner_err1
        EXTERNAL default_via9  {
             SPACING <= 0
             CONVEX_TO_CONVEX < cut_cornerMinSpacing
             FLAG_DISCONNECTED = FALSE
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = TRUE
        } TEMP = sameNet_corner_err2 
        BOOLEAN sameNet_corner_err1 OR sameNet_corner_err2 {
             COMMENT = "$layer_name SameNetSpc: corner to corner spacing = cut_cornerMinSpacing um "
        } (42 ) 
        EXTERNAL default_via9  {
             COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = cut_sameNetMinSpacing um "
             SPACING < cut_sameNetMinSpacing
             FLAG_DISCONNECTED = FALSE
             SET_CORNERS_TO_SPACING = FALSE
             PARALLEL_POINT_PROJECTION = FALSE
             NON_PARALLEL = TRUE
             TOUCH = FALSE
             POINT_TOUCH = FALSE
        } (42 )
    } else {
        EXTERNAL default_via9  {
            COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = cut_sameNetMinSpacing um (corner to corner spacing = cut_cornerMinSpacing um) "
            SPACING < cut_sameNetMinSpacing
            CONVEX_TO_CONVEX < cut_cornerMinSpacing
            FLAG_DISCONNECTED = FALSE
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
        } (42 )
    }
  } else {
    EXTERNAL default_via9  {
        COMMENT = "$layer_name SameNetSpc: same-net minimum spacing = cut_sameNetMinSpacing um"
        SPACING < cut_sameNetMinSpacing
	BOX_CORNER = FALSE 
        FLAG_DISCONNECTED = FALSE
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
    } (42 )
  }
  if (cut_cornerMinSpacing > 0) {
    if (cornerSpacingMode == 1) {
        /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
        EXTERNAL default_via9  {
          SPACING <= 0
          CONVEX_TO_CONVEX [POINT_PROJECTION] < cut_cornerMinSpacing
          NON_PARALLEL = TRUE
          POINT_TOUCH = TRUE
          BOX_CORNER = FALSE
          NODAL = TRUE
        } TEMP = diffNet_corner_err1 
        EXTERNAL default_via9  {
          SPACING <= 0
          CONVEX_TO_CONVEX < cut_cornerMinSpacing
          NON_PARALLEL = TRUE
          POINT_TOUCH = TRUE
          BOX_CORNER = TRUE
          NODAL = TRUE
        } TEMP = diffNet_corner_err2 
        BOOLEAN diffNet_corner_err1 OR diffNet_corner_err2 {
          COMMENT = "$layer_name Spacing   : corner to corner spacing = cut_cornerMinSpacing um "
        } (42 )
        EXTERNAL default_via9  {
          COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
          SPACING < cut_minSpacing
          SET_CORNERS_TO_SPACING = FALSE
          PARALLEL_POINT_PROJECTION = FALSE
          NON_PARALLEL = TRUE
          TOUCH = FALSE
          POINT_TOUCH = FALSE
          NODAL = TRUE
        } (42 )
    } else {
        EXTERNAL default_via9  {
          COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um (corner to corner spacing = cut_cornerMinSpacing um) "
          SPACING < cut_minSpacing
          CONVEX_TO_CONVEX < cut_cornerMinSpacing
          NON_PARALLEL = TRUE
          POINT_TOUCH = TRUE
          NODAL = TRUE
        } (42 )
    }
  } else {
    EXTERNAL default_via9  {
      COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
      SPACING < cut_minSpacing
      BOX_CORNER = FALSE 
      NON_PARALLEL = TRUE
      POINT_TOUCH = TRUE
      NODAL = TRUE
    } (42 ) 
  }
} else {
   if (cut_minSpacing > 0) {
     if (cut_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
           /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
           EXTERNAL default_via9  {
             SPACING <= 0
             CONVEX_TO_CONVEX [POINT_PROJECTION] < cut_cornerMinSpacing
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = FALSE 
           } TEMP = corner_err1 
           EXTERNAL default_via9  {
             SPACING <= 0
             CONVEX_TO_CONVEX < cut_cornerMinSpacing
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
             BOX_CORNER = TRUE
           } TEMP = corner_err2 
           BOOLEAN corner_err1 OR corner_err2 {
             COMMENT = "$layer_name Spacing   : corner to corner spacing = cut_cornerMinSpacing um "
           } (42 )
           EXTERNAL default_via9  {
             COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
             SPACING < cut_minSpacing
             SET_CORNERS_TO_SPACING = FALSE
             PARALLEL_POINT_PROJECTION = FALSE
             NON_PARALLEL = TRUE
             TOUCH = FALSE
             POINT_TOUCH = FALSE
           } (42 )
        } else {
           EXTERNAL default_via9  {
             COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um (corner to corner spacing = cut_cornerMinSpacing um) "
             SPACING < cut_minSpacing
             CONVEX_TO_CONVEX < cut_cornerMinSpacing
             NON_PARALLEL = TRUE
             POINT_TOUCH = TRUE
           } (42 )
        }
    } else {
       EXTERNAL default_via9  {
          COMMENT = "$layer_name Spacing   : minimum spacing = cut_minSpacing um"
          SPACING < cut_minSpacing
	  BOX_CORNER = FALSE 
	  NON_PARALLEL = TRUE
	  POINT_TOUCH = TRUE
       } (42 )
    }
  }
}
 
/*check blockage spacing*/
if (ignoreBlockage == 0) {
   if (!layer_empty (via9_blockage )) {
      if (cutBlkg_minSpacing > 0) {
	  EXTERNAL via9_blockage  via9  {
              COMMENT = "$layer_name Spacing   : contact & blockage minimum spacing = cutBlkg_minSpacing um"
	      SPACING < cutBlkg_minSpacing
	      BOX_CORNER = FALSE 
	      NON_PARALLEL = TRUE
	      POINT_TOUCH = TRUE
          } (42 )
      }
   }
}
/*check blockage overlap*/ 
/*check shorts between top_level routing and fram_blockages*/
if (cutBlkg_minSpacing > 0 || checkCrossHierShort > 0) {
   if (readCellView > 0) {
       COPY empty {} TEMP = real_blockage
       COPY via9  {} TEMP = top_cut
   } else {
       COPY via9_fram  {} TEMP = real_blockage
       COPY via9_top  {} TEMP = top_cut
   }
   if (ignoreBlockage == 0) {
      BOOLEAN via9_blockage  OR real_blockage {} TEMP=all_blockage
   } else {
      COPY real_blockage {} TEMP=all_blockage
   }
   
   BOOLEAN all_blockage AND top_cut {} TEMP = overlap_shape1
   EXTERNAL all_blockage top_cut {
      SPACING <= 0
      TOUCH = TRUE
   } TEMP = overlap_shape2
   if (checkCrossHierShort > 0) {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
          COMMENT = "$layer_name Short Cross Hierarchy"
      } (42 )
   } else {
      BOOLEAN overlap_shape1 OR overlap_shape2 {
          COMMENT = "$layer_name Overlap   : cut & blockage overlap"
      } (42 )
   }
}
/*check adjacent via number*/
if (cut_adjacentCutRange > 0 && cut_maxNumAdjacentCut > 0) {
    if (router_ignoreSameNetAdjacentViaDRC) {
       EXTERNAL via9  {  
	   SPACING < cut_adjacentCutRange
	   SET_CORNERS_TO_SPACING = FALSE
	   PARALLEL_POINT_PROJECTION = FALSE
	   NON_PARALLEL = TRUE
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
           NODAL = TRUE
       } TEMP=edge_spacing
       EXTERNAL via9  {
	   SPACING < 0
	   CONVEX_TO_EDGE < cut_adjacentCutRange
	   CONVEX_TO_CONVEX < cut_adjacentCutRange
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
           NODAL = TRUE
       } TEMP=corner_spacing
    } else {
       EXTERNAL via9  {  
	   SPACING < cut_adjacentCutRange
	   SET_CORNERS_TO_SPACING = FALSE
	   PARALLEL_POINT_PROJECTION = FALSE
	   NON_PARALLEL = TRUE
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
       } TEMP=edge_spacing
 
       EXTERNAL via9  {
	   SPACING < 0
	   CONVEX_TO_EDGE < cut_adjacentCutRange
	   CONVEX_TO_CONVEX < cut_adjacentCutRange
	   BOX_CORNER = FALSE
	   SHADOW = FALSE
       } TEMP=corner_spacing
    }
    SIZE edge_spacing { UNDERSIZE = 0.0002  } TEMP = edge_spacing1
    SIZE edge_spacing1 { OVERSIZE = 0.0002  } TEMP = edge_spacing2
    BOOLEAN (edge_spacing NOT edge_spacing2) OR edge_spacing1 { } TEMP=edge_spacing
 
    SIZE corner_spacing { UNDERSIZE = 0.0002  } TEMP = corner_spacing1
    SIZE corner_spacing1 { OVERSIZE = 0.0002  } TEMP = corner_spacing2
    BOOLEAN (corner_spacing NOT corner_spacing2) OR corner_spacing1 { } TEMP=corner_spacing
  
    BOOLEAN edge_spacing OR corner_spacing { } TEMP = spacing
 
    SIZE via9  { OVERSIZE = 5* 0.0002  } TEMP = cut
 
    SELECT cut INTERACT spacing {
        POINT_TOUCH = TRUE
        RANGE = [cut_maxNumAdjacentCut + 1, 9999999999 ]
    } TEMP = enclosed_cut
 
    SELECT via9  INSIDE enclosed_cut {
        COMMENT = "$layer_name AdjContNum: maximum number of the adjacent contacts ( cut_adjacentCutRange um) = cut_maxNumAdjacentCut "
    } (42 )
}
 
/*check enclosed via spacing*/
if (cut_enclosedCutNeighborRange > 0 && cut_enclosedCutNumNeighbor > 0) {
    if (cut_enclosedCutDiagViaExcluded) {
       EXTERNAL via9  {
          SPACING < cut_enclosedCutNeighborRange
          SET_CORNERS_TO_SPACING = FALSE
          PARALLEL_POINT_PROJECTION = FALSE
          NON_PARALLEL = TRUE
          BOX_CORNER = FALSE
          SHADOW = FALSE
       } TEMP = edge_spacing
       SELECT via9  TOUCHING edge_spacing {
          RANGE = [cut_enclosedCutNumNeighbor, 9999999999 ]
       } TEMP = enclosed_cut
    } else {
       /* Work around: for SIZE_RECT FLAG_INTERACTION_COUNT parser bug */
       
@ 308 "adrc/adrc_check_via.ev"
       if (cut_enclosedCutNumNeighbor==1) {
          
@-         SIZE_RECT via9  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  0  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==2) {
          
@-         SIZE_RECT via9  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  1  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==3) {
          
@-         SIZE_RECT via9  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  2  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==4) {
          
@-         SIZE_RECT via9  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  3  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==5) {
          
@-         SIZE_RECT via9  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  4  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==6) {
          
@-         SIZE_RECT via9  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  5  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==7) {
          
@-         SIZE_RECT via9  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  6  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==8) {
          
@-         SIZE_RECT via9  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  7  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor==9) {
          
@-         SIZE_RECT via9  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  8  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       } else if (cut_enclosedCutNumNeighbor>9) {
          
@-         SIZE_RECT via9  { 
@-            RANGE1=[0, 10] 
@-            RANGE2=[0, 10] 
@-            RANGE1_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            RANGE2_EDGESIZE=(cut_enclosedCutNeighborRange/2.0- 0.0001 ) 
@-            FLAG_INTERACTION_COUNT >  9  
@-            CORNER_METHOD = RADIAL 
@-         } TEMP=enclosed_cut 
       }
    }
    if (router_ignoreSameNetAdjacentViaDRC) {
      /* Good approximation for same net via filter */
      CENTER_TO_CENTER via9  {
        NODAL=TRUE
        SPACING < cut_enclosedCutNeighborRange + 1.41421*cut_size + 0.0001 
        OUTPUT_VECTOR = TRUE
      } TEMP = c2c_spacing
      SIZE via9  { UNDERSIZE = (cut_size/2.0- 0.0001 ) } TEMP=cut_center
      BOOLEAN c2c_spacing NOT cut_center { } TEMP=c2c_spacing
      SIZE cut_center { OVERSIZE = 0.0002  } TEMP=cut_center
      BOOLEAN c2c_spacing AND via9   { } TEMP=c2c_filter
      SELECT cut_center INTERACT c2c_filter {
        POINT_TOUCH=TRUE
        RANGE = [cut_enclosedCutNumNeighbor, 9999999999 ]
      } TEMP = target_cut
   
      SELECT enclosed_cut ENCLOSING target_cut { } TEMP = enclosed_cut
    }
  
    if (cut_enclosedCutMinSpacing > 0) {
        EXTERNAL enclosed_cut {
        COMMENT = "$layer_name EncContSpc: minimum spacing between enclosed contacts ( cut_enclosedCutNeighborRange um / cut_enclosedCutNumNeighbor ) = cut_enclosedCutMinSpacing "
            SPACING < cut_enclosedCutMinSpacing
            SET_CORNERS_TO_SPACING = TRUE 
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
        } (42 )
    }
 
    if (cut_enclosedCutToNeighborMinSpacing > 0) {
       if (router_ignoreSameNetAdjacentViaDRC) {
          CONNECT { enclosed_cut BY via9  }
          EXTERNAL enclosed_cut via9  {
              COMMENT = "$layer_name EncContSpc: minimum spacing between enclosed and neighboring contacts ( cut_enclosedCutNeighborRange um / cut_enclosedCutNumNeighbor ) = cut_enclosedCutToNeighborMinSpacing "
              SPACING < cut_enclosedCutToNeighborMinSpacing
              SET_CORNERS_TO_SPACING = TRUE 
	      BOX_CORNER = FALSE 
	      NON_PARALLEL = TRUE
	      POINT_TOUCH = TRUE
              NODAL = TRUE
          } (42 )
       } else {
          EXTERNAL enclosed_cut via9  {
              COMMENT = "$layer_name EncContSpc: minimum spacing between enclosed and neighboring contacts ( cut_enclosedCutNeighborRange um / cut_enclosedCutNumNeighbor ) = cut_enclosedCutToNeighborMinSpacing "
              SPACING < cut_enclosedCutToNeighborMinSpacing
              SET_CORNERS_TO_SPACING = TRUE 
	      BOX_CORNER = FALSE 
	      NON_PARALLEL = TRUE
	      POINT_TOUCH = TRUE
          } (42 )
       }
    }
}
 
/*check max stack level, upward only*/
if (cut_maxStackLevel > 0 && cut_stackLevelSpacing > 0) {
    if (cut_maxStackLevel == 1) {
      BOOLEAN via9  AND CUT_LAYER1 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 2) {
      BOOLEAN (via9  AND CUT_LAYER1) AND CUT_LAYER2 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 3) {
      BOOLEAN (via9  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3)
        { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 4) {
      BOOLEAN ((via9  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND CUT_LAYER4 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 5) {
      BOOLEAN ((via9  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND (CUT_LAYER4 AND CUT_LAYER5) { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 6) {
      BOOLEAN ((via9  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND ((CUT_LAYER4 AND CUT_LAYER5) AND CUT_LAYER6) { } TEMP = neighbors
    }
    else if (cut_maxStackLevel >= 7) { 
      BOOLEAN ((via9  AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND ((CUT_LAYER4 AND CUT_LAYER5) AND (CUT_LAYER6 AND CUT_LAYER7))
       { } TEMP = neighbors
    }
 
    if (!layer_empty(neighbors)) {
      SELECT CUT_LAYER0 INTERACT neighbors {
        LINE_TOUCH = FALSE POINT_TOUCH = FALSE 
      } TEMP = neighbors
      EXTERNAL neighbors {
	spacing <= cut_stackLevelSpacing
      } TEMP = via_arr_ext
      if (!layer_empty (via_arr_ext)) {
	SELECT neighbors OUTSIDE via_arr_ext {
         COMMENT = "$layer_name StackLevel: maximum stack level = cut_maxStackLevel "
          LINE_TOUCH = FALSE
          POINT_TOUCH = FALSE	    
        } (42 )
      }
      else {
        BOOLEAN via9  AND neighbors {
            COMMENT = "$layer_name StackLevel: maximum stack level = cut_maxStackLevel "
        } (42 )
      }
    }
  }
  else if (cut_maxStackLevel > 0) {
    if (cut_maxStackLevel == 1) {
      COPY CUT_LAYER1 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 2) {
      BOOLEAN CUT_LAYER1 AND CUT_LAYER2 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 3) {
      BOOLEAN CUT_LAYER1 AND (CUT_LAYER2 AND CUT_LAYER3)
        { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 4) {
      BOOLEAN (CUT_LAYER1 AND CUT_LAYER2) AND (CUT_LAYER3 AND CUT_LAYER4)
        { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 5) {
      BOOLEAN ((CUT_LAYER1 AND CUT_LAYER2) AND (CUT_LAYER3 AND CUT_LAYER4))
        AND CUT_LAYER5 { } TEMP = neighbors
    }
    else if (cut_maxStackLevel == 6) {
      BOOLEAN ((CUT_LAYER6 AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND (CUT_LAYER4 AND CUT_LAYER5) { } TEMP = neighbors
    }
    else if (cut_maxStackLevel >= 7) { 
      BOOLEAN ((CUT_LAYER7 AND CUT_LAYER1) AND (CUT_LAYER2 AND CUT_LAYER3))
        AND ((CUT_LAYER4 AND CUT_LAYER5) AND CUT_LAYER6) { } TEMP = neighbors
    }
 
    if (!layer_empty (neighbors)) {
        BOOLEAN via9  AND neighbors {
            COMMENT = "$layer_name StackLevel: maximum stack level = cut_maxStackLevel "
        } (42 )
    }
}
 
/*Check fat contact*/
if (cut_fatContactMinSpacing > 0 && cut_fatTblDimension == 0) {
    if (cut_fatContactThreshold1 > 0) {
    	SIZE metal9    { UNDER_OVER = cut_fatContactThreshold1 / 2.0 - 0.0001  } TEMP = m_fat
    	BOOLEAN m_fat AND metal9  { } TEMP = m_fat
 
    	SELECT via9  INSIDE  m_fat { } TEMP = v_fat
 
    	EXTERNAL v_fat via9  {
            COMMENT = "$layer_name FatContSpc: fat contact ( cut_fatContactThreshold1 um, lower layer) minimum spacing = cut_fatContactMinSpacing um"
            SPACING < cut_fatContactMinSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
        } (42 )
    }
 
    if (cut_fatContactThreshold2 > 0) {
    	SIZE metal10    { UNDER_OVER = cut_fatContactThreshold2 / 2.0 - 0.0001  } TEMP = m_fat
    	BOOLEAN m_fat AND metal10  { } TEMP = m_fat
 
    	SELECT via9  INSIDE  m_fat { } TEMP = v_fat
 
    	EXTERNAL v_fat via9  {
            COMMENT = "$layer_name FatContSpc: fat contact ( cut_fatContactThreshold2 um, upper layer) minimum spacing = cut_fatContactMinSpacing um"
            SPACING < cut_fatContactMinSpacing
	    BOX_CORNER = FALSE 
	    NON_PARALLEL = TRUE
	    POINT_TOUCH = TRUE
        } (42 )
    }
}
/* Avoid empty optimization result parsing error */
if (addEmptyViaCheck) {
   BOOLEAN empty OR empty {
      COMMENT = "$layer_name Empty: Dummy Output"
   } (42 )
   SET addEmptyViaCheck=0;
}
 
/* reset variables */















SET cut_size = 0;
SET cut_minSpacing = 0;
SET cut_sameNetMinSpacing = 0;
SET cut_cornerMinSpacing = 0;
SET cutBlkg_minSpacing = 0;
SET cut_maxNumAdjacentCut = 0;
SET cut_adjacentCutRange = 0;
SET cut_enclosedCutNeighborRange = 0;
SET cut_enclosedCutNumNeighbor = 0;
SET cut_enclosedCutMinSpacing = 0;
SET cut_enclosedCutToNeighborMinSpacing = 0;
SET cut_enclosedCutDiagViaExcluded = 0;
SET cut_maxStackLevel = 0;
SET cut_defaultContactMinSpacing = 0;
SET cut_fatContactThreshold1 = 0;
SET cut_fatContactThreshold2 = 0;
SET cut_fatContactMinSpacing = 0;
SET cut_maxCutSpacing = 0; 
SET cut_fatTblDimension = 0;
SET cut_fatTblThreshold_1 = 0;
SET cut_fatTblThreshold_2 = 0;
SET cut_fatTblNextThreshold_1 = 0;
SET cut_fatTblNextThreshold_2 = 0;
SET cut_fatTblMinCuts = 0;
SET cut_fatTblMinSpacing = 0;
SET cut_fatTblExtensionRange = 0;
SET cut_fatTblExtensionMinCuts = 0;
SET cut_fatTblExtensionMinSpacing = 0;
@ 1473 "adrc/adrc.ev" 2











/*Via/Via design rules*/

/*Via/Metal design rules*/
SET diff_endOfLineMode = 0;

/*via 1 / metal 1*/
SET layer_name = "V1/M1";






if (!layer_empty (via1 )) {
    if (!layer_empty (metal1 )) {
        
@ 1 "adrc/adrc_check_diff.ev" 1
/*check spacing*/
if (diff_minSpacing > 0 && diff_netMinSpacing > 0) {
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via1  metal1  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
                NODAL = TRUE
            } TEMP = diffNet_corner_err1
            EXTERNAL via1  metal1  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
                NODAL = TRUE
            } TEMP = diffNet_corner_err2
            BOOLEAN diffNet_corner_err1 OR diffNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (11 )
            EXTERNAL via1  metal1  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NODAL = TRUE
            } (11 )
        } else {
            EXTERNAL via1  metal1  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_netMinSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (11 )
        }
    } else {
        EXTERNAL via1  metal1  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
            SPACING < diff_netMinSpacing
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
            NODAL = TRUE
        } (11 )
    }
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via1  metal1  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
            } TEMP = sameNet_corner_err1
            EXTERNAL via1  metal1  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
            } TEMP = sameNet_corner_err2
            BOOLEAN sameNet_corner_err1 OR sameNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (11 )
            EXTERNAL via1  metal1  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                FLAG_DISCONNECTED = FALSE
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
            } (11 )
        } else {
            EXTERNAL via1  metal1  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_minSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (11 )
        }
    } else {
        EXTERNAL via1  metal1  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
            SPACING < diff_minSpacing
            FLAG_DISCONNECTED = FALSE
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
        } (11 )
    }
} else {
    if (diff_netMinSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via1  metal1  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                    NODAL = TRUE
                } TEMP = corner_err1
                EXTERNAL via1  metal1  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                    NODAL = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (11 )
                EXTERNAL via1  metal1  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                    SPACING < diff_netMinSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                    NODAL = TRUE
                } (11 )
            } else {
                EXTERNAL via1  metal1  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_netMinSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                    NODAL = TRUE
                } (11 )
            }
        } else {
            EXTERNAL via1  metal1  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (11 )
        }
    } else if (diff_minSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via1  metal1  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                } TEMP = corner_err1
                EXTERNAL via1  metal1  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (11 )
                EXTERNAL via1  metal1  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                    SPACING < diff_minSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                } (11 )
            } else {
                EXTERNAL via1  metal1  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_minSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                } (11 )
            }
        } else {
            EXTERNAL via1  metal1  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (11 )
        }
    }
}
 
/*check enclosure*/
if (diff_minEnclosure > 0) {
    ENCLOSE via1  BY metal1  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
        SPACING < diff_minEnclosure
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
	TOUCH = TRUE
    } (11 )
    BOOLEAN via1  NOT metal1  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
    } (11 )
}
 
/*check end_of_line enclosure*/
if (diff_endOfLineEnclosure > 0) {
    if (diff_minEnclosure  == 0) {
       BOOLEAN via1  NOT metal1  {
           COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
       } (11 )
    }
    if (diff_endOfLineMode == 0) {
        ENCLOSE via1  BY metal1  {
	    SPACING < diff_endOfLineEnclosure
	    SET_CORNERS_TO_SPACING = FALSE
	    PARALLEL_POINT_PROJECTION = FALSE
	    SHADOW_OTHER_LAYER = TRUE  
	    TOUCH = TRUE
	    POINT_TOUCH = FALSE
	    NON_PARALLEL = TRUE
            OUTPUT_EDGES = TRUE
        } TEMP = violation
 
        SELECT_EDGE via1  TOUCHING violation {  } TEMP = edges
        SELECT_VECTOR edges { ANGLE_RANGE = [0, 0] } TEMP = h_edges
        SELECT_VECTOR edges { ANGLE_RANGE = [90, 90] } TEMP = v_edges
        SELECT h_edges INTERACT v_edges { POINT_TOUCH = TRUE } TEMP = h_edges
 
        SELECT via1  ENCLOSING h_edges {
            COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
        } (11 )
    }
    else {
    }
}
 
/*check stackable*/
if (diff_not_stackable > 0) {
     BOOLEAN via1  AND metal1  {
        COMMENT = "$layer_name Stackable: not stackable"
    } (11 )
}
/*check fat metal via keep-out area*/
if (diff_fatTblViaKeepoutThreshold > 0 && diff_fatTblViaKeepoutMinSize > 0 && diff_fatTblViaKeepoutEnclosure > 0) {
    if (diff_fatTblViaKeepoutThreshold > 0) {
        if ((diff_fatTblViaKeepoutThreshold / 2.0) > 0.0001 ) {
           SIZE metal1  { UNDER_OVER = diff_fatTblViaKeepoutThreshold / 2.0 - 0.0001  } TEMP = fat_candidate
           if (diff_fatTblViaKeepoutNextThreshold > 0) {
              SIZE fat_candidate { UNDER_OVER = diff_fatTblViaKeepoutNextThreshold / 2.0 - 0.0001  } TEMP = fat_next
              BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
              BOOLEAN fat AND metal1  { } TEMP = fat
              SET diff_fatTblViaKeepoutNextThreshold = 0;
           } else {
              BOOLEAN fat_candidate AND metal1  {  } TEMP = fat
           }
        } else {
           COPY metal1  { } TEMP = fat
           COPY metal1  { } TEMP = fat_candidate 
        }
    }
    VERTEX fat_candidate {
       CONVEX = TRUE
       SIZE = 0.0002 
    } TEMP = fat_corners
    VERTEX fat {
       CONVEX = TRUE
       SIZE = 0.0002 
    } TEMP = wire_corners
    SELECT wire_corners INTERACT fat_corners { } TEMP = wire_corners
    SELECT_EDGE fat INTERACT wire_corners { } TEMP = edge_corners
    SELECT_VECTOR edge_corners {
       LENGTH_RANGE = [0, diff_fatTblViaKeepoutMinSize- 0.0001 ]
    } TEMP = edge_tmp1
    BOOLEAN edge_corners NOT edge_tmp1 { } TEMP = edge_tmp2
    SELECT wire_corners OUTSIDE edge_tmp1 {  } TEMP = real_corners
    BOOLEAN edge_tmp2 AND real_corners { } TEMP = real_edge
    SIZE real_edge {
       VSIZE_HEAD = diff_fatTblViaKeepoutMinSize-2* 0.0002 
       VSIZE_TAIL = diff_fatTblViaKeepoutMinSize-2* 0.0002 
       VSIZE_INSIDE = diff_fatTblViaKeepoutEnclosure- 0.0002 
    } TEMP = forb_corners
    SELECT via1  INSIDE fat { } TEMP = v_fat
    /* Work around: need an accurate via_cluster */
    SELECT via_cluster INSIDE fat { } TEMP = v_fat_cluster
    SELECT v_fat INTERACT forb_corners { } TEMP = bad_vias
    BOOLEAN v_fat NOT bad_vias { } TEMP = good_vias
    SELECT v_fat_cluster OUTSIDE good_vias { } TEMP = bad_v_fat_cluster
    SELECT v_fat INTERACT bad_v_fat_cluster {
       COMMENT = "$layer_name ViaKepOut: fat metal ( diff_fatTblViaKeepoutThreshold um) contact keep-out area ( diff_fatTblViaKeepoutMinSize um, diff_fatTblViaKeepoutEnclosure um) "
    } (11 )
}
 
/* reset variables */



 
SET diff_minSpacing = 0;
SET diff_netMinSpacing = 0;
SET diff_cornerMinSpacing = 0;
SET diff_minEnclosure = 0;
SET diff_endOfLineEnclosure = 0;
SET diff_not_stackable = 0;
SET diff_fatTblViaKeepoutThreshold = 0;
SET diff_fatTblViaKeepoutNextThreshold = 0;
SET diff_fatTblViaKeepoutMinSize = 0;
SET diff_fatTblViaKeepoutEnclosure = 0;
@ 1499 "adrc/adrc.ev" 2

    }
}
DISCONNECT


/*via 2 / metal 2*/
SET layer_name = "V2/M2";





LOAD_CONNECT_DB all_layer

if (!layer_empty (via2 )) {
    if (!layer_empty (metal2 )) {
        
@ 1 "adrc/adrc_check_diff.ev" 1
/*check spacing*/
if (diff_minSpacing > 0 && diff_netMinSpacing > 0) {
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via2  metal2  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
                NODAL = TRUE
            } TEMP = diffNet_corner_err1
            EXTERNAL via2  metal2  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
                NODAL = TRUE
            } TEMP = diffNet_corner_err2
            BOOLEAN diffNet_corner_err1 OR diffNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (13 )
            EXTERNAL via2  metal2  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NODAL = TRUE
            } (13 )
        } else {
            EXTERNAL via2  metal2  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_netMinSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (13 )
        }
    } else {
        EXTERNAL via2  metal2  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
            SPACING < diff_netMinSpacing
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
            NODAL = TRUE
        } (13 )
    }
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via2  metal2  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
            } TEMP = sameNet_corner_err1
            EXTERNAL via2  metal2  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
            } TEMP = sameNet_corner_err2
            BOOLEAN sameNet_corner_err1 OR sameNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (13 )
            EXTERNAL via2  metal2  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                FLAG_DISCONNECTED = FALSE
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
            } (13 )
        } else {
            EXTERNAL via2  metal2  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_minSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (13 )
        }
    } else {
        EXTERNAL via2  metal2  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
            SPACING < diff_minSpacing
            FLAG_DISCONNECTED = FALSE
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
        } (13 )
    }
} else {
    if (diff_netMinSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via2  metal2  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                    NODAL = TRUE
                } TEMP = corner_err1
                EXTERNAL via2  metal2  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                    NODAL = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (13 )
                EXTERNAL via2  metal2  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                    SPACING < diff_netMinSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                    NODAL = TRUE
                } (13 )
            } else {
                EXTERNAL via2  metal2  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_netMinSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                    NODAL = TRUE
                } (13 )
            }
        } else {
            EXTERNAL via2  metal2  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (13 )
        }
    } else if (diff_minSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via2  metal2  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                } TEMP = corner_err1
                EXTERNAL via2  metal2  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (13 )
                EXTERNAL via2  metal2  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                    SPACING < diff_minSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                } (13 )
            } else {
                EXTERNAL via2  metal2  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_minSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                } (13 )
            }
        } else {
            EXTERNAL via2  metal2  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (13 )
        }
    }
}
 
/*check enclosure*/
if (diff_minEnclosure > 0) {
    ENCLOSE via2  BY metal2  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
        SPACING < diff_minEnclosure
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
	TOUCH = TRUE
    } (13 )
    BOOLEAN via2  NOT metal2  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
    } (13 )
}
 
/*check end_of_line enclosure*/
if (diff_endOfLineEnclosure > 0) {
    if (diff_minEnclosure  == 0) {
       BOOLEAN via2  NOT metal2  {
           COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
       } (13 )
    }
    if (diff_endOfLineMode == 0) {
        ENCLOSE via2  BY metal2  {
	    SPACING < diff_endOfLineEnclosure
	    SET_CORNERS_TO_SPACING = FALSE
	    PARALLEL_POINT_PROJECTION = FALSE
	    SHADOW_OTHER_LAYER = TRUE  
	    TOUCH = TRUE
	    POINT_TOUCH = FALSE
	    NON_PARALLEL = TRUE
            OUTPUT_EDGES = TRUE
        } TEMP = violation
 
        SELECT_EDGE via2  TOUCHING violation {  } TEMP = edges
        SELECT_VECTOR edges { ANGLE_RANGE = [0, 0] } TEMP = h_edges
        SELECT_VECTOR edges { ANGLE_RANGE = [90, 90] } TEMP = v_edges
        SELECT h_edges INTERACT v_edges { POINT_TOUCH = TRUE } TEMP = h_edges
 
        SELECT via2  ENCLOSING h_edges {
            COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
        } (13 )
    }
    else {
    }
}
 
/*check stackable*/
if (diff_not_stackable > 0) {
     BOOLEAN via2  AND metal2  {
        COMMENT = "$layer_name Stackable: not stackable"
    } (13 )
}
/*check fat metal via keep-out area*/
if (diff_fatTblViaKeepoutThreshold > 0 && diff_fatTblViaKeepoutMinSize > 0 && diff_fatTblViaKeepoutEnclosure > 0) {
    if (diff_fatTblViaKeepoutThreshold > 0) {
        if ((diff_fatTblViaKeepoutThreshold / 2.0) > 0.0001 ) {
           SIZE metal2  { UNDER_OVER = diff_fatTblViaKeepoutThreshold / 2.0 - 0.0001  } TEMP = fat_candidate
           if (diff_fatTblViaKeepoutNextThreshold > 0) {
              SIZE fat_candidate { UNDER_OVER = diff_fatTblViaKeepoutNextThreshold / 2.0 - 0.0001  } TEMP = fat_next
              BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
              BOOLEAN fat AND metal2  { } TEMP = fat
              SET diff_fatTblViaKeepoutNextThreshold = 0;
           } else {
              BOOLEAN fat_candidate AND metal2  {  } TEMP = fat
           }
        } else {
           COPY metal2  { } TEMP = fat
           COPY metal2  { } TEMP = fat_candidate 
        }
    }
    VERTEX fat_candidate {
       CONVEX = TRUE
       SIZE = 0.0002 
    } TEMP = fat_corners
    VERTEX fat {
       CONVEX = TRUE
       SIZE = 0.0002 
    } TEMP = wire_corners
    SELECT wire_corners INTERACT fat_corners { } TEMP = wire_corners
    SELECT_EDGE fat INTERACT wire_corners { } TEMP = edge_corners
    SELECT_VECTOR edge_corners {
       LENGTH_RANGE = [0, diff_fatTblViaKeepoutMinSize- 0.0001 ]
    } TEMP = edge_tmp1
    BOOLEAN edge_corners NOT edge_tmp1 { } TEMP = edge_tmp2
    SELECT wire_corners OUTSIDE edge_tmp1 {  } TEMP = real_corners
    BOOLEAN edge_tmp2 AND real_corners { } TEMP = real_edge
    SIZE real_edge {
       VSIZE_HEAD = diff_fatTblViaKeepoutMinSize-2* 0.0002 
       VSIZE_TAIL = diff_fatTblViaKeepoutMinSize-2* 0.0002 
       VSIZE_INSIDE = diff_fatTblViaKeepoutEnclosure- 0.0002 
    } TEMP = forb_corners
    SELECT via2  INSIDE fat { } TEMP = v_fat
    /* Work around: need an accurate via_cluster */
    SELECT via_cluster INSIDE fat { } TEMP = v_fat_cluster
    SELECT v_fat INTERACT forb_corners { } TEMP = bad_vias
    BOOLEAN v_fat NOT bad_vias { } TEMP = good_vias
    SELECT v_fat_cluster OUTSIDE good_vias { } TEMP = bad_v_fat_cluster
    SELECT v_fat INTERACT bad_v_fat_cluster {
       COMMENT = "$layer_name ViaKepOut: fat metal ( diff_fatTblViaKeepoutThreshold um) contact keep-out area ( diff_fatTblViaKeepoutMinSize um, diff_fatTblViaKeepoutEnclosure um) "
    } (13 )
}
 
/* reset variables */



 
SET diff_minSpacing = 0;
SET diff_netMinSpacing = 0;
SET diff_cornerMinSpacing = 0;
SET diff_minEnclosure = 0;
SET diff_endOfLineEnclosure = 0;
SET diff_not_stackable = 0;
SET diff_fatTblViaKeepoutThreshold = 0;
SET diff_fatTblViaKeepoutNextThreshold = 0;
SET diff_fatTblViaKeepoutMinSize = 0;
SET diff_fatTblViaKeepoutEnclosure = 0;
@ 1516 "adrc/adrc.ev" 2

    }
}
DISCONNECT


/*via 3 / metal 3*/
SET layer_name = "V3/M3";





LOAD_CONNECT_DB all_layer

if (!layer_empty (via3 )) {
    if (!layer_empty (metal3 )) {
        
@ 1 "adrc/adrc_check_diff.ev" 1
/*check spacing*/
if (diff_minSpacing > 0 && diff_netMinSpacing > 0) {
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via3  metal3  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
                NODAL = TRUE
            } TEMP = diffNet_corner_err1
            EXTERNAL via3  metal3  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
                NODAL = TRUE
            } TEMP = diffNet_corner_err2
            BOOLEAN diffNet_corner_err1 OR diffNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (15 )
            EXTERNAL via3  metal3  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NODAL = TRUE
            } (15 )
        } else {
            EXTERNAL via3  metal3  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_netMinSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (15 )
        }
    } else {
        EXTERNAL via3  metal3  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
            SPACING < diff_netMinSpacing
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
            NODAL = TRUE
        } (15 )
    }
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via3  metal3  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
            } TEMP = sameNet_corner_err1
            EXTERNAL via3  metal3  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
            } TEMP = sameNet_corner_err2
            BOOLEAN sameNet_corner_err1 OR sameNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (15 )
            EXTERNAL via3  metal3  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                FLAG_DISCONNECTED = FALSE
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
            } (15 )
        } else {
            EXTERNAL via3  metal3  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_minSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (15 )
        }
    } else {
        EXTERNAL via3  metal3  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
            SPACING < diff_minSpacing
            FLAG_DISCONNECTED = FALSE
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
        } (15 )
    }
} else {
    if (diff_netMinSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via3  metal3  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                    NODAL = TRUE
                } TEMP = corner_err1
                EXTERNAL via3  metal3  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                    NODAL = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (15 )
                EXTERNAL via3  metal3  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                    SPACING < diff_netMinSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                    NODAL = TRUE
                } (15 )
            } else {
                EXTERNAL via3  metal3  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_netMinSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                    NODAL = TRUE
                } (15 )
            }
        } else {
            EXTERNAL via3  metal3  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (15 )
        }
    } else if (diff_minSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via3  metal3  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                } TEMP = corner_err1
                EXTERNAL via3  metal3  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (15 )
                EXTERNAL via3  metal3  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                    SPACING < diff_minSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                } (15 )
            } else {
                EXTERNAL via3  metal3  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_minSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                } (15 )
            }
        } else {
            EXTERNAL via3  metal3  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (15 )
        }
    }
}
 
/*check enclosure*/
if (diff_minEnclosure > 0) {
    ENCLOSE via3  BY metal3  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
        SPACING < diff_minEnclosure
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
	TOUCH = TRUE
    } (15 )
    BOOLEAN via3  NOT metal3  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
    } (15 )
}
 
/*check end_of_line enclosure*/
if (diff_endOfLineEnclosure > 0) {
    if (diff_minEnclosure  == 0) {
       BOOLEAN via3  NOT metal3  {
           COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
       } (15 )
    }
    if (diff_endOfLineMode == 0) {
        ENCLOSE via3  BY metal3  {
	    SPACING < diff_endOfLineEnclosure
	    SET_CORNERS_TO_SPACING = FALSE
	    PARALLEL_POINT_PROJECTION = FALSE
	    SHADOW_OTHER_LAYER = TRUE  
	    TOUCH = TRUE
	    POINT_TOUCH = FALSE
	    NON_PARALLEL = TRUE
            OUTPUT_EDGES = TRUE
        } TEMP = violation
 
        SELECT_EDGE via3  TOUCHING violation {  } TEMP = edges
        SELECT_VECTOR edges { ANGLE_RANGE = [0, 0] } TEMP = h_edges
        SELECT_VECTOR edges { ANGLE_RANGE = [90, 90] } TEMP = v_edges
        SELECT h_edges INTERACT v_edges { POINT_TOUCH = TRUE } TEMP = h_edges
 
        SELECT via3  ENCLOSING h_edges {
            COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
        } (15 )
    }
    else {
    }
}
 
/*check stackable*/
if (diff_not_stackable > 0) {
     BOOLEAN via3  AND metal3  {
        COMMENT = "$layer_name Stackable: not stackable"
    } (15 )
}
/*check fat metal via keep-out area*/
if (diff_fatTblViaKeepoutThreshold > 0 && diff_fatTblViaKeepoutMinSize > 0 && diff_fatTblViaKeepoutEnclosure > 0) {
    if (diff_fatTblViaKeepoutThreshold > 0) {
        if ((diff_fatTblViaKeepoutThreshold / 2.0) > 0.0001 ) {
           SIZE metal3  { UNDER_OVER = diff_fatTblViaKeepoutThreshold / 2.0 - 0.0001  } TEMP = fat_candidate
           if (diff_fatTblViaKeepoutNextThreshold > 0) {
              SIZE fat_candidate { UNDER_OVER = diff_fatTblViaKeepoutNextThreshold / 2.0 - 0.0001  } TEMP = fat_next
              BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
              BOOLEAN fat AND metal3  { } TEMP = fat
              SET diff_fatTblViaKeepoutNextThreshold = 0;
           } else {
              BOOLEAN fat_candidate AND metal3  {  } TEMP = fat
           }
        } else {
           COPY metal3  { } TEMP = fat
           COPY metal3  { } TEMP = fat_candidate 
        }
    }
    VERTEX fat_candidate {
       CONVEX = TRUE
       SIZE = 0.0002 
    } TEMP = fat_corners
    VERTEX fat {
       CONVEX = TRUE
       SIZE = 0.0002 
    } TEMP = wire_corners
    SELECT wire_corners INTERACT fat_corners { } TEMP = wire_corners
    SELECT_EDGE fat INTERACT wire_corners { } TEMP = edge_corners
    SELECT_VECTOR edge_corners {
       LENGTH_RANGE = [0, diff_fatTblViaKeepoutMinSize- 0.0001 ]
    } TEMP = edge_tmp1
    BOOLEAN edge_corners NOT edge_tmp1 { } TEMP = edge_tmp2
    SELECT wire_corners OUTSIDE edge_tmp1 {  } TEMP = real_corners
    BOOLEAN edge_tmp2 AND real_corners { } TEMP = real_edge
    SIZE real_edge {
       VSIZE_HEAD = diff_fatTblViaKeepoutMinSize-2* 0.0002 
       VSIZE_TAIL = diff_fatTblViaKeepoutMinSize-2* 0.0002 
       VSIZE_INSIDE = diff_fatTblViaKeepoutEnclosure- 0.0002 
    } TEMP = forb_corners
    SELECT via3  INSIDE fat { } TEMP = v_fat
    /* Work around: need an accurate via_cluster */
    SELECT via_cluster INSIDE fat { } TEMP = v_fat_cluster
    SELECT v_fat INTERACT forb_corners { } TEMP = bad_vias
    BOOLEAN v_fat NOT bad_vias { } TEMP = good_vias
    SELECT v_fat_cluster OUTSIDE good_vias { } TEMP = bad_v_fat_cluster
    SELECT v_fat INTERACT bad_v_fat_cluster {
       COMMENT = "$layer_name ViaKepOut: fat metal ( diff_fatTblViaKeepoutThreshold um) contact keep-out area ( diff_fatTblViaKeepoutMinSize um, diff_fatTblViaKeepoutEnclosure um) "
    } (15 )
}
 
/* reset variables */



 
SET diff_minSpacing = 0;
SET diff_netMinSpacing = 0;
SET diff_cornerMinSpacing = 0;
SET diff_minEnclosure = 0;
SET diff_endOfLineEnclosure = 0;
SET diff_not_stackable = 0;
SET diff_fatTblViaKeepoutThreshold = 0;
SET diff_fatTblViaKeepoutNextThreshold = 0;
SET diff_fatTblViaKeepoutMinSize = 0;
SET diff_fatTblViaKeepoutEnclosure = 0;
@ 1533 "adrc/adrc.ev" 2

    }
}
DISCONNECT


/*via 4 / metal 4*/
SET layer_name = "V4/M4";





LOAD_CONNECT_DB all_layer

if (!layer_empty (via4 )) {
    if (!layer_empty (metal4 )) {
        
@ 1 "adrc/adrc_check_diff.ev" 1
/*check spacing*/
if (diff_minSpacing > 0 && diff_netMinSpacing > 0) {
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via4  metal4  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
                NODAL = TRUE
            } TEMP = diffNet_corner_err1
            EXTERNAL via4  metal4  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
                NODAL = TRUE
            } TEMP = diffNet_corner_err2
            BOOLEAN diffNet_corner_err1 OR diffNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (17 )
            EXTERNAL via4  metal4  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NODAL = TRUE
            } (17 )
        } else {
            EXTERNAL via4  metal4  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_netMinSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (17 )
        }
    } else {
        EXTERNAL via4  metal4  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
            SPACING < diff_netMinSpacing
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
            NODAL = TRUE
        } (17 )
    }
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via4  metal4  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
            } TEMP = sameNet_corner_err1
            EXTERNAL via4  metal4  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
            } TEMP = sameNet_corner_err2
            BOOLEAN sameNet_corner_err1 OR sameNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (17 )
            EXTERNAL via4  metal4  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                FLAG_DISCONNECTED = FALSE
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
            } (17 )
        } else {
            EXTERNAL via4  metal4  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_minSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (17 )
        }
    } else {
        EXTERNAL via4  metal4  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
            SPACING < diff_minSpacing
            FLAG_DISCONNECTED = FALSE
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
        } (17 )
    }
} else {
    if (diff_netMinSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via4  metal4  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                    NODAL = TRUE
                } TEMP = corner_err1
                EXTERNAL via4  metal4  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                    NODAL = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (17 )
                EXTERNAL via4  metal4  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                    SPACING < diff_netMinSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                    NODAL = TRUE
                } (17 )
            } else {
                EXTERNAL via4  metal4  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_netMinSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                    NODAL = TRUE
                } (17 )
            }
        } else {
            EXTERNAL via4  metal4  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (17 )
        }
    } else if (diff_minSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via4  metal4  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                } TEMP = corner_err1
                EXTERNAL via4  metal4  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (17 )
                EXTERNAL via4  metal4  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                    SPACING < diff_minSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                } (17 )
            } else {
                EXTERNAL via4  metal4  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_minSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                } (17 )
            }
        } else {
            EXTERNAL via4  metal4  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (17 )
        }
    }
}
 
/*check enclosure*/
if (diff_minEnclosure > 0) {
    ENCLOSE via4  BY metal4  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
        SPACING < diff_minEnclosure
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
	TOUCH = TRUE
    } (17 )
    BOOLEAN via4  NOT metal4  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
    } (17 )
}
 
/*check end_of_line enclosure*/
if (diff_endOfLineEnclosure > 0) {
    if (diff_minEnclosure  == 0) {
       BOOLEAN via4  NOT metal4  {
           COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
       } (17 )
    }
    if (diff_endOfLineMode == 0) {
        ENCLOSE via4  BY metal4  {
	    SPACING < diff_endOfLineEnclosure
	    SET_CORNERS_TO_SPACING = FALSE
	    PARALLEL_POINT_PROJECTION = FALSE
	    SHADOW_OTHER_LAYER = TRUE  
	    TOUCH = TRUE
	    POINT_TOUCH = FALSE
	    NON_PARALLEL = TRUE
            OUTPUT_EDGES = TRUE
        } TEMP = violation
 
        SELECT_EDGE via4  TOUCHING violation {  } TEMP = edges
        SELECT_VECTOR edges { ANGLE_RANGE = [0, 0] } TEMP = h_edges
        SELECT_VECTOR edges { ANGLE_RANGE = [90, 90] } TEMP = v_edges
        SELECT h_edges INTERACT v_edges { POINT_TOUCH = TRUE } TEMP = h_edges
 
        SELECT via4  ENCLOSING h_edges {
            COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
        } (17 )
    }
    else {
    }
}
 
/*check stackable*/
if (diff_not_stackable > 0) {
     BOOLEAN via4  AND metal4  {
        COMMENT = "$layer_name Stackable: not stackable"
    } (17 )
}
/*check fat metal via keep-out area*/
if (diff_fatTblViaKeepoutThreshold > 0 && diff_fatTblViaKeepoutMinSize > 0 && diff_fatTblViaKeepoutEnclosure > 0) {
    if (diff_fatTblViaKeepoutThreshold > 0) {
        if ((diff_fatTblViaKeepoutThreshold / 2.0) > 0.0001 ) {
           SIZE metal4  { UNDER_OVER = diff_fatTblViaKeepoutThreshold / 2.0 - 0.0001  } TEMP = fat_candidate
           if (diff_fatTblViaKeepoutNextThreshold > 0) {
              SIZE fat_candidate { UNDER_OVER = diff_fatTblViaKeepoutNextThreshold / 2.0 - 0.0001  } TEMP = fat_next
              BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
              BOOLEAN fat AND metal4  { } TEMP = fat
              SET diff_fatTblViaKeepoutNextThreshold = 0;
           } else {
              BOOLEAN fat_candidate AND metal4  {  } TEMP = fat
           }
        } else {
           COPY metal4  { } TEMP = fat
           COPY metal4  { } TEMP = fat_candidate 
        }
    }
    VERTEX fat_candidate {
       CONVEX = TRUE
       SIZE = 0.0002 
    } TEMP = fat_corners
    VERTEX fat {
       CONVEX = TRUE
       SIZE = 0.0002 
    } TEMP = wire_corners
    SELECT wire_corners INTERACT fat_corners { } TEMP = wire_corners
    SELECT_EDGE fat INTERACT wire_corners { } TEMP = edge_corners
    SELECT_VECTOR edge_corners {
       LENGTH_RANGE = [0, diff_fatTblViaKeepoutMinSize- 0.0001 ]
    } TEMP = edge_tmp1
    BOOLEAN edge_corners NOT edge_tmp1 { } TEMP = edge_tmp2
    SELECT wire_corners OUTSIDE edge_tmp1 {  } TEMP = real_corners
    BOOLEAN edge_tmp2 AND real_corners { } TEMP = real_edge
    SIZE real_edge {
       VSIZE_HEAD = diff_fatTblViaKeepoutMinSize-2* 0.0002 
       VSIZE_TAIL = diff_fatTblViaKeepoutMinSize-2* 0.0002 
       VSIZE_INSIDE = diff_fatTblViaKeepoutEnclosure- 0.0002 
    } TEMP = forb_corners
    SELECT via4  INSIDE fat { } TEMP = v_fat
    /* Work around: need an accurate via_cluster */
    SELECT via_cluster INSIDE fat { } TEMP = v_fat_cluster
    SELECT v_fat INTERACT forb_corners { } TEMP = bad_vias
    BOOLEAN v_fat NOT bad_vias { } TEMP = good_vias
    SELECT v_fat_cluster OUTSIDE good_vias { } TEMP = bad_v_fat_cluster
    SELECT v_fat INTERACT bad_v_fat_cluster {
       COMMENT = "$layer_name ViaKepOut: fat metal ( diff_fatTblViaKeepoutThreshold um) contact keep-out area ( diff_fatTblViaKeepoutMinSize um, diff_fatTblViaKeepoutEnclosure um) "
    } (17 )
}
 
/* reset variables */



 
SET diff_minSpacing = 0;
SET diff_netMinSpacing = 0;
SET diff_cornerMinSpacing = 0;
SET diff_minEnclosure = 0;
SET diff_endOfLineEnclosure = 0;
SET diff_not_stackable = 0;
SET diff_fatTblViaKeepoutThreshold = 0;
SET diff_fatTblViaKeepoutNextThreshold = 0;
SET diff_fatTblViaKeepoutMinSize = 0;
SET diff_fatTblViaKeepoutEnclosure = 0;
@ 1550 "adrc/adrc.ev" 2

    }
}
DISCONNECT


/*via 5 / metal 5*/
SET layer_name = "V5/M5";





LOAD_CONNECT_DB all_layer

if (!layer_empty (via5 )) {
    if (!layer_empty (metal5 )) {
        
@ 1 "adrc/adrc_check_diff.ev" 1
/*check spacing*/
if (diff_minSpacing > 0 && diff_netMinSpacing > 0) {
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via5  metal5  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
                NODAL = TRUE
            } TEMP = diffNet_corner_err1
            EXTERNAL via5  metal5  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
                NODAL = TRUE
            } TEMP = diffNet_corner_err2
            BOOLEAN diffNet_corner_err1 OR diffNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (19 )
            EXTERNAL via5  metal5  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NODAL = TRUE
            } (19 )
        } else {
            EXTERNAL via5  metal5  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_netMinSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (19 )
        }
    } else {
        EXTERNAL via5  metal5  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
            SPACING < diff_netMinSpacing
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
            NODAL = TRUE
        } (19 )
    }
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via5  metal5  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
            } TEMP = sameNet_corner_err1
            EXTERNAL via5  metal5  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
            } TEMP = sameNet_corner_err2
            BOOLEAN sameNet_corner_err1 OR sameNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (19 )
            EXTERNAL via5  metal5  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                FLAG_DISCONNECTED = FALSE
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
            } (19 )
        } else {
            EXTERNAL via5  metal5  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_minSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (19 )
        }
    } else {
        EXTERNAL via5  metal5  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
            SPACING < diff_minSpacing
            FLAG_DISCONNECTED = FALSE
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
        } (19 )
    }
} else {
    if (diff_netMinSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via5  metal5  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                    NODAL = TRUE
                } TEMP = corner_err1
                EXTERNAL via5  metal5  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                    NODAL = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (19 )
                EXTERNAL via5  metal5  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                    SPACING < diff_netMinSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                    NODAL = TRUE
                } (19 )
            } else {
                EXTERNAL via5  metal5  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_netMinSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                    NODAL = TRUE
                } (19 )
            }
        } else {
            EXTERNAL via5  metal5  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (19 )
        }
    } else if (diff_minSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via5  metal5  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                } TEMP = corner_err1
                EXTERNAL via5  metal5  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (19 )
                EXTERNAL via5  metal5  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                    SPACING < diff_minSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                } (19 )
            } else {
                EXTERNAL via5  metal5  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_minSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                } (19 )
            }
        } else {
            EXTERNAL via5  metal5  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (19 )
        }
    }
}
 
/*check enclosure*/
if (diff_minEnclosure > 0) {
    ENCLOSE via5  BY metal5  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
        SPACING < diff_minEnclosure
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
	TOUCH = TRUE
    } (19 )
    BOOLEAN via5  NOT metal5  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
    } (19 )
}
 
/*check end_of_line enclosure*/
if (diff_endOfLineEnclosure > 0) {
    if (diff_minEnclosure  == 0) {
       BOOLEAN via5  NOT metal5  {
           COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
       } (19 )
    }
    if (diff_endOfLineMode == 0) {
        ENCLOSE via5  BY metal5  {
	    SPACING < diff_endOfLineEnclosure
	    SET_CORNERS_TO_SPACING = FALSE
	    PARALLEL_POINT_PROJECTION = FALSE
	    SHADOW_OTHER_LAYER = TRUE  
	    TOUCH = TRUE
	    POINT_TOUCH = FALSE
	    NON_PARALLEL = TRUE
            OUTPUT_EDGES = TRUE
        } TEMP = violation
 
        SELECT_EDGE via5  TOUCHING violation {  } TEMP = edges
        SELECT_VECTOR edges { ANGLE_RANGE = [0, 0] } TEMP = h_edges
        SELECT_VECTOR edges { ANGLE_RANGE = [90, 90] } TEMP = v_edges
        SELECT h_edges INTERACT v_edges { POINT_TOUCH = TRUE } TEMP = h_edges
 
        SELECT via5  ENCLOSING h_edges {
            COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
        } (19 )
    }
    else {
    }
}
 
/*check stackable*/
if (diff_not_stackable > 0) {
     BOOLEAN via5  AND metal5  {
        COMMENT = "$layer_name Stackable: not stackable"
    } (19 )
}
/*check fat metal via keep-out area*/
if (diff_fatTblViaKeepoutThreshold > 0 && diff_fatTblViaKeepoutMinSize > 0 && diff_fatTblViaKeepoutEnclosure > 0) {
    if (diff_fatTblViaKeepoutThreshold > 0) {
        if ((diff_fatTblViaKeepoutThreshold / 2.0) > 0.0001 ) {
           SIZE metal5  { UNDER_OVER = diff_fatTblViaKeepoutThreshold / 2.0 - 0.0001  } TEMP = fat_candidate
           if (diff_fatTblViaKeepoutNextThreshold > 0) {
              SIZE fat_candidate { UNDER_OVER = diff_fatTblViaKeepoutNextThreshold / 2.0 - 0.0001  } TEMP = fat_next
              BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
              BOOLEAN fat AND metal5  { } TEMP = fat
              SET diff_fatTblViaKeepoutNextThreshold = 0;
           } else {
              BOOLEAN fat_candidate AND metal5  {  } TEMP = fat
           }
        } else {
           COPY metal5  { } TEMP = fat
           COPY metal5  { } TEMP = fat_candidate 
        }
    }
    VERTEX fat_candidate {
       CONVEX = TRUE
       SIZE = 0.0002 
    } TEMP = fat_corners
    VERTEX fat {
       CONVEX = TRUE
       SIZE = 0.0002 
    } TEMP = wire_corners
    SELECT wire_corners INTERACT fat_corners { } TEMP = wire_corners
    SELECT_EDGE fat INTERACT wire_corners { } TEMP = edge_corners
    SELECT_VECTOR edge_corners {
       LENGTH_RANGE = [0, diff_fatTblViaKeepoutMinSize- 0.0001 ]
    } TEMP = edge_tmp1
    BOOLEAN edge_corners NOT edge_tmp1 { } TEMP = edge_tmp2
    SELECT wire_corners OUTSIDE edge_tmp1 {  } TEMP = real_corners
    BOOLEAN edge_tmp2 AND real_corners { } TEMP = real_edge
    SIZE real_edge {
       VSIZE_HEAD = diff_fatTblViaKeepoutMinSize-2* 0.0002 
       VSIZE_TAIL = diff_fatTblViaKeepoutMinSize-2* 0.0002 
       VSIZE_INSIDE = diff_fatTblViaKeepoutEnclosure- 0.0002 
    } TEMP = forb_corners
    SELECT via5  INSIDE fat { } TEMP = v_fat
    /* Work around: need an accurate via_cluster */
    SELECT via_cluster INSIDE fat { } TEMP = v_fat_cluster
    SELECT v_fat INTERACT forb_corners { } TEMP = bad_vias
    BOOLEAN v_fat NOT bad_vias { } TEMP = good_vias
    SELECT v_fat_cluster OUTSIDE good_vias { } TEMP = bad_v_fat_cluster
    SELECT v_fat INTERACT bad_v_fat_cluster {
       COMMENT = "$layer_name ViaKepOut: fat metal ( diff_fatTblViaKeepoutThreshold um) contact keep-out area ( diff_fatTblViaKeepoutMinSize um, diff_fatTblViaKeepoutEnclosure um) "
    } (19 )
}
 
/* reset variables */



 
SET diff_minSpacing = 0;
SET diff_netMinSpacing = 0;
SET diff_cornerMinSpacing = 0;
SET diff_minEnclosure = 0;
SET diff_endOfLineEnclosure = 0;
SET diff_not_stackable = 0;
SET diff_fatTblViaKeepoutThreshold = 0;
SET diff_fatTblViaKeepoutNextThreshold = 0;
SET diff_fatTblViaKeepoutMinSize = 0;
SET diff_fatTblViaKeepoutEnclosure = 0;
@ 1567 "adrc/adrc.ev" 2

    }
}
DISCONNECT


/*via 6 / metal 6*/
SET layer_name = "V6/M6";





LOAD_CONNECT_DB all_layer

if (!layer_empty (via6 )) {
    if (!layer_empty (metal6 )) {
        
@ 1 "adrc/adrc_check_diff.ev" 1
/*check spacing*/
if (diff_minSpacing > 0 && diff_netMinSpacing > 0) {
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via6  metal6  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
                NODAL = TRUE
            } TEMP = diffNet_corner_err1
            EXTERNAL via6  metal6  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
                NODAL = TRUE
            } TEMP = diffNet_corner_err2
            BOOLEAN diffNet_corner_err1 OR diffNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (21 )
            EXTERNAL via6  metal6  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NODAL = TRUE
            } (21 )
        } else {
            EXTERNAL via6  metal6  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_netMinSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (21 )
        }
    } else {
        EXTERNAL via6  metal6  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
            SPACING < diff_netMinSpacing
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
            NODAL = TRUE
        } (21 )
    }
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via6  metal6  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
            } TEMP = sameNet_corner_err1
            EXTERNAL via6  metal6  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
            } TEMP = sameNet_corner_err2
            BOOLEAN sameNet_corner_err1 OR sameNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (21 )
            EXTERNAL via6  metal6  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                FLAG_DISCONNECTED = FALSE
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
            } (21 )
        } else {
            EXTERNAL via6  metal6  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_minSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (21 )
        }
    } else {
        EXTERNAL via6  metal6  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
            SPACING < diff_minSpacing
            FLAG_DISCONNECTED = FALSE
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
        } (21 )
    }
} else {
    if (diff_netMinSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via6  metal6  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                    NODAL = TRUE
                } TEMP = corner_err1
                EXTERNAL via6  metal6  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                    NODAL = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (21 )
                EXTERNAL via6  metal6  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                    SPACING < diff_netMinSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                    NODAL = TRUE
                } (21 )
            } else {
                EXTERNAL via6  metal6  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_netMinSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                    NODAL = TRUE
                } (21 )
            }
        } else {
            EXTERNAL via6  metal6  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (21 )
        }
    } else if (diff_minSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via6  metal6  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                } TEMP = corner_err1
                EXTERNAL via6  metal6  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (21 )
                EXTERNAL via6  metal6  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                    SPACING < diff_minSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                } (21 )
            } else {
                EXTERNAL via6  metal6  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_minSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                } (21 )
            }
        } else {
            EXTERNAL via6  metal6  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (21 )
        }
    }
}
 
/*check enclosure*/
if (diff_minEnclosure > 0) {
    ENCLOSE via6  BY metal6  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
        SPACING < diff_minEnclosure
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
	TOUCH = TRUE
    } (21 )
    BOOLEAN via6  NOT metal6  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
    } (21 )
}
 
/*check end_of_line enclosure*/
if (diff_endOfLineEnclosure > 0) {
    if (diff_minEnclosure  == 0) {
       BOOLEAN via6  NOT metal6  {
           COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
       } (21 )
    }
    if (diff_endOfLineMode == 0) {
        ENCLOSE via6  BY metal6  {
	    SPACING < diff_endOfLineEnclosure
	    SET_CORNERS_TO_SPACING = FALSE
	    PARALLEL_POINT_PROJECTION = FALSE
	    SHADOW_OTHER_LAYER = TRUE  
	    TOUCH = TRUE
	    POINT_TOUCH = FALSE
	    NON_PARALLEL = TRUE
            OUTPUT_EDGES = TRUE
        } TEMP = violation
 
        SELECT_EDGE via6  TOUCHING violation {  } TEMP = edges
        SELECT_VECTOR edges { ANGLE_RANGE = [0, 0] } TEMP = h_edges
        SELECT_VECTOR edges { ANGLE_RANGE = [90, 90] } TEMP = v_edges
        SELECT h_edges INTERACT v_edges { POINT_TOUCH = TRUE } TEMP = h_edges
 
        SELECT via6  ENCLOSING h_edges {
            COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
        } (21 )
    }
    else {
    }
}
 
/*check stackable*/
if (diff_not_stackable > 0) {
     BOOLEAN via6  AND metal6  {
        COMMENT = "$layer_name Stackable: not stackable"
    } (21 )
}
/*check fat metal via keep-out area*/
if (diff_fatTblViaKeepoutThreshold > 0 && diff_fatTblViaKeepoutMinSize > 0 && diff_fatTblViaKeepoutEnclosure > 0) {
    if (diff_fatTblViaKeepoutThreshold > 0) {
        if ((diff_fatTblViaKeepoutThreshold / 2.0) > 0.0001 ) {
           SIZE metal6  { UNDER_OVER = diff_fatTblViaKeepoutThreshold / 2.0 - 0.0001  } TEMP = fat_candidate
           if (diff_fatTblViaKeepoutNextThreshold > 0) {
              SIZE fat_candidate { UNDER_OVER = diff_fatTblViaKeepoutNextThreshold / 2.0 - 0.0001  } TEMP = fat_next
              BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
              BOOLEAN fat AND metal6  { } TEMP = fat
              SET diff_fatTblViaKeepoutNextThreshold = 0;
           } else {
              BOOLEAN fat_candidate AND metal6  {  } TEMP = fat
           }
        } else {
           COPY metal6  { } TEMP = fat
           COPY metal6  { } TEMP = fat_candidate 
        }
    }
    VERTEX fat_candidate {
       CONVEX = TRUE
       SIZE = 0.0002 
    } TEMP = fat_corners
    VERTEX fat {
       CONVEX = TRUE
       SIZE = 0.0002 
    } TEMP = wire_corners
    SELECT wire_corners INTERACT fat_corners { } TEMP = wire_corners
    SELECT_EDGE fat INTERACT wire_corners { } TEMP = edge_corners
    SELECT_VECTOR edge_corners {
       LENGTH_RANGE = [0, diff_fatTblViaKeepoutMinSize- 0.0001 ]
    } TEMP = edge_tmp1
    BOOLEAN edge_corners NOT edge_tmp1 { } TEMP = edge_tmp2
    SELECT wire_corners OUTSIDE edge_tmp1 {  } TEMP = real_corners
    BOOLEAN edge_tmp2 AND real_corners { } TEMP = real_edge
    SIZE real_edge {
       VSIZE_HEAD = diff_fatTblViaKeepoutMinSize-2* 0.0002 
       VSIZE_TAIL = diff_fatTblViaKeepoutMinSize-2* 0.0002 
       VSIZE_INSIDE = diff_fatTblViaKeepoutEnclosure- 0.0002 
    } TEMP = forb_corners
    SELECT via6  INSIDE fat { } TEMP = v_fat
    /* Work around: need an accurate via_cluster */
    SELECT via_cluster INSIDE fat { } TEMP = v_fat_cluster
    SELECT v_fat INTERACT forb_corners { } TEMP = bad_vias
    BOOLEAN v_fat NOT bad_vias { } TEMP = good_vias
    SELECT v_fat_cluster OUTSIDE good_vias { } TEMP = bad_v_fat_cluster
    SELECT v_fat INTERACT bad_v_fat_cluster {
       COMMENT = "$layer_name ViaKepOut: fat metal ( diff_fatTblViaKeepoutThreshold um) contact keep-out area ( diff_fatTblViaKeepoutMinSize um, diff_fatTblViaKeepoutEnclosure um) "
    } (21 )
}
 
/* reset variables */



 
SET diff_minSpacing = 0;
SET diff_netMinSpacing = 0;
SET diff_cornerMinSpacing = 0;
SET diff_minEnclosure = 0;
SET diff_endOfLineEnclosure = 0;
SET diff_not_stackable = 0;
SET diff_fatTblViaKeepoutThreshold = 0;
SET diff_fatTblViaKeepoutNextThreshold = 0;
SET diff_fatTblViaKeepoutMinSize = 0;
SET diff_fatTblViaKeepoutEnclosure = 0;
@ 1584 "adrc/adrc.ev" 2

    }
}
DISCONNECT


/*via 7 / metal 7*/
SET layer_name = "V7/M7";





LOAD_CONNECT_DB all_layer

if (!layer_empty (via7 )) {
    if (!layer_empty (metal7 )) {
        
@ 1 "adrc/adrc_check_diff.ev" 1
/*check spacing*/
if (diff_minSpacing > 0 && diff_netMinSpacing > 0) {
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via7  metal7  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
                NODAL = TRUE
            } TEMP = diffNet_corner_err1
            EXTERNAL via7  metal7  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
                NODAL = TRUE
            } TEMP = diffNet_corner_err2
            BOOLEAN diffNet_corner_err1 OR diffNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (23 )
            EXTERNAL via7  metal7  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NODAL = TRUE
            } (23 )
        } else {
            EXTERNAL via7  metal7  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_netMinSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (23 )
        }
    } else {
        EXTERNAL via7  metal7  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
            SPACING < diff_netMinSpacing
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
            NODAL = TRUE
        } (23 )
    }
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via7  metal7  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
            } TEMP = sameNet_corner_err1
            EXTERNAL via7  metal7  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
            } TEMP = sameNet_corner_err2
            BOOLEAN sameNet_corner_err1 OR sameNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (23 )
            EXTERNAL via7  metal7  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                FLAG_DISCONNECTED = FALSE
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
            } (23 )
        } else {
            EXTERNAL via7  metal7  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_minSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (23 )
        }
    } else {
        EXTERNAL via7  metal7  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
            SPACING < diff_minSpacing
            FLAG_DISCONNECTED = FALSE
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
        } (23 )
    }
} else {
    if (diff_netMinSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via7  metal7  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                    NODAL = TRUE
                } TEMP = corner_err1
                EXTERNAL via7  metal7  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                    NODAL = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (23 )
                EXTERNAL via7  metal7  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                    SPACING < diff_netMinSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                    NODAL = TRUE
                } (23 )
            } else {
                EXTERNAL via7  metal7  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_netMinSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                    NODAL = TRUE
                } (23 )
            }
        } else {
            EXTERNAL via7  metal7  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (23 )
        }
    } else if (diff_minSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via7  metal7  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                } TEMP = corner_err1
                EXTERNAL via7  metal7  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (23 )
                EXTERNAL via7  metal7  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                    SPACING < diff_minSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                } (23 )
            } else {
                EXTERNAL via7  metal7  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_minSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                } (23 )
            }
        } else {
            EXTERNAL via7  metal7  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (23 )
        }
    }
}
 
/*check enclosure*/
if (diff_minEnclosure > 0) {
    ENCLOSE via7  BY metal7  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
        SPACING < diff_minEnclosure
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
	TOUCH = TRUE
    } (23 )
    BOOLEAN via7  NOT metal7  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
    } (23 )
}
 
/*check end_of_line enclosure*/
if (diff_endOfLineEnclosure > 0) {
    if (diff_minEnclosure  == 0) {
       BOOLEAN via7  NOT metal7  {
           COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
       } (23 )
    }
    if (diff_endOfLineMode == 0) {
        ENCLOSE via7  BY metal7  {
	    SPACING < diff_endOfLineEnclosure
	    SET_CORNERS_TO_SPACING = FALSE
	    PARALLEL_POINT_PROJECTION = FALSE
	    SHADOW_OTHER_LAYER = TRUE  
	    TOUCH = TRUE
	    POINT_TOUCH = FALSE
	    NON_PARALLEL = TRUE
            OUTPUT_EDGES = TRUE
        } TEMP = violation
 
        SELECT_EDGE via7  TOUCHING violation {  } TEMP = edges
        SELECT_VECTOR edges { ANGLE_RANGE = [0, 0] } TEMP = h_edges
        SELECT_VECTOR edges { ANGLE_RANGE = [90, 90] } TEMP = v_edges
        SELECT h_edges INTERACT v_edges { POINT_TOUCH = TRUE } TEMP = h_edges
 
        SELECT via7  ENCLOSING h_edges {
            COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
        } (23 )
    }
    else {
    }
}
 
/*check stackable*/
if (diff_not_stackable > 0) {
     BOOLEAN via7  AND metal7  {
        COMMENT = "$layer_name Stackable: not stackable"
    } (23 )
}
/*check fat metal via keep-out area*/
if (diff_fatTblViaKeepoutThreshold > 0 && diff_fatTblViaKeepoutMinSize > 0 && diff_fatTblViaKeepoutEnclosure > 0) {
    if (diff_fatTblViaKeepoutThreshold > 0) {
        if ((diff_fatTblViaKeepoutThreshold / 2.0) > 0.0001 ) {
           SIZE metal7  { UNDER_OVER = diff_fatTblViaKeepoutThreshold / 2.0 - 0.0001  } TEMP = fat_candidate
           if (diff_fatTblViaKeepoutNextThreshold > 0) {
              SIZE fat_candidate { UNDER_OVER = diff_fatTblViaKeepoutNextThreshold / 2.0 - 0.0001  } TEMP = fat_next
              BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
              BOOLEAN fat AND metal7  { } TEMP = fat
              SET diff_fatTblViaKeepoutNextThreshold = 0;
           } else {
              BOOLEAN fat_candidate AND metal7  {  } TEMP = fat
           }
        } else {
           COPY metal7  { } TEMP = fat
           COPY metal7  { } TEMP = fat_candidate 
        }
    }
    VERTEX fat_candidate {
       CONVEX = TRUE
       SIZE = 0.0002 
    } TEMP = fat_corners
    VERTEX fat {
       CONVEX = TRUE
       SIZE = 0.0002 
    } TEMP = wire_corners
    SELECT wire_corners INTERACT fat_corners { } TEMP = wire_corners
    SELECT_EDGE fat INTERACT wire_corners { } TEMP = edge_corners
    SELECT_VECTOR edge_corners {
       LENGTH_RANGE = [0, diff_fatTblViaKeepoutMinSize- 0.0001 ]
    } TEMP = edge_tmp1
    BOOLEAN edge_corners NOT edge_tmp1 { } TEMP = edge_tmp2
    SELECT wire_corners OUTSIDE edge_tmp1 {  } TEMP = real_corners
    BOOLEAN edge_tmp2 AND real_corners { } TEMP = real_edge
    SIZE real_edge {
       VSIZE_HEAD = diff_fatTblViaKeepoutMinSize-2* 0.0002 
       VSIZE_TAIL = diff_fatTblViaKeepoutMinSize-2* 0.0002 
       VSIZE_INSIDE = diff_fatTblViaKeepoutEnclosure- 0.0002 
    } TEMP = forb_corners
    SELECT via7  INSIDE fat { } TEMP = v_fat
    /* Work around: need an accurate via_cluster */
    SELECT via_cluster INSIDE fat { } TEMP = v_fat_cluster
    SELECT v_fat INTERACT forb_corners { } TEMP = bad_vias
    BOOLEAN v_fat NOT bad_vias { } TEMP = good_vias
    SELECT v_fat_cluster OUTSIDE good_vias { } TEMP = bad_v_fat_cluster
    SELECT v_fat INTERACT bad_v_fat_cluster {
       COMMENT = "$layer_name ViaKepOut: fat metal ( diff_fatTblViaKeepoutThreshold um) contact keep-out area ( diff_fatTblViaKeepoutMinSize um, diff_fatTblViaKeepoutEnclosure um) "
    } (23 )
}
 
/* reset variables */



 
SET diff_minSpacing = 0;
SET diff_netMinSpacing = 0;
SET diff_cornerMinSpacing = 0;
SET diff_minEnclosure = 0;
SET diff_endOfLineEnclosure = 0;
SET diff_not_stackable = 0;
SET diff_fatTblViaKeepoutThreshold = 0;
SET diff_fatTblViaKeepoutNextThreshold = 0;
SET diff_fatTblViaKeepoutMinSize = 0;
SET diff_fatTblViaKeepoutEnclosure = 0;
@ 1601 "adrc/adrc.ev" 2

    }
}
DISCONNECT


/*via 8 / metal 8*/
SET layer_name = "V8/M8";





LOAD_CONNECT_DB all_layer

if (!layer_empty (via8 )) {
    if (!layer_empty (metal8 )) {
        
@ 1 "adrc/adrc_check_diff.ev" 1
/*check spacing*/
if (diff_minSpacing > 0 && diff_netMinSpacing > 0) {
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via8  metal8  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
                NODAL = TRUE
            } TEMP = diffNet_corner_err1
            EXTERNAL via8  metal8  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
                NODAL = TRUE
            } TEMP = diffNet_corner_err2
            BOOLEAN diffNet_corner_err1 OR diffNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (25 )
            EXTERNAL via8  metal8  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NODAL = TRUE
            } (25 )
        } else {
            EXTERNAL via8  metal8  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_netMinSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (25 )
        }
    } else {
        EXTERNAL via8  metal8  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
            SPACING < diff_netMinSpacing
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
            NODAL = TRUE
        } (25 )
    }
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via8  metal8  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
            } TEMP = sameNet_corner_err1
            EXTERNAL via8  metal8  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
            } TEMP = sameNet_corner_err2
            BOOLEAN sameNet_corner_err1 OR sameNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (25 )
            EXTERNAL via8  metal8  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                FLAG_DISCONNECTED = FALSE
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
            } (25 )
        } else {
            EXTERNAL via8  metal8  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_minSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (25 )
        }
    } else {
        EXTERNAL via8  metal8  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
            SPACING < diff_minSpacing
            FLAG_DISCONNECTED = FALSE
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
        } (25 )
    }
} else {
    if (diff_netMinSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via8  metal8  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                    NODAL = TRUE
                } TEMP = corner_err1
                EXTERNAL via8  metal8  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                    NODAL = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (25 )
                EXTERNAL via8  metal8  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                    SPACING < diff_netMinSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                    NODAL = TRUE
                } (25 )
            } else {
                EXTERNAL via8  metal8  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_netMinSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                    NODAL = TRUE
                } (25 )
            }
        } else {
            EXTERNAL via8  metal8  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (25 )
        }
    } else if (diff_minSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via8  metal8  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                } TEMP = corner_err1
                EXTERNAL via8  metal8  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (25 )
                EXTERNAL via8  metal8  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                    SPACING < diff_minSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                } (25 )
            } else {
                EXTERNAL via8  metal8  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_minSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                } (25 )
            }
        } else {
            EXTERNAL via8  metal8  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (25 )
        }
    }
}
 
/*check enclosure*/
if (diff_minEnclosure > 0) {
    ENCLOSE via8  BY metal8  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
        SPACING < diff_minEnclosure
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
	TOUCH = TRUE
    } (25 )
    BOOLEAN via8  NOT metal8  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
    } (25 )
}
 
/*check end_of_line enclosure*/
if (diff_endOfLineEnclosure > 0) {
    if (diff_minEnclosure  == 0) {
       BOOLEAN via8  NOT metal8  {
           COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
       } (25 )
    }
    if (diff_endOfLineMode == 0) {
        ENCLOSE via8  BY metal8  {
	    SPACING < diff_endOfLineEnclosure
	    SET_CORNERS_TO_SPACING = FALSE
	    PARALLEL_POINT_PROJECTION = FALSE
	    SHADOW_OTHER_LAYER = TRUE  
	    TOUCH = TRUE
	    POINT_TOUCH = FALSE
	    NON_PARALLEL = TRUE
            OUTPUT_EDGES = TRUE
        } TEMP = violation
 
        SELECT_EDGE via8  TOUCHING violation {  } TEMP = edges
        SELECT_VECTOR edges { ANGLE_RANGE = [0, 0] } TEMP = h_edges
        SELECT_VECTOR edges { ANGLE_RANGE = [90, 90] } TEMP = v_edges
        SELECT h_edges INTERACT v_edges { POINT_TOUCH = TRUE } TEMP = h_edges
 
        SELECT via8  ENCLOSING h_edges {
            COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
        } (25 )
    }
    else {
    }
}
 
/*check stackable*/
if (diff_not_stackable > 0) {
     BOOLEAN via8  AND metal8  {
        COMMENT = "$layer_name Stackable: not stackable"
    } (25 )
}
/*check fat metal via keep-out area*/
if (diff_fatTblViaKeepoutThreshold > 0 && diff_fatTblViaKeepoutMinSize > 0 && diff_fatTblViaKeepoutEnclosure > 0) {
    if (diff_fatTblViaKeepoutThreshold > 0) {
        if ((diff_fatTblViaKeepoutThreshold / 2.0) > 0.0001 ) {
           SIZE metal8  { UNDER_OVER = diff_fatTblViaKeepoutThreshold / 2.0 - 0.0001  } TEMP = fat_candidate
           if (diff_fatTblViaKeepoutNextThreshold > 0) {
              SIZE fat_candidate { UNDER_OVER = diff_fatTblViaKeepoutNextThreshold / 2.0 - 0.0001  } TEMP = fat_next
              BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
              BOOLEAN fat AND metal8  { } TEMP = fat
              SET diff_fatTblViaKeepoutNextThreshold = 0;
           } else {
              BOOLEAN fat_candidate AND metal8  {  } TEMP = fat
           }
        } else {
           COPY metal8  { } TEMP = fat
           COPY metal8  { } TEMP = fat_candidate 
        }
    }
    VERTEX fat_candidate {
       CONVEX = TRUE
       SIZE = 0.0002 
    } TEMP = fat_corners
    VERTEX fat {
       CONVEX = TRUE
       SIZE = 0.0002 
    } TEMP = wire_corners
    SELECT wire_corners INTERACT fat_corners { } TEMP = wire_corners
    SELECT_EDGE fat INTERACT wire_corners { } TEMP = edge_corners
    SELECT_VECTOR edge_corners {
       LENGTH_RANGE = [0, diff_fatTblViaKeepoutMinSize- 0.0001 ]
    } TEMP = edge_tmp1
    BOOLEAN edge_corners NOT edge_tmp1 { } TEMP = edge_tmp2
    SELECT wire_corners OUTSIDE edge_tmp1 {  } TEMP = real_corners
    BOOLEAN edge_tmp2 AND real_corners { } TEMP = real_edge
    SIZE real_edge {
       VSIZE_HEAD = diff_fatTblViaKeepoutMinSize-2* 0.0002 
       VSIZE_TAIL = diff_fatTblViaKeepoutMinSize-2* 0.0002 
       VSIZE_INSIDE = diff_fatTblViaKeepoutEnclosure- 0.0002 
    } TEMP = forb_corners
    SELECT via8  INSIDE fat { } TEMP = v_fat
    /* Work around: need an accurate via_cluster */
    SELECT via_cluster INSIDE fat { } TEMP = v_fat_cluster
    SELECT v_fat INTERACT forb_corners { } TEMP = bad_vias
    BOOLEAN v_fat NOT bad_vias { } TEMP = good_vias
    SELECT v_fat_cluster OUTSIDE good_vias { } TEMP = bad_v_fat_cluster
    SELECT v_fat INTERACT bad_v_fat_cluster {
       COMMENT = "$layer_name ViaKepOut: fat metal ( diff_fatTblViaKeepoutThreshold um) contact keep-out area ( diff_fatTblViaKeepoutMinSize um, diff_fatTblViaKeepoutEnclosure um) "
    } (25 )
}
 
/* reset variables */



 
SET diff_minSpacing = 0;
SET diff_netMinSpacing = 0;
SET diff_cornerMinSpacing = 0;
SET diff_minEnclosure = 0;
SET diff_endOfLineEnclosure = 0;
SET diff_not_stackable = 0;
SET diff_fatTblViaKeepoutThreshold = 0;
SET diff_fatTblViaKeepoutNextThreshold = 0;
SET diff_fatTblViaKeepoutMinSize = 0;
SET diff_fatTblViaKeepoutEnclosure = 0;
@ 1618 "adrc/adrc.ev" 2

    }
}
DISCONNECT


/*via 9 / metal 9*/
SET layer_name = "V9/M9";





LOAD_CONNECT_DB all_layer

if (!layer_empty (via9 )) {
    if (!layer_empty (metal9 )) {
        
@ 1 "adrc/adrc_check_diff.ev" 1
/*check spacing*/
if (diff_minSpacing > 0 && diff_netMinSpacing > 0) {
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via9  metal9  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
                NODAL = TRUE
            } TEMP = diffNet_corner_err1
            EXTERNAL via9  metal9  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
                NODAL = TRUE
            } TEMP = diffNet_corner_err2
            BOOLEAN diffNet_corner_err1 OR diffNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (27 )
            EXTERNAL via9  metal9  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NODAL = TRUE
            } (27 )
        } else {
            EXTERNAL via9  metal9  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_netMinSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (27 )
        }
    } else {
        EXTERNAL via9  metal9  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
            SPACING < diff_netMinSpacing
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
            NODAL = TRUE
        } (27 )
    }
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via9  metal9  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
            } TEMP = sameNet_corner_err1
            EXTERNAL via9  metal9  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
            } TEMP = sameNet_corner_err2
            BOOLEAN sameNet_corner_err1 OR sameNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (27 )
            EXTERNAL via9  metal9  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                FLAG_DISCONNECTED = FALSE
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
            } (27 )
        } else {
            EXTERNAL via9  metal9  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_minSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (27 )
        }
    } else {
        EXTERNAL via9  metal9  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
            SPACING < diff_minSpacing
            FLAG_DISCONNECTED = FALSE
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
        } (27 )
    }
} else {
    if (diff_netMinSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via9  metal9  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                    NODAL = TRUE
                } TEMP = corner_err1
                EXTERNAL via9  metal9  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                    NODAL = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (27 )
                EXTERNAL via9  metal9  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                    SPACING < diff_netMinSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                    NODAL = TRUE
                } (27 )
            } else {
                EXTERNAL via9  metal9  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_netMinSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                    NODAL = TRUE
                } (27 )
            }
        } else {
            EXTERNAL via9  metal9  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (27 )
        }
    } else if (diff_minSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via9  metal9  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                } TEMP = corner_err1
                EXTERNAL via9  metal9  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (27 )
                EXTERNAL via9  metal9  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                    SPACING < diff_minSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                } (27 )
            } else {
                EXTERNAL via9  metal9  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_minSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                } (27 )
            }
        } else {
            EXTERNAL via9  metal9  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (27 )
        }
    }
}
 
/*check enclosure*/
if (diff_minEnclosure > 0) {
    ENCLOSE via9  BY metal9  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
        SPACING < diff_minEnclosure
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
	TOUCH = TRUE
    } (27 )
    BOOLEAN via9  NOT metal9  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
    } (27 )
}
 
/*check end_of_line enclosure*/
if (diff_endOfLineEnclosure > 0) {
    if (diff_minEnclosure  == 0) {
       BOOLEAN via9  NOT metal9  {
           COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
       } (27 )
    }
    if (diff_endOfLineMode == 0) {
        ENCLOSE via9  BY metal9  {
	    SPACING < diff_endOfLineEnclosure
	    SET_CORNERS_TO_SPACING = FALSE
	    PARALLEL_POINT_PROJECTION = FALSE
	    SHADOW_OTHER_LAYER = TRUE  
	    TOUCH = TRUE
	    POINT_TOUCH = FALSE
	    NON_PARALLEL = TRUE
            OUTPUT_EDGES = TRUE
        } TEMP = violation
 
        SELECT_EDGE via9  TOUCHING violation {  } TEMP = edges
        SELECT_VECTOR edges { ANGLE_RANGE = [0, 0] } TEMP = h_edges
        SELECT_VECTOR edges { ANGLE_RANGE = [90, 90] } TEMP = v_edges
        SELECT h_edges INTERACT v_edges { POINT_TOUCH = TRUE } TEMP = h_edges
 
        SELECT via9  ENCLOSING h_edges {
            COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
        } (27 )
    }
    else {
    }
}
 
/*check stackable*/
if (diff_not_stackable > 0) {
     BOOLEAN via9  AND metal9  {
        COMMENT = "$layer_name Stackable: not stackable"
    } (27 )
}
/*check fat metal via keep-out area*/
if (diff_fatTblViaKeepoutThreshold > 0 && diff_fatTblViaKeepoutMinSize > 0 && diff_fatTblViaKeepoutEnclosure > 0) {
    if (diff_fatTblViaKeepoutThreshold > 0) {
        if ((diff_fatTblViaKeepoutThreshold / 2.0) > 0.0001 ) {
           SIZE metal9  { UNDER_OVER = diff_fatTblViaKeepoutThreshold / 2.0 - 0.0001  } TEMP = fat_candidate
           if (diff_fatTblViaKeepoutNextThreshold > 0) {
              SIZE fat_candidate { UNDER_OVER = diff_fatTblViaKeepoutNextThreshold / 2.0 - 0.0001  } TEMP = fat_next
              BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
              BOOLEAN fat AND metal9  { } TEMP = fat
              SET diff_fatTblViaKeepoutNextThreshold = 0;
           } else {
              BOOLEAN fat_candidate AND metal9  {  } TEMP = fat
           }
        } else {
           COPY metal9  { } TEMP = fat
           COPY metal9  { } TEMP = fat_candidate 
        }
    }
    VERTEX fat_candidate {
       CONVEX = TRUE
       SIZE = 0.0002 
    } TEMP = fat_corners
    VERTEX fat {
       CONVEX = TRUE
       SIZE = 0.0002 
    } TEMP = wire_corners
    SELECT wire_corners INTERACT fat_corners { } TEMP = wire_corners
    SELECT_EDGE fat INTERACT wire_corners { } TEMP = edge_corners
    SELECT_VECTOR edge_corners {
       LENGTH_RANGE = [0, diff_fatTblViaKeepoutMinSize- 0.0001 ]
    } TEMP = edge_tmp1
    BOOLEAN edge_corners NOT edge_tmp1 { } TEMP = edge_tmp2
    SELECT wire_corners OUTSIDE edge_tmp1 {  } TEMP = real_corners
    BOOLEAN edge_tmp2 AND real_corners { } TEMP = real_edge
    SIZE real_edge {
       VSIZE_HEAD = diff_fatTblViaKeepoutMinSize-2* 0.0002 
       VSIZE_TAIL = diff_fatTblViaKeepoutMinSize-2* 0.0002 
       VSIZE_INSIDE = diff_fatTblViaKeepoutEnclosure- 0.0002 
    } TEMP = forb_corners
    SELECT via9  INSIDE fat { } TEMP = v_fat
    /* Work around: need an accurate via_cluster */
    SELECT via_cluster INSIDE fat { } TEMP = v_fat_cluster
    SELECT v_fat INTERACT forb_corners { } TEMP = bad_vias
    BOOLEAN v_fat NOT bad_vias { } TEMP = good_vias
    SELECT v_fat_cluster OUTSIDE good_vias { } TEMP = bad_v_fat_cluster
    SELECT v_fat INTERACT bad_v_fat_cluster {
       COMMENT = "$layer_name ViaKepOut: fat metal ( diff_fatTblViaKeepoutThreshold um) contact keep-out area ( diff_fatTblViaKeepoutMinSize um, diff_fatTblViaKeepoutEnclosure um) "
    } (27 )
}
 
/* reset variables */



 
SET diff_minSpacing = 0;
SET diff_netMinSpacing = 0;
SET diff_cornerMinSpacing = 0;
SET diff_minEnclosure = 0;
SET diff_endOfLineEnclosure = 0;
SET diff_not_stackable = 0;
SET diff_fatTblViaKeepoutThreshold = 0;
SET diff_fatTblViaKeepoutNextThreshold = 0;
SET diff_fatTblViaKeepoutMinSize = 0;
SET diff_fatTblViaKeepoutEnclosure = 0;
@ 1635 "adrc/adrc.ev" 2

    }
}
DISCONNECT


/*via 1 / metal 2*/
SET layer_name = "V1/M2";





LOAD_CONNECT_DB all_layer

if (!layer_empty (via1 )) {
    if (!layer_empty (metal2 )) {
        
@ 1 "adrc/adrc_check_diff.ev" 1
/*check spacing*/
if (diff_minSpacing > 0 && diff_netMinSpacing > 0) {
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via1  metal2  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
                NODAL = TRUE
            } TEMP = diffNet_corner_err1
            EXTERNAL via1  metal2  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
                NODAL = TRUE
            } TEMP = diffNet_corner_err2
            BOOLEAN diffNet_corner_err1 OR diffNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (13 )
            EXTERNAL via1  metal2  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NODAL = TRUE
            } (13 )
        } else {
            EXTERNAL via1  metal2  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_netMinSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (13 )
        }
    } else {
        EXTERNAL via1  metal2  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
            SPACING < diff_netMinSpacing
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
            NODAL = TRUE
        } (13 )
    }
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via1  metal2  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
            } TEMP = sameNet_corner_err1
            EXTERNAL via1  metal2  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
            } TEMP = sameNet_corner_err2
            BOOLEAN sameNet_corner_err1 OR sameNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (13 )
            EXTERNAL via1  metal2  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                FLAG_DISCONNECTED = FALSE
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
            } (13 )
        } else {
            EXTERNAL via1  metal2  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_minSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (13 )
        }
    } else {
        EXTERNAL via1  metal2  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
            SPACING < diff_minSpacing
            FLAG_DISCONNECTED = FALSE
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
        } (13 )
    }
} else {
    if (diff_netMinSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via1  metal2  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                    NODAL = TRUE
                } TEMP = corner_err1
                EXTERNAL via1  metal2  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                    NODAL = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (13 )
                EXTERNAL via1  metal2  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                    SPACING < diff_netMinSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                    NODAL = TRUE
                } (13 )
            } else {
                EXTERNAL via1  metal2  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_netMinSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                    NODAL = TRUE
                } (13 )
            }
        } else {
            EXTERNAL via1  metal2  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (13 )
        }
    } else if (diff_minSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via1  metal2  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                } TEMP = corner_err1
                EXTERNAL via1  metal2  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (13 )
                EXTERNAL via1  metal2  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                    SPACING < diff_minSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                } (13 )
            } else {
                EXTERNAL via1  metal2  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_minSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                } (13 )
            }
        } else {
            EXTERNAL via1  metal2  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (13 )
        }
    }
}
 
/*check enclosure*/
if (diff_minEnclosure > 0) {
    ENCLOSE via1  BY metal2  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
        SPACING < diff_minEnclosure
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
	TOUCH = TRUE
    } (13 )
    BOOLEAN via1  NOT metal2  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
    } (13 )
}
 
/*check end_of_line enclosure*/
if (diff_endOfLineEnclosure > 0) {
    if (diff_minEnclosure  == 0) {
       BOOLEAN via1  NOT metal2  {
           COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
       } (13 )
    }
    if (diff_endOfLineMode == 0) {
        ENCLOSE via1  BY metal2  {
	    SPACING < diff_endOfLineEnclosure
	    SET_CORNERS_TO_SPACING = FALSE
	    PARALLEL_POINT_PROJECTION = FALSE
	    SHADOW_OTHER_LAYER = TRUE  
	    TOUCH = TRUE
	    POINT_TOUCH = FALSE
	    NON_PARALLEL = TRUE
            OUTPUT_EDGES = TRUE
        } TEMP = violation
 
        SELECT_EDGE via1  TOUCHING violation {  } TEMP = edges
        SELECT_VECTOR edges { ANGLE_RANGE = [0, 0] } TEMP = h_edges
        SELECT_VECTOR edges { ANGLE_RANGE = [90, 90] } TEMP = v_edges
        SELECT h_edges INTERACT v_edges { POINT_TOUCH = TRUE } TEMP = h_edges
 
        SELECT via1  ENCLOSING h_edges {
            COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
        } (13 )
    }
    else {
    }
}
 
/*check stackable*/
if (diff_not_stackable > 0) {
     BOOLEAN via1  AND metal2  {
        COMMENT = "$layer_name Stackable: not stackable"
    } (13 )
}
/*check fat metal via keep-out area*/
if (diff_fatTblViaKeepoutThreshold > 0 && diff_fatTblViaKeepoutMinSize > 0 && diff_fatTblViaKeepoutEnclosure > 0) {
    if (diff_fatTblViaKeepoutThreshold > 0) {
        if ((diff_fatTblViaKeepoutThreshold / 2.0) > 0.0001 ) {
           SIZE metal2  { UNDER_OVER = diff_fatTblViaKeepoutThreshold / 2.0 - 0.0001  } TEMP = fat_candidate
           if (diff_fatTblViaKeepoutNextThreshold > 0) {
              SIZE fat_candidate { UNDER_OVER = diff_fatTblViaKeepoutNextThreshold / 2.0 - 0.0001  } TEMP = fat_next
              BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
              BOOLEAN fat AND metal2  { } TEMP = fat
              SET diff_fatTblViaKeepoutNextThreshold = 0;
           } else {
              BOOLEAN fat_candidate AND metal2  {  } TEMP = fat
           }
        } else {
           COPY metal2  { } TEMP = fat
           COPY metal2  { } TEMP = fat_candidate 
        }
    }
    VERTEX fat_candidate {
       CONVEX = TRUE
       SIZE = 0.0002 
    } TEMP = fat_corners
    VERTEX fat {
       CONVEX = TRUE
       SIZE = 0.0002 
    } TEMP = wire_corners
    SELECT wire_corners INTERACT fat_corners { } TEMP = wire_corners
    SELECT_EDGE fat INTERACT wire_corners { } TEMP = edge_corners
    SELECT_VECTOR edge_corners {
       LENGTH_RANGE = [0, diff_fatTblViaKeepoutMinSize- 0.0001 ]
    } TEMP = edge_tmp1
    BOOLEAN edge_corners NOT edge_tmp1 { } TEMP = edge_tmp2
    SELECT wire_corners OUTSIDE edge_tmp1 {  } TEMP = real_corners
    BOOLEAN edge_tmp2 AND real_corners { } TEMP = real_edge
    SIZE real_edge {
       VSIZE_HEAD = diff_fatTblViaKeepoutMinSize-2* 0.0002 
       VSIZE_TAIL = diff_fatTblViaKeepoutMinSize-2* 0.0002 
       VSIZE_INSIDE = diff_fatTblViaKeepoutEnclosure- 0.0002 
    } TEMP = forb_corners
    SELECT via1  INSIDE fat { } TEMP = v_fat
    /* Work around: need an accurate via_cluster */
    SELECT via_cluster INSIDE fat { } TEMP = v_fat_cluster
    SELECT v_fat INTERACT forb_corners { } TEMP = bad_vias
    BOOLEAN v_fat NOT bad_vias { } TEMP = good_vias
    SELECT v_fat_cluster OUTSIDE good_vias { } TEMP = bad_v_fat_cluster
    SELECT v_fat INTERACT bad_v_fat_cluster {
       COMMENT = "$layer_name ViaKepOut: fat metal ( diff_fatTblViaKeepoutThreshold um) contact keep-out area ( diff_fatTblViaKeepoutMinSize um, diff_fatTblViaKeepoutEnclosure um) "
    } (13 )
}
 
/* reset variables */



 
SET diff_minSpacing = 0;
SET diff_netMinSpacing = 0;
SET diff_cornerMinSpacing = 0;
SET diff_minEnclosure = 0;
SET diff_endOfLineEnclosure = 0;
SET diff_not_stackable = 0;
SET diff_fatTblViaKeepoutThreshold = 0;
SET diff_fatTblViaKeepoutNextThreshold = 0;
SET diff_fatTblViaKeepoutMinSize = 0;
SET diff_fatTblViaKeepoutEnclosure = 0;
@ 1652 "adrc/adrc.ev" 2

    }
}
DISCONNECT


/*via 2 / metal 3*/
SET layer_name = "V2/M3";





LOAD_CONNECT_DB all_layer

if (!layer_empty (via2 )) {
    if (!layer_empty (metal3 )) {
        
@ 1 "adrc/adrc_check_diff.ev" 1
/*check spacing*/
if (diff_minSpacing > 0 && diff_netMinSpacing > 0) {
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via2  metal3  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
                NODAL = TRUE
            } TEMP = diffNet_corner_err1
            EXTERNAL via2  metal3  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
                NODAL = TRUE
            } TEMP = diffNet_corner_err2
            BOOLEAN diffNet_corner_err1 OR diffNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (15 )
            EXTERNAL via2  metal3  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NODAL = TRUE
            } (15 )
        } else {
            EXTERNAL via2  metal3  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_netMinSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (15 )
        }
    } else {
        EXTERNAL via2  metal3  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
            SPACING < diff_netMinSpacing
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
            NODAL = TRUE
        } (15 )
    }
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via2  metal3  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
            } TEMP = sameNet_corner_err1
            EXTERNAL via2  metal3  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
            } TEMP = sameNet_corner_err2
            BOOLEAN sameNet_corner_err1 OR sameNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (15 )
            EXTERNAL via2  metal3  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                FLAG_DISCONNECTED = FALSE
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
            } (15 )
        } else {
            EXTERNAL via2  metal3  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_minSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (15 )
        }
    } else {
        EXTERNAL via2  metal3  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
            SPACING < diff_minSpacing
            FLAG_DISCONNECTED = FALSE
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
        } (15 )
    }
} else {
    if (diff_netMinSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via2  metal3  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                    NODAL = TRUE
                } TEMP = corner_err1
                EXTERNAL via2  metal3  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                    NODAL = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (15 )
                EXTERNAL via2  metal3  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                    SPACING < diff_netMinSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                    NODAL = TRUE
                } (15 )
            } else {
                EXTERNAL via2  metal3  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_netMinSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                    NODAL = TRUE
                } (15 )
            }
        } else {
            EXTERNAL via2  metal3  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (15 )
        }
    } else if (diff_minSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via2  metal3  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                } TEMP = corner_err1
                EXTERNAL via2  metal3  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (15 )
                EXTERNAL via2  metal3  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                    SPACING < diff_minSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                } (15 )
            } else {
                EXTERNAL via2  metal3  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_minSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                } (15 )
            }
        } else {
            EXTERNAL via2  metal3  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (15 )
        }
    }
}
 
/*check enclosure*/
if (diff_minEnclosure > 0) {
    ENCLOSE via2  BY metal3  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
        SPACING < diff_minEnclosure
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
	TOUCH = TRUE
    } (15 )
    BOOLEAN via2  NOT metal3  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
    } (15 )
}
 
/*check end_of_line enclosure*/
if (diff_endOfLineEnclosure > 0) {
    if (diff_minEnclosure  == 0) {
       BOOLEAN via2  NOT metal3  {
           COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
       } (15 )
    }
    if (diff_endOfLineMode == 0) {
        ENCLOSE via2  BY metal3  {
	    SPACING < diff_endOfLineEnclosure
	    SET_CORNERS_TO_SPACING = FALSE
	    PARALLEL_POINT_PROJECTION = FALSE
	    SHADOW_OTHER_LAYER = TRUE  
	    TOUCH = TRUE
	    POINT_TOUCH = FALSE
	    NON_PARALLEL = TRUE
            OUTPUT_EDGES = TRUE
        } TEMP = violation
 
        SELECT_EDGE via2  TOUCHING violation {  } TEMP = edges
        SELECT_VECTOR edges { ANGLE_RANGE = [0, 0] } TEMP = h_edges
        SELECT_VECTOR edges { ANGLE_RANGE = [90, 90] } TEMP = v_edges
        SELECT h_edges INTERACT v_edges { POINT_TOUCH = TRUE } TEMP = h_edges
 
        SELECT via2  ENCLOSING h_edges {
            COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
        } (15 )
    }
    else {
    }
}
 
/*check stackable*/
if (diff_not_stackable > 0) {
     BOOLEAN via2  AND metal3  {
        COMMENT = "$layer_name Stackable: not stackable"
    } (15 )
}
/*check fat metal via keep-out area*/
if (diff_fatTblViaKeepoutThreshold > 0 && diff_fatTblViaKeepoutMinSize > 0 && diff_fatTblViaKeepoutEnclosure > 0) {
    if (diff_fatTblViaKeepoutThreshold > 0) {
        if ((diff_fatTblViaKeepoutThreshold / 2.0) > 0.0001 ) {
           SIZE metal3  { UNDER_OVER = diff_fatTblViaKeepoutThreshold / 2.0 - 0.0001  } TEMP = fat_candidate
           if (diff_fatTblViaKeepoutNextThreshold > 0) {
              SIZE fat_candidate { UNDER_OVER = diff_fatTblViaKeepoutNextThreshold / 2.0 - 0.0001  } TEMP = fat_next
              BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
              BOOLEAN fat AND metal3  { } TEMP = fat
              SET diff_fatTblViaKeepoutNextThreshold = 0;
           } else {
              BOOLEAN fat_candidate AND metal3  {  } TEMP = fat
           }
        } else {
           COPY metal3  { } TEMP = fat
           COPY metal3  { } TEMP = fat_candidate 
        }
    }
    VERTEX fat_candidate {
       CONVEX = TRUE
       SIZE = 0.0002 
    } TEMP = fat_corners
    VERTEX fat {
       CONVEX = TRUE
       SIZE = 0.0002 
    } TEMP = wire_corners
    SELECT wire_corners INTERACT fat_corners { } TEMP = wire_corners
    SELECT_EDGE fat INTERACT wire_corners { } TEMP = edge_corners
    SELECT_VECTOR edge_corners {
       LENGTH_RANGE = [0, diff_fatTblViaKeepoutMinSize- 0.0001 ]
    } TEMP = edge_tmp1
    BOOLEAN edge_corners NOT edge_tmp1 { } TEMP = edge_tmp2
    SELECT wire_corners OUTSIDE edge_tmp1 {  } TEMP = real_corners
    BOOLEAN edge_tmp2 AND real_corners { } TEMP = real_edge
    SIZE real_edge {
       VSIZE_HEAD = diff_fatTblViaKeepoutMinSize-2* 0.0002 
       VSIZE_TAIL = diff_fatTblViaKeepoutMinSize-2* 0.0002 
       VSIZE_INSIDE = diff_fatTblViaKeepoutEnclosure- 0.0002 
    } TEMP = forb_corners
    SELECT via2  INSIDE fat { } TEMP = v_fat
    /* Work around: need an accurate via_cluster */
    SELECT via_cluster INSIDE fat { } TEMP = v_fat_cluster
    SELECT v_fat INTERACT forb_corners { } TEMP = bad_vias
    BOOLEAN v_fat NOT bad_vias { } TEMP = good_vias
    SELECT v_fat_cluster OUTSIDE good_vias { } TEMP = bad_v_fat_cluster
    SELECT v_fat INTERACT bad_v_fat_cluster {
       COMMENT = "$layer_name ViaKepOut: fat metal ( diff_fatTblViaKeepoutThreshold um) contact keep-out area ( diff_fatTblViaKeepoutMinSize um, diff_fatTblViaKeepoutEnclosure um) "
    } (15 )
}
 
/* reset variables */



 
SET diff_minSpacing = 0;
SET diff_netMinSpacing = 0;
SET diff_cornerMinSpacing = 0;
SET diff_minEnclosure = 0;
SET diff_endOfLineEnclosure = 0;
SET diff_not_stackable = 0;
SET diff_fatTblViaKeepoutThreshold = 0;
SET diff_fatTblViaKeepoutNextThreshold = 0;
SET diff_fatTblViaKeepoutMinSize = 0;
SET diff_fatTblViaKeepoutEnclosure = 0;
@ 1669 "adrc/adrc.ev" 2

    }
}
DISCONNECT


/*via 3 / metal 4*/
SET layer_name = "V3/M4";





LOAD_CONNECT_DB all_layer

if (!layer_empty (via3 )) {
    if (!layer_empty (metal4 )) {
        
@ 1 "adrc/adrc_check_diff.ev" 1
/*check spacing*/
if (diff_minSpacing > 0 && diff_netMinSpacing > 0) {
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via3  metal4  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
                NODAL = TRUE
            } TEMP = diffNet_corner_err1
            EXTERNAL via3  metal4  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
                NODAL = TRUE
            } TEMP = diffNet_corner_err2
            BOOLEAN diffNet_corner_err1 OR diffNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (17 )
            EXTERNAL via3  metal4  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NODAL = TRUE
            } (17 )
        } else {
            EXTERNAL via3  metal4  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_netMinSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (17 )
        }
    } else {
        EXTERNAL via3  metal4  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
            SPACING < diff_netMinSpacing
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
            NODAL = TRUE
        } (17 )
    }
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via3  metal4  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
            } TEMP = sameNet_corner_err1
            EXTERNAL via3  metal4  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
            } TEMP = sameNet_corner_err2
            BOOLEAN sameNet_corner_err1 OR sameNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (17 )
            EXTERNAL via3  metal4  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                FLAG_DISCONNECTED = FALSE
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
            } (17 )
        } else {
            EXTERNAL via3  metal4  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_minSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (17 )
        }
    } else {
        EXTERNAL via3  metal4  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
            SPACING < diff_minSpacing
            FLAG_DISCONNECTED = FALSE
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
        } (17 )
    }
} else {
    if (diff_netMinSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via3  metal4  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                    NODAL = TRUE
                } TEMP = corner_err1
                EXTERNAL via3  metal4  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                    NODAL = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (17 )
                EXTERNAL via3  metal4  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                    SPACING < diff_netMinSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                    NODAL = TRUE
                } (17 )
            } else {
                EXTERNAL via3  metal4  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_netMinSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                    NODAL = TRUE
                } (17 )
            }
        } else {
            EXTERNAL via3  metal4  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (17 )
        }
    } else if (diff_minSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via3  metal4  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                } TEMP = corner_err1
                EXTERNAL via3  metal4  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (17 )
                EXTERNAL via3  metal4  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                    SPACING < diff_minSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                } (17 )
            } else {
                EXTERNAL via3  metal4  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_minSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                } (17 )
            }
        } else {
            EXTERNAL via3  metal4  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (17 )
        }
    }
}
 
/*check enclosure*/
if (diff_minEnclosure > 0) {
    ENCLOSE via3  BY metal4  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
        SPACING < diff_minEnclosure
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
	TOUCH = TRUE
    } (17 )
    BOOLEAN via3  NOT metal4  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
    } (17 )
}
 
/*check end_of_line enclosure*/
if (diff_endOfLineEnclosure > 0) {
    if (diff_minEnclosure  == 0) {
       BOOLEAN via3  NOT metal4  {
           COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
       } (17 )
    }
    if (diff_endOfLineMode == 0) {
        ENCLOSE via3  BY metal4  {
	    SPACING < diff_endOfLineEnclosure
	    SET_CORNERS_TO_SPACING = FALSE
	    PARALLEL_POINT_PROJECTION = FALSE
	    SHADOW_OTHER_LAYER = TRUE  
	    TOUCH = TRUE
	    POINT_TOUCH = FALSE
	    NON_PARALLEL = TRUE
            OUTPUT_EDGES = TRUE
        } TEMP = violation
 
        SELECT_EDGE via3  TOUCHING violation {  } TEMP = edges
        SELECT_VECTOR edges { ANGLE_RANGE = [0, 0] } TEMP = h_edges
        SELECT_VECTOR edges { ANGLE_RANGE = [90, 90] } TEMP = v_edges
        SELECT h_edges INTERACT v_edges { POINT_TOUCH = TRUE } TEMP = h_edges
 
        SELECT via3  ENCLOSING h_edges {
            COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
        } (17 )
    }
    else {
    }
}
 
/*check stackable*/
if (diff_not_stackable > 0) {
     BOOLEAN via3  AND metal4  {
        COMMENT = "$layer_name Stackable: not stackable"
    } (17 )
}
/*check fat metal via keep-out area*/
if (diff_fatTblViaKeepoutThreshold > 0 && diff_fatTblViaKeepoutMinSize > 0 && diff_fatTblViaKeepoutEnclosure > 0) {
    if (diff_fatTblViaKeepoutThreshold > 0) {
        if ((diff_fatTblViaKeepoutThreshold / 2.0) > 0.0001 ) {
           SIZE metal4  { UNDER_OVER = diff_fatTblViaKeepoutThreshold / 2.0 - 0.0001  } TEMP = fat_candidate
           if (diff_fatTblViaKeepoutNextThreshold > 0) {
              SIZE fat_candidate { UNDER_OVER = diff_fatTblViaKeepoutNextThreshold / 2.0 - 0.0001  } TEMP = fat_next
              BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
              BOOLEAN fat AND metal4  { } TEMP = fat
              SET diff_fatTblViaKeepoutNextThreshold = 0;
           } else {
              BOOLEAN fat_candidate AND metal4  {  } TEMP = fat
           }
        } else {
           COPY metal4  { } TEMP = fat
           COPY metal4  { } TEMP = fat_candidate 
        }
    }
    VERTEX fat_candidate {
       CONVEX = TRUE
       SIZE = 0.0002 
    } TEMP = fat_corners
    VERTEX fat {
       CONVEX = TRUE
       SIZE = 0.0002 
    } TEMP = wire_corners
    SELECT wire_corners INTERACT fat_corners { } TEMP = wire_corners
    SELECT_EDGE fat INTERACT wire_corners { } TEMP = edge_corners
    SELECT_VECTOR edge_corners {
       LENGTH_RANGE = [0, diff_fatTblViaKeepoutMinSize- 0.0001 ]
    } TEMP = edge_tmp1
    BOOLEAN edge_corners NOT edge_tmp1 { } TEMP = edge_tmp2
    SELECT wire_corners OUTSIDE edge_tmp1 {  } TEMP = real_corners
    BOOLEAN edge_tmp2 AND real_corners { } TEMP = real_edge
    SIZE real_edge {
       VSIZE_HEAD = diff_fatTblViaKeepoutMinSize-2* 0.0002 
       VSIZE_TAIL = diff_fatTblViaKeepoutMinSize-2* 0.0002 
       VSIZE_INSIDE = diff_fatTblViaKeepoutEnclosure- 0.0002 
    } TEMP = forb_corners
    SELECT via3  INSIDE fat { } TEMP = v_fat
    /* Work around: need an accurate via_cluster */
    SELECT via_cluster INSIDE fat { } TEMP = v_fat_cluster
    SELECT v_fat INTERACT forb_corners { } TEMP = bad_vias
    BOOLEAN v_fat NOT bad_vias { } TEMP = good_vias
    SELECT v_fat_cluster OUTSIDE good_vias { } TEMP = bad_v_fat_cluster
    SELECT v_fat INTERACT bad_v_fat_cluster {
       COMMENT = "$layer_name ViaKepOut: fat metal ( diff_fatTblViaKeepoutThreshold um) contact keep-out area ( diff_fatTblViaKeepoutMinSize um, diff_fatTblViaKeepoutEnclosure um) "
    } (17 )
}
 
/* reset variables */



 
SET diff_minSpacing = 0;
SET diff_netMinSpacing = 0;
SET diff_cornerMinSpacing = 0;
SET diff_minEnclosure = 0;
SET diff_endOfLineEnclosure = 0;
SET diff_not_stackable = 0;
SET diff_fatTblViaKeepoutThreshold = 0;
SET diff_fatTblViaKeepoutNextThreshold = 0;
SET diff_fatTblViaKeepoutMinSize = 0;
SET diff_fatTblViaKeepoutEnclosure = 0;
@ 1686 "adrc/adrc.ev" 2

    }
}
DISCONNECT


/*via 4 / metal 5*/
SET layer_name = "V4/M5";





LOAD_CONNECT_DB all_layer

if (!layer_empty (via4 )) {
    if (!layer_empty (metal5 )) {
        
@ 1 "adrc/adrc_check_diff.ev" 1
/*check spacing*/
if (diff_minSpacing > 0 && diff_netMinSpacing > 0) {
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via4  metal5  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
                NODAL = TRUE
            } TEMP = diffNet_corner_err1
            EXTERNAL via4  metal5  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
                NODAL = TRUE
            } TEMP = diffNet_corner_err2
            BOOLEAN diffNet_corner_err1 OR diffNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (19 )
            EXTERNAL via4  metal5  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NODAL = TRUE
            } (19 )
        } else {
            EXTERNAL via4  metal5  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_netMinSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (19 )
        }
    } else {
        EXTERNAL via4  metal5  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
            SPACING < diff_netMinSpacing
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
            NODAL = TRUE
        } (19 )
    }
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via4  metal5  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
            } TEMP = sameNet_corner_err1
            EXTERNAL via4  metal5  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
            } TEMP = sameNet_corner_err2
            BOOLEAN sameNet_corner_err1 OR sameNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (19 )
            EXTERNAL via4  metal5  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                FLAG_DISCONNECTED = FALSE
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
            } (19 )
        } else {
            EXTERNAL via4  metal5  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_minSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (19 )
        }
    } else {
        EXTERNAL via4  metal5  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
            SPACING < diff_minSpacing
            FLAG_DISCONNECTED = FALSE
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
        } (19 )
    }
} else {
    if (diff_netMinSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via4  metal5  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                    NODAL = TRUE
                } TEMP = corner_err1
                EXTERNAL via4  metal5  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                    NODAL = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (19 )
                EXTERNAL via4  metal5  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                    SPACING < diff_netMinSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                    NODAL = TRUE
                } (19 )
            } else {
                EXTERNAL via4  metal5  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_netMinSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                    NODAL = TRUE
                } (19 )
            }
        } else {
            EXTERNAL via4  metal5  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (19 )
        }
    } else if (diff_minSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via4  metal5  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                } TEMP = corner_err1
                EXTERNAL via4  metal5  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (19 )
                EXTERNAL via4  metal5  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                    SPACING < diff_minSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                } (19 )
            } else {
                EXTERNAL via4  metal5  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_minSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                } (19 )
            }
        } else {
            EXTERNAL via4  metal5  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (19 )
        }
    }
}
 
/*check enclosure*/
if (diff_minEnclosure > 0) {
    ENCLOSE via4  BY metal5  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
        SPACING < diff_minEnclosure
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
	TOUCH = TRUE
    } (19 )
    BOOLEAN via4  NOT metal5  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
    } (19 )
}
 
/*check end_of_line enclosure*/
if (diff_endOfLineEnclosure > 0) {
    if (diff_minEnclosure  == 0) {
       BOOLEAN via4  NOT metal5  {
           COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
       } (19 )
    }
    if (diff_endOfLineMode == 0) {
        ENCLOSE via4  BY metal5  {
	    SPACING < diff_endOfLineEnclosure
	    SET_CORNERS_TO_SPACING = FALSE
	    PARALLEL_POINT_PROJECTION = FALSE
	    SHADOW_OTHER_LAYER = TRUE  
	    TOUCH = TRUE
	    POINT_TOUCH = FALSE
	    NON_PARALLEL = TRUE
            OUTPUT_EDGES = TRUE
        } TEMP = violation
 
        SELECT_EDGE via4  TOUCHING violation {  } TEMP = edges
        SELECT_VECTOR edges { ANGLE_RANGE = [0, 0] } TEMP = h_edges
        SELECT_VECTOR edges { ANGLE_RANGE = [90, 90] } TEMP = v_edges
        SELECT h_edges INTERACT v_edges { POINT_TOUCH = TRUE } TEMP = h_edges
 
        SELECT via4  ENCLOSING h_edges {
            COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
        } (19 )
    }
    else {
    }
}
 
/*check stackable*/
if (diff_not_stackable > 0) {
     BOOLEAN via4  AND metal5  {
        COMMENT = "$layer_name Stackable: not stackable"
    } (19 )
}
/*check fat metal via keep-out area*/
if (diff_fatTblViaKeepoutThreshold > 0 && diff_fatTblViaKeepoutMinSize > 0 && diff_fatTblViaKeepoutEnclosure > 0) {
    if (diff_fatTblViaKeepoutThreshold > 0) {
        if ((diff_fatTblViaKeepoutThreshold / 2.0) > 0.0001 ) {
           SIZE metal5  { UNDER_OVER = diff_fatTblViaKeepoutThreshold / 2.0 - 0.0001  } TEMP = fat_candidate
           if (diff_fatTblViaKeepoutNextThreshold > 0) {
              SIZE fat_candidate { UNDER_OVER = diff_fatTblViaKeepoutNextThreshold / 2.0 - 0.0001  } TEMP = fat_next
              BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
              BOOLEAN fat AND metal5  { } TEMP = fat
              SET diff_fatTblViaKeepoutNextThreshold = 0;
           } else {
              BOOLEAN fat_candidate AND metal5  {  } TEMP = fat
           }
        } else {
           COPY metal5  { } TEMP = fat
           COPY metal5  { } TEMP = fat_candidate 
        }
    }
    VERTEX fat_candidate {
       CONVEX = TRUE
       SIZE = 0.0002 
    } TEMP = fat_corners
    VERTEX fat {
       CONVEX = TRUE
       SIZE = 0.0002 
    } TEMP = wire_corners
    SELECT wire_corners INTERACT fat_corners { } TEMP = wire_corners
    SELECT_EDGE fat INTERACT wire_corners { } TEMP = edge_corners
    SELECT_VECTOR edge_corners {
       LENGTH_RANGE = [0, diff_fatTblViaKeepoutMinSize- 0.0001 ]
    } TEMP = edge_tmp1
    BOOLEAN edge_corners NOT edge_tmp1 { } TEMP = edge_tmp2
    SELECT wire_corners OUTSIDE edge_tmp1 {  } TEMP = real_corners
    BOOLEAN edge_tmp2 AND real_corners { } TEMP = real_edge
    SIZE real_edge {
       VSIZE_HEAD = diff_fatTblViaKeepoutMinSize-2* 0.0002 
       VSIZE_TAIL = diff_fatTblViaKeepoutMinSize-2* 0.0002 
       VSIZE_INSIDE = diff_fatTblViaKeepoutEnclosure- 0.0002 
    } TEMP = forb_corners
    SELECT via4  INSIDE fat { } TEMP = v_fat
    /* Work around: need an accurate via_cluster */
    SELECT via_cluster INSIDE fat { } TEMP = v_fat_cluster
    SELECT v_fat INTERACT forb_corners { } TEMP = bad_vias
    BOOLEAN v_fat NOT bad_vias { } TEMP = good_vias
    SELECT v_fat_cluster OUTSIDE good_vias { } TEMP = bad_v_fat_cluster
    SELECT v_fat INTERACT bad_v_fat_cluster {
       COMMENT = "$layer_name ViaKepOut: fat metal ( diff_fatTblViaKeepoutThreshold um) contact keep-out area ( diff_fatTblViaKeepoutMinSize um, diff_fatTblViaKeepoutEnclosure um) "
    } (19 )
}
 
/* reset variables */



 
SET diff_minSpacing = 0;
SET diff_netMinSpacing = 0;
SET diff_cornerMinSpacing = 0;
SET diff_minEnclosure = 0;
SET diff_endOfLineEnclosure = 0;
SET diff_not_stackable = 0;
SET diff_fatTblViaKeepoutThreshold = 0;
SET diff_fatTblViaKeepoutNextThreshold = 0;
SET diff_fatTblViaKeepoutMinSize = 0;
SET diff_fatTblViaKeepoutEnclosure = 0;
@ 1703 "adrc/adrc.ev" 2

    }
}
DISCONNECT


/*via 5 / metal 6*/
SET layer_name = "V5/M6";





LOAD_CONNECT_DB all_layer

if (!layer_empty (via5 )) {
    if (!layer_empty (metal6 )) {
        
@ 1 "adrc/adrc_check_diff.ev" 1
/*check spacing*/
if (diff_minSpacing > 0 && diff_netMinSpacing > 0) {
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via5  metal6  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
                NODAL = TRUE
            } TEMP = diffNet_corner_err1
            EXTERNAL via5  metal6  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
                NODAL = TRUE
            } TEMP = diffNet_corner_err2
            BOOLEAN diffNet_corner_err1 OR diffNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (21 )
            EXTERNAL via5  metal6  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NODAL = TRUE
            } (21 )
        } else {
            EXTERNAL via5  metal6  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_netMinSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (21 )
        }
    } else {
        EXTERNAL via5  metal6  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
            SPACING < diff_netMinSpacing
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
            NODAL = TRUE
        } (21 )
    }
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via5  metal6  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
            } TEMP = sameNet_corner_err1
            EXTERNAL via5  metal6  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
            } TEMP = sameNet_corner_err2
            BOOLEAN sameNet_corner_err1 OR sameNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (21 )
            EXTERNAL via5  metal6  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                FLAG_DISCONNECTED = FALSE
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
            } (21 )
        } else {
            EXTERNAL via5  metal6  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_minSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (21 )
        }
    } else {
        EXTERNAL via5  metal6  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
            SPACING < diff_minSpacing
            FLAG_DISCONNECTED = FALSE
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
        } (21 )
    }
} else {
    if (diff_netMinSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via5  metal6  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                    NODAL = TRUE
                } TEMP = corner_err1
                EXTERNAL via5  metal6  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                    NODAL = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (21 )
                EXTERNAL via5  metal6  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                    SPACING < diff_netMinSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                    NODAL = TRUE
                } (21 )
            } else {
                EXTERNAL via5  metal6  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_netMinSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                    NODAL = TRUE
                } (21 )
            }
        } else {
            EXTERNAL via5  metal6  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (21 )
        }
    } else if (diff_minSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via5  metal6  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                } TEMP = corner_err1
                EXTERNAL via5  metal6  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (21 )
                EXTERNAL via5  metal6  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                    SPACING < diff_minSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                } (21 )
            } else {
                EXTERNAL via5  metal6  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_minSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                } (21 )
            }
        } else {
            EXTERNAL via5  metal6  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (21 )
        }
    }
}
 
/*check enclosure*/
if (diff_minEnclosure > 0) {
    ENCLOSE via5  BY metal6  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
        SPACING < diff_minEnclosure
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
	TOUCH = TRUE
    } (21 )
    BOOLEAN via5  NOT metal6  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
    } (21 )
}
 
/*check end_of_line enclosure*/
if (diff_endOfLineEnclosure > 0) {
    if (diff_minEnclosure  == 0) {
       BOOLEAN via5  NOT metal6  {
           COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
       } (21 )
    }
    if (diff_endOfLineMode == 0) {
        ENCLOSE via5  BY metal6  {
	    SPACING < diff_endOfLineEnclosure
	    SET_CORNERS_TO_SPACING = FALSE
	    PARALLEL_POINT_PROJECTION = FALSE
	    SHADOW_OTHER_LAYER = TRUE  
	    TOUCH = TRUE
	    POINT_TOUCH = FALSE
	    NON_PARALLEL = TRUE
            OUTPUT_EDGES = TRUE
        } TEMP = violation
 
        SELECT_EDGE via5  TOUCHING violation {  } TEMP = edges
        SELECT_VECTOR edges { ANGLE_RANGE = [0, 0] } TEMP = h_edges
        SELECT_VECTOR edges { ANGLE_RANGE = [90, 90] } TEMP = v_edges
        SELECT h_edges INTERACT v_edges { POINT_TOUCH = TRUE } TEMP = h_edges
 
        SELECT via5  ENCLOSING h_edges {
            COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
        } (21 )
    }
    else {
    }
}
 
/*check stackable*/
if (diff_not_stackable > 0) {
     BOOLEAN via5  AND metal6  {
        COMMENT = "$layer_name Stackable: not stackable"
    } (21 )
}
/*check fat metal via keep-out area*/
if (diff_fatTblViaKeepoutThreshold > 0 && diff_fatTblViaKeepoutMinSize > 0 && diff_fatTblViaKeepoutEnclosure > 0) {
    if (diff_fatTblViaKeepoutThreshold > 0) {
        if ((diff_fatTblViaKeepoutThreshold / 2.0) > 0.0001 ) {
           SIZE metal6  { UNDER_OVER = diff_fatTblViaKeepoutThreshold / 2.0 - 0.0001  } TEMP = fat_candidate
           if (diff_fatTblViaKeepoutNextThreshold > 0) {
              SIZE fat_candidate { UNDER_OVER = diff_fatTblViaKeepoutNextThreshold / 2.0 - 0.0001  } TEMP = fat_next
              BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
              BOOLEAN fat AND metal6  { } TEMP = fat
              SET diff_fatTblViaKeepoutNextThreshold = 0;
           } else {
              BOOLEAN fat_candidate AND metal6  {  } TEMP = fat
           }
        } else {
           COPY metal6  { } TEMP = fat
           COPY metal6  { } TEMP = fat_candidate 
        }
    }
    VERTEX fat_candidate {
       CONVEX = TRUE
       SIZE = 0.0002 
    } TEMP = fat_corners
    VERTEX fat {
       CONVEX = TRUE
       SIZE = 0.0002 
    } TEMP = wire_corners
    SELECT wire_corners INTERACT fat_corners { } TEMP = wire_corners
    SELECT_EDGE fat INTERACT wire_corners { } TEMP = edge_corners
    SELECT_VECTOR edge_corners {
       LENGTH_RANGE = [0, diff_fatTblViaKeepoutMinSize- 0.0001 ]
    } TEMP = edge_tmp1
    BOOLEAN edge_corners NOT edge_tmp1 { } TEMP = edge_tmp2
    SELECT wire_corners OUTSIDE edge_tmp1 {  } TEMP = real_corners
    BOOLEAN edge_tmp2 AND real_corners { } TEMP = real_edge
    SIZE real_edge {
       VSIZE_HEAD = diff_fatTblViaKeepoutMinSize-2* 0.0002 
       VSIZE_TAIL = diff_fatTblViaKeepoutMinSize-2* 0.0002 
       VSIZE_INSIDE = diff_fatTblViaKeepoutEnclosure- 0.0002 
    } TEMP = forb_corners
    SELECT via5  INSIDE fat { } TEMP = v_fat
    /* Work around: need an accurate via_cluster */
    SELECT via_cluster INSIDE fat { } TEMP = v_fat_cluster
    SELECT v_fat INTERACT forb_corners { } TEMP = bad_vias
    BOOLEAN v_fat NOT bad_vias { } TEMP = good_vias
    SELECT v_fat_cluster OUTSIDE good_vias { } TEMP = bad_v_fat_cluster
    SELECT v_fat INTERACT bad_v_fat_cluster {
       COMMENT = "$layer_name ViaKepOut: fat metal ( diff_fatTblViaKeepoutThreshold um) contact keep-out area ( diff_fatTblViaKeepoutMinSize um, diff_fatTblViaKeepoutEnclosure um) "
    } (21 )
}
 
/* reset variables */



 
SET diff_minSpacing = 0;
SET diff_netMinSpacing = 0;
SET diff_cornerMinSpacing = 0;
SET diff_minEnclosure = 0;
SET diff_endOfLineEnclosure = 0;
SET diff_not_stackable = 0;
SET diff_fatTblViaKeepoutThreshold = 0;
SET diff_fatTblViaKeepoutNextThreshold = 0;
SET diff_fatTblViaKeepoutMinSize = 0;
SET diff_fatTblViaKeepoutEnclosure = 0;
@ 1720 "adrc/adrc.ev" 2

    }
}
DISCONNECT


/*via 6 / metal 7*/
SET layer_name = "V6/M7";





LOAD_CONNECT_DB all_layer

if (!layer_empty (via6 )) {
    if (!layer_empty (metal7 )) {
        
@ 1 "adrc/adrc_check_diff.ev" 1
/*check spacing*/
if (diff_minSpacing > 0 && diff_netMinSpacing > 0) {
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via6  metal7  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
                NODAL = TRUE
            } TEMP = diffNet_corner_err1
            EXTERNAL via6  metal7  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
                NODAL = TRUE
            } TEMP = diffNet_corner_err2
            BOOLEAN diffNet_corner_err1 OR diffNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (23 )
            EXTERNAL via6  metal7  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NODAL = TRUE
            } (23 )
        } else {
            EXTERNAL via6  metal7  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_netMinSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (23 )
        }
    } else {
        EXTERNAL via6  metal7  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
            SPACING < diff_netMinSpacing
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
            NODAL = TRUE
        } (23 )
    }
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via6  metal7  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
            } TEMP = sameNet_corner_err1
            EXTERNAL via6  metal7  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
            } TEMP = sameNet_corner_err2
            BOOLEAN sameNet_corner_err1 OR sameNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (23 )
            EXTERNAL via6  metal7  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                FLAG_DISCONNECTED = FALSE
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
            } (23 )
        } else {
            EXTERNAL via6  metal7  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_minSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (23 )
        }
    } else {
        EXTERNAL via6  metal7  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
            SPACING < diff_minSpacing
            FLAG_DISCONNECTED = FALSE
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
        } (23 )
    }
} else {
    if (diff_netMinSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via6  metal7  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                    NODAL = TRUE
                } TEMP = corner_err1
                EXTERNAL via6  metal7  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                    NODAL = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (23 )
                EXTERNAL via6  metal7  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                    SPACING < diff_netMinSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                    NODAL = TRUE
                } (23 )
            } else {
                EXTERNAL via6  metal7  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_netMinSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                    NODAL = TRUE
                } (23 )
            }
        } else {
            EXTERNAL via6  metal7  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (23 )
        }
    } else if (diff_minSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via6  metal7  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                } TEMP = corner_err1
                EXTERNAL via6  metal7  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (23 )
                EXTERNAL via6  metal7  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                    SPACING < diff_minSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                } (23 )
            } else {
                EXTERNAL via6  metal7  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_minSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                } (23 )
            }
        } else {
            EXTERNAL via6  metal7  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (23 )
        }
    }
}
 
/*check enclosure*/
if (diff_minEnclosure > 0) {
    ENCLOSE via6  BY metal7  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
        SPACING < diff_minEnclosure
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
	TOUCH = TRUE
    } (23 )
    BOOLEAN via6  NOT metal7  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
    } (23 )
}
 
/*check end_of_line enclosure*/
if (diff_endOfLineEnclosure > 0) {
    if (diff_minEnclosure  == 0) {
       BOOLEAN via6  NOT metal7  {
           COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
       } (23 )
    }
    if (diff_endOfLineMode == 0) {
        ENCLOSE via6  BY metal7  {
	    SPACING < diff_endOfLineEnclosure
	    SET_CORNERS_TO_SPACING = FALSE
	    PARALLEL_POINT_PROJECTION = FALSE
	    SHADOW_OTHER_LAYER = TRUE  
	    TOUCH = TRUE
	    POINT_TOUCH = FALSE
	    NON_PARALLEL = TRUE
            OUTPUT_EDGES = TRUE
        } TEMP = violation
 
        SELECT_EDGE via6  TOUCHING violation {  } TEMP = edges
        SELECT_VECTOR edges { ANGLE_RANGE = [0, 0] } TEMP = h_edges
        SELECT_VECTOR edges { ANGLE_RANGE = [90, 90] } TEMP = v_edges
        SELECT h_edges INTERACT v_edges { POINT_TOUCH = TRUE } TEMP = h_edges
 
        SELECT via6  ENCLOSING h_edges {
            COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
        } (23 )
    }
    else {
    }
}
 
/*check stackable*/
if (diff_not_stackable > 0) {
     BOOLEAN via6  AND metal7  {
        COMMENT = "$layer_name Stackable: not stackable"
    } (23 )
}
/*check fat metal via keep-out area*/
if (diff_fatTblViaKeepoutThreshold > 0 && diff_fatTblViaKeepoutMinSize > 0 && diff_fatTblViaKeepoutEnclosure > 0) {
    if (diff_fatTblViaKeepoutThreshold > 0) {
        if ((diff_fatTblViaKeepoutThreshold / 2.0) > 0.0001 ) {
           SIZE metal7  { UNDER_OVER = diff_fatTblViaKeepoutThreshold / 2.0 - 0.0001  } TEMP = fat_candidate
           if (diff_fatTblViaKeepoutNextThreshold > 0) {
              SIZE fat_candidate { UNDER_OVER = diff_fatTblViaKeepoutNextThreshold / 2.0 - 0.0001  } TEMP = fat_next
              BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
              BOOLEAN fat AND metal7  { } TEMP = fat
              SET diff_fatTblViaKeepoutNextThreshold = 0;
           } else {
              BOOLEAN fat_candidate AND metal7  {  } TEMP = fat
           }
        } else {
           COPY metal7  { } TEMP = fat
           COPY metal7  { } TEMP = fat_candidate 
        }
    }
    VERTEX fat_candidate {
       CONVEX = TRUE
       SIZE = 0.0002 
    } TEMP = fat_corners
    VERTEX fat {
       CONVEX = TRUE
       SIZE = 0.0002 
    } TEMP = wire_corners
    SELECT wire_corners INTERACT fat_corners { } TEMP = wire_corners
    SELECT_EDGE fat INTERACT wire_corners { } TEMP = edge_corners
    SELECT_VECTOR edge_corners {
       LENGTH_RANGE = [0, diff_fatTblViaKeepoutMinSize- 0.0001 ]
    } TEMP = edge_tmp1
    BOOLEAN edge_corners NOT edge_tmp1 { } TEMP = edge_tmp2
    SELECT wire_corners OUTSIDE edge_tmp1 {  } TEMP = real_corners
    BOOLEAN edge_tmp2 AND real_corners { } TEMP = real_edge
    SIZE real_edge {
       VSIZE_HEAD = diff_fatTblViaKeepoutMinSize-2* 0.0002 
       VSIZE_TAIL = diff_fatTblViaKeepoutMinSize-2* 0.0002 
       VSIZE_INSIDE = diff_fatTblViaKeepoutEnclosure- 0.0002 
    } TEMP = forb_corners
    SELECT via6  INSIDE fat { } TEMP = v_fat
    /* Work around: need an accurate via_cluster */
    SELECT via_cluster INSIDE fat { } TEMP = v_fat_cluster
    SELECT v_fat INTERACT forb_corners { } TEMP = bad_vias
    BOOLEAN v_fat NOT bad_vias { } TEMP = good_vias
    SELECT v_fat_cluster OUTSIDE good_vias { } TEMP = bad_v_fat_cluster
    SELECT v_fat INTERACT bad_v_fat_cluster {
       COMMENT = "$layer_name ViaKepOut: fat metal ( diff_fatTblViaKeepoutThreshold um) contact keep-out area ( diff_fatTblViaKeepoutMinSize um, diff_fatTblViaKeepoutEnclosure um) "
    } (23 )
}
 
/* reset variables */



 
SET diff_minSpacing = 0;
SET diff_netMinSpacing = 0;
SET diff_cornerMinSpacing = 0;
SET diff_minEnclosure = 0;
SET diff_endOfLineEnclosure = 0;
SET diff_not_stackable = 0;
SET diff_fatTblViaKeepoutThreshold = 0;
SET diff_fatTblViaKeepoutNextThreshold = 0;
SET diff_fatTblViaKeepoutMinSize = 0;
SET diff_fatTblViaKeepoutEnclosure = 0;
@ 1737 "adrc/adrc.ev" 2

    }
}
DISCONNECT


/*via 7 / metal 8*/
SET layer_name = "V7/M8";





LOAD_CONNECT_DB all_layer

if (!layer_empty (via7 )) {
    if (!layer_empty (metal8 )) {
        
@ 1 "adrc/adrc_check_diff.ev" 1
/*check spacing*/
if (diff_minSpacing > 0 && diff_netMinSpacing > 0) {
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via7  metal8  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
                NODAL = TRUE
            } TEMP = diffNet_corner_err1
            EXTERNAL via7  metal8  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
                NODAL = TRUE
            } TEMP = diffNet_corner_err2
            BOOLEAN diffNet_corner_err1 OR diffNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (25 )
            EXTERNAL via7  metal8  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NODAL = TRUE
            } (25 )
        } else {
            EXTERNAL via7  metal8  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_netMinSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (25 )
        }
    } else {
        EXTERNAL via7  metal8  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
            SPACING < diff_netMinSpacing
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
            NODAL = TRUE
        } (25 )
    }
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via7  metal8  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
            } TEMP = sameNet_corner_err1
            EXTERNAL via7  metal8  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
            } TEMP = sameNet_corner_err2
            BOOLEAN sameNet_corner_err1 OR sameNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (25 )
            EXTERNAL via7  metal8  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                FLAG_DISCONNECTED = FALSE
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
            } (25 )
        } else {
            EXTERNAL via7  metal8  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_minSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (25 )
        }
    } else {
        EXTERNAL via7  metal8  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
            SPACING < diff_minSpacing
            FLAG_DISCONNECTED = FALSE
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
        } (25 )
    }
} else {
    if (diff_netMinSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via7  metal8  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                    NODAL = TRUE
                } TEMP = corner_err1
                EXTERNAL via7  metal8  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                    NODAL = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (25 )
                EXTERNAL via7  metal8  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                    SPACING < diff_netMinSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                    NODAL = TRUE
                } (25 )
            } else {
                EXTERNAL via7  metal8  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_netMinSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                    NODAL = TRUE
                } (25 )
            }
        } else {
            EXTERNAL via7  metal8  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (25 )
        }
    } else if (diff_minSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via7  metal8  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                } TEMP = corner_err1
                EXTERNAL via7  metal8  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (25 )
                EXTERNAL via7  metal8  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                    SPACING < diff_minSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                } (25 )
            } else {
                EXTERNAL via7  metal8  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_minSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                } (25 )
            }
        } else {
            EXTERNAL via7  metal8  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (25 )
        }
    }
}
 
/*check enclosure*/
if (diff_minEnclosure > 0) {
    ENCLOSE via7  BY metal8  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
        SPACING < diff_minEnclosure
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
	TOUCH = TRUE
    } (25 )
    BOOLEAN via7  NOT metal8  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
    } (25 )
}
 
/*check end_of_line enclosure*/
if (diff_endOfLineEnclosure > 0) {
    if (diff_minEnclosure  == 0) {
       BOOLEAN via7  NOT metal8  {
           COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
       } (25 )
    }
    if (diff_endOfLineMode == 0) {
        ENCLOSE via7  BY metal8  {
	    SPACING < diff_endOfLineEnclosure
	    SET_CORNERS_TO_SPACING = FALSE
	    PARALLEL_POINT_PROJECTION = FALSE
	    SHADOW_OTHER_LAYER = TRUE  
	    TOUCH = TRUE
	    POINT_TOUCH = FALSE
	    NON_PARALLEL = TRUE
            OUTPUT_EDGES = TRUE
        } TEMP = violation
 
        SELECT_EDGE via7  TOUCHING violation {  } TEMP = edges
        SELECT_VECTOR edges { ANGLE_RANGE = [0, 0] } TEMP = h_edges
        SELECT_VECTOR edges { ANGLE_RANGE = [90, 90] } TEMP = v_edges
        SELECT h_edges INTERACT v_edges { POINT_TOUCH = TRUE } TEMP = h_edges
 
        SELECT via7  ENCLOSING h_edges {
            COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
        } (25 )
    }
    else {
    }
}
 
/*check stackable*/
if (diff_not_stackable > 0) {
     BOOLEAN via7  AND metal8  {
        COMMENT = "$layer_name Stackable: not stackable"
    } (25 )
}
/*check fat metal via keep-out area*/
if (diff_fatTblViaKeepoutThreshold > 0 && diff_fatTblViaKeepoutMinSize > 0 && diff_fatTblViaKeepoutEnclosure > 0) {
    if (diff_fatTblViaKeepoutThreshold > 0) {
        if ((diff_fatTblViaKeepoutThreshold / 2.0) > 0.0001 ) {
           SIZE metal8  { UNDER_OVER = diff_fatTblViaKeepoutThreshold / 2.0 - 0.0001  } TEMP = fat_candidate
           if (diff_fatTblViaKeepoutNextThreshold > 0) {
              SIZE fat_candidate { UNDER_OVER = diff_fatTblViaKeepoutNextThreshold / 2.0 - 0.0001  } TEMP = fat_next
              BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
              BOOLEAN fat AND metal8  { } TEMP = fat
              SET diff_fatTblViaKeepoutNextThreshold = 0;
           } else {
              BOOLEAN fat_candidate AND metal8  {  } TEMP = fat
           }
        } else {
           COPY metal8  { } TEMP = fat
           COPY metal8  { } TEMP = fat_candidate 
        }
    }
    VERTEX fat_candidate {
       CONVEX = TRUE
       SIZE = 0.0002 
    } TEMP = fat_corners
    VERTEX fat {
       CONVEX = TRUE
       SIZE = 0.0002 
    } TEMP = wire_corners
    SELECT wire_corners INTERACT fat_corners { } TEMP = wire_corners
    SELECT_EDGE fat INTERACT wire_corners { } TEMP = edge_corners
    SELECT_VECTOR edge_corners {
       LENGTH_RANGE = [0, diff_fatTblViaKeepoutMinSize- 0.0001 ]
    } TEMP = edge_tmp1
    BOOLEAN edge_corners NOT edge_tmp1 { } TEMP = edge_tmp2
    SELECT wire_corners OUTSIDE edge_tmp1 {  } TEMP = real_corners
    BOOLEAN edge_tmp2 AND real_corners { } TEMP = real_edge
    SIZE real_edge {
       VSIZE_HEAD = diff_fatTblViaKeepoutMinSize-2* 0.0002 
       VSIZE_TAIL = diff_fatTblViaKeepoutMinSize-2* 0.0002 
       VSIZE_INSIDE = diff_fatTblViaKeepoutEnclosure- 0.0002 
    } TEMP = forb_corners
    SELECT via7  INSIDE fat { } TEMP = v_fat
    /* Work around: need an accurate via_cluster */
    SELECT via_cluster INSIDE fat { } TEMP = v_fat_cluster
    SELECT v_fat INTERACT forb_corners { } TEMP = bad_vias
    BOOLEAN v_fat NOT bad_vias { } TEMP = good_vias
    SELECT v_fat_cluster OUTSIDE good_vias { } TEMP = bad_v_fat_cluster
    SELECT v_fat INTERACT bad_v_fat_cluster {
       COMMENT = "$layer_name ViaKepOut: fat metal ( diff_fatTblViaKeepoutThreshold um) contact keep-out area ( diff_fatTblViaKeepoutMinSize um, diff_fatTblViaKeepoutEnclosure um) "
    } (25 )
}
 
/* reset variables */



 
SET diff_minSpacing = 0;
SET diff_netMinSpacing = 0;
SET diff_cornerMinSpacing = 0;
SET diff_minEnclosure = 0;
SET diff_endOfLineEnclosure = 0;
SET diff_not_stackable = 0;
SET diff_fatTblViaKeepoutThreshold = 0;
SET diff_fatTblViaKeepoutNextThreshold = 0;
SET diff_fatTblViaKeepoutMinSize = 0;
SET diff_fatTblViaKeepoutEnclosure = 0;
@ 1754 "adrc/adrc.ev" 2

    }
}
DISCONNECT


/*via 8 / metal 9*/
SET layer_name = "V8/M9";





LOAD_CONNECT_DB all_layer

if (!layer_empty (via8 )) {
    if (!layer_empty (metal9 )) {
        
@ 1 "adrc/adrc_check_diff.ev" 1
/*check spacing*/
if (diff_minSpacing > 0 && diff_netMinSpacing > 0) {
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via8  metal9  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
                NODAL = TRUE
            } TEMP = diffNet_corner_err1
            EXTERNAL via8  metal9  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
                NODAL = TRUE
            } TEMP = diffNet_corner_err2
            BOOLEAN diffNet_corner_err1 OR diffNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (27 )
            EXTERNAL via8  metal9  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
                NODAL = TRUE
            } (27 )
        } else {
            EXTERNAL via8  metal9  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_netMinSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (27 )
        }
    } else {
        EXTERNAL via8  metal9  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
            SPACING < diff_netMinSpacing
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
            NODAL = TRUE
        } (27 )
    }
    if (diff_cornerMinSpacing > 0) {
        if (cornerSpacingMode == 1) {
            /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
            EXTERNAL via8  metal9  {
                SPACING <= 0
                CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = FALSE
            } TEMP = sameNet_corner_err1
            EXTERNAL via8  metal9  {
                SPACING <= 0
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                BOX_CORNER = TRUE
            } TEMP = sameNet_corner_err2
            BOOLEAN sameNet_corner_err1 OR sameNet_corner_err2 {
                COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
            } (27 )
            EXTERNAL via8  metal9  {
                COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                FLAG_DISCONNECTED = FALSE
                SET_CORNERS_TO_SPACING = FALSE
                PARALLEL_POINT_PROJECTION = FALSE
                NON_PARALLEL = TRUE
                TOUCH = FALSE
                POINT_TOUCH = FALSE
            } (27 )
        } else {
            EXTERNAL via8  metal9  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                SPACING < diff_minSpacing
                CONVEX_TO_CONVEX < diff_cornerMinSpacing
                FLAG_DISCONNECTED = FALSE
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (27 )
        }
    } else {
        EXTERNAL via8  metal9  {
            COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
            SPACING < diff_minSpacing
            FLAG_DISCONNECTED = FALSE
            NON_PARALLEL = TRUE
            POINT_TOUCH = TRUE
            TOUCH = TRUE
        } (27 )
    }
} else {
    if (diff_netMinSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via8  metal9  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                    NODAL = TRUE
                } TEMP = corner_err1
                EXTERNAL via8  metal9  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                    NODAL = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (27 )
                EXTERNAL via8  metal9  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_netMinSpacing um"
                    SPACING < diff_netMinSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                    NODAL = TRUE
                } (27 )
            } else {
                EXTERNAL via8  metal9  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_netMinSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                    NODAL = TRUE
                } (27 )
            }
        } else {
            EXTERNAL via8  metal9  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_netMinSpacing um"
                SPACING < diff_netMinSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
                NODAL = TRUE
            } (27 )
        }
    } else if (diff_minSpacing > 0) {
        if (diff_cornerMinSpacing > 0) {
            if (cornerSpacingMode == 1) {
                /* Work around: CONVEX_TO_CONVEX [POINT_PROJECTION] has a bug */
                EXTERNAL via8  metal9  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX [POINT_PROJECTION] < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = FALSE
                } TEMP = corner_err1
                EXTERNAL via8  metal9  {
                    SPACING <= 0
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    BOX_CORNER = TRUE
                } TEMP = corner_err2
                BOOLEAN corner_err1 OR corner_err2 {
                    COMMENT = "$layer_name Spacing   : corner to corner spacing = diff_cornerMinSpacing um "
                } (27 )
                EXTERNAL via8  metal9  {
                    COMMENT = "$layer_name Spacing   : minimum spacing = diff_minSpacing um"
                    SPACING < diff_minSpacing
                    SET_CORNERS_TO_SPACING = FALSE
                    PARALLEL_POINT_PROJECTION = FALSE
                    NON_PARALLEL = TRUE
                    TOUCH = FALSE
                    POINT_TOUCH = FALSE
                } (27 )
            } else {
                EXTERNAL via8  metal9  {
                    COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um (corner to corner spacing = diff_cornerMinSpacing um)"
                    SPACING < diff_minSpacing
                    CONVEX_TO_CONVEX < diff_cornerMinSpacing
                    NON_PARALLEL = TRUE
                    POINT_TOUCH = TRUE
                    TOUCH = TRUE
                } (27 )
            }
        } else {
            EXTERNAL via8  metal9  {
                COMMENT = "$layer_name Spacing  : minimum spacing = diff_minSpacing um"
                SPACING < diff_minSpacing
                NON_PARALLEL = TRUE
                POINT_TOUCH = TRUE
                TOUCH = TRUE
            } (27 )
        }
    }
}
 
/*check enclosure*/
if (diff_minEnclosure > 0) {
    ENCLOSE via8  BY metal9  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
        SPACING < diff_minEnclosure
	NON_PARALLEL = TRUE
	POINT_TOUCH = TRUE
	TOUCH = TRUE
    } (27 )
    BOOLEAN via8  NOT metal9  {
        COMMENT = "$layer_name Enclosure: minimum enclosure ( diff_minEnclosure )"
    } (27 )
}
 
/*check end_of_line enclosure*/
if (diff_endOfLineEnclosure > 0) {
    if (diff_minEnclosure  == 0) {
       BOOLEAN via8  NOT metal9  {
           COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
       } (27 )
    }
    if (diff_endOfLineMode == 0) {
        ENCLOSE via8  BY metal9  {
	    SPACING < diff_endOfLineEnclosure
	    SET_CORNERS_TO_SPACING = FALSE
	    PARALLEL_POINT_PROJECTION = FALSE
	    SHADOW_OTHER_LAYER = TRUE  
	    TOUCH = TRUE
	    POINT_TOUCH = FALSE
	    NON_PARALLEL = TRUE
            OUTPUT_EDGES = TRUE
        } TEMP = violation
 
        SELECT_EDGE via8  TOUCHING violation {  } TEMP = edges
        SELECT_VECTOR edges { ANGLE_RANGE = [0, 0] } TEMP = h_edges
        SELECT_VECTOR edges { ANGLE_RANGE = [90, 90] } TEMP = v_edges
        SELECT h_edges INTERACT v_edges { POINT_TOUCH = TRUE } TEMP = h_edges
 
        SELECT via8  ENCLOSING h_edges {
            COMMENT = "$layer_name EndOfLine: end-of-line minimum enclosure ( diff_endOfLineEnclosure )"
        } (27 )
    }
    else {
    }
}
 
/*check stackable*/
if (diff_not_stackable > 0) {
     BOOLEAN via8  AND metal9  {
        COMMENT = "$layer_name Stackable: not stackable"
    } (27 )
}
/*check fat metal via keep-out area*/
if (diff_fatTblViaKeepoutThreshold > 0 && diff_fatTblViaKeepoutMinSize > 0 && diff_fatTblViaKeepoutEnclosure > 0) {
    if (diff_fatTblViaKeepoutThreshold > 0) {
        if ((diff_fatTblViaKeepoutThreshold / 2.0) > 0.0001 ) {
           SIZE metal9  { UNDER_OVER = diff_fatTblViaKeepoutThreshold / 2.0 - 0.0001  } TEMP = fat_candidate
           if (diff_fatTblViaKeepoutNextThreshold > 0) {
              SIZE fat_candidate { UNDER_OVER = diff_fatTblViaKeepoutNextThreshold / 2.0 - 0.0001  } TEMP = fat_next
              BOOLEAN fat_candidate NOT fat_next { } TEMP = fat
              BOOLEAN fat AND metal9  { } TEMP = fat
              SET diff_fatTblViaKeepoutNextThreshold = 0;
           } else {
              BOOLEAN fat_candidate AND metal9  {  } TEMP = fat
           }
        } else {
           COPY metal9  { } TEMP = fat
           COPY metal9  { } TEMP = fat_candidate 
        }
    }
    VERTEX fat_candidate {
       CONVEX = TRUE
       SIZE = 0.0002 
    } TEMP = fat_corners
    VERTEX fat {
       CONVEX = TRUE
       SIZE = 0.0002 
    } TEMP = wire_corners
    SELECT wire_corners INTERACT fat_corners { } TEMP = wire_corners
    SELECT_EDGE fat INTERACT wire_corners { } TEMP = edge_corners
    SELECT_VECTOR edge_corners {
       LENGTH_RANGE = [0, diff_fatTblViaKeepoutMinSize- 0.0001 ]
    } TEMP = edge_tmp1
    BOOLEAN edge_corners NOT edge_tmp1 { } TEMP = edge_tmp2
    SELECT wire_corners OUTSIDE edge_tmp1 {  } TEMP = real_corners
    BOOLEAN edge_tmp2 AND real_corners { } TEMP = real_edge
    SIZE real_edge {
       VSIZE_HEAD = diff_fatTblViaKeepoutMinSize-2* 0.0002 
       VSIZE_TAIL = diff_fatTblViaKeepoutMinSize-2* 0.0002 
       VSIZE_INSIDE = diff_fatTblViaKeepoutEnclosure- 0.0002 
    } TEMP = forb_corners
    SELECT via8  INSIDE fat { } TEMP = v_fat
    /* Work around: need an accurate via_cluster */
    SELECT via_cluster INSIDE fat { } TEMP = v_fat_cluster
    SELECT v_fat INTERACT forb_corners { } TEMP = bad_vias
    BOOLEAN v_fat NOT bad_vias { } TEMP = good_vias
    SELECT v_fat_cluster OUTSIDE good_vias { } TEMP = bad_v_fat_cluster
    SELECT v_fat INTERACT bad_v_fat_cluster {
       COMMENT = "$layer_name ViaKepOut: fat metal ( diff_fatTblViaKeepoutThreshold um) contact keep-out area ( diff_fatTblViaKeepoutMinSize um, diff_fatTblViaKeepoutEnclosure um) "
    } (27 )
}
 
/* reset variables */



 
SET diff_minSpacing = 0;
SET diff_netMinSpacing = 0;
SET diff_cornerMinSpacing = 0;
SET diff_minEnclosure = 0;
SET diff_endOfLineEnclosure = 0;
SET diff_not_stackable = 0;
SET diff_fatTblViaKeepoutThreshold = 0;
SET diff_fatTblViaKeepoutNextThreshold = 0;
SET diff_fatTblViaKeepoutMinSize = 0;
SET diff_fatTblViaKeepoutEnclosure = 0;
@ 1771 "adrc/adrc.ev" 2

    }
}
DISCONNECT


/*Via keep-out area design rules*/

